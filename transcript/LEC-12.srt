
1
00:00:00,000 --> 00:00:10,000
Hello everyone, welcome to lecture 12. I'm Steve Gilbert and today we're going to look at processing disk files.

2
00:00:10,000 --> 00:00:13,000
Let's start with a little bit of review though.

3
00:00:13,000 --> 00:00:18,000
So first I want to look at streams and data loops.

4
00:00:18,000 --> 00:00:26,000
So the stream classes that we're going to use are IStream and OStream.

5
00:00:26,000 --> 00:00:35,000
IStream is the input stream class. It's a class that knows how to read data and bring it into your program.

6
00:00:35,000 --> 00:00:43,000
The OStream class is an output stream class. It knows how to read/write data and send it out of your program.

7
00:00:43,000 --> 00:00:54,000
When your program starts up, it automatically creates several global standard stream objects.

8
00:00:54,000 --> 00:01:02,000
CIN for input, COUT for output, and CERR for sending out error messages.

9
00:01:02,000 --> 00:01:14,000
These are automatically connected to your operating system's standard streams called StandardIN, StandardOUT, and StandardERR.

10
00:01:14,000 --> 00:01:25,000
By the way, Java does exactly the same thing. StandardIN is connected to a scanner object when you create it.

11
00:01:25,000 --> 00:01:32,000
System.OUT is connected to the StandardOUTput just like COUT is.

12
00:01:32,000 --> 00:01:41,000
And System.ERR is connected to StandardOUTput just like CERR is in Java.

13
00:01:41,000 --> 00:01:46,000
Now we can use these streams with a special kind of loop called a data loop.

14
00:01:46,000 --> 00:01:55,000
A data loop stops not when we reach a counter, not when we reach a limit, but when the source is out of data.

15
00:01:55,000 --> 00:01:59,000
And there are three different ways to read from a stream.

16
00:01:59,000 --> 00:02:07,000
We can read a character by character, which is what we did when we wrote our filter programs in the last lecture.

17
00:02:07,000 --> 00:02:12,000
So while CIN, GET CH, COUT, PUT CH.

18
00:02:12,000 --> 00:02:21,000
We can also use the string function called GETLINE to read an entire line of input.

19
00:02:21,000 --> 00:02:29,000
So notice here I'm saying while GETLINE, I'm using any kind of input stream, IN, LINE,

20
00:02:29,000 --> 00:02:35,000
and this will again, when it's out of data, it will return false, and I'm printing out the line.

21
00:02:35,000 --> 00:02:40,000
When you read this line, it will strip the new line character from the end,

22
00:02:40,000 --> 00:02:47,000
so I needed to add it here if I wanted my output to look the same as the input.

23
00:02:47,000 --> 00:02:51,000
And finally I can read token by token.

24
00:02:51,000 --> 00:02:56,000
So I can do while IN, N, COUT, N.

25
00:02:56,000 --> 00:03:06,000
And this will not only read whatever kind IN is, but it will convert the characters into the type of IN.

26
00:03:06,000 --> 00:03:11,000
So if I had a file full of integers, I could process it using this.

27
00:03:11,000 --> 00:03:13,000
Of course, this is slightly different.

28
00:03:13,000 --> 00:03:18,000
GET and GETLINE will only end when they run out of data.

29
00:03:18,000 --> 00:03:23,000
When I have a formatted input like this, or token-oriented input,

30
00:03:23,000 --> 00:03:30,000
it could end when there is something that is not an integer, for instance, in the stream.

31
00:03:30,000 --> 00:03:34,000
So we're going to look at a function that takes a stream as input,

32
00:03:34,000 --> 00:03:45,000
and we're going to use a data loop with the first exercise today called SUM EVENS.

33
00:03:45,000 --> 00:03:49,000
So make sure you've gone to week 3.

34
00:03:49,000 --> 00:03:54,000
On week 3, make sure you've gone to the files tab over here.

35
00:03:54,000 --> 00:03:56,000
Click the lecture exercises.

36
00:03:56,000 --> 00:03:59,000
Click the link for the starter code.

37
00:03:59,000 --> 00:04:03,000
Go ahead and make a copy of this, change the name on it,

38
00:04:03,000 --> 00:04:09,000
and we're ready to go with exercise A on data loops.

39
00:04:09,000 --> 00:04:18,000
So we're going to write the function SUMEVEN that adds all the even numbers inside its ISTREAM argument.

40
00:04:18,000 --> 00:04:26,000
So go ahead and open a shell over here on folder A in 12,

41
00:04:26,000 --> 00:04:39,000
and open up evensummer.cpp.

42
00:04:39,000 --> 00:04:43,000
So this function is going to return an int.

43
00:04:43,000 --> 00:04:46,000
Let's see what it was named again.

44
00:04:46,000 --> 00:04:48,000
It was named SUMEVENS.

45
00:04:48,000 --> 00:04:54,000
It's going to take an ISTREAM argument, so it's going to read from a stream.

46
00:04:54,000 --> 00:05:03,000
So SUMEVENS ISTREAM, we'll just call it int.

47
00:05:03,000 --> 00:05:11,000
And we'll do int sum is zero and return sum.

48
00:05:11,000 --> 00:05:17,000
Unfortunately when we try and compile this, when we just do make down here,

49
00:05:17,000 --> 00:05:22,000
you'll see we get a whole bunch of errors.

50
00:05:22,000 --> 00:05:30,000
And the problem is that we are passing the wrong kind of argument.

51
00:05:30,000 --> 00:05:38,000
So when you pass a stream, it's a library type, so you cannot pass it by value.

52
00:05:38,000 --> 00:05:42,000
So we're going to pass it by reference.

53
00:05:42,000 --> 00:05:47,000
And so now when we do make, the code compiles.

54
00:05:47,000 --> 00:05:51,000
So you cannot pass streams by value.

55
00:05:51,000 --> 00:05:55,000
You cannot pass streams by value.

56
00:05:55,000 --> 00:06:02,000
Now for our data loop, we want to read an integer from this stream.

57
00:06:02,000 --> 00:06:09,000
So we're going to have int n. We're going to say while int n.

58
00:06:09,000 --> 00:06:19,000
So while we read the integer n from int, if n remainder 2 equals zero,

59
00:06:19,000 --> 00:06:24,000
it's an even number, then we're going to add it to our sum.

60
00:06:24,000 --> 00:06:30,000
So sum plus equals n.

61
00:06:30,000 --> 00:06:40,000
Okay, so let's try that.

62
00:06:40,000 --> 00:06:44,000
Make test.

63
00:06:44,000 --> 00:06:47,000
And here we've added some integers here.

64
00:06:47,000 --> 00:06:51,000
One, two, three, four, one, two, five, seven.

65
00:06:51,000 --> 00:06:53,000
No even numbers here.

66
00:06:53,000 --> 00:06:55,000
All even numbers here.

67
00:06:55,000 --> 00:06:57,000
No numbers here.

68
00:06:57,000 --> 00:06:58,000
And so forth.

69
00:06:58,000 --> 00:07:01,000
So notice we're not doing this with a string.

70
00:07:01,000 --> 00:07:04,000
We're doing it with a stream.

71
00:07:04,000 --> 00:07:06,000
We're doing it with a stream.

72
00:07:06,000 --> 00:07:10,000
Remember all stream input is character input.

73
00:07:10,000 --> 00:07:21,000
Character input.

74
00:07:21,000 --> 00:07:26,000
So we talked about filter programs in the last lecture, in lecture 11.

75
00:07:26,000 --> 00:07:32,000
So filter programs read from standard input, and they write to standard output.

76
00:07:32,000 --> 00:07:37,000
State filters, like the one we did, look for changes in input.

77
00:07:37,000 --> 00:07:42,000
So CECO changed the state of its printed flag.

78
00:07:42,000 --> 00:07:47,000
So the printing Boolean flag was used to monitor the stream state

79
00:07:47,000 --> 00:07:51,000
when we did that with Alice in Wonderland.

80
00:07:51,000 --> 00:07:56,000
Process filters modify their stream's contents.

81
00:07:56,000 --> 00:08:02,000
So here, for instance, is the toUpper filter that I showed you in the last lecture.

82
00:08:02,000 --> 00:08:06,000
Well, CN getCH, C output, toUpperCH.

83
00:08:06,000 --> 00:08:10,000
So we're processing the data as we go through.

84
00:08:10,000 --> 00:08:20,000
So we're going to do that with an exercise just to get a little bit more used to stream input and output.

85
00:08:20,000 --> 00:08:26,000
We're going to write a 150 encryption library.

86
00:08:26,000 --> 00:08:31,000
So let's look at the details over there in our handout.

87
00:08:31,000 --> 00:08:36,000
So an encryption program scrambles the bytes in a file

88
00:08:36,000 --> 00:08:44,000
so that the file is unreadable except to those who know the decryption method and the secret keyword.

89
00:08:44,000 --> 00:08:50,000
Now, we're going to ignore 2,000 years of progress in the field of encryption,

90
00:08:50,000 --> 00:08:54,000
and we're going to use a method that was familiar to Julius Caesar.

91
00:08:54,000 --> 00:09:01,000
He simply replaced his A's with a D, B's with an E, and so forth.

92
00:09:01,000 --> 00:09:04,000
And this is called the Caesar cipher.

93
00:09:04,000 --> 00:09:13,000
And so the idea with a Caesar cipher, or any cipher, is you get input, which is plain text,

94
00:09:13,000 --> 00:09:18,000
and then you get output, which is called cipher text.

95
00:09:18,000 --> 00:09:20,000
Now, notice a couple things about it.

96
00:09:20,000 --> 00:09:25,000
We are only ciphering the things that are characters.

97
00:09:25,000 --> 00:09:34,000
We are not ciphering the spaces, and we're not ciphering any punctuation.

98
00:09:34,000 --> 00:09:37,000
We're only ciphering the characters.

99
00:09:37,000 --> 00:09:44,000
Now, with encryption, if we pass in encryption text, we should get back the plain text.

100
00:09:44,000 --> 00:09:51,000
So let's go ahead and look at our lib function in the starter code over here in B.

101
00:09:51,000 --> 00:09:56,000
Let's close Even Summer, close these shells we've opened already,

102
00:09:56,000 --> 00:10:02,000
go down to B, and you can see I have a folder called enclib.

103
00:10:02,000 --> 00:10:07,000
So let's open a shell on that, on enclib.

104
00:10:07,000 --> 00:10:14,000
And we're going to look at encrypt the header file.

105
00:10:14,000 --> 00:10:21,000
And you can see I've already put inside here the two functions we're going to write in the namespace inc.

106
00:10:21,000 --> 00:10:24,000
I've already documented them.

107
00:10:24,000 --> 00:10:31,000
And we are simply going to implement those two functions over here.

108
00:10:31,000 --> 00:10:38,000
So go ahead and put your name on the top there.

109
00:10:38,000 --> 00:10:49,000
And then let's grab from inc.h, let's grab the namespace,

110
00:10:49,000 --> 00:10:53,000
and the prototype, and pop it over here.

111
00:10:53,000 --> 00:10:59,000
I'm going to leave the documentation over here because it makes it a little bit easier.

112
00:10:59,000 --> 00:11:06,000
Ok, so we have one function that will take plain text and turn it to cipher text,

113
00:11:06,000 --> 00:11:11,000
and one function that will take cipher text and turn it to plain text.

114
00:11:11,000 --> 00:11:16,000
Notice each of these are going to read from input and write to output.

115
00:11:16,000 --> 00:11:19,000
So both of them are going to use a data loop.

116
00:11:19,000 --> 00:11:35,000
So char ch while in.get, notice we're not using cn here, ch, out.

117
00:11:35,000 --> 00:11:38,000
We're not using cout either.

118
00:11:38,000 --> 00:11:42,000
Put ch.

119
00:11:42,000 --> 00:11:50,000
Let's put the other one for the plain text one.

120
00:11:50,000 --> 00:11:56,000
So now we've got our stubs here, our things that read from input, write to output.

121
00:11:56,000 --> 00:12:00,000
We're not using the key here at all.

122
00:12:00,000 --> 00:12:06,000
And so let's do make test.

123
00:12:06,000 --> 00:12:14,000
So you can see on this, all of these failed of course because we haven't done any encryption.

124
00:12:14,000 --> 00:12:20,000
So I am getting, so notice I'm putting out exactly what I got in.

125
00:12:20,000 --> 00:12:26,000
So when I get in attack at dawn, I expect to get this as output.

126
00:12:26,000 --> 00:12:32,000
When I get in how now brown cow, I expect to get this as output.

127
00:12:32,000 --> 00:12:44,000
When I decrypt attack this, I expect to get attack at dawn and how now brown cow and I love cs150.

128
00:12:44,000 --> 00:12:49,000
So let's go and look at each of those characters.

129
00:12:49,000 --> 00:12:58,000
What we're going to do is we're going to add this number, shifting the characters rightward.

130
00:12:58,000 --> 00:13:04,000
So if it's an A and the key was one, it's going to become B.

131
00:13:04,000 --> 00:13:13,000
So we could simply try that by saying key.

132
00:13:13,000 --> 00:13:22,000
And to decrypt it, we're going to do the same thing.

133
00:13:22,000 --> 00:13:28,000
Okay, let's see how that works. That's pretty simplified.

134
00:13:28,000 --> 00:13:32,000
But let's see if it in fact works.

135
00:13:32,000 --> 00:13:39,000
It didn't look like it worked anywhere because look at, we are almost got that one right.

136
00:13:39,000 --> 00:13:44,000
But we're encrypting the spaces.

137
00:13:44,000 --> 00:13:54,000
So notice that that means that when we print the data out, we need to say,

138
00:13:54,000 --> 00:14:17,000
if, and we're going to use from the CC type up here, we're going to use the header, we're going to use the function if is alpha.

139
00:14:17,000 --> 00:14:19,000
And we could do it manually, right?

140
00:14:19,000 --> 00:14:24,000
We could say if ch, I mean I could do it like this.

141
00:14:24,000 --> 00:14:34,000
If ch is greater or equal to A and ch is less than or equal to Z.

142
00:14:34,000 --> 00:14:43,000
Or ch is greater or equal to A and ch is less than or equal to Z.

143
00:14:43,000 --> 00:14:52,000
That would be the same as saying if is alpha ch.

144
00:14:52,000 --> 00:14:55,000
Which is probably a little bit easier to read.

145
00:14:55,000 --> 00:15:01,000
So if it's alpha, we're going to print the thing with the key.

146
00:15:01,000 --> 00:15:09,000
Else, we're going to output ch.

147
00:15:09,000 --> 00:15:13,000
We're going to do the same thing up here.

148
00:15:13,000 --> 00:15:14,000
I'll just put it right there.

149
00:15:14,000 --> 00:15:20,000
If is alpha ch.

150
00:15:20,000 --> 00:15:21,000
I'll put that.

151
00:15:21,000 --> 00:15:28,000
Else, I'll put ch plus key.

152
00:15:28,000 --> 00:15:32,000
OK, let's try it this third time.

153
00:15:32,000 --> 00:15:40,000
The second time we didn't get any passing. Let's see if we get any passing this time.

154
00:15:40,000 --> 00:15:42,000
Ah, I got one passing.

155
00:15:42,000 --> 00:15:45,000
I got how now brown cow.

156
00:15:45,000 --> 00:15:55,000
How now brown cow.

157
00:15:55,000 --> 00:16:03,000
That one is still not working. Let me try that again.

158
00:16:03,000 --> 00:16:07,000
The first one is still not working at all and I thought we kind of fixed that.

159
00:16:07,000 --> 00:16:12,000
So let's look. Oh, notice the mistake I made there.

160
00:16:12,000 --> 00:16:17,000
So if it's not an alpha character, we just want to put it out.

161
00:16:17,000 --> 00:16:22,000
OK, not with the key.

162
00:16:22,000 --> 00:16:25,000
OK, let's try it again.

163
00:16:25,000 --> 00:16:27,000
Now we got two passing.

164
00:16:27,000 --> 00:16:32,000
So how now brown cow works in both cases.

165
00:16:32,000 --> 00:16:35,000
This is the encrypted version of it.

166
00:16:35,000 --> 00:16:40,000
This is the decrypted version of the ciphertext here.

167
00:16:40,000 --> 00:16:43,000
This doesn't quite work.

168
00:16:43,000 --> 00:16:45,000
So this is a tackadon.

169
00:16:45,000 --> 00:16:52,000
So attack seems to work. At seems to work.

170
00:16:52,000 --> 00:16:57,000
So instead of B here, I have that.

171
00:16:57,000 --> 00:17:00,000
So our key here is five.

172
00:17:00,000 --> 00:17:08,000
So if I take W, I should change it to an X for one, Y for two, Z for three.

173
00:17:08,000 --> 00:17:13,000
Oh, four is going to move me beyond the characters.

174
00:17:13,000 --> 00:17:21,000
Right. So if I'm at the end of the character, if I'm at the end of the set of characters and I'm moving to the right,

175
00:17:21,000 --> 00:17:27,000
then I have to add myself around. Right. I have to move it around.

176
00:17:27,000 --> 00:17:37,000
So that means we're kind of doing a remainder operator, but I need to use a.

177
00:17:37,000 --> 00:17:40,000
I need to use an actual modulus operator.

178
00:17:40,000 --> 00:17:48,000
So this looked pretty simple, but it's not actually that simple.

179
00:17:48,000 --> 00:17:54,000
So we can do it two ways. I'll show you one way where I do three things.

180
00:17:54,000 --> 00:18:13,000
So is upper. Ch. Else if is lower. Ch.

181
00:18:13,000 --> 00:18:23,000
OK, for this one, what we're going to do if it's upper, what I'm going to need to do is,

182
00:18:23,000 --> 00:18:29,000
you know, that's not going to work. Let me pause it for a second. Let me figure out how to get it to work.

183
00:18:29,000 --> 00:18:35,000
OK, so this is relatively complex. So what I'm going to have to do,

184
00:18:35,000 --> 00:18:51,000
so I'm going to have to take the ASCII code. If it's uppercase, I'm going to have to subtract it from the A.

185
00:18:51,000 --> 00:19:06,000
Then I'm going to add the key to it. I'm going to take that remainder 26.

186
00:19:06,000 --> 00:19:24,000
And then I'm going to add A to it. And we'd have to do exactly the same thing with the lowercase one.

187
00:19:24,000 --> 00:19:33,000
Except we change it to the lowercase character.

188
00:19:33,000 --> 00:19:43,000
So let's try that and see if the encryption works.

189
00:19:43,000 --> 00:19:50,000
So the encryption all works right here. Let me show you why that works.

190
00:19:50,000 --> 00:19:57,000
So basically with characters, here's what we have in memory.

191
00:19:57,000 --> 00:20:06,000
We have a whole bunch of ASCII characters and then A, B, C, D, through Z.

192
00:20:06,000 --> 00:20:17,000
Then some more characters and then A, B, C, D, through lowercase C and then some more characters.

193
00:20:17,000 --> 00:20:32,000
And so A is ASCII 65 and lowercase A is ASCII 97.

194
00:20:32,000 --> 00:20:39,000
So that's how they're organized. So what we need to do is we need to find the position.

195
00:20:39,000 --> 00:20:47,000
So if we get an A here, we want the number zero. If we get this A, we also want the number zero.

196
00:20:47,000 --> 00:20:54,000
So let's use that scheme. So I'm going to call that position.

197
00:20:54,000 --> 00:21:16,000
So int pos equals, so is upper CH? Then pos is going to be A minus CH.

198
00:21:16,000 --> 00:21:31,000
If it's not, if it's lower, then pos, now that's actually, we're going to say, int pos equals zero.

199
00:21:31,000 --> 00:21:56,000
If is upper CH, pos equals A minus CH. Else if is lower CH, pos equals A minus CH.

200
00:21:56,000 --> 00:22:05,000
So that gives me my position zero, one, two, three, four. I'm going to add the key to pos.

201
00:22:05,000 --> 00:22:18,000
And I'm going to take it remainder 26. So if we have W and we go beyond 26, it will wrap around to be the character B, which is what we want.

202
00:22:18,000 --> 00:22:30,000
So I'm going to say pos equals pos plus key remainder 26.

203
00:22:30,000 --> 00:22:55,000
Now, what do I need to do? If CH is upper, I need to output A plus pos.

204
00:22:55,000 --> 00:23:09,000
That will give me the character of that position. And in this case, I would need to output A plus pos.

205
00:23:09,000 --> 00:23:28,000
So we have to know for the difference if it's upper or lower case.

206
00:23:28,000 --> 00:23:35,000
OK, let's try that one and then we'll put it into the decryption thing.

207
00:23:35,000 --> 00:23:42,000
The decryption is slightly more complex. OK.

208
00:23:42,000 --> 00:23:46,000
OK, so all these I got completely wrong.

209
00:23:46,000 --> 00:23:49,000
And that didn't work at all.

210
00:23:49,000 --> 00:23:54,000
I'm going to pause again and spend a few seconds thinking about this.

211
00:23:54,000 --> 00:24:01,000
OK, I saw what I did last time. The mistake was I did the subtraction the wrong way.

212
00:24:01,000 --> 00:24:08,000
So let's say if is alpha CH.

213
00:24:08,000 --> 00:24:12,000
So it's got to be an upper case or lower case character.

214
00:24:12,000 --> 00:24:19,000
Let's find its position inside its respective character set.

215
00:24:19,000 --> 00:24:27,000
So if pos equals is upper CH.

216
00:24:27,000 --> 00:24:34,000
So its position is CH minus A.

217
00:24:34,000 --> 00:24:37,000
Before I wrote that as A minus CH.

218
00:24:37,000 --> 00:24:43,000
If it's lower case, its position is CH minus lower case A.

219
00:24:43,000 --> 00:24:49,000
So again, if that's an upper or lower case A, position will be zero.

220
00:24:49,000 --> 00:24:51,000
Now we want to update the position.

221
00:24:51,000 --> 00:25:01,000
So pos equals pos plus key.

222
00:25:01,000 --> 00:25:07,000
Remainder 26 to get us the wraparound effect.

223
00:25:07,000 --> 00:25:10,000
Now we want to update the characters.

224
00:25:10,000 --> 00:25:18,000
So CH equals is upper CH.

225
00:25:18,000 --> 00:25:26,000
If it's upper CH, then CH is uppercase A plus the position.

226
00:25:26,000 --> 00:25:32,000
And if it's lower case, it's lower case A plus the position.

227
00:25:32,000 --> 00:25:35,000
Now this is what we do if it's an alphabetical character.

228
00:25:35,000 --> 00:25:40,000
We encrypt it, all of the characters we print out right here.

229
00:25:40,000 --> 00:25:44,000
So let's try that.

230
00:25:44,000 --> 00:25:47,000
Let's do make test.

231
00:25:47,000 --> 00:25:51,000
And our encryption for the plain text works ok.

232
00:25:51,000 --> 00:25:58,000
And actually that is a little bit clearer as to what's happening there.

233
00:25:58,000 --> 00:26:05,000
Let's go ahead and just take this code here.

234
00:26:05,000 --> 00:26:09,000
And let's think about the decryption.

235
00:26:09,000 --> 00:26:15,000
Now the decryption, we're subtracting something from the key.

236
00:26:15,000 --> 00:26:19,000
And so again, we get the position the same.

237
00:26:19,000 --> 00:26:22,000
We subtract the key the same.

238
00:26:22,000 --> 00:26:26,000
But now we have a problem in this little piece of code right here.

239
00:26:26,000 --> 00:26:32,000
Because if this is a negative number, which it will be if we had an A and we shift it left,

240
00:26:32,000 --> 00:26:41,000
if that is a negative number, the mod 26 doesn't work.

241
00:26:41,000 --> 00:26:49,000
So what we have to do is add pos plus 26 minus key.

242
00:26:49,000 --> 00:26:57,000
In other words, we have to shift one whole alphabetical set at the same time.

243
00:26:57,000 --> 00:27:01,000
And that should do the decryption part ok.

244
00:27:01,000 --> 00:27:04,000
To turn it into plain text.

245
00:27:04,000 --> 00:27:07,000
So let's try it.

246
00:27:07,000 --> 00:27:09,000
Let's do make test.

247
00:27:09,000 --> 00:27:13,000
And that correctly decrypts our text.

248
00:27:13,000 --> 00:27:16,000
Attack at dawn is turned into this.

249
00:27:16,000 --> 00:27:23,000
This is turned into attack at dawn.

250
00:27:23,000 --> 00:27:28,000
Ok, so that was a little more complex than I expected.

251
00:27:28,000 --> 00:27:36,000
But a little bit of good review for process filters.

252
00:27:36,000 --> 00:27:38,000
Ok, so now let's go to our next topic.

253
00:27:38,000 --> 00:27:45,000
Our next topic is going to be how do I program using disk files.

254
00:27:45,000 --> 00:27:54,000
So C++ has some classes that explicitly allow you to specify the source to read from a file

255
00:27:54,000 --> 00:27:58,000
or a sink to write to a file in code.

256
00:27:58,000 --> 00:28:00,000
So these are in a new header.

257
00:28:00,000 --> 00:28:02,000
They are not in Iostream.

258
00:28:02,000 --> 00:28:04,000
It is in the header fstream.

259
00:28:04,000 --> 00:28:10,000
You probably also need to include Iostream if you want to use cin and cout

260
00:28:10,000 --> 00:28:13,000
because those are created in the Iostream header.

261
00:28:13,000 --> 00:28:17,000
So these classes are called ifstream.

262
00:28:17,000 --> 00:28:19,000
Not istream, ifstream.

263
00:28:19,000 --> 00:28:22,000
So the f signifying that it is a file.

264
00:28:22,000 --> 00:28:25,000
That will connect to a file and read data.

265
00:28:25,000 --> 00:28:31,000
An ofstream, again the f signifying a file, connect to a file and write data.

266
00:28:31,000 --> 00:28:38,000
Again, if you want to use cin and cout, those are created in Iostream, so include that as well.

267
00:28:38,000 --> 00:28:44,000
Now, using explicit files involves three steps.

268
00:28:44,000 --> 00:28:49,000
First, with cin and cout we didn't have to create any objects.

269
00:28:49,000 --> 00:28:59,000
With the ifstream and ofstream, we need to explicitly create an instance of the stream class we are going to use.

270
00:28:59,000 --> 00:29:05,000
So again, we didn't need to do these with the standard streams, cin and cout.

271
00:29:05,000 --> 00:29:09,000
We do need to use it with these explicit file streams.

272
00:29:09,000 --> 00:29:13,000
Secondly, we need to open the file or create the file.

273
00:29:13,000 --> 00:29:17,000
We simply associate the stream with a source or sync.

274
00:29:17,000 --> 00:29:19,000
There are a couple of different methods.

275
00:29:19,000 --> 00:29:24,000
And then we just read and write from it exactly as if it was cin and cout.

276
00:29:24,000 --> 00:29:33,000
Finally, in Java you have to be very, very careful to close your stream after you have opened it

277
00:29:33,000 --> 00:29:35,000
if you create a dist file stream.

278
00:29:35,000 --> 00:29:38,000
In C++ we don't need to worry about that.

279
00:29:38,000 --> 00:29:44,000
It will automatically be closed by a destructor, so you don't need to worry about that.

280
00:29:44,000 --> 00:29:51,000
You may occasionally need to use the close member function, but most of the time you will not.

281
00:29:51,000 --> 00:29:58,000
So, to create and associate the object, you can do this.

282
00:29:58,000 --> 00:30:05,000
Here I have created an instance of the stream, just like I create an int or any other variable.

283
00:30:05,000 --> 00:30:11,000
And then I have called the member function open and told it what text file I want to open.

284
00:30:11,000 --> 00:30:13,000
Now this is a path.

285
00:30:13,000 --> 00:30:17,000
This would be in the current working directory.

286
00:30:17,000 --> 00:30:22,000
If you wanted to open it in a different path, you would pass the entire path inside here

287
00:30:22,000 --> 00:30:26,000
as a C style string or as a string object.

288
00:30:26,000 --> 00:30:29,000
You can do the whole thing in one statement though,

289
00:30:29,000 --> 00:30:34,000
by just passing the path that you want to open to the constructor.

290
00:30:34,000 --> 00:30:38,000
So here I am using the default constructor and then calling open on it.

291
00:30:38,000 --> 00:30:41,000
Here I am just using the constructor that opens it.

292
00:30:41,000 --> 00:30:48,000
You would use exactly the same pattern for OFStream, which would create an output file.

293
00:30:48,000 --> 00:30:55,000
Now, how do we know if the file was opened correctly or it was created correctly?

294
00:30:55,000 --> 00:31:02,000
What you have to do, if you can't open it, is you have to check the stream itself.

295
00:31:02,000 --> 00:31:09,000
If the stream is false, or if its member function fail is true,

296
00:31:09,000 --> 00:31:12,000
then it didn't open correctly.

297
00:31:12,000 --> 00:31:14,000
It didn't open correctly.

298
00:31:14,000 --> 00:31:18,000
And so, what do you do when you can't open it?

299
00:31:18,000 --> 00:31:22,000
Well, you could use a loop and you could reprompt for the correct file name.

300
00:31:22,000 --> 00:31:25,000
If you are asking the user to enter a file name.

301
00:31:25,000 --> 00:31:27,000
Or you could print an error message.

302
00:31:27,000 --> 00:31:33,000
Now, since this is an error message, we want to use not cout, but we want to use cerror.

303
00:31:33,000 --> 00:31:40,000
And we could return from the function, return an error code, exit from the program altogether.

304
00:31:40,000 --> 00:31:46,000
So, let's look at an example that does that.

305
00:31:46,000 --> 00:31:52,000
And for this, we are going to use the second kind of data loop, a line oriented data loop.

306
00:31:52,000 --> 00:31:57,000
So, a line oriented data loop reads one line of text at a time.

307
00:31:57,000 --> 00:32:01,000
It throws away the new line from that line of text.

308
00:32:01,000 --> 00:32:06,000
Notice that it does not, git line does not return the string.

309
00:32:06,000 --> 00:32:13,000
Instead, the string is a string passed by reference, which is filled in, in the function.

310
00:32:13,000 --> 00:32:18,000
What it does return is it returns the stream object itself.

311
00:32:18,000 --> 00:32:21,000
And we'll use that as the boolean condition.

312
00:32:21,000 --> 00:32:26,000
While the stream is still good, git align.

313
00:32:26,000 --> 00:32:33,000
You also, with git line, it's sometimes hard to remember that it's not included in I/O's stream.

314
00:32:33,000 --> 00:32:37,000
It instead is a function inside the string type.

315
00:32:37,000 --> 00:32:40,000
So, you have to remember to include string.

316
00:32:40,000 --> 00:32:44,000
So, our third exercise today is the flip lines problems.

317
00:32:44,000 --> 00:32:48,000
What we are going to do is open a file or print an error message.

318
00:32:48,000 --> 00:32:51,000
So, we are going to go over the stuff we did in the last slide.

319
00:32:51,000 --> 00:32:57,000
And then we are going to reverse the first pair of lines, the second pair, and so forth.

320
00:32:57,000 --> 00:33:01,000
So, let's go over here.

321
00:33:01,000 --> 00:33:09,000
Let's look at the exercise.

322
00:33:09,000 --> 00:33:12,000
So, here we are going to read this file.

323
00:33:12,000 --> 00:33:15,000
We are going to read the first two lines.

324
00:33:15,000 --> 00:33:21,000
And then in the output we are going to take the second line and print it first, and the first line and print it second.

325
00:33:21,000 --> 00:33:23,000
We are going to do that through the whole file.

326
00:33:23,000 --> 00:33:27,000
Now, notice that a line can be blank, as on the third pair.

327
00:33:27,000 --> 00:33:32,000
And so we switch to "Beware the Jabberwock" with a blank line.

328
00:33:32,000 --> 00:33:37,000
And we may have an odd number of lines.

329
00:33:37,000 --> 00:33:41,000
In that case, only the last line is printed in its original position.

330
00:33:41,000 --> 00:33:47,000
It's not flipped with an invisible line that would be after it.

331
00:33:47,000 --> 00:33:49,000
Now, we are going to do two things here.

332
00:33:49,000 --> 00:33:55,000
We are going to do that, processing the line by line.

333
00:33:55,000 --> 00:34:00,000
But we are also going to look at the process for opening and checking a file.

334
00:34:00,000 --> 00:34:06,000
So, we are going to write the function named "flip lines" that accepts the name of the file as its parameter.

335
00:34:06,000 --> 00:34:10,000
It's not a stream, like the first exercise we did today.

336
00:34:10,000 --> 00:34:18,000
And it's going to open and write to the console the same file's contents with the lines switched, like I just said.

337
00:34:18,000 --> 00:34:29,000
If the file cannot be opened, then "cannot open filename.txt" is printed to "Sierra" with "filename.txt" replaced with the actual name.

338
00:34:29,000 --> 00:34:31,000
So, let's do that.

339
00:34:31,000 --> 00:34:34,000
OK, this is in C.

340
00:34:34,000 --> 00:34:38,000
So, we are going to do "flip lines".

341
00:34:38,000 --> 00:34:46,000
So, put our name on it.

342
00:34:46,000 --> 00:34:52,000
And the function is named "flip lines".

343
00:34:52,000 --> 00:35:00,000
It's not going to return anything, so it's going to be a void function.

344
00:35:00,000 --> 00:35:07,000
And it's going to take a string for the filename.

345
00:35:07,000 --> 00:35:09,000
So, there's our stub.

346
00:35:09,000 --> 00:35:14,000
Let's go ahead and open a terminal on C.

347
00:35:14,000 --> 00:35:17,000
And simply do "make" to make sure the stub works.

348
00:35:17,000 --> 00:35:22,000
Yes, it works. So, it complies.

349
00:35:22,000 --> 00:35:28,000
So, step one. We need to create an input stream on filename.

350
00:35:28,000 --> 00:35:35,000
So, "if stream in" and we'll pass in "fname".

351
00:35:35,000 --> 00:35:37,000
Let me do it. So, this is the original name.

352
00:35:37,000 --> 00:35:41,000
So, "in open fname".

353
00:35:41,000 --> 00:35:43,000
So, that's perfectly OK.

354
00:35:43,000 --> 00:35:45,000
It's kind of a lot of extra work, though.

355
00:35:45,000 --> 00:35:47,000
So, let's do this.

356
00:35:47,000 --> 00:35:52,000
"if stream in fname".

357
00:35:52,000 --> 00:35:55,000
So, that's "create" and "open" at the same time.

358
00:35:55,000 --> 00:35:59,000
And I'll comment out these first two lines.

359
00:35:59,000 --> 00:36:02,000
Now, we need to make sure if it opened.

360
00:36:02,000 --> 00:36:05,000
So, "if in failed" to open.

361
00:36:05,000 --> 00:36:08,000
"if in fail".

362
00:36:08,000 --> 00:36:15,000
What we're going to do is say "sr".

363
00:36:15,000 --> 00:36:21,000
"cannot open fname".

364
00:36:21,000 --> 00:36:26,000
And since this is a void function, I'm just going to return.

365
00:36:26,000 --> 00:36:29,000
Or, so I can do "return".

366
00:36:29,000 --> 00:36:31,000
Notice it's a void function.

367
00:36:31,000 --> 00:36:41,000
Or, I could skip this return.

368
00:36:41,000 --> 00:36:43,000
I could skip that return.

369
00:36:43,000 --> 00:36:47,000
And I could put the remaining part of the code in the "else" down here.

370
00:36:47,000 --> 00:36:49,000
So, I'll do that.

371
00:36:49,000 --> 00:36:54,000
I know specifically in 250 they don't like you putting this return inside there.

372
00:36:54,000 --> 00:36:57,000
So, I'll do that.

373
00:36:57,000 --> 00:36:59,000
I generally would do it.

374
00:36:59,000 --> 00:37:04,000
But, I'm trying to make it easier for you when you go on to the next class.

375
00:37:04,000 --> 00:37:07,000
So, we can't open the file name.

376
00:37:07,000 --> 00:37:10,000
If we didn't fail, what are we going to do?

377
00:37:10,000 --> 00:37:14,000
We're going to read the file and print it to output.

378
00:37:14,000 --> 00:37:16,000
So, I need two lines.

379
00:37:16,000 --> 00:37:18,000
I need to read two lines at a time.

380
00:37:18,000 --> 00:37:25,000
So, I'm going to have "string line1" and "line2".

381
00:37:25,000 --> 00:37:34,000
I'm going to say "while getline in line1".

382
00:37:34,000 --> 00:37:36,000
So, that's going to read one line.

383
00:37:36,000 --> 00:37:43,000
And now I'm going to say "if getline in line2".

384
00:37:43,000 --> 00:37:45,000
Now I've read two lines.

385
00:37:45,000 --> 00:37:49,000
If that fails, of course, I've only read one line.

386
00:37:49,000 --> 00:37:55,000
And then I'm going to do "cout".

387
00:37:55,000 --> 00:38:04,000
I'm going to print "line2", a new line, "line1", and a new line.

388
00:38:04,000 --> 00:38:22,000
If that failed, else, then of course I'm going to do "cout line1" and "line2" because we didn't read two lines.

389
00:38:22,000 --> 00:38:25,000
So, here's getting a file name in.

390
00:38:25,000 --> 00:38:27,000
Opening the file.

391
00:38:27,000 --> 00:38:34,000
If we can't open it, printing out an error message. Otherwise, reading and printing the output.

392
00:38:34,000 --> 00:38:38,000
So, let's try this. Let's open up a shell there.

393
00:38:38,000 --> 00:38:46,000
Let's do "make test".

394
00:38:46,000 --> 00:38:48,000
Oops.

395
00:38:48,000 --> 00:38:52,000
Sorry, I didn't want that. I guess because I had multiple ones there.

396
00:38:52,000 --> 00:39:02,000
I was trying to get rid of this extra one over here.

397
00:39:02,000 --> 00:39:04,000
Kind of too much work.

398
00:39:04,000 --> 00:39:09,000
"make test"

399
00:39:09,000 --> 00:39:15,000
Ok, so, here's an easy file that had a second line and a first line. It just replaced it.

400
00:39:15,000 --> 00:39:20,000
Here's trying to check the error message. Kind of an open, no loadout text.

401
00:39:20,000 --> 00:39:23,000
And here's the original test in here.

402
00:39:23,000 --> 00:39:27,000
Checking the file that was on the handout here.

403
00:39:27,000 --> 00:39:41,000
This file right here.

404
00:39:41,000 --> 00:39:47,000
Ok, so there's the whole function right there.

405
00:39:47,000 --> 00:39:53,000
Now, I, as I mentioned, I would probably do it like this.

406
00:39:53,000 --> 00:40:00,000
There's no reason to go on. I would remove that "else" part there.

407
00:40:00,000 --> 00:40:04,000
Because if I got here.

408
00:40:04,000 --> 00:40:13,000
I like that because it's a little bit shorter, personally.

409
00:40:13,000 --> 00:40:17,000
Alright, let's go on now.

410
00:40:17,000 --> 00:40:21,000
And look at token oriented dataloops.

411
00:40:21,000 --> 00:40:26,000
So this is what we started with today, while in VAR.

412
00:40:26,000 --> 00:40:29,000
We're reading one token at a time.

413
00:40:29,000 --> 00:40:36,000
Now this fails at end to file, like the other two loops do. The character oriented and the light oriented.

414
00:40:36,000 --> 00:40:40,000
And it fails when it can't convert the token.

415
00:40:40,000 --> 00:40:47,000
So if we failed because we couldn't convert a token, and we weren't at end to file,

416
00:40:47,000 --> 00:40:51,000
we'd need to clear the error flags with in.clear

417
00:40:51,000 --> 00:40:54,000
before we could read anything else.

418
00:40:54,000 --> 00:40:58,000
And then we'd still need to remove the offending input.

419
00:40:58,000 --> 00:41:04,000
So, here I've created a string just to hold the offending input.

420
00:41:04,000 --> 00:41:08,000
If in fail, in clear, in error data.

421
00:41:08,000 --> 00:41:17,000
So this clears the flags, this removes the token, and then we can keep going on

422
00:41:17,000 --> 00:41:21,000
to the remaining data.

423
00:41:21,000 --> 00:41:25,000
So we're going to look at a final exercise today.

424
00:41:25,000 --> 00:41:27,000
Expenses.

425
00:41:27,000 --> 00:41:32,000
We're going to process a file with characters and tokens.

426
00:41:32,000 --> 00:41:36,000
So we're going to learn a couple of tricks to doing that.

427
00:41:36,000 --> 00:41:40,000
So let's close flip lines.

428
00:41:40,000 --> 00:41:44,000
Let's open up d, expenses.cpp.

429
00:41:44,000 --> 00:41:49,000
Let's open expenses.txt too. So this is the file we're processing.

430
00:41:49,000 --> 00:41:53,000
What we want to do is we want to read each line.

431
00:41:53,000 --> 00:41:57,000
We want to sum up this person's expenses,

432
00:41:57,000 --> 00:42:02,000
print their name, and print their

433
00:42:02,000 --> 00:42:04,000
print their data out.

434
00:42:04,000 --> 00:42:10,000
Print the sum of their expenses.

435
00:42:10,000 --> 00:42:16,000
So let's add a comment on there. Notice we have an in file and an out file.

436
00:42:16,000 --> 00:42:19,000
We're going to open the input file.

437
00:42:19,000 --> 00:42:27,000
So if string in, in file.

438
00:42:27,000 --> 00:42:33,000
If we can't find it, if in fail.

439
00:42:33,000 --> 00:42:36,000
We're going to print an error message.

440
00:42:36,000 --> 00:42:47,000
Sierra cannot open in file.

441
00:42:47,000 --> 00:42:51,000
And I'm going to just return from that.

442
00:42:51,000 --> 00:42:54,000
Then we're going to create the output file.

443
00:42:54,000 --> 00:42:58,000
It says expenses summary, but we're going to use the name out file,

444
00:42:58,000 --> 00:43:00,000
which is created up here.

445
00:43:00,000 --> 00:43:08,000
So we're going to say OF string out,

446
00:43:08,000 --> 00:43:12,000
and I'm going to create it with out file.

447
00:43:12,000 --> 00:43:15,000
And we have to check to make sure that worked as well.

448
00:43:15,000 --> 00:43:20,000
So if out fail,

449
00:43:20,000 --> 00:43:29,000
Sierra cannot create out file,

450
00:43:29,000 --> 00:43:34,000
and I'll return there.

451
00:43:34,000 --> 00:43:38,000
Okay, so this is the setup before we do anything.

452
00:43:38,000 --> 00:43:42,000
Now we've opened both the input and output file,

453
00:43:42,000 --> 00:43:45,000
and we can loop through each character in the file.

454
00:43:45,000 --> 00:43:48,000
So let's write a loop that does that.

455
00:43:48,000 --> 00:43:51,000
I'm going to leave that up there

456
00:43:51,000 --> 00:43:56,000
and write it down here rather than writing inside it.

457
00:43:56,000 --> 00:44:06,000
So char ch while in get ch.

458
00:44:06,000 --> 00:44:09,000
Okay, so that's our main loop.

459
00:44:09,000 --> 00:44:12,000
Loop through each character in the file.

460
00:44:12,000 --> 00:44:18,000
Now if the character is a non-digit, then print it out.

461
00:44:18,000 --> 00:44:26,000
So if not is digit ch,

462
00:44:26,000 --> 00:44:35,000
out put ch.

463
00:44:35,000 --> 00:44:43,000
Otherwise, so else, we'll have some code inside here, the else.

464
00:44:43,000 --> 00:44:47,000
Okay, so we've read our first digit in the line.

465
00:44:47,000 --> 00:44:50,000
So again, let's look at expenses.txt.

466
00:44:50,000 --> 00:44:56,000
I read and printed that, that, that, that, that, that, that, that, that space,

467
00:44:56,000 --> 00:45:00,000
and now I've just read the two.

468
00:45:00,000 --> 00:45:07,000
So here I need to create and initialize a sum for the line.

469
00:45:07,000 --> 00:45:13,000
So double sum zero.

470
00:45:13,000 --> 00:45:20,000
I need to repeat until input fails or ch equals the null, right?

471
00:45:20,000 --> 00:45:30,000
So I need to say while in or while not in fail

472
00:45:30,000 --> 00:45:37,000
and ch is not equal to the null line.

473
00:45:37,000 --> 00:45:40,000
Now notice the instruction says until.

474
00:45:40,000 --> 00:45:46,000
We have to put it in the reverse sense and say keep going while this is true.

475
00:45:46,000 --> 00:45:50,000
Okay.

476
00:45:50,000 --> 00:46:00,000
So if ch is a digit,

477
00:46:00,000 --> 00:46:03,000
what we're going to do is put it back in the stream.

478
00:46:03,000 --> 00:46:12,000
So in put back ch

479
00:46:12,000 --> 00:46:18,000
or alternatively in unget would work as well.

480
00:46:18,000 --> 00:46:22,000
Now we need to read the entire number from the stream.

481
00:46:22,000 --> 00:46:24,000
So look at expenses.txt.

482
00:46:24,000 --> 00:46:28,000
We read the digit two, took it out of the stream,

483
00:46:28,000 --> 00:46:31,000
but we want to actually read this whole number.

484
00:46:31,000 --> 00:46:34,000
So we have to take the two and put it back in the stream

485
00:46:34,000 --> 00:46:37,000
so we're reading right from that point.

486
00:46:37,000 --> 00:46:40,000
Now to read that whole number and convert it, of course,

487
00:46:40,000 --> 00:46:44,000
what I need to use is formatted input.

488
00:46:44,000 --> 00:46:50,000
So I need to say double in, in, in.

489
00:46:50,000 --> 00:46:53,000
So we read the number from the stream.

490
00:46:53,000 --> 00:46:56,000
Of course we need to add the number to the sum.

491
00:46:56,000 --> 00:47:02,000
So sum plus equals in.

492
00:47:02,000 --> 00:47:06,000
Now if it's not a digit or even if it was a digit,

493
00:47:06,000 --> 00:47:10,000
after that loop we need to read the next digit.

494
00:47:10,000 --> 00:47:16,000
So in, get, ch.

495
00:47:16,000 --> 00:47:21,000
Now at the end of this while loop, after the loop is over,

496
00:47:21,000 --> 00:47:24,000
after we've done all of this stuff,

497
00:47:24,000 --> 00:47:28,000
we need to print the sum with two decimals and a new line.

498
00:47:28,000 --> 00:47:31,000
So that's right here.

499
00:47:31,000 --> 00:47:40,000
We need to say out, not cout, fixed, set precision,

500
00:47:40,000 --> 00:47:47,000
to, sum, end.

501
00:47:47,000 --> 00:47:51,000
Now we could actually put the out fixed precision up here

502
00:47:51,000 --> 00:47:54,000
even before the loop started, so we just have to do the sum.

503
00:47:54,000 --> 00:48:05,000
So this would be perfectly fine.

504
00:48:05,000 --> 00:48:11,000
And here we could just say out, sum, end out,

505
00:48:11,000 --> 00:48:23,000
and it kind of doesn't clutter up the flow of the control with the output.

506
00:48:23,000 --> 00:48:28,000
So here's our outer loop, well we can read a character.

507
00:48:28,000 --> 00:48:33,000
Here is our inner loop where we're summing up the numbers in one line

508
00:48:33,000 --> 00:48:43,000
and printing out the output.

509
00:48:43,000 --> 00:48:46,000
Okay, let's go ahead and try that and see how we did.

510
00:48:46,000 --> 00:48:56,000
Let's get a shell on that.

511
00:48:56,000 --> 00:49:04,000
So we're going to say make, and make test.

512
00:49:04,000 --> 00:49:11,000
Okay, so I tried to open a file that did not exist.

513
00:49:11,000 --> 00:49:16,000
I tried to open a file that you were not allowed to write to.

514
00:49:16,000 --> 00:49:21,000
And I tried to create a file with the correct input.

515
00:49:21,000 --> 00:49:22,000
That worked okay.

516
00:49:22,000 --> 00:49:28,000
Then I read the file, so that makes sure that I read the next correct number of lines.

517
00:49:28,000 --> 00:49:35,000
And then I correctly went through and read the, summed the data.

518
00:49:35,000 --> 00:49:45,000
Now you might wonder, you might wonder why I had to go to all this extra work inside here

519
00:49:45,000 --> 00:49:52,000
to read the, why I couldn't just do well in, arrow, arrow, end,

520
00:49:52,000 --> 00:49:54,000
and get it to work like that.

521
00:49:54,000 --> 00:50:01,000
Well notice, some of the people have put in notes inside here,

522
00:50:01,000 --> 00:50:04,000
and we have to make sure we skip over those.

523
00:50:04,000 --> 00:50:12,000
And so those would fail inside, inside that line.

524
00:50:12,000 --> 00:50:18,000
And so this last exercise we did, process a file with characters

525
00:50:18,000 --> 00:50:26,000
and with token oriented input, and opening files.

526
00:50:26,000 --> 00:50:29,000
Okay, that's it for today.

527
00:50:29,000 --> 00:50:34,000
And I will see you on the next lecture, on lecture 13.


