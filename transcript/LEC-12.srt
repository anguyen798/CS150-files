1
00:00:00,000 --> 00:00:00,000
Hello everyone, welcome to lecture 12. I'm Steve Gilbert and today we're going to look at processing disk files.

2
00:00:00,000 --> 00:00:00,000
Let's start with a little bit of review though.

3
00:00:00,000 --> 00:00:00,000
So first I want to look at streams and data loops.

4
00:00:00,000 --> 00:00:00,000
So the stream classes that we're going to use are IStream and OStream.

5
00:00:00,000 --> 00:00:00,000
IStream is the input stream class. It's a class that knows how to read data and bring it into your program.

6
00:00:00,000 --> 00:00:00,000
The OStream class is an output stream class. It knows how to read/write data and send it out of your program.

7
00:00:00,000 --> 00:00:00,000
When your program starts up, it automatically creates several global standard stream objects.

8
00:00:00,000 --> 00:00:00,000
CIN for input, COUT for output, and CERR for sending out error messages.

9
00:00:00,000 --> 00:00:00,000
These are automatically connected to your operating system's standard streams called StandardIN, StandardOUT, and StandardERR.

10
00:00:00,000 --> 00:00:00,000
By the way, Java does exactly the same thing. StandardIN is connected to a scanner object when you create it.

11
00:00:00,000 --> 00:00:00,000
System.OUT is connected to the StandardOUTput just like COUT is.

12
00:00:00,000 --> 00:00:00,000
And System.ERR is connected to StandardOUTput just like CERR is in Java.

13
00:00:00,000 --> 00:00:00,000
Now we can use these streams with a special kind of loop called a data loop.

14
00:00:00,000 --> 00:00:00,000
A data loop stops not when we reach a counter, not when we reach a limit, but when the source is out of data.

15
00:00:00,000 --> 00:00:00,000
And there are three different ways to read from a stream.

16
00:00:00,000 --> 00:00:00,000
We can read a character by character, which is what we did when we wrote our filter programs in the last lecture.

17
00:00:00,000 --> 00:00:00,000
So while CIN, GET CH, COUT, PUT CH.

18
00:00:00,000 --> 00:00:00,000
We can also use the string function called GETLINE to read an entire line of input.

19
00:00:00,000 --> 00:00:00,000
So notice here I'm saying while GETLINE, I'm using any kind of input stream, IN, LINE,

20
00:00:00,000 --> 00:00:00,000
and this will again, when it's out of data, it will return false, and I'm printing out the line.

21
00:00:00,000 --> 00:00:00,000
When you read this line, it will strip the new line character from the end,

22
00:00:00,000 --> 00:00:00,000
so I needed to add it here if I wanted my output to look the same as the input.

23
00:00:00,000 --> 00:00:00,000
And finally I can read token by token.

24
00:00:00,000 --> 00:00:00,000
So I can do while IN, N, COUT, N.

25
00:00:00,000 --> 00:00:00,000
And this will not only read whatever kind IN is, but it will convert the characters into the type of IN.

26
00:00:00,000 --> 00:00:00,000
So if I had a file full of integers, I could process it using this.

27
00:00:00,000 --> 00:00:00,000
Of course, this is slightly different.

28
00:00:00,000 --> 00:00:00,000
GET and GETLINE will only end when they run out of data.

29
00:00:00,000 --> 00:00:00,000
When I have a formatted input like this, or token-oriented input,

30
00:00:00,000 --> 00:00:00,000
it could end when there is something that is not an integer, for instance, in the stream.

31
00:00:00,000 --> 00:00:00,000
So we're going to look at a function that takes a stream as input,

32
00:00:00,000 --> 00:00:00,000
and we're going to use a data loop with the first exercise today called SUM EVENS.

33
00:00:00,000 --> 00:00:00,000
So make sure you've gone to week 3.

34
00:00:00,000 --> 00:00:00,000
On week 3, make sure you've gone to the files tab over here.

35
00:00:00,000 --> 00:00:00,000
Click the lecture exercises.

36
00:00:00,000 --> 00:00:00,000
Click the link for the starter code.

37
00:00:00,000 --> 00:00:00,000
Go ahead and make a copy of this, change the name on it,

38
00:00:00,000 --> 00:00:00,000
and we're ready to go with exercise A on data loops.

39
00:00:00,000 --> 00:00:00,000
So we're going to write the function SUMEVEN that adds all the even numbers inside its ISTREAM argument.

40
00:00:00,000 --> 00:00:00,000
So go ahead and open a shell over here on folder A in 12,

41
00:00:00,000 --> 00:00:00,000
and open up evensummer.cpp.

42
00:00:00,000 --> 00:00:00,000
So this function is going to return an int.

43
00:00:00,000 --> 00:00:00,000
Let's see what it was named again.

44
00:00:00,000 --> 00:00:00,000
It was named SUMEVENS.

45
00:00:00,000 --> 00:00:00,000
It's going to take an ISTREAM argument, so it's going to read from a stream.

46
00:00:00,000 --> 00:00:00,000
So SUMEVENS ISTREAM, we'll just call it int.

47
00:00:00,000 --> 00:00:00,000
And we'll do int sum is zero and return sum.

48
00:00:00,000 --> 00:00:00,000
Unfortunately when we try and compile this, when we just do make down here,

49
00:00:00,000 --> 00:00:00,000
you'll see we get a whole bunch of errors.

50
00:00:00,000 --> 00:00:00,000
And the problem is that we are passing the wrong kind of argument.

51
00:00:00,000 --> 00:00:00,000
So when you pass a stream, it's a library type, so you cannot pass it by value.

52
00:00:00,000 --> 00:00:00,000
So we're going to pass it by reference.

53
00:00:00,000 --> 00:00:00,000
And so now when we do make, the code compiles.

54
00:00:00,000 --> 00:00:00,000
So you cannot pass streams by value.

55
00:00:00,000 --> 00:00:00,000
You cannot pass streams by value.

56
00:00:00,000 --> 00:00:00,000
Now for our data loop, we want to read an integer from this stream.

57
00:00:00,000 --> 00:00:00,000
So we're going to have int n. We're going to say while int n.

58
00:00:00,000 --> 00:00:00,000
So while we read the integer n from int, if n remainder 2 equals zero,

59
00:00:00,000 --> 00:00:00,000
it's an even number, then we're going to add it to our sum.

60
00:00:00,000 --> 00:00:00,000
So sum plus equals n.

61
00:00:00,000 --> 00:00:00,000
Okay, so let's try that.

62
00:00:00,000 --> 00:00:00,000
Make test.

63
00:00:00,000 --> 00:00:00,000
And here we've added some integers here.

64
00:00:00,000 --> 00:00:00,000
One, two, three, four, one, two, five, seven.

65
00:00:00,000 --> 00:00:00,000
No even numbers here.

66
00:00:00,000 --> 00:00:00,000
All even numbers here.

67
00:00:00,000 --> 00:00:00,000
No numbers here.

68
00:00:00,000 --> 00:00:00,000
And so forth.

69
00:00:00,000 --> 00:00:00,000
So notice we're not doing this with a string.

70
00:00:00,000 --> 00:00:00,000
We're doing it with a stream.

71
00:00:00,000 --> 00:00:00,000
We're doing it with a stream.

72
00:00:00,000 --> 00:00:00,000
Remember all stream input is character input.

73
00:00:00,000 --> 00:00:00,000
Character input.

74
00:00:00,000 --> 00:00:00,000
So we talked about filter programs in the last lecture, in lecture 11.

75
00:00:00,000 --> 00:00:00,000
So filter programs read from standard input, and they write to standard output.

76
00:00:00,000 --> 00:00:00,000
State filters, like the one we did, look for changes in input.

77
00:00:00,000 --> 00:00:00,000
So CECO changed the state of its printed flag.

78
00:00:00,000 --> 00:00:00,000
So the printing Boolean flag was used to monitor the stream state,

79
00:00:00,000 --> 00:00:00,000
when we did that with Alice in Wonderland.

80
00:00:00,000 --> 00:00:00,000
Process filters modify their stream's contents.

81
00:00:00,000 --> 00:00:00,000
So here, for instance, is the toUpper filter that I showed you in the last lecture.

82
00:00:00,000 --> 00:00:00,000
Well, CN getCH, C output, toUpperCH.

83
00:00:00,000 --> 00:00:00,000
So we're processing the data as we go through.

84
00:00:00,000 --> 00:00:00,000
So we're going to do that with an exercise, just to get a little bit more used to stream input and output.

85
00:00:00,000 --> 00:00:00,000
We're going to write a 150 encryption library.

86
00:00:00,000 --> 00:00:00,000
So let's look at the details over there in our handout.

87
00:00:00,000 --> 00:00:00,000
So an encryption program scrambles the bytes in a file,

88
00:00:00,000 --> 00:00:00,000
so that the file is unreadable, except to those who know the decryption method and the secret keyword.

89
00:00:00,000 --> 00:00:00,000
Now, we're going to ignore 2000 years of progress in the field of encryption,

90
00:00:00,000 --> 00:00:00,000
and we're going to use a method that was familiar to Julius Caesar.

91
00:00:00,000 --> 00:00:00,000
He simply replaced his A's with a D, B's with an E, and so forth.

92
00:00:00,000 --> 00:00:00,000
And this is called the Caesar Cipher.

93
00:00:00,000 --> 00:00:00,000
And so the idea with a Caesar Cipher, or any cipher,

94
00:00:00,000 --> 00:00:00,000
is you get input, which is plain text,

95
00:00:00,000 --> 00:00:00,000
and then you get output, which is called cipher text.

96
00:00:00,000 --> 00:00:00,000
Now, notice a couple things about it.

97
00:00:00,000 --> 00:00:00,000
We are only ciphering the things that are characters.

98
00:00:00,000 --> 00:00:00,000
We are not ciphering the spaces, and we're not ciphering any punctuation.

99
00:00:00,000 --> 00:00:00,000
We're only ciphering the characters.

100
00:00:00,000 --> 00:00:00,000
Now, with encryption, if we pass in encryption text, we should get back the plain text.

101
00:00:00,000 --> 00:00:00,000
So let's go ahead and look at our lib function in the starter code over here in B.

102
00:00:00,000 --> 00:00:00,000
Let's close Even Summer, close these shells we've opened already,

103
00:00:00,000 --> 00:00:00,000
go down to B, and you can see I have a folder called enclib.

104
00:00:00,000 --> 00:00:00,000
So let's open a shell on that, on enclib,

105
00:00:00,000 --> 00:00:00,000
and we're going to look at encrypt the header file.

106
00:00:00,000 --> 00:00:00,000
And you can see I've already put inside here the two functions we're going to write in the namespace inc.

107
00:00:00,000 --> 00:00:00,000
I've already documented them.

108
00:00:00,000 --> 00:00:00,000
And we are simply going to implement those two functions over here.

109
00:00:00,000 --> 00:00:00,000
So go ahead and put your name on the top there.

110
00:00:00,000 --> 00:00:00,000
And then let's grab from inc.h, let's grab the namespace,

111
00:00:00,000 --> 00:00:00,000
and the prototype, and pop it over here.

112
00:00:00,000 --> 00:00:00,000
I'm going to leave the documentation over here because it makes it a little bit easier.

113
00:00:00,000 --> 00:00:00,000
Ok, so we have one function that will take plain text and turn it to cipher text,

114
00:00:00,000 --> 00:00:00,000
and one function that will take cipher text and turn it to plain text.

115
00:00:00,000 --> 00:00:00,000
Notice each of these are going to read from input and write to output.

116
00:00:00,000 --> 00:00:00,000
So both of them are going to use a data loop.

117
00:00:00,000 --> 00:00:00,000
So char ch while in.get, notice we're not using cn here, ch, out.

118
00:00:00,000 --> 00:00:00,000
We're not using cout either.

119
00:00:00,000 --> 00:00:00,000
Put ch.

120
00:00:00,000 --> 00:00:00,000
Let's put the other one for the plain text one.

121
00:00:00,000 --> 00:00:00,000
So now we've got our stubs here, our things that read from input, write to output.

122
00:00:00,000 --> 00:00:00,000
We're not using the key here at all.

123
00:00:00,000 --> 00:00:00,000
And so let's do make test.

124
00:00:00,000 --> 00:00:00,000
So you can see on this, all of these failed of course because we haven't done any encryption.

125
00:00:00,000 --> 00:00:00,000
So I am getting, so notice I'm putting out exactly what I got in.

126
00:00:00,000 --> 00:00:00,000
So when I get in attack at dawn, I expect to get this as output.

127
00:00:00,000 --> 00:00:00,000
When I get in how now brown cow, I expect to get this as output.

128
00:00:00,000 --> 00:00:00,000
When I decrypt attack this, I expect to get attack at dawn and how now brown cow and I love cs150.

129
00:00:00,000 --> 00:00:00,000
So let's go and look at each of those characters.

130
00:00:00,000 --> 00:00:00,000
What we're going to do is we're going to add this number, shifting the characters rightward.

131
00:00:00,000 --> 00:00:00,000
So if it's an A and the key was one, it's going to become B.

132
00:00:00,000 --> 00:00:00,000
So we could simply try that by saying key.

133
00:00:00,000 --> 00:00:00,000
And to decrypt it, we're going to do the same thing.

134
00:00:00,000 --> 00:00:00,000
Okay, let's see how that works. That's pretty simplified.

135
00:00:00,000 --> 00:00:00,000
But let's see if it in fact works.

136
00:00:00,000 --> 00:00:00,000
It didn't look like it worked anywhere because look at, we are almost got that one right.

137
00:00:00,000 --> 00:00:00,000
But we're encrypting the spaces.

138
00:00:00,000 --> 00:00:00,000
So notice that that means that when we print the data out, we need to say,

139
00:00:00,000 --> 00:00:00,000
if, and we're going to use from the CC type up here, we're going to use the header, we're going to use the function if is alpha.

140
00:00:00,000 --> 00:00:00,000
And we could do it manually, right?

141
00:00:00,000 --> 00:00:00,000
We could say if ch, I mean I could do it like this.

142
00:00:00,000 --> 00:00:00,000
If ch is greater or equal to A and ch is less than or equal to Z.

143
00:00:00,000 --> 00:00:00,000
Or ch is greater or equal to A and ch is less than or equal to Z.

144
00:00:00,000 --> 00:00:00,000
That would be the same as saying if is alpha ch.

145
00:00:00,000 --> 00:00:00,000
Which is probably a little bit easier to read.

146
00:00:00,000 --> 00:00:00,000
So if it's alpha, we're going to print the thing with the key.

147
00:00:00,000 --> 00:00:00,000
Else, we're going to output ch.

148
00:00:00,000 --> 00:00:00,000
We're going to do the same thing up here.

149
00:00:00,000 --> 00:00:00,000
I'll just put it right there.

150
00:00:00,000 --> 00:00:00,000
If is alpha ch.

151
00:00:00,000 --> 00:00:00,000
I'll put that.

152
00:00:00,000 --> 00:00:00,000
Else, I'll put ch plus key.

153
00:00:00,000 --> 00:00:00,000
OK, let's try it this third time.

154
00:00:00,000 --> 00:00:00,000
The second time we didn't get any passing. Let's see if we get any passing this time.

155
00:00:00,000 --> 00:00:00,000
Ah, I got one passing.

156
00:00:00,000 --> 00:00:00,000
I got how now brown cow.

157
00:00:00,000 --> 00:00:00,000
How now brown cow.

158
00:00:00,000 --> 00:00:00,000
That one is still not working. Let me try that again.

159
00:00:00,000 --> 00:00:00,000
The first one is still not working at all and I thought we kind of fixed that.

160
00:00:00,000 --> 00:00:00,000
So let's look. Oh, notice the mistake I made there.

161
00:00:00,000 --> 00:00:00,000
So if it's not an alpha character, we just want to put it out.

162
00:00:00,000 --> 00:00:00,000
OK, not with the key.

163
00:00:00,000 --> 00:00:00,000
OK, let's try it again.

164
00:00:00,000 --> 00:00:00,000
Now we got two passing.

165
00:00:00,000 --> 00:00:00,000
So how now brown cow works in both cases.

166
00:00:00,000 --> 00:00:00,000
This is the encrypted version of it.

167
00:00:00,000 --> 00:00:00,000
This is the decrypted version of the ciphertext here.

168
00:00:00,000 --> 00:00:00,000
This doesn't quite work.

169
00:00:00,000 --> 00:00:00,000
So this is a tackadon.

170
00:00:00,000 --> 00:00:00,000
So attack seems to work. At seems to work.

171
00:00:00,000 --> 00:00:00,000
So instead of B here, I have that.

172
00:00:00,000 --> 00:00:00,000
So our key here is five.

173
00:00:00,000 --> 00:00:00,000
So if I take W, I should change it to an X for one, Y for two, Z for three.

174
00:00:00,000 --> 00:00:00,000
Oh, four is going to move me beyond the characters.

175
00:00:00,000 --> 00:00:00,000
Right. So if I'm at the end of the character, if I'm at the end of the set of characters and I'm moving to the right,

176
00:00:00,000 --> 00:00:00,000
then I have to add myself around. Right. I have to move it around.

177
00:00:00,000 --> 00:00:00,000
So that means we're kind of doing a remainder operator, but I need to use a.

178
00:00:00,000 --> 00:00:00,000
I need to use an actual modulus operator.

179
00:00:00,000 --> 00:00:00,000
So this looked pretty simple, but it's not actually that simple.

180
00:00:00,000 --> 00:00:00,000
So we can do it two ways. I'll show you one way where I do three things.

181
00:00:00,000 --> 00:00:00,000
So is upper. Ch. Else if is lower. Ch.

182
00:00:00,000 --> 00:00:00,000
OK, for this one, what we're going to do if it's upper, what I'm going to need to do is,

183
00:00:00,000 --> 00:00:00,000
you know, that's not going to work. Let me pause it for a second. Let me figure out how to get it to work.

184
00:00:00,000 --> 00:00:00,000
OK, so this is relatively complex. So what I'm going to have to do,

185
00:00:00,000 --> 00:00:00,000
so I'm going to have to take the ASCII code. If it's uppercase, I'm going to have to subtract it from the A.

186
00:00:00,000 --> 00:00:00,000
Then I'm going to add the key to it. I'm going to take that remainder 26.

187
00:00:00,000 --> 00:00:00,000
And then I'm going to add A to it. And we'd have to do exactly the same thing with the lowercase one.

188
00:00:00,000 --> 00:00:00,000
Except we change it to the lowercase character.

189
00:00:00,000 --> 00:00:00,000
So let's try that and see if the encryption works.

190
00:00:00,000 --> 00:00:00,000
So the encryption all works right here. Let me show you why that works.

191
00:00:00,000 --> 00:00:00,000
So basically with characters, here's what we have in memory.

192
00:00:00,000 --> 00:00:00,000
We have a whole bunch of ASCII characters and then A, B, C, D, through Z.

193
00:00:00,000 --> 00:00:00,000
Then some more characters and then A, B, C, D, through lowercase C and then some more characters.

194
00:00:00,000 --> 00:00:00,000
And so A is ASCII 65 and lowercase A is ASCII 97.

195
00:00:00,000 --> 00:00:00,000
So that's how they're organized. So what we need to do is we need to find the position.

196
00:00:00,000 --> 00:00:00,000
So if we get an A here, we want the number zero. If we get this A, we also want the number zero.

197
00:00:00,000 --> 00:00:00,000
So let's use that scheme. So I'm going to call that position.

198
00:00:00,000 --> 00:00:00,000
So int pos equals, so is upper CH? Then pos is going to be A minus CH.

199
00:00:00,000 --> 00:00:00,000
If it's not, if it's lower, then pos, now that's actually, we're going to say, int pos equals zero.

200
00:00:00,000 --> 00:00:00,000
If is upper CH, pos equals A minus CH. Else if is lower CH, pos equals A minus CH.

201
00:00:00,000 --> 00:00:00,000
So that gives me my position zero, one, two, three, four. I'm going to add the key to pos.

202
00:00:00,000 --> 00:00:00,000
And I'm going to take it remainder 26. So if we have W and we go beyond 26, it will wrap around to be the character B, which is what we want.

203
00:00:00,000 --> 00:00:00,000
So I'm going to say pos equals pos plus key remainder 26.

204
00:00:00,000 --> 00:00:00,000
Now, what do I need to do? If CH is upper, I need to output A plus pos.

205
00:00:00,000 --> 00:00:00,000
That will give me the character of that position. And in this case, I would need to output A plus pos.

206
00:00:00,000 --> 00:00:00,000
So we have to know for the difference if it's upper or lower case.

207
00:00:00,000 --> 00:00:00,000
OK, let's try that one and then we'll put it into the decryption thing.

208
00:00:00,000 --> 00:00:00,000
The decryption is slightly more complex. OK.

209
00:00:00,000 --> 00:00:00,000
OK, so all these I got completely wrong.

210
00:00:00,000 --> 00:00:00,000
And that didn't work at all.

211
00:00:00,000 --> 00:00:00,000
I'm going to pause again and spend a few seconds thinking about this.

212
00:00:00,000 --> 00:00:00,000
OK, I saw what I did last time. The mistake was I did the subtraction the wrong way.

213
00:00:00,000 --> 00:00:00,000
So let's say if is alpha CH.

214
00:00:00,000 --> 00:00:00,000
So it's got to be an upper case or lower case character.

215
00:00:00,000 --> 00:00:00,000
Let's find its position inside its respective character set.

216
00:00:00,000 --> 00:00:00,000
So if pos equals is upper CH.

217
00:00:00,000 --> 00:00:00,000
So its position is CH minus A.

218
00:00:00,000 --> 00:00:00,000
Before I wrote that as A minus CH.

219
00:00:00,000 --> 00:00:00,000
If it's lower case, its position is CH minus lower case A.

220
00:00:00,000 --> 00:00:00,000
So again, if that's an upper or lower case A, position will be zero.

221
00:00:00,000 --> 00:00:00,000
Now we want to update the position.

222
00:00:00,000 --> 00:00:00,000
So pos equals pos plus key.

223
00:00:00,000 --> 00:00:00,000
Remainder 26 to get us the wraparound effect.

224
00:00:00,000 --> 00:00:00,000
Now we want to update the characters.

225
00:00:00,000 --> 00:00:00,000
So CH equals is upper CH.

226
00:00:00,000 --> 00:00:00,000
If it's upper CH, then CH is uppercase A plus the position.

227
00:00:00,000 --> 00:00:00,000
And if it's lower case, it's lower case A plus the position.

228
00:00:00,000 --> 00:00:00,000
Now this is what we do if it's an alphabetical character.

229
00:00:00,000 --> 00:00:00,000
We encrypt it, all of the characters we print out right here.

230
00:00:00,000 --> 00:00:00,000
So let's try that.

231
00:00:00,000 --> 00:00:00,000
Let's do make test.

232
00:00:00,000 --> 00:00:00,000
And our encryption for the plain text works ok.

233
00:00:00,000 --> 00:00:00,000
And actually that is a little bit clearer as to what's happening there.

234
00:00:00,000 --> 00:00:00,000
Let's go ahead and just take this code here.

235
00:00:00,000 --> 00:00:00,000
And let's think about the decryption.

236
00:00:00,000 --> 00:00:00,000
Now the decryption, we're subtracting something from the key.

237
00:00:00,000 --> 00:00:00,000
And so again, we get the position the same.

238
00:00:00,000 --> 00:00:00,000
We subtract the key the same.

239
00:00:00,000 --> 00:00:00,000
But now we have a problem in this little piece of code right here.

240
00:00:00,000 --> 00:00:00,000
Because if this is a negative number, which it will be if we had an A and we shift it left,

241
00:00:00,000 --> 00:00:00,000
if that is a negative number, the mod 26 doesn't work.

242
00:00:00,000 --> 00:00:00,000
So what we have to do is add pos plus 26 minus key.

243
00:00:00,000 --> 00:00:00,000
In other words, we have to shift one whole alphabetical set at the same time.

244
00:00:00,000 --> 00:00:00,000
And that should do the decryption part ok.

245
00:00:00,000 --> 00:00:00,000
To turn it into plain text.

246
00:00:00,000 --> 00:00:00,000
So let's try it.

247
00:00:00,000 --> 00:00:00,000
Let's do make test.

248
00:00:00,000 --> 00:00:00,000
And that correctly decrypts our text.

249
00:00:00,000 --> 00:00:00,000
Attack at dawn is turned into this.

250
00:00:00,000 --> 00:00:00,000
This is turned into attack at dawn.

251
00:00:00,000 --> 00:00:00,000
Ok, so that was a little more complex than I expected.

252
00:00:00,000 --> 00:00:00,000
But a little bit of good review for process filters.

253
00:00:00,000 --> 00:00:00,000
Ok, so now let's go to our next topic.

254
00:00:00,000 --> 00:00:00,000
Our next topic is going to be how do I program using disk files.

255
00:00:00,000 --> 00:00:00,000
So C++ has some classes that explicitly allow you to specify the source to read from a file

256
00:00:00,000 --> 00:00:00,000
or a sink to write to a file in code.

257
00:00:00,000 --> 00:00:00,000
So these are in a new header.

258
00:00:00,000 --> 00:00:00,000
They are not in Iostream.

259
00:00:00,000 --> 00:00:00,000
It is in the header fstream.

260
00:00:00,000 --> 00:00:00,000
You probably also need to include Iostream if you want to use cin and cout

261
00:00:00,000 --> 00:00:00,000
because those are created in the Iostream header.

262
00:00:00,000 --> 00:00:00,000
So these classes are called ifstream.

263
00:00:00,000 --> 00:00:00,000
Not istream, ifstream.

264
00:00:00,000 --> 00:00:00,000
So the f signifying that it is a file.

265
00:00:00,000 --> 00:00:00,000
That will connect to a file and read data.

266
00:00:00,000 --> 00:00:00,000
An ofstream, again the f signifying a file, connect to a file and write data.

267
00:00:00,000 --> 00:00:00,000
Again, if you want to use cin and cout, those are created in Iostream, so include that as well.

268
00:00:00,000 --> 00:00:00,000
Now, using explicit files involves three steps.

269
00:00:00,000 --> 00:00:00,000
First, with cin and cout we didn't have to create any objects.

270
00:00:00,000 --> 00:00:00,000
With the ifstream and ofstream, we need to explicitly create an instance of the stream class we are going to use.

271
00:00:00,000 --> 00:00:00,000
So again, we didn't need to do these with the standard streams, cin and cout.

272
00:00:00,000 --> 00:00:00,000
We do need to use it with these explicit file streams.

273
00:00:00,000 --> 00:00:00,000
Secondly, we need to open the file or create the file.

274
00:00:00,000 --> 00:00:00,000
We simply associate the stream with a source or sync.

275
00:00:00,000 --> 00:00:00,000
There are a couple of different methods.

276
00:00:00,000 --> 00:00:00,000
And then we just read and write from it exactly as if it was cin and cout.

277
00:00:00,000 --> 00:00:00,000
Finally, in Java you have to be very, very careful to close your stream after you have opened it

278
00:00:00,000 --> 00:00:00,000
if you create a dist file stream.

279
00:00:00,000 --> 00:00:00,000
In C++ we don't need to worry about that.

280
00:00:00,000 --> 00:00:00,000
It will automatically be closed by a destructor, so you don't need to worry about that.

281
00:00:00,000 --> 00:00:00,000
You may occasionally need to use the close member function, but most of the time you will not.

282
00:00:00,000 --> 00:00:00,000
So, to create and associate the object, you can do this.

283
00:00:00,000 --> 00:00:00,000
Here I have created an instance of the stream, just like I create an int or any other variable.

284
00:00:00,000 --> 00:00:00,000
And then I have called the member function open and told it what text file I want to open.

285
00:00:00,000 --> 00:00:00,000
Now this is a path.

286
00:00:00,000 --> 00:00:00,000
This would be in the current working directory.

287
00:00:00,000 --> 00:00:00,000
If you wanted to open it in a different path, you would pass the entire path inside here

288
00:00:00,000 --> 00:00:00,000
as a C style string or as a string object.

289
00:00:00,000 --> 00:00:00,000
You can do the whole thing in one statement though,

290
00:00:00,000 --> 00:00:00,000
by just passing the path that you want to open to the constructor.

291
00:00:00,000 --> 00:00:00,000
So here I am using the default constructor and then calling open on it.

292
00:00:00,000 --> 00:00:00,000
Here I am just using the constructor that opens it.

293
00:00:00,000 --> 00:00:00,000
You would use exactly the same pattern for OFStream, which would create an output file.

294
00:00:00,000 --> 00:00:00,000
Now, how do we know if the file was opened correctly or it was created correctly?

295
00:00:00,000 --> 00:00:00,000
What you have to do, if you can't open it, is you have to check the stream itself.

296
00:00:00,000 --> 00:00:00,000
If the stream is false, or if its member function fail is true,

297
00:00:00,000 --> 00:00:00,000
then it didn't open correctly.

298
00:00:00,000 --> 00:00:00,000
It didn't open correctly.

299
00:00:00,000 --> 00:00:00,000
And so, what do you do when you can't open it?

300
00:00:00,000 --> 00:00:00,000
Well, you could use a loop and you could reprompt for the correct file name.

301
00:00:00,000 --> 00:00:00,000
If you are asking the user to enter a file name.

302
00:00:00,000 --> 00:00:00,000
Or you could print an error message.

303
00:00:00,000 --> 00:00:00,000
Now, since this is an error message, we want to use not cout, but we want to use cerror.

304
00:00:00,000 --> 00:00:00,000
And we could return from the function, return an error code, exit from the program altogether.

305
00:00:00,000 --> 00:00:00,000
So, let's look at an example that does that.

306
00:00:00,000 --> 00:00:00,000
And for this, we are going to use the second kind of data loop, a line oriented data loop.

307
00:00:00,000 --> 00:00:00,000
So, a line oriented data loop reads one line of text at a time.

308
00:00:00,000 --> 00:00:00,000
It throws away the new line from that line of text.

309
00:00:00,000 --> 00:00:00,000
Notice that it does not, git line does not return the string.

310
00:00:00,000 --> 00:00:00,000
Instead, the string is a string passed by reference, which is filled in, in the function.

311
00:00:00,000 --> 00:00:00,000
What it does return is it returns the stream object itself.

312
00:00:00,000 --> 00:00:00,000
And we'll use that as the boolean condition.

313
00:00:00,000 --> 00:00:00,000
While the stream is still good, git align.

314
00:00:00,000 --> 00:00:00,000
You also, with git line, it's sometimes hard to remember that it's not included in I/O's stream.

315
00:00:00,000 --> 00:00:00,000
It instead is a function inside the string type.

316
00:00:00,000 --> 00:00:00,000
So, you have to remember to include string.

317
00:00:00,000 --> 00:00:00,000
So, our third exercise today is the flip lines problems.

318
00:00:00,000 --> 00:00:00,000
What we are going to do is open a file or print an error message.

319
00:00:00,000 --> 00:00:00,000
So, we are going to go over the stuff we did in the last slide.

320
00:00:00,000 --> 00:00:00,000
And then we are going to reverse the first pair of lines, the second pair, and so forth.

321
00:00:00,000 --> 00:00:00,000
So, let's go over here.

322
00:00:00,000 --> 00:00:00,000
Let's look at the exercise.

323
00:00:00,000 --> 00:00:00,000
So, here we are going to read this file.

324
00:00:00,000 --> 00:00:00,000
We are going to read the first two lines.

325
00:00:00,000 --> 00:00:00,000
And then in the output we are going to take the second line and print it first, and the first line and print it second.

326
00:00:00,000 --> 00:00:00,000
We are going to do that through the whole file.

327
00:00:00,000 --> 00:00:00,000
Now, notice that a line can be blank, as on the third pair.

328
00:00:00,000 --> 00:00:00,000
And so we switch to "Beware the Jabberwock" with a blank line.

329
00:00:00,000 --> 00:00:00,000
And we may have an odd number of lines.

330
00:00:00,000 --> 00:00:00,000
In that case, only the last line is printed in its original position.

331
00:00:00,000 --> 00:00:00,000
It's not flipped with an invisible line that would be after it.

332
00:00:00,000 --> 00:00:00,000
Now, we are going to do two things here.

333
00:00:00,000 --> 00:00:00,000
We are going to do that, processing the line by line.

334
00:00:00,000 --> 00:00:00,000
But we are also going to look at the process for opening and checking a file.

335
00:00:00,000 --> 00:00:00,000
So, we are going to write the function named "flip lines" that accepts the name of the file as its parameter.

336
00:00:00,000 --> 00:00:00,000
It's not a stream, like the first exercise we did today.

337
00:00:00,000 --> 00:00:00,000
And it's going to open and write to the console the same file's contents with the lines switched, like I just said.

338
00:00:00,000 --> 00:00:00,000
If the file cannot be opened, then "cannot open filename.txt" is printed to "Sierra" with "filename.txt" replaced with the actual name.

339
00:00:00,000 --> 00:00:00,000
So, let's do that.

340
00:00:00,000 --> 00:00:00,000
OK, this is in C.

341
00:00:00,000 --> 00:00:00,000
So, we are going to do "flip lines".

342
00:00:00,000 --> 00:00:00,000
So, put our name on it.

343
00:00:00,000 --> 00:00:00,000
And the function is named "flip lines".

344
00:00:00,000 --> 00:00:00,000
It's not going to return anything, so it's going to be a void function.

345
00:00:00,000 --> 00:00:00,000
And it's going to take a string for the filename.

346
00:00:00,000 --> 00:00:00,000
So, there's our stub.

347
00:00:00,000 --> 00:00:00,000
Let's go ahead and open a terminal on C.

348
00:00:00,000 --> 00:00:00,000
And simply do "make" to make sure the stub works.

349
00:00:00,000 --> 00:00:00,000
Yes, it works. So, it complies.

350
00:00:00,000 --> 00:00:00,000
So, step one. We need to create an input stream on filename.

351
00:00:00,000 --> 00:00:00,000
So, "if stream in" and we'll pass in "fname".

352
00:00:00,000 --> 00:00:00,000
Let me do it. So, this is the original name.

353
00:00:00,000 --> 00:00:00,000
So, "in open fname".

354
00:00:00,000 --> 00:00:00,000
So, that's perfectly OK.

355
00:00:00,000 --> 00:00:00,000
It's kind of a lot of extra work, though.

356
00:00:00,000 --> 00:00:00,000
So, let's do this.

357
00:00:00,000 --> 00:00:00,000
"if stream in fname".

358
00:00:00,000 --> 00:00:00,000
So, that's "create" and "open" at the same time.

359
00:00:00,000 --> 00:00:00,000
And I'll comment out these first two lines.

360
00:00:00,000 --> 00:00:00,000
Now, we need to make sure if it opened.

361
00:00:00,000 --> 00:00:00,000
So, "if in failed" to open.

362
00:00:00,000 --> 00:00:00,000
"if in fail".

363
00:00:00,000 --> 00:00:00,000
What we're going to do is say "sr".

364
00:00:00,000 --> 00:00:00,000
"cannot open fname".

365
00:00:00,000 --> 00:00:00,000
And since this is a void function, I'm just going to return.

366
00:00:00,000 --> 00:00:00,000
Or, so I can do "return".

367
00:00:00,000 --> 00:00:00,000
Notice it's a void function.

368
00:00:00,000 --> 00:00:00,000
Or, I could skip this return.

369
00:00:00,000 --> 00:00:00,000
I could skip that return.

370
00:00:00,000 --> 00:00:00,000
And I could put the remaining part of the code in the "else" down here.

371
00:00:00,000 --> 00:00:00,000
So, I'll do that.

372
00:00:00,000 --> 00:00:00,000
I know specifically in 250 they don't like you putting this return inside there.

373
00:00:00,000 --> 00:00:00,000
So, I'll do that.

374
00:00:00,000 --> 00:00:00,000
I generally would do it.

375
00:00:00,000 --> 00:00:00,000
But, I'm trying to make it easier for you when you go on to the next class.

376
00:00:00,000 --> 00:00:00,000
So, we can't open the file name.

377
00:00:00,000 --> 00:00:00,000
If we didn't fail, what are we going to do?

378
00:00:00,000 --> 00:00:00,000
We're going to read the file and print it to output.

379
00:00:00,000 --> 00:00:00,000
So, I need two lines.

380
00:00:00,000 --> 00:00:00,000
I need to read two lines at a time.

381
00:00:00,000 --> 00:00:00,000
So, I'm going to have "string line1" and "line2".

382
00:00:00,000 --> 00:00:00,000
I'm going to say "while getline in line1".

383
00:00:00,000 --> 00:00:00,000
So, that's going to read one line.

384
00:00:00,000 --> 00:00:00,000
And now I'm going to say "if getline in line2".

385
00:00:00,000 --> 00:00:00,000
Now I've read two lines.

386
00:00:00,000 --> 00:00:00,000
If that fails, of course, I've only read one line.

387
00:00:00,000 --> 00:00:00,000
And then I'm going to do "cout".

388
00:00:00,000 --> 00:00:00,000
I'm going to print "line2", a new line, "line1", and a new line.

389
00:00:00,000 --> 00:00:00,000
If that failed, else, then of course I'm going to do "cout line1" and "line2" because we didn't read two lines.

390
00:00:00,000 --> 00:00:00,000
So, here's getting a file name in.

391
00:00:00,000 --> 00:00:00,000
Opening the file.

392
00:00:00,000 --> 00:00:00,000
If we can't open it, printing out an error message. Otherwise, reading and printing the output.

393
00:00:00,000 --> 00:00:00,000
So, let's try this. Let's open up a shell there.

394
00:00:00,000 --> 00:00:00,000
Let's do "make test".

395
00:00:00,000 --> 00:00:00,000
Oops.

396
00:00:00,000 --> 00:00:00,000
Sorry, I didn't want that. I guess because I had multiple ones there.

397
00:00:00,000 --> 00:00:00,000
I was trying to get rid of this extra one over here.

398
00:00:00,000 --> 00:00:00,000
Kind of too much work.

399
00:00:00,000 --> 00:00:00,000
"make test"

400
00:00:00,000 --> 00:00:00,000
Ok, so, here's an easy file that had a second line and a first line. It just replaced it.

401
00:00:00,000 --> 00:00:00,000
Here's trying to check the error message. Kind of an open, no loadout text.

402
00:00:00,000 --> 00:00:00,000
And here's the original test in here.

403
00:00:00,000 --> 00:00:00,000
Checking the file that was on the handout here.

404
00:00:00,000 --> 00:00:00,000
This file right here.

405
00:00:00,000 --> 00:00:00,000
Ok, so there's the whole function right there.

406
00:00:00,000 --> 00:00:00,000
Now, I, as I mentioned, I would probably do it like this.

407
00:00:00,000 --> 00:00:00,000
There's no reason to go on. I would remove that "else" part there.

408
00:00:00,000 --> 00:00:00,000
Because if I got here.

409
00:00:00,000 --> 00:00:00,000
I like that because it's a little bit shorter, personally.

410
00:00:00,000 --> 00:00:00,000
Alright, let's go on now.

411
00:00:00,000 --> 00:00:00,000
And look at token oriented dataloops.

412
00:00:00,000 --> 00:00:00,000
So this is what we started with today, while in VAR.

413
00:00:00,000 --> 00:00:00,000
We're reading one token at a time.

414
00:00:00,000 --> 00:00:00,000
Now this fails at end to file, like the other two loops do. The character oriented and the light oriented.

415
00:00:00,000 --> 00:00:00,000
And it fails when it can't convert the token.

416
00:00:00,000 --> 00:00:00,000
So if we failed because we couldn't convert a token, and we weren't at end to file,

417
00:00:00,000 --> 00:00:00,000
we'd need to clear the error flags with in.clear

418
00:00:00,000 --> 00:00:00,000
before we could read anything else.

419
00:00:00,000 --> 00:00:00,000
And then we'd still need to remove the offending input.

420
00:00:00,000 --> 00:00:00,000
So, here I've created a string just to hold the offending input.

421
00:00:00,000 --> 00:00:00,000
If in fail, in clear, in error data.

422
00:00:00,000 --> 00:00:00,000
So this clears the flags, this removes the token, and then we can keep going on

423
00:00:00,000 --> 00:00:00,000
to the remaining data.

424
00:00:00,000 --> 00:00:00,000
So we're going to look at a final exercise today.

425
00:00:00,000 --> 00:00:00,000
Expenses.

426
00:00:00,000 --> 00:00:00,000
We're going to process a file with characters and tokens.

427
00:00:00,000 --> 00:00:00,000
So we're going to learn a couple of tricks to doing that.

428
00:00:00,000 --> 00:00:00,000
So let's close flip lines.

429
00:00:00,000 --> 00:00:00,000
Let's open up d, expenses.cpp.

430
00:00:00,000 --> 00:00:00,000
Let's open expenses.txt too. So this is the file we're processing.

431
00:00:00,000 --> 00:00:00,000
What we want to do is we want to read each line.

432
00:00:00,000 --> 00:00:00,000
We want to sum up this person's expenses,

433
00:00:00,000 --> 00:00:00,000
print their name, and print their

434
00:00:00,000 --> 00:00:00,000
print their data out.

435
00:00:00,000 --> 00:00:00,000
Print the sum of their expenses.

436
00:00:00,000 --> 00:00:00,000
So let's add a comment on there. Notice we have an in file and an out file.

437
00:00:00,000 --> 00:00:00,000
We're going to open the input file.

438
00:00:00,000 --> 00:00:00,000
So if string in, in file.

439
00:00:00,000 --> 00:00:00,000
If we can't find it, if in fail.

440
00:00:00,000 --> 00:00:00,000
We're going to print an error message.

441
00:00:00,000 --> 00:00:00,000
Sierra cannot open in file.

442
00:00:00,000 --> 00:00:00,000
And I'm going to just return from that.

443
00:00:00,000 --> 00:00:00,000
Then we're going to create the output file.

444
00:00:00,000 --> 00:00:00,000
It says expenses summary, but we're going to use the name out file,

445
00:00:00,000 --> 00:00:00,000
which is created up here.

446
00:00:00,000 --> 00:00:00,000
So we're going to say OF string out,

447
00:00:00,000 --> 00:00:00,000
and I'm going to create it with out file.

448
00:00:00,000 --> 00:00:00,000
And we have to check to make sure that worked as well.

449
00:00:00,000 --> 00:00:00,000
So if out fail,

450
00:00:00,000 --> 00:00:00,000
Sierra cannot create out file,

451
00:00:00,000 --> 00:00:00,000
and I'll return there.

452
00:00:00,000 --> 00:00:00,000
Okay, so this is the setup before we do anything.

453
00:00:00,000 --> 00:00:00,000
Now we've opened both the input and output file,

454
00:00:00,000 --> 00:00:00,000
and we can loop through each character in the file.

455
00:00:00,000 --> 00:00:00,000
So let's write a loop that does that.

456
00:00:00,000 --> 00:00:00,000
I'm going to leave that up there

457
00:00:00,000 --> 00:00:00,000
and write it down here rather than writing inside it.

458
00:00:00,000 --> 00:00:00,000
So char ch while in get ch.

459
00:00:00,000 --> 00:00:00,000
Okay, so that's our main loop.

460
00:00:00,000 --> 00:00:00,000
Loop through each character in the file.

461
00:00:00,000 --> 00:00:00,000
Now if the character is a non-digit, then print it out.

462
00:00:00,000 --> 00:00:00,000
So if not is digit ch,

463
00:00:00,000 --> 00:00:00,000
out put ch.

464
00:00:00,000 --> 00:00:00,000
Otherwise, so else, we'll have some code inside here, the else.

465
00:00:00,000 --> 00:00:00,000
Okay, so we've read our first digit in the line.

466
00:00:00,000 --> 00:00:00,000
So again, let's look at expenses.txt.

467
00:00:00,000 --> 00:00:00,000
I read and printed that, that, that, that, that, that, that, that, that space,

468
00:00:00,000 --> 00:00:00,000
and now I've just read the two.

469
00:00:00,000 --> 00:00:00,000
So here I need to create and initialize a sum for the line.

470
00:00:00,000 --> 00:00:00,000
So double sum zero.

471
00:00:00,000 --> 00:00:00,000
I need to repeat until input fails or ch equals the null, right?

472
00:00:00,000 --> 00:00:00,000
So I need to say while in or while not in fail

473
00:00:00,000 --> 00:00:00,000
and ch is not equal to the null line.

474
00:00:00,000 --> 00:00:00,000
Now notice the instruction says until.

475
00:00:00,000 --> 00:00:00,000
We have to put it in the reverse sense and say keep going while this is true.

476
00:00:00,000 --> 00:00:00,000
Okay.

477
00:00:00,000 --> 00:00:00,000
So if ch is a digit,

478
00:00:00,000 --> 00:00:00,000
what we're going to do is put it back in the stream.

479
00:00:00,000 --> 00:00:00,000
So in put back ch

480
00:00:00,000 --> 00:00:00,000
or alternatively in unget would work as well.

481
00:00:00,000 --> 00:00:00,000
Now we need to read the entire number from the stream.

482
00:00:00,000 --> 00:00:00,000
So look at expenses.txt.

483
00:00:00,000 --> 00:00:00,000
We read the digit two, took it out of the stream,

484
00:00:00,000 --> 00:00:00,000
but we want to actually read this whole number.

485
00:00:00,000 --> 00:00:00,000
So we have to take the two and put it back in the stream

486
00:00:00,000 --> 00:00:00,000
so we're reading right from that point.

487
00:00:00,000 --> 00:00:00,000
Now to read that whole number and convert it, of course,

488
00:00:00,000 --> 00:00:00,000
what I need to use is formatted input.

489
00:00:00,000 --> 00:00:00,000
So I need to say double in, in, in.

490
00:00:00,000 --> 00:00:00,000
So we read the number from the stream.

491
00:00:00,000 --> 00:00:00,000
Of course we need to add the number to the sum.

492
00:00:00,000 --> 00:00:00,000
So sum plus equals in.

493
00:00:00,000 --> 00:00:00,000
Now if it's not a digit or even if it was a digit,

494
00:00:00,000 --> 00:00:00,000
after that loop we need to read the next digit.

495
00:00:00,000 --> 00:00:00,000
So in, get, ch.

496
00:00:00,000 --> 00:00:00,000
Now at the end of this while loop, after the loop is over,

497
00:00:00,000 --> 00:00:00,000
after we've done all of this stuff,

498
00:00:00,000 --> 00:00:00,000
we need to print the sum with two decimals and a new line.

499
00:00:00,000 --> 00:00:00,000
So that's right here.

500
00:00:00,000 --> 00:00:00,000
We need to say out, not cout, fixed, set precision,

501
00:00:00,000 --> 00:00:00,000
to, sum, end.

502
00:00:00,000 --> 00:00:00,000
Now we could actually put the out fixed precision up here

503
00:00:00,000 --> 00:00:00,000
even before the loop started, so we just have to do the sum.

504
00:00:00,000 --> 00:00:00,000
So this would be perfectly fine.

505
00:00:00,000 --> 00:00:00,000
And here we could just say out, sum, end out,

506
00:00:00,000 --> 00:00:00,000
and it kind of doesn't clutter up the flow of the control with the output.

507
00:00:00,000 --> 00:00:00,000
So here's our outer loop, well we can read a character.

508
00:00:00,000 --> 00:00:00,000
Here is our inner loop where we're summing up the numbers in one line

509
00:00:00,000 --> 00:00:00,000
and printing out the output.

510
00:00:00,000 --> 00:00:00,000
Okay, let's go ahead and try that and see how we did.

511
00:00:00,000 --> 00:00:00,000
Let's get a shell on that.

512
00:00:00,000 --> 00:00:00,000
So we're going to say make, and make test.

513
00:00:00,000 --> 00:00:00,000
Okay, so I tried to open a file that did not exist.

514
00:00:00,000 --> 00:00:00,000
I tried to open a file that you were not allowed to write to.

515
00:00:00,000 --> 00:00:00,000
And I tried to create a file with the correct input.

516
00:00:00,000 --> 00:00:00,000
That worked okay.

517
00:00:00,000 --> 00:00:00,000
Then I read the file, so that makes sure that I read the next correct number of lines.

518
00:00:00,000 --> 00:00:00,000
And then I correctly went through and read the, summed the data.

519
00:00:00,000 --> 00:00:00,000
Now you might wonder, you might wonder why I had to go to all this extra work inside here

520
00:00:00,000 --> 00:00:00,000
to read the, why I couldn't just do well in, arrow, arrow, end,

521
00:00:00,000 --> 00:00:00,000
and get it to work like that.

522
00:00:00,000 --> 00:00:00,000
Well notice, some of the people have put in notes inside here,

523
00:00:00,000 --> 00:00:00,000
and we have to make sure we skip over those.

524
00:00:00,000 --> 00:00:00,000
And so those would fail inside, inside that line.

525
00:00:00,000 --> 00:00:00,000
And so this last exercise we did, process a file with characters

526
00:00:00,000 --> 00:00:00,000
and with token oriented input, and opening files.

527
00:00:00,000 --> 00:00:00,000
Okay, that's it for today.

528
00:00:00,000 --> 00:00:00,000
And I will see you on the next lecture, on lecture 13.

