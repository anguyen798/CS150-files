WEBVTT

00:00:00.000 --> 00:00:00.000
 Hello everyone, this is Steve Gilbert. Welcome to lecture 15 on user-defined data types.

00:00:00.000 --> 00:00:00.000
 We're going to start out today by doing a little stream review.

00:00:00.000 --> 00:00:00.000
 We're going to read a text file that contains star information.

00:00:00.000 --> 00:00:00.000
 This is a star catalog. And so we're going to open and read the input file.

00:00:00.000 --> 00:00:00.000
 And so we're going to look at stars.txt. Now in the input file, we'll see several different values.

00:00:00.000 --> 00:00:00.000
 Let's just go ahead and do that right now. So we're in lecture 15 and I have opened the starcat.cpp here.

00:00:00.000 --> 00:00:00.000
 I'm going to put my name on it. And I'm also going to open up stars.txt so I can see the data file that I'm reading.

00:00:00.000 --> 00:00:00.000
 So you notice that I have three doubles starting each line of text.

00:00:00.000 --> 00:00:00.000
 And those represent the location in space of that particular star.

00:00:00.000 --> 00:00:00.000
 That number is followed by an integer, 28 here in this first case.

00:00:00.000 --> 00:00:00.000
 This is called the Draper number. The Draper number. What it is, it's a catalog identifier.

00:00:00.000 --> 00:00:00.000
 In a star catalog, kind of like the Dewey Decimal number you'd have on a book in the library.

00:00:00.000 --> 00:00:00.000
 Following that, we have a third double. Let me go take a look right here.

00:00:00.000 --> 00:00:00.000
 4.61. And this represents the magnitude or brightness of the star.

00:00:00.000 --> 00:00:00.000
 Following that, we have another identifier, that integer 3.

00:00:00.000 --> 00:00:00.000
 And that represents a different catalog number in a catalog called the Harvard catalog.

00:00:00.000 --> 00:00:00.000
 So this number is called the Harvard Revised number.

00:00:00.000 --> 00:00:00.000
 Now some stars, like this star on line 6, and this star on line 7, have a string at the end of it. Some kind of name.

00:00:00.000 --> 00:00:00.000
 Those are what we call the name stars. If you scroll through them, you may recognize some of the stars.

00:00:00.000 --> 00:00:00.000
 Let's see if I can find one I recognize. I don't actually recognize any of those names.

00:00:00.000 --> 00:00:00.000
 Here's Polaris. I recognize the North star.

00:00:00.000 --> 00:00:00.000
 Now the stars that have a name may actually have two names.

00:00:00.000 --> 00:00:00.000
 They may have a Latin name and a common name and so forth.

00:00:00.000 --> 00:00:00.000
 Or they may just have a common name. And if they have two names, the first name is ended with a semicolon, like that.

00:00:00.000 --> 00:00:00.000
 So our job here today is to read the stars and print only the name stars. Print the primary name, a comma, an X and a Y in space.

00:00:00.000 --> 00:00:00.000
 We're going to skip the Z and the magnitude.

00:00:00.000 --> 00:00:00.000
 So let's go ahead and do that.

00:00:00.000 --> 00:00:00.000
 So let's go to StarCat. As I mentioned, you want to put your name. And I'm going to move that over there just to kind of clear up the screen.

00:00:00.000 --> 00:00:00.000
 So the catalog number is coming in as a string and we want to open it.

00:00:00.000 --> 00:00:00.000
 We've included fstream here so we know how to open file streams.

00:00:00.000 --> 00:00:00.000
 So we're going to create an input file stream. And I have stream. I'll call it in.

00:00:00.000 --> 00:00:00.000
 And I'm going to open it with cat name.

00:00:00.000 --> 00:00:00.000
 Now, if we can't open the file, then we want to print an error message and exit.

00:00:00.000 --> 00:00:00.000
 So if in fail, CR cannot open cat name, capital N on cat name.

00:00:00.000 --> 00:00:00.000
 And since this is a void function, I'm just going to return.

00:00:00.000 --> 00:00:00.000
 Ok, now let's read the file. So basically, notice that every line has X, Y, Z, a Draper number, a magnitude, and a Harvard number.

00:00:00.000 --> 00:00:00.000
 So that means I need to create variables for that, right?

00:00:00.000 --> 00:00:00.000
 So I'm going to say double X, Y, Z, magnitude. Those are my four doubles.

00:00:00.000 --> 00:00:00.000
 And Harvard and Draper. Or Draper and Harvard. Let me put them in the order they're in.

00:00:00.000 --> 00:00:00.000
 And to read the file using streams, I just use formatted input.

00:00:00.000 --> 00:00:00.000
 So while in X, Y, Z, Draper number's next, so make sure you don't put magnitude there.

00:00:00.000 --> 00:00:00.000
 Then the magnitude. And then the Harvard number.

00:00:00.000 --> 00:00:00.000
 Ok, well that's true.

00:00:00.000 --> 00:00:00.000
 So this will process some of the file. So let's go to the top of this text file.

00:00:00.000 --> 00:00:00.000
 So that would process that line.

00:00:00.000 --> 00:00:00.000
 And then, when we read the next line, that would process it. That would process the next line.

00:00:00.000 --> 00:00:00.000
 That would process this amount of data in line six.

00:00:00.000 --> 00:00:00.000
 But when we came around again, this is what it would read for X.

00:00:00.000 --> 00:00:00.000
 And what would happen when it tried to read that? It would stop working.

00:00:00.000 --> 00:00:00.000
 So we have to see if there's any extra text at the end of each line.

00:00:00.000 --> 00:00:00.000
 So after we've read the numbers off from the line, we're going to have to create a variable.

00:00:00.000 --> 00:00:00.000
 So string line. I'll call it rest.

00:00:00.000 --> 00:00:00.000
 So string rest and get line in rest.

00:00:00.000 --> 00:00:00.000
 So when we finish reading this first line, we've read the three,

00:00:00.000 --> 00:00:00.000
 there is still an invisible new line sitting out here waiting to be read.

00:00:00.000 --> 00:00:00.000
 And we haven't displayed that yet.

00:00:00.000 --> 00:00:00.000
 We could turn on with the editor. I'm sure there's a way to display these hidden files.

00:00:00.000 --> 00:00:00.000
 I'm not displaying them right now.

00:00:00.000 --> 00:00:00.000
 But there's a new line.

00:00:00.000 --> 00:00:00.000
 And so get line reads everything up to, including the new line, to clear off to go to the next line.

00:00:00.000 --> 00:00:00.000
 Now that's not important if we don't have a string, but if it is a string, we want to read that.

00:00:00.000 --> 00:00:00.000
 Alpha Hertz or cath semicolon space casp beta.

00:00:00.000 --> 00:00:00.000
 And so what we want to do now is after we've read the rest of the line, we want to see if it's if it's not empty.

00:00:00.000 --> 00:00:00.000
 So if rest if not rest empty.

00:00:00.000 --> 00:00:00.000
 That means I have a first name, a name one and possibly a name to possibly a name to.

00:00:00.000 --> 00:00:00.000
 So we're going to need to use those. Actually, I'm going to use them only inside here.

00:00:00.000 --> 00:00:00.000
 So let me move that down here.

00:00:00.000 --> 00:00:00.000
 So because I'm only going to print the name stars, which means that I only need to print inside this if statement.

00:00:00.000 --> 00:00:00.000
 If it's if it's not a name star, I'm not going to print it.

00:00:00.000 --> 00:00:00.000
 So let me create a couple of variables. String name one, name two.

00:00:00.000 --> 00:00:00.000
 Let me find out if there's a semicolon. So size T pause or auto pause equals rest.

00:00:00.000 --> 00:00:00.000
 Find a semicolon.

00:00:00.000 --> 00:00:00.000
 Now, two possibilities. One possibility is that it is set to string in pause.

00:00:00.000 --> 00:00:00.000
 So if pause is equal to string colon colon and pause.

00:00:00.000 --> 00:00:00.000
 In other words, it wasn't found. That means we have one name.

00:00:00.000 --> 00:00:00.000
 So name one equals rest substring.

00:00:00.000 --> 00:00:00.000
 Why? Why substring one? Because in this case where I have one, notice when I do get line, that'll be space alpha hertz.

00:00:00.000 --> 00:00:00.000
 Right. Because there's always a space at the end of the Harvard number.

00:00:00.000 --> 00:00:00.000
 And so name two will just be the empty string.

00:00:00.000 --> 00:00:00.000
 If that's not the case, I have two names. So name one equals rest substring starting at position one and going up to pause.

00:00:00.000 --> 00:00:00.000
 And name two equals rest substring starting at pause plus one.

00:00:00.000 --> 00:00:00.000
 No, no, actually starting at pause plus two. If we started at pause plus one.

00:00:00.000 --> 00:00:00.000
 So here's pause, right? We started at pause plus one. I'd have a space in front of the second name.

00:00:00.000 --> 00:00:00.000
 And I don't want that. So I'm starting at pause plus two. So I only have CAS beta inside there.

00:00:00.000 --> 00:00:00.000
 OK, so we know that this is extracted the name part of it. Now we're going to print the primary name. Name one.

00:00:00.000 --> 00:00:00.000
 X and a Y and the magnitude.

00:00:00.000 --> 00:00:00.000
 So I'm going to say C out. Name one. Comma space parenthesis.

00:00:00.000 --> 00:00:00.000
 X comma space or comma space. Y.

00:00:00.000 --> 00:00:00.000
 Right print. A comma, a space and the magnitude.

00:00:00.000 --> 00:00:00.000
 Print a new line. We might want to bring that down to two lines.

00:00:00.000 --> 00:00:00.000
 I don't know where you want to split it. Maybe right there.

00:00:00.000 --> 00:00:00.000
 Maybe that'll look a little bit better.

00:00:00.000 --> 00:00:00.000
 Now if we do make run, it'll just call our function star cat and pass in stars dot text.

00:00:00.000 --> 00:00:00.000
 So let's just do alt L.

00:00:00.000 --> 00:00:00.000
 Oh, you can't do alt L. This is the new version of the IDE. So we have to come over here to A, open a terminal there.

00:00:00.000 --> 00:00:00.000
 And then let's go ahead and do make run.

00:00:00.000 --> 00:00:00.000
 And here we have the name. We've read the entire catalog of stars. We have the name, X, Y and the magnitude of each of those stars.

00:00:00.000 --> 00:00:00.000
 So make run just does it all. Make test tests to make sure that you've actually done it correctly.

00:00:00.000 --> 00:00:00.000
 So if we do make test.

00:00:00.000 --> 00:00:00.000
 Notice that it will test several different things. It looks like make test, some of them are failing.

00:00:00.000 --> 00:00:00.000
 So if we read that. If you read O zero. Oh, it looks like we're actually getting a semicolon after our name.

00:00:00.000 --> 00:00:00.000
 OK, for some of those stars that have two names. So we have some debugging to do on that.

00:00:00.000 --> 00:00:00.000
 So name one, pause.

00:00:00.000 --> 00:00:00.000
 Does this look like pause minus one?

00:00:00.000 --> 00:00:00.000
 I think it does, because if we want to pause, we're not counting for the fact that we're starting here from one.

00:00:00.000 --> 00:00:00.000
 So that's what testing is for, to make sure that you got all of them correct.

00:00:00.000 --> 00:00:00.000
 And I have some inputs here that in fact should have been Polaris, but in fact was Polaris semicolon.

00:00:00.000 --> 00:00:00.000
 Should have been Ruchba, in fact was Ruchba with a semicolon.

00:00:00.000 --> 00:00:00.000
 Let's try it again.

00:00:00.000 --> 00:00:00.000
 OK, so that passes all of the tests. That looks OK.

00:00:00.000 --> 00:00:00.000
 All right, so let's go on now and get to today's topic.

00:00:00.000 --> 00:00:00.000
 So what we have here is each line in stars.txt consists of related information, related information.

00:00:00.000 --> 00:00:00.000
 The X and the Y and the Z about one particular star.

00:00:00.000 --> 00:00:00.000
 And just to print out that data, variables work fine. But what if I wanted to gather up all the information about a star

00:00:00.000 --> 00:00:00.000
 and pass it to a bunch of functions that would analyze different characteristics of those stars?

00:00:00.000 --> 00:00:00.000
 Well, simple variables aren't flexible enough for this.

00:00:00.000 --> 00:00:00.000
 What we need is we need a way to package up all the parts into some kind of more complex structured data of different types.

00:00:00.000 --> 00:00:00.000
 So in computer science and in programming languages, we call such structured types records.

00:00:00.000 --> 00:00:00.000
 And in C++, records are called structures or the keyword is struct we'll use to create them.

00:00:00.000 --> 00:00:00.000
 So basically, it's just a collection of data where each collection represents one item of a particular user defined kind, like a star in this case.

00:00:00.000 --> 00:00:00.000
 We say that the data is heterogeneous, meaning that we can have integers and strings and doubles all together wrapped up in one record.

00:00:00.000 --> 00:00:00.000
 It doesn't need to be all of the same type like an array does.

00:00:00.000 --> 00:00:00.000
 We say that it's accessible, meaning that we can directly access each of the parts.

00:00:00.000 --> 00:00:00.000
 So here's the syntax for creating a structure definition.

00:00:00.000 --> 00:00:00.000
 It's the keyword struct instead of class.

00:00:00.000 --> 00:00:00.000
 The name of the struct, which we call formally a structure tag, but other than me formally telling you this, we'll just call it the structure name.

00:00:00.000 --> 00:00:00.000
 Inside the structure, we have named members.

00:00:00.000 --> 00:00:00.000
 So members are like variable definitions, but they're not actually variable definitions.

00:00:00.000 --> 00:00:00.000
 They're potential variable definitions.

00:00:00.000 --> 00:00:00.000
 So notice I've named one PID, the person ID.

00:00:00.000 --> 00:00:00.000
 I've named one name.

00:00:00.000 --> 00:00:00.000
 I've named one DOB.

00:00:00.000 --> 00:00:00.000
 And notice that the structures can be the built-in types, library types, or other structured types.

00:00:00.000 --> 00:00:00.000
 Now this might look like creating a class in Java and adding data members or adding instance variables.

00:00:00.000 --> 00:00:00.000
 It's very, very similar.

00:00:00.000 --> 00:00:00.000
 We don't use the keywords public or private here in front of the things like you would do in Java.

00:00:00.000 --> 00:00:00.000
 But there's one difference that's going to trip you up.

00:00:00.000 --> 00:00:00.000
 That difference is in C++, we always need to put a semicolon at the end of the structure definition.

00:00:00.000 --> 00:00:00.000
 In Java you don't. In C++ you must.

00:00:00.000 --> 00:00:00.000
 Now, structures are a new user-defined type.

00:00:00.000 --> 00:00:00.000
 They're a definition.

00:00:00.000 --> 00:00:00.000
 They're a definition for a type.

00:00:00.000 --> 00:00:00.000
 They're not a definition for a variable.

00:00:00.000 --> 00:00:00.000
 So since they're a definition for a type, we usually place that definition in a header file.

00:00:00.000 --> 00:00:00.000
 Now there's a problem though.

00:00:00.000 --> 00:00:00.000
 What if that header file was included twice?

00:00:00.000 --> 00:00:00.000
 It's an error if the definition is included twice, is seen twice.

00:00:00.000 --> 00:00:00.000
 Your code will not compile.

00:00:00.000 --> 00:00:00.000
 And so just like we did with functions, we'll use header guards to prevent that.

00:00:00.000 --> 00:00:00.000
 So let's go ahead and add our structure definition to stars.h.

00:00:00.000 --> 00:00:00.000
 And this is the definition I'm going to use.

00:00:00.000 --> 00:00:00.000
 Struct star. I'm going to put all my doubles together just like I had them in the file.

00:00:00.000 --> 00:00:00.000
 My two integers together and my two strings.

00:00:00.000 --> 00:00:00.000
 So all of this data will store the data about one star.

00:00:00.000 --> 00:00:00.000
 So we're simply going to change this program.

00:00:00.000 --> 00:00:00.000
 We're going to add the structure definition in stars.h.

00:00:00.000 --> 00:00:00.000
 So I'm going to say struct star.

00:00:00.000 --> 00:00:00.000
 I'm going to open and close it and put the semicolon on all at once so I don't forget it.

00:00:00.000 --> 00:00:00.000
 I'm going to add the data members, so double, x, y, z, magnitude, int draper, Harvard,

00:00:00.000 --> 00:00:00.000
 and standard string, name one and name two.

00:00:00.000 --> 00:00:00.000
 So notice my header file already includes this.

00:00:00.000 --> 00:00:00.000
 And remember in a header file we cannot use using namespace standard.

00:00:00.000 --> 00:00:00.000
 So for a structure, if you want to use a type, just like for a prototype in header file,

00:00:00.000 --> 00:00:00.000
 you have to fully qualify the library type.

00:00:00.000 --> 00:00:00.000
 So there is our star structure.

00:00:00.000 --> 00:00:00.000
 What can we do with that star structure?

00:00:00.000 --> 00:00:00.000
 Well, what we can do is we can create variables of that type.

00:00:00.000 --> 00:00:00.000
 So if you have a type, its purpose is to create variables.

00:00:00.000 --> 00:00:00.000
 These are called structure variables.

00:00:00.000 --> 00:00:00.000
 Like primitive types, such variables are uninitialized.

00:00:00.000 --> 00:00:00.000
 So star a and b, both of them would be star objects with x, y, z, and so forth.

00:00:00.000 --> 00:00:00.000
 But x, y, z, and all the other members would be set to random numbers.

00:00:00.000 --> 00:00:00.000
 The two names, name one and name two, would be okay.

00:00:00.000 --> 00:00:00.000
 They'd be the empty string.

00:00:00.000 --> 00:00:00.000
 So you can initialize such a variable in several ways.

00:00:00.000 --> 00:00:00.000
 One, you can give it the default value.

00:00:00.000 --> 00:00:00.000
 So just when you create the variable, put the curly braces after it,

00:00:00.000 --> 00:00:00.000
 and that will default initialize it.

00:00:00.000 --> 00:00:00.000
 In other words, all the x's and y's will be zero.

00:00:00.000 --> 00:00:00.000
 You can aggregate initialize it, meaning you supply a value for each of the data members.

00:00:00.000 --> 00:00:00.000
 So in this case, x is .873, y is .032, z is .486, magnitude is 2.07.

00:00:00.000 --> 00:00:00.000
 The Draper number is .358, the Harvard number is 15, name one is Rigel, name two is Beta.

00:00:00.000 --> 00:00:00.000
 Now, notice that the order that you put the data members depends on the order that the data members are defined in the structure.

00:00:00.000 --> 00:00:00.000
 Notice that this order is different than what we read the data in.

00:00:00.000 --> 00:00:00.000
 Notice that we read x, y, z, then the Draper number,

00:00:00.000 --> 00:00:00.000
 but in the structure we put the x, y, z and the magnitude all together.

00:00:00.000 --> 00:00:00.000
 And so that's the way you have to initialize it.

00:00:00.000 --> 00:00:00.000
 Finally, we can initialize it one third way.

00:00:00.000 --> 00:00:00.000
 If we have another star, we can either assign to it or we can copy initialize it.

00:00:00.000 --> 00:00:00.000
 In other words, I can create a star E and it will have the same values that star C has.

00:00:00.000 --> 00:00:00.000
 Now, structures can contain other structures, so if we create some useful, say, utility structures,

00:00:00.000 --> 00:00:00.000
 a point 3D that has x, y, and z, a names structure that contained a couple of names,

00:00:00.000 --> 00:00:00.000
 and a catalog structure that contained two catalogs, we could then use these structures inside another structure.

00:00:00.000 --> 00:00:00.000
 We could nest them and we could define our star like this.

00:00:00.000 --> 00:00:00.000
 So, this might be a little bit more readable.

00:00:00.000 --> 00:00:00.000
 You can see what those x, y, and z represent, the location, then the magnitude,

00:00:00.000 --> 00:00:00.000
 then the catalog numbers, and then the names of the stars.

00:00:00.000 --> 00:00:00.000
 So, this might be a little bit more readable.

00:00:00.000 --> 00:00:00.000
 Now, to access the data members, we simply use the dot operator,

00:00:00.000 --> 00:00:00.000
 very similar to what you do in Java if you had a public instance variable.

00:00:00.000 --> 00:00:00.000
 So, if I want to access the name in the structure variable A, I just say a.name1 or a.name2.

00:00:00.000 --> 00:00:00.000
 You can also print it out, of course. So, just the name of the structure variable,

00:00:00.000 --> 00:00:00.000
 and then the name of the data member inside the structure variable.

00:00:00.000 --> 00:00:00.000
 For a nested structure, you just keep adding dots.

00:00:00.000 --> 00:00:00.000
 So, you remember I created a structure, a different star structure that had a location in it.

00:00:00.000 --> 00:00:00.000
 So, s.location would bring back a .3D structure, and then I'd select x out of it.

00:00:00.000 --> 00:00:00.000
 So, I'm selecting members from a structure using the dot, the member selection operator.

00:00:00.000 --> 00:00:00.000
 You can also assign and copy entire structure variables.

00:00:00.000 --> 00:00:00.000
 You cannot compare them. You can assign them and copy them.

00:00:00.000 --> 00:00:00.000
 So, let's go ahead and modify our star cat to use our structure variable

00:00:00.000 --> 00:00:00.000
 instead of the individual variables we used before.

00:00:00.000 --> 00:00:00.000
 So, let's come back to star cat.

00:00:00.000 --> 00:00:00.000
 First, let's come up here and say I want to include stars.h.

00:00:00.000 --> 00:00:00.000
 Notice now my program knows about the user defined type.

00:00:00.000 --> 00:00:00.000
 So, instead of these variables on line 21 and 22, I can create a star variable.

00:00:00.000 --> 00:00:00.000
 So, I can say star s.

00:00:00.000 --> 00:00:00.000
 So, I no longer have individual variables. I have them grouped together in this record.

00:00:00.000 --> 00:00:00.000
 Now, when I read them, these parts, these members are inside the variable s.

00:00:00.000 --> 00:00:00.000
 So, I'd say sx, sy, sz, sdraper, smagnitude, and sharper.

00:00:00.000 --> 00:00:00.000
 Now, notice that when I do this, these are in the order that the members are defined inside the stars.txt file,

00:00:00.000 --> 00:00:00.000
 not the order they're defined inside the structure.

00:00:00.000 --> 00:00:00.000
 So, this extracts it from the text file and puts it in the structure.

00:00:00.000 --> 00:00:00.000
 So, even though x, y, z, and magnitude are together, we don't read the magnitude before the draper number

00:00:00.000 --> 00:00:00.000
 because in the text file, the draper number appears first.

00:00:00.000 --> 00:00:00.000
 So, we're going to get the rest from the file.

00:00:00.000 --> 00:00:00.000
 And if it's not empty, so first, notice we have a name1 and name2,

00:00:00.000 --> 00:00:00.000
 but we want to make sure that every time we come through here,

00:00:00.000 --> 00:00:00.000
 since I'm not reading into name1 and name2,

00:00:00.000 --> 00:00:00.000
 every time I come through here, I reset name1 and name2.

00:00:00.000 --> 00:00:00.000
 So, s.name1 = s.name2, and both of those are going to be equal to the empty string.

00:00:00.000 --> 00:00:00.000
 Okay, so I no longer need this line on line 32, right there, name1 and name2.

00:00:00.000 --> 00:00:00.000
 And so, I'm going to say if I find this semicolon, then s.name1 is that,

00:00:00.000 --> 00:00:00.000
 and s.name1 and s.name2.

00:00:00.000 --> 00:00:00.000
 And when I print them out, finally, I'm printing out s.name1, s.x,

00:00:00.000 --> 00:00:00.000
 s.y, and s.magnitude.

00:00:00.000 --> 00:00:00.000
 Okay, so let's try that out.

00:00:00.000 --> 00:00:00.000
 And all we're going to do is do make test again.

00:00:00.000 --> 00:00:00.000
 Okay, and we still got 100%, so in this case,

00:00:00.000 --> 00:00:00.000
 we're not using the individual variables.

00:00:00.000 --> 00:00:00.000
 We have encapsulated all of the variables into this single star object right here,

00:00:00.000 --> 00:00:00.000
 this single star.

00:00:00.000 --> 00:00:00.000
 Now, probably most of you are thinking, "Well, yeah, so what?

00:00:00.000 --> 00:00:00.000
 That didn't seem any better."

00:00:00.000 --> 00:00:00.000
 But now that we've encapsulated the data inside the structure,

00:00:00.000 --> 00:00:00.000
 we can write functions that take and produce structure variables.

00:00:00.000 --> 00:00:00.000
 And so that's our next step.

00:00:00.000 --> 00:00:00.000
 So for our next step, what we want to do is write functions that take structures.

00:00:00.000 --> 00:00:00.000
 Now, in the C language, where structures were developed,

00:00:00.000 --> 00:00:00.000
 they were known as second-class types.

00:00:00.000 --> 00:00:00.000
 That's because they don't always act the same way as the built-in types.

00:00:00.000 --> 00:00:00.000
 The built-in types are the natives.

00:00:00.000 --> 00:00:00.000
 The second-class types don't have all the features of the built-in types.

00:00:00.000 --> 00:00:00.000
 So if A and B are structure variables, say stars,

00:00:00.000 --> 00:00:00.000
 this would be illegal if A and B are structure types.

00:00:00.000 --> 00:00:00.000
 But the built-in types get to do this.

00:00:00.000 --> 00:00:00.000
 And so we can fix this by writing functions to supply the missing operations.

00:00:00.000 --> 00:00:00.000
 So I could write a method called equals, and I could say if equal A, B,

00:00:00.000 --> 00:00:00.000
 and get back true and false, and use that instead.

00:00:00.000 --> 00:00:00.000
 So we can pass structure variables to functions.

00:00:00.000 --> 00:00:00.000
 We can also write a function that returns a structure.

00:00:00.000 --> 00:00:00.000
 We're going to use the same rules for variable passing as for strings.

00:00:00.000 --> 00:00:00.000
 So structure types we're going to pass by reference or const reference.

00:00:00.000 --> 00:00:00.000
 We'll never pass structure types by value.

00:00:00.000 --> 00:00:00.000
 So if I wanted to write my equal function that I would use in place of this,

00:00:00.000 --> 00:00:00.000
 that the first-class types do, I'd pass a const string ref A and a const string ref B.

00:00:00.000 --> 00:00:00.000
 And if they were equal, I'd return true in that case.

00:00:00.000 --> 00:00:00.000
 So we're going to do that.

00:00:00.000 --> 00:00:00.000
 We're going to write some functions to print and read star objects.

00:00:00.000 --> 00:00:00.000
 And so my print function is going to take the stream that I'm going to read from,

00:00:00.000 --> 00:00:00.000
 and a write to, and a star that I'm going to display.

00:00:00.000 --> 00:00:00.000
 And it's going to return the stream after it's done.

00:00:00.000 --> 00:00:00.000
 And my read function is going to take the stream I'm going to read from,

00:00:00.000 --> 00:00:00.000
 and a star by reference that I'm going to fill in when I read.

00:00:00.000 --> 00:00:00.000
 Now, notice the functions are returning the modified stream so we can test it.

00:00:00.000 --> 00:00:00.000
 In other words, I want to be able to do this.

00:00:00.000 --> 00:00:00.000
 I want to say I have stream in stars.text, star.s, and I'll read in s.

00:00:00.000 --> 00:00:00.000
 So for our next exercise, let's do in B, let's prototype and implement these two functions, print and read.

00:00:00.000 --> 00:00:00.000
 Then we'll uncomment the first section of run and do make run.

00:00:00.000 --> 00:00:00.000
 So let's close these.

00:00:00.000 --> 00:00:00.000
 Let's open B.

00:00:00.000 --> 00:00:00.000
 Let me right click it.

00:00:00.000 --> 00:00:00.000
 Open it in the integrated terminal there.

00:00:00.000 --> 00:00:00.000
 And we'll have stars.h and stars.cpp.

00:00:00.000 --> 00:00:00.000
 Put your names in stars.cpp.

00:00:00.000 --> 00:00:00.000
 And then in stars.h, notice I already have my struct star.

00:00:00.000 --> 00:00:00.000
 I already have my struct star.

00:00:00.000 --> 00:00:00.000
 I've included string and iostream.

00:00:00.000 --> 00:00:00.000
 So let's just put in the prototypes for those two functions.

00:00:00.000 --> 00:00:00.000
 So for my print function, it's an ostream ref.

00:00:00.000 --> 00:00:00.000
 But I'm inside a header file.

00:00:00.000 --> 00:00:00.000
 I can't use using namespace standard.

00:00:00.000 --> 00:00:00.000
 So the compiler is not going to understand that.

00:00:00.000 --> 00:00:00.000
 So I have to write standard colon ostream ref.

00:00:00.000 --> 00:00:00.000
 Print is the name of the function.

00:00:00.000 --> 00:00:00.000
 It's going to take a standard ostream ref for the output.

00:00:00.000 --> 00:00:00.000
 And it's going to take a const star ref s for the star.

00:00:00.000 --> 00:00:00.000
 And for our input, it's going to take a standard iostream ref.

00:00:00.000 --> 00:00:00.000
 We're going to call the function read.

00:00:00.000 --> 00:00:00.000
 I'm going to take an iostream ref in as my input stream.

00:00:00.000 --> 00:00:00.000
 And this time I'm going to take a star by reference s.

00:00:00.000 --> 00:00:00.000
 Okay, so there's my two prototypes.

00:00:00.000 --> 00:00:00.000
 Let's copy the two prototypes.

00:00:00.000 --> 00:00:00.000
 Let's move them over to stars.cpp.

00:00:00.000 --> 00:00:00.000
 Let's put a body on it.

00:00:00.000 --> 00:00:00.000
 Remove the semicolon.

00:00:00.000 --> 00:00:00.000
 And let's return the output stream and the input stream.

00:00:00.000 --> 00:00:00.000
 Okay, now I haven't done any reading or printing in here.

00:00:00.000 --> 00:00:00.000
 So what do we need to do to read from output?

00:00:00.000 --> 00:00:00.000
 Basically we need to do what we did back up in A.

00:00:00.000 --> 00:00:00.000
 So notice I have a star here.

00:00:00.000 --> 00:00:00.000
 Now I'm going to print it exactly like we printed it before.

00:00:00.000 --> 00:00:00.000
 So I'm going to say out name one, comma, space.

00:00:00.000 --> 00:00:00.000
 It's not name one, is it?

00:00:00.000 --> 00:00:00.000
 It's s.name one.

00:00:00.000 --> 00:00:00.000
 And s.x, a comma and a space, and s.y.

00:00:00.000 --> 00:00:00.000
 And a closing parenthesis and a comma and a space.

00:00:00.000 --> 00:00:00.000
 And s.magnitude.

00:00:00.000 --> 00:00:00.000
 Now we don't want to use a new line like we did when we were printing it out ourselves.

00:00:00.000 --> 00:00:00.000
 When you call the print function, they'll use the new line on it at that point.

00:00:00.000 --> 00:00:00.000
 They'll use the new line on it at that point.

00:00:00.000 --> 00:00:00.000
 Now to read the data, we have a star object here.

00:00:00.000 --> 00:00:00.000
 I have start there, of course it should be a star.

00:00:00.000 --> 00:00:00.000
 You can see the difference in the coloring here.

00:00:00.000 --> 00:00:00.000
 And did I make that mistake over in the header file?

00:00:00.000 --> 00:00:00.000
 Yeah, I did.

00:00:00.000 --> 00:00:00.000
 So that should be a star, not a start.

00:00:00.000 --> 00:00:00.000
 So to read, what we're going to do is we're going to say in s.x, s.y, s.z.

00:00:00.000 --> 00:00:00.000
 Even though we're not printing z, we still need to read it.

00:00:00.000 --> 00:00:00.000
 s.draper, s.magnitude, and s.harvard.

00:00:00.000 --> 00:00:00.000
 We need to set the name one and name two to nothing.

00:00:00.000 --> 00:00:00.000
 So s.name1 equals s.name2 equals the empty string.

00:00:00.000 --> 00:00:00.000
 Then we need to put exactly the same code we had before.

00:00:00.000 --> 00:00:00.000
 So if we need to read, we need to do git line in.

00:00:00.000 --> 00:00:00.000
 We need to create a string, I'll call it name.

00:00:00.000 --> 00:00:00.000
 So now if that name has something in it, we need to transfer it to our strings.

00:00:00.000 --> 00:00:00.000
 So if not name empty, or let me write it the other way, it's probably more easier for you.

00:00:00.000 --> 00:00:00.000
 So if name not equal to that, the name's not empty, we're going to say auto pause equals name find.

00:00:00.000 --> 00:00:00.000
 Notice this time we used double quotes, you can use double quotes or single quotes there.

00:00:00.000 --> 00:00:00.000
 So if pause equals equals string end pause, if it's not found, that means we only have one name.

00:00:00.000 --> 00:00:00.000
 So if pause equals equals end pause, it means we only have one name.

00:00:00.000 --> 00:00:00.000
 So, and I think I did this wrong in the last exercise we did in A.

00:00:00.000 --> 00:00:00.000
 So I'm going to say s.name1 equals name substring.

00:00:00.000 --> 00:00:00.000
 Let's put that up here so it's a little easier to read.

00:00:00.000 --> 00:00:00.000
 And if that's not the case, name1 equals name substring1 and pause minus 1.

00:00:00.000 --> 00:00:00.000
 Again, to count for the space at the beginning of it.

00:00:00.000 --> 00:00:00.000
 And whenever I have two lines, I don't like to put two statements on one line.

00:00:00.000 --> 00:00:00.000
 I only use one line here when I can fit the whole thing on the side there.

00:00:00.000 --> 00:00:00.000
 So name2 equals name substring pause plus 2.

00:00:00.000 --> 00:00:00.000
 And we're going to return in.

00:00:00.000 --> 00:00:00.000
 So let's come down here and let's uncomment part 1 here.

00:00:00.000 --> 00:00:00.000
 So notice we're opening stars.txt, we're creating a star, and we're calling the read function.

00:00:00.000 --> 00:00:00.000
 While read in, if not name empty and s magnitude greater than 6, print cout s.

00:00:00.000 --> 00:00:00.000
 And we're printing an end out at the end of that.

00:00:00.000 --> 00:00:00.000
 So notice that this is, this code right here, is almost the same thing as star cat that we did in part A.

00:00:00.000 --> 00:00:00.000
 In other words, because we have functions now, we've been able to compress it down to these two pieces.

00:00:00.000 --> 00:00:00.000
 And so it's much easier to read, much more flexible, much easier to use.

00:00:00.000 --> 00:00:00.000
 So let's try that. Let's do make run.

00:00:00.000 --> 00:00:00.000
 Okay, so name1, so I have a syntax error there, and name2.

00:00:00.000 --> 00:00:00.000
 And of course, that's because this is not name1, right?

00:00:00.000 --> 00:00:00.000
 It's s.name1 and s.name2.

00:00:00.000 --> 00:00:00.000
 Let me clear it and run it again.

00:00:00.000 --> 00:00:00.000
 Okay, so these are all the stars that are named that have a magnitude greater than 6.

00:00:00.000 --> 00:00:00.000
 So again, writing functions, you can see how easy it is to use them after you've written the function.

00:00:00.000 --> 00:00:00.000
 And how easy it is to use it after you've written the function.

00:00:00.000 --> 00:00:00.000
 Now, it would be nicer if we could use the regular operators for our output.

00:00:00.000 --> 00:00:00.000
 In other words, if there was no difference between a star and printing an int, that's what we're shooting for.

00:00:00.000 --> 00:00:00.000
 And so for any user-defined type, you can overload most of the C++ operators to work with that type.

00:00:00.000 --> 00:00:00.000
 So we're going to be covering this many, many times in this class.

00:00:00.000 --> 00:00:00.000
 This is your first introduction to it.

00:00:00.000 --> 00:00:00.000
 So, plus, equals, equals, greater than, all of those are called binary operators.

00:00:00.000 --> 00:00:00.000
 Because we have a plus b, the operator plus takes two operands, the a and the b.

00:00:00.000 --> 00:00:00.000
 One's on the left-hand side, one's on the right-hand side.

00:00:00.000 --> 00:00:00.000
 The same through equals, equals, greater than, and so forth.

00:00:00.000 --> 00:00:00.000
 So the syntax is whatever the return type, so greater than returns a bool, equals, equals returns a bool.

00:00:00.000 --> 00:00:00.000
 Plus would return whatever type this object type is.

00:00:00.000 --> 00:00:00.000
 So it could be an int, it could be a double, it could be a star.

00:00:00.000 --> 00:00:00.000
 And so it's the return type, say bool, the operator, and then the symbol used for the operator.

00:00:00.000 --> 00:00:00.000
 The symbol used for the operator, so operator greater than, operator equals, equals.

00:00:00.000 --> 00:00:00.000
 And then the two arguments that will appear on the left-hand side and the right.

00:00:00.000 --> 00:00:00.000
 So LHS here just means the left-hand side, RHS just means the right-hand side.

00:00:00.000 --> 00:00:00.000
 And again, we replace the question mark here with the operator symbol.

00:00:00.000 --> 00:00:00.000
 So, suppose we wanted to compare star operators by magnitude.

00:00:00.000 --> 00:00:00.000
 If we wanted to do that, we'd use the less than operator.

00:00:00.000 --> 00:00:00.000
 So notice the function is named operator less than.

00:00:00.000 --> 00:00:00.000
 Less than returns a bool, true or false.

00:00:00.000 --> 00:00:00.000
 Would take two const stars, so const star ref LHS, const star ref RHS.

00:00:00.000 --> 00:00:00.000
 And then would return true if the magnitude of the left-hand side was less than the magnitude on the right-hand side.

00:00:00.000 --> 00:00:00.000
 Now, what we'd like to do now is we'd like to overload the input and output operators.

00:00:00.000 --> 00:00:00.000
 So the output operators have this prototype.

00:00:00.000 --> 00:00:00.000
 Now, that should look familiar to you as well as that one.

00:00:00.000 --> 00:00:00.000
 The only difference between read and print and these operators is the name of the function.

00:00:00.000 --> 00:00:00.000
 So, almost exactly the same signature as print and read, but with different names.

00:00:00.000 --> 00:00:00.000
 And so we can implement those by using read and print to implement them.

00:00:00.000 --> 00:00:00.000
 So we're going to go ahead and do that.

00:00:00.000 --> 00:00:00.000
 We're going to complete our second exercise here by adding these two member functions,

00:00:00.000 --> 00:00:00.000
 or these two overloaded operators to our code.

00:00:00.000 --> 00:00:00.000
 So in stars.h, we're going to take, make a copy of these two.

00:00:00.000 --> 00:00:00.000
 And I'm simply going to name this one operator output.

00:00:00.000 --> 00:00:00.000
 It's an O-string.

00:00:00.000 --> 00:00:00.000
 And this one I'm going to name operator input.

00:00:00.000 --> 00:00:00.000
 It's an I-string.

00:00:00.000 --> 00:00:00.000
 So notice that I used exactly the same prototype, just with a different name.

00:00:00.000 --> 00:00:00.000
 I'm going to copy it over to stars.cpp.

00:00:00.000 --> 00:00:00.000
 I'm going to paste them up here.

00:00:00.000 --> 00:00:00.000
 Remove the semicolon.

00:00:00.000 --> 00:00:00.000
 Remove the semicolon here.

00:00:00.000 --> 00:00:00.000
 And since we've already implemented that functionality as a function, I can just say return print out s.

00:00:00.000 --> 00:00:00.000
 And for this one I can just say return read in s.

00:00:00.000 --> 00:00:00.000
 So I'm using these functions up here that we wrote by hand to implement our overloaded operators.

00:00:00.000 --> 00:00:00.000
 And if you come down to run, now we can go ahead and comment out the remainder of this.

00:00:00.000 --> 00:00:00.000
 The remainder of that. And we should be able to do make run again.

00:00:00.000 --> 00:00:00.000
 And notice that the input and output operators work perfectly fine.

00:00:00.000 --> 00:00:00.000
 And reading from a string works perfectly fine.

00:00:00.000 --> 00:00:00.000
 So we can pass a string stream, you notice, for this third part.

00:00:00.000 --> 00:00:00.000
 I've just created an I-string stream with some values in it.

00:00:00.000 --> 00:00:00.000
 I pass it to read and it works perfectly fine.

00:00:00.000 --> 00:00:00.000
 And the input operators, so notice for part two here, rather than saying while read in s, I'm saying while in arrow s.

00:00:00.000 --> 00:00:00.000
 And here I'm saying cout arrow arrow s.

00:00:00.000 --> 00:00:00.000
 So I'm using exactly the same syntax.

00:00:00.000 --> 00:00:00.000
 So to finish this up, make sure the run part works.

00:00:00.000 --> 00:00:00.000
 Go ahead and just do make test.

00:00:00.000 --> 00:00:00.000
 And it will test running and looking at several different kinds of stars.

00:00:00.000 --> 00:00:00.000
 Testing individually the output operator to make sure that it's correct.

00:00:00.000 --> 00:00:00.000
 Testing individually the input operator.

00:00:00.000 --> 00:00:00.000
 Again, this is what the input is. Here's one with two names.

00:00:00.000 --> 00:00:00.000
 We test it with one name. Test it with one with no name.

00:00:00.000 --> 00:00:00.000
 So we can test all those possibilities.

00:00:00.000 --> 00:00:00.000
 And this is just testing read and print separately.

00:00:00.000 --> 00:00:00.000
 So here's testing read. Here's testing print.

00:00:00.000 --> 00:00:00.000
 Here's testing the input operator. Here's testing the output operator.

00:00:00.000 --> 00:00:00.000
 Okay, so structured types are things like the date that you see on the right.

00:00:00.000 --> 00:00:00.000
 It has January 3rd, 2009.

00:00:00.000 --> 00:00:00.000
 It has a string and a couple of integers.

00:00:00.000 --> 00:00:00.000
 So that's a structured type.

00:00:00.000 --> 00:00:00.000
 We can also create user defined scalar types.

00:00:00.000 --> 00:00:00.000
 Ones that have only a single value versus the structured type or the record that adds multiple values together.

00:00:00.000 --> 00:00:00.000
 With scalar values, we can enumerate, meaning we can list or count each possible value.

00:00:00.000 --> 00:00:00.000
 For instance, if I want to create a type that represents the weekdays,

00:00:00.000 --> 00:00:00.000
 it's Monday, Tuesday, Wednesday, Thursday, and Friday.

00:00:00.000 --> 00:00:00.000
 Saturday and Sunday wouldn't be one of the weekdays.

00:00:00.000 --> 00:00:00.000
 We can write this two ways.

00:00:00.000 --> 00:00:00.000
 In C++11, we use the words "anum" followed by "class".

00:00:00.000 --> 00:00:00.000
 So anum, class, weekday.

00:00:00.000 --> 00:00:00.000
 These are called scoped enumerations.

00:00:00.000 --> 00:00:00.000
 They were introduced again in C++11.

00:00:00.000 --> 00:00:00.000
 C++ and C, the older version of C++, that's what's called a plain enumeration.

00:00:00.000 --> 00:00:00.000
 You generally want to use the scoped enumerations because they have less opportunities for errors.

00:00:00.000 --> 00:00:00.000
 So let's look at defining an enumerated type.

00:00:00.000 --> 00:00:00.000
 So an enumerated type is a set of related integer values which act like a type.

00:00:00.000 --> 00:00:00.000
 You provide a name for each value.

00:00:00.000 --> 00:00:00.000
 For example, the suit values for a deck of cards would include the clubs, the spades, the diamonds, and the hearts.

00:00:00.000 --> 00:00:00.000
 Now notice the names are separated by commas.

00:00:00.000 --> 00:00:00.000
 There's no ending semicolon. There's an ending semicolon at the end of the definition of the type.

00:00:00.000 --> 00:00:00.000
 But there's no semicolon after the word "hearts".

00:00:00.000 --> 00:00:00.000
 So no ending semicolon.

00:00:00.000 --> 00:00:00.000
 You should use lowercase or propercase. Avoid using uppercase.

00:00:00.000 --> 00:00:00.000
 Here are some of the things you can do with a scoped enumeration.

00:00:00.000 --> 00:00:00.000
 I could create a suit variable, S, an enumerated type variable.

00:00:00.000 --> 00:00:00.000
 I could initialize it. What would I initialize it with?

00:00:00.000 --> 00:00:00.000
 I'd initialize it not with hearts, but with its fully qualified name, suit colon colon hearts.

00:00:00.000 --> 00:00:00.000
 I could compare it to another enumerated type.

00:00:00.000 --> 00:00:00.000
 I couldn't compare it to an integer, but I could compare it to suit clubs using not equals and equals.

00:00:00.000 --> 00:00:00.000
 Now greater than and less than also kind of works, but it's not very, very useful.

00:00:00.000 --> 00:00:00.000
 So generally we'll use equals or not equals.

00:00:00.000 --> 00:00:00.000
 We can use that variable as a switch selector.

00:00:00.000 --> 00:00:00.000
 So switch S, case suit clubs, return clubs. Case suit hearts, return hearts.

00:00:00.000 --> 00:00:00.000
 So this is converting a suit type into a string type.

00:00:00.000 --> 00:00:00.000
 If it wasn't one of the four clubs, which are the only things it could possibly be,

00:00:00.000 --> 00:00:00.000
 would return some kind of error or have an assertion there or throw an exception, something like that.

00:00:00.000 --> 00:00:00.000
 So why do we want to use enumerated types?

00:00:00.000 --> 00:00:00.000
 Consider a playing card.

00:00:00.000 --> 00:00:00.000
 A playing card has two things.

00:00:00.000 --> 00:00:00.000
 It has a suit and a rank.

00:00:00.000 --> 00:00:00.000
 We could represent that suit and that rank like ace, king, queen, jack is the rank,

00:00:00.000 --> 00:00:00.000
 and diamonds, hearts, spades, and clubs are the suits.

00:00:00.000 --> 00:00:00.000
 We could represent those by using strings or integers or something else.

00:00:00.000 --> 00:00:00.000
 So imagine if we represented the rank and the suit using strings.

00:00:00.000 --> 00:00:00.000
 There should be a comma between rank and suit here,

00:00:00.000 --> 00:00:00.000
 and I will probably fix that on the slides that you'll see if you click the slides.

00:00:00.000 --> 00:00:00.000
 Then I go and create a card object.

00:00:00.000 --> 00:00:00.000
 And I create a card A and I pass it ace and clubs.

00:00:00.000 --> 00:00:00.000
 Well, what's the problem?

00:00:00.000 --> 00:00:00.000
 Well, cubs is the wrong spelling for the clubs,

00:00:00.000 --> 00:00:00.000
 so instead of the ace of clubs, I get something that doesn't make any sense.

00:00:00.000 --> 00:00:00.000
 In other words, my type is not very resilient.

00:00:00.000 --> 00:00:00.000
 The compiler can't check the fact that I've passed the wrong values.

00:00:00.000 --> 00:00:00.000
 Suppose instead I decide to make rank and suit integers.

00:00:00.000 --> 00:00:00.000
 And then I create some constants like this, ace 101 and clubs 1001.

00:00:00.000 --> 00:00:00.000
 So I start all the ranks at 1 and I start all the suits at 1000.

00:00:00.000 --> 00:00:00.000
 And then I try and create a card B, clubs ace.

00:00:00.000 --> 00:00:00.000
 Well, what's the problem?

00:00:00.000 --> 00:00:00.000
 Again, my structure has rank and suit.

00:00:00.000 --> 00:00:00.000
 What I've passed in is 1001 for the rank and 101 for the suit.

00:00:00.000 --> 00:00:00.000
 Both of those are invalid values, and I would have to do some extra checking.

00:00:00.000 --> 00:00:00.000
 Again, the compiler can't check to see that I have switched my rank and suit,

00:00:00.000 --> 00:00:00.000
 where it's supposed to be rank suit, and I've passed in clubs.

00:00:00.000 --> 00:00:00.000
 I've passed in suit and rank.

00:00:00.000 --> 00:00:00.000
 Again, the compiler can't change that.

00:00:00.000 --> 00:00:00.000
 Suppose, however, that I created an enumerated type for the rank,

00:00:00.000 --> 00:00:00.000
 an enumerated type for the suit.

00:00:00.000 --> 00:00:00.000
 Then I would create it like this, card rank ace, rank clubs.

00:00:00.000 --> 00:00:00.000
 If I switch those, the compiler would tell me.

00:00:00.000 --> 00:00:00.000
 I would know the moment I tried to compile my code, I've made a mistake.

00:00:00.000 --> 00:00:00.000
 I would not have to ever worry about creating a card object with invalid values.

00:00:00.000 --> 00:00:00.000
 It would be impossible.

00:00:00.000 --> 00:00:00.000
 And so that's really why we want to use enumerated types.

00:00:00.000 --> 00:00:00.000
 We say that we're creating strong types for our arguments and our parameters.

00:00:00.000 --> 00:00:00.000
 Now, there is no built-in input/output with enumerated types.

00:00:00.000 --> 00:00:00.000
 You may write a two-string function.

00:00:00.000 --> 00:00:00.000
 You may want to convert it to a string for output with a function.

00:00:00.000 --> 00:00:00.000
 So here's a two-string function that takes a rank.

00:00:00.000 --> 00:00:00.000
 We'll switch on the rank, and then case rank ace, we'll return ace.

00:00:00.000 --> 00:00:00.000
 Case rank two, we'll return two. Case rank three, we'll return three.

00:00:00.000 --> 00:00:00.000
 So let's go ahead and do that.

00:00:00.000 --> 00:00:00.000
 So for our exercise here with enumerated types,

00:00:00.000 --> 00:00:00.000
 we're going to take the coin type and we're going to complete the two-string function for the coin type.

00:00:00.000 --> 00:00:00.000
 So let me close that.

00:00:00.000 --> 00:00:00.000
 Let me close this. Let me close this.

00:00:00.000 --> 00:00:00.000
 Let's go down to C.

00:00:00.000 --> 00:00:00.000
 And this will be in enumH.

00:00:00.000 --> 00:00:00.000
 So here's our enumerated type.

00:00:00.000 --> 00:00:00.000
 And we're going to write the two-string function.

00:00:00.000 --> 00:00:00.000
 And let's see if we want to do the two-string and the value of function.

00:00:00.000 --> 00:00:00.000
 So actually we're going to write two functions in this.

00:00:00.000 --> 00:00:00.000
 And so this is in enumOps.cpp.

00:00:00.000 --> 00:00:00.000
 So let's put your name in here.

00:00:00.000 --> 00:00:00.000
 Notice I've included enum.h right here.

00:00:00.000 --> 00:00:00.000
 I'm going to put my name at the top of this just to get the practice.

00:00:00.000 --> 00:00:00.000
 So I'm going to put summer22 for this.

00:00:00.000 --> 00:00:00.000
 Okay, let's go grab those two prototypes.

00:00:00.000 --> 00:00:00.000
 And we'll see how we would add our implementation for that right here.

00:00:00.000 --> 00:00:00.000
 Okay, so if I want to convert a coin object to string, I'm going to have to use a switch statement.

00:00:00.000 --> 00:00:00.000
 So I'm going to have to say switch on C.

00:00:00.000 --> 00:00:00.000
 Now I'm going to have to say case coin colon colon and then what the coin types are.

00:00:00.000 --> 00:00:00.000
 So what are my coin types?

00:00:00.000 --> 00:00:00.000
 I'll just copy them right here.

00:00:00.000 --> 00:00:00.000
 So case coin penny colon.

00:00:00.000 --> 00:00:00.000
 So that's the structure.

00:00:00.000 --> 00:00:00.000
 The colon colon and the colon is kind of confusing here.

00:00:00.000 --> 00:00:00.000
 I'm going to return penny.

00:00:00.000 --> 00:00:00.000
 And this will be case coin dime, case coin quarter, case coin nickel.

00:00:00.000 --> 00:00:00.000
 Let's put the colons on the end of each of those case labels.

00:00:00.000 --> 00:00:00.000
 So here we're going to return nickel.

00:00:00.000 --> 00:00:00.000
 Here we're going to return a dime.

00:00:00.000 --> 00:00:00.000
 Here I'm going to return a quarter.

00:00:00.000 --> 00:00:00.000
 And here I'm going to return half dollar.

00:00:00.000 --> 00:00:00.000
 Okay, what if it is none of those?

00:00:00.000 --> 00:00:00.000
 Well, technically it has to be one of those.

00:00:00.000 --> 00:00:00.000
 I believe the code will compile without us putting a default in it.

00:00:00.000 --> 00:00:00.000
 Let's just try it.

00:00:00.000 --> 00:00:00.000
 Let's open up a shell on that.

00:00:00.000 --> 00:00:00.000
 Let's just do make on it.

00:00:00.000 --> 00:00:00.000
 Okay, value of, okay, control reaches end of non-void function.

00:00:00.000 --> 00:00:00.000
 So it does require us to do something.

00:00:00.000 --> 00:00:00.000
 And so what we could do here is we could just add an assert or a throw or just a return.

00:00:00.000 --> 00:00:00.000
 Or you could add a throw statement.

00:00:00.000 --> 00:00:00.000
 A throw would work fine.

00:00:00.000 --> 00:00:00.000
 And we could put this, of course, inside the default.

00:00:00.000 --> 00:00:00.000
 In which case we don't need it here.

00:00:00.000 --> 00:00:00.000
 It's maybe a little more obvious over there that that is an error in that case.

00:00:00.000 --> 00:00:00.000
 Okay, so now we've got a coin and we want to get its value.

00:00:00.000 --> 00:00:00.000
 Now we could do a switch like this, case coin penny, return one.

00:00:00.000 --> 00:00:00.000
 Case coin nickel, return two.

00:00:00.000 --> 00:00:00.000
 But notice when I created my enumerated type,

00:00:00.000 --> 00:00:00.000
 I provided an underlying value for each of the types that represents the type of the value.

00:00:00.000 --> 00:00:00.000
 Now we want to return it as a double.

00:00:00.000 --> 00:00:00.000
 And so what we're going to need to do is we're going to need to cast this to its underlying type.

00:00:00.000 --> 00:00:00.000
 So I'm going to say static return static cast double C divided by 100.

00:00:00.000 --> 00:00:00.000
 And this actually should be, you should cast it to an int, not a double.

00:00:00.000 --> 00:00:00.000
 So static cast int divided by 100 will give us a double.

00:00:00.000 --> 00:00:00.000
 And that should, in fact, pass all our tests.

00:00:00.000 --> 00:00:00.000
 Make works, so make test.

00:00:00.000 --> 00:00:00.000
 And to string, oh, it wanted half dollar to look slightly different, so let's fix that.

00:00:00.000 --> 00:00:00.000
 It wants it to look like that.

00:00:00.000 --> 00:00:00.000
 So let's say make test.

00:00:00.000 --> 00:00:00.000
 Okay, so all of these work.

00:00:00.000 --> 00:00:00.000
 Okay, so this was converting a type, an enumerated type to a two string,

00:00:00.000 --> 00:00:00.000
 so we could do output on it and a value of,

00:00:00.000 --> 00:00:00.000
 so we could use it in a calculation, a coin type rather than an integer.

00:00:00.000 --> 00:00:00.000
 I could use it with other types.

00:00:00.000 --> 00:00:00.000
 Okay, the last thing we want to look at today in this lecture is we want to look at I/O operators.

00:00:00.000 --> 00:00:00.000
 So I've already seen these I/O operators for stars.

00:00:00.000 --> 00:00:00.000
 We have const star ref.

00:00:00.000 --> 00:00:00.000
 We can use them for any user defined types, including for enumerated types.

00:00:00.000 --> 00:00:00.000
 So we're going to use the two string for rank and suit.

00:00:00.000 --> 00:00:00.000
 Card, of course, is a structure in this case,

00:00:00.000 --> 00:00:00.000
 so we can use the output operators for our cards just like we did with our stars.

00:00:00.000 --> 00:00:00.000
 The input operator looks like this, just like the ones we used for stars.

00:00:00.000 --> 00:00:00.000
 Our input is going to be in the form of AS for ace of spades, TH for ten of hearts,

00:00:00.000 --> 00:00:00.000
 JC for jack of clubs, and so forth.

00:00:00.000 --> 00:00:00.000
 So this is our last exercise. We're going to write the card I/O operators down in,

00:00:00.000 --> 00:00:00.000
 let's close that,

00:00:00.000 --> 00:00:00.000
 down in D.

00:00:00.000 --> 00:00:00.000
 So let's open a shell on that.

00:00:00.000 --> 00:00:00.000
 And let's close the previous shells.

00:00:00.000 --> 00:00:00.000
 And so I only have one shell open on D.

00:00:00.000 --> 00:00:00.000
 Let's open card I/O dot CVP. This is the one we're going to change.

00:00:00.000 --> 00:00:00.000
 Cards dot H, I believe, already has our prototypes inside there.

00:00:00.000 --> 00:00:00.000
 So we can just copy those prototypes, that's what we're going to write.

00:00:00.000 --> 00:00:00.000
 It has these functions already written, the two string for the suit and the two string for the rank.

00:00:00.000 --> 00:00:00.000
 So the output one is pretty easy.

00:00:00.000 --> 00:00:00.000
 The output one, we're simply going to say out, two string, C dot rank.

00:00:00.000 --> 00:00:00.000
 Then we're going to put of, and two string, C dot suit.

00:00:00.000 --> 00:00:00.000
 And then we're going to return out.

00:00:00.000 --> 00:00:00.000
 So that's pretty easy. We're taking two string, and again, that's already defined for us here.

00:00:00.000 --> 00:00:00.000
 And here are the types for suits and ranks.

00:00:00.000 --> 00:00:00.000
 So we don't need to use a switch statement for that.

00:00:00.000 --> 00:00:00.000
 This is our structure for our card. It has a rank and a suit.

00:00:00.000 --> 00:00:00.000
 So the output is pretty easy. The input is a little more difficult.

00:00:00.000 --> 00:00:00.000
 So we're going to return in at the end of this.

00:00:00.000 --> 00:00:00.000
 We're going to need to read two characters.

00:00:00.000 --> 00:00:00.000
 So I'm going to call those R and C.

00:00:00.000 --> 00:00:00.000
 So char R and C.

00:00:00.000 --> 00:00:00.000
 And we're going to need to read in R and C.

00:00:00.000 --> 00:00:00.000
 Now there is no easy way to compute, convert R to C, other than writing a switch.

00:00:00.000 --> 00:00:00.000
 So we're going to write switch R, and then switch C.

00:00:00.000 --> 00:00:00.000
 Now the parts that make up a rank, let's just go copy them over here.

00:00:00.000 --> 00:00:00.000
 There's our suit.

00:00:00.000 --> 00:00:00.000
 So let me just copy both of those over here.

00:00:00.000 --> 00:00:00.000
 Okay, so here's our ranks.

00:00:00.000 --> 00:00:00.000
 Now that's our suits.

00:00:00.000 --> 00:00:00.000
 Let's paste them in there and comment them out.

00:00:00.000 --> 00:00:00.000
 Here's our ranks.

00:00:00.000 --> 00:00:00.000
 And I should have called this R and S, right? Rank and suit.

00:00:00.000 --> 00:00:00.000
 Okay, so there's my ranks.

00:00:00.000 --> 00:00:00.000
 Here's my suit.

00:00:00.000 --> 00:00:00.000
 Okay, so let's put the syntax in there.

00:00:00.000 --> 00:00:00.000
 So case rank colon colon ace.

00:00:00.000 --> 00:00:00.000
 What we're going to say is C rank equals.

00:00:00.000 --> 00:00:00.000
 Of course, let me put this. I'm really messing this up.

00:00:00.000 --> 00:00:00.000
 Case ace, then C.rank equals rank.ace and break.

00:00:00.000 --> 00:00:00.000
 Okay, so we're going to do the same thing. I'm just going to copy that code there.

00:00:00.000 --> 00:00:00.000
 Let's put in all the ranks.

00:00:00.000 --> 00:00:00.000
 Two, three, four, five, six, seven, eight, nine.

00:00:00.000 --> 00:00:00.000
 Can't put ten as a character, so we're going to use T.

00:00:00.000 --> 00:00:00.000
 Jack, queen, and one more.

00:00:00.000 --> 00:00:00.000
 King.

00:00:00.000 --> 00:00:00.000
 So this is going to be.

00:00:00.000 --> 00:00:00.000
 So that's going to be two. Three. Four. Five. Six. Seven. Eight.

00:00:00.000 --> 00:00:00.000
 Oops.

00:00:00.000 --> 00:00:00.000
 Eight. Nine. Ten. Jack. Queen. King.

00:00:00.000 --> 00:00:00.000
 And let's put a default.

00:00:00.000 --> 00:00:00.000
 Let's throw an exception.

00:00:00.000 --> 00:00:00.000
 Throw a string.

00:00:00.000 --> 00:00:00.000
 Throw a bad rank.

00:00:00.000 --> 00:00:00.000
 Okay, now let me copy one of these lines here.

00:00:00.000 --> 00:00:00.000
 We'll use the same thing for the suit.

00:00:00.000 --> 00:00:00.000
 Although, of course, it's much closer. It's very shorter.

00:00:00.000 --> 00:00:00.000
 So the suits are going to be spades, clubs, C suit.

00:00:00.000 --> 00:00:00.000
 That should be C, right?

00:00:00.000 --> 00:00:00.000
 And this is going to be suit clubs.

00:00:00.000 --> 00:00:00.000
 And we can just make. I'm not quite sure what I did.

00:00:00.000 --> 00:00:00.000
 So here's spades, diamonds, hearts.

00:00:00.000 --> 00:00:00.000
 And this, of course, is S, D, and H.

00:00:00.000 --> 00:00:00.000
 And we'll do the same thing for the default.

00:00:00.000 --> 00:00:00.000
 I'll just throw a bad suit instead of a bad rank.

00:00:00.000 --> 00:00:00.000
 Okay, let's try it here.

00:00:00.000 --> 00:00:00.000
 So let's do make.

00:00:00.000 --> 00:00:00.000
 And let's do make test.

00:00:00.000 --> 00:00:00.000
 Okay, so here's my output operator. I created this car with rank of ace.

00:00:00.000 --> 00:00:00.000
 It prints out ace of spades.

00:00:00.000 --> 00:00:00.000
 Queen of hearts. Jack of diamonds.

00:00:00.000 --> 00:00:00.000
 Now I've created a, I've got in seven of clubs.

00:00:00.000 --> 00:00:00.000
 If you want to see what I'm processing, I'm processing this file.

00:00:00.000 --> 00:00:00.000
 Seven of clubs, two of diamonds, ten of diamonds, ten of clubs, queen of hearts.

00:00:00.000 --> 00:00:00.000
 And if we look at the output,

00:00:00.000 --> 00:00:00.000
 what we got is seven of clubs, two of diamonds, ten of diamonds, ten of clubs, queen of hearts.

00:00:00.000 --> 00:00:00.000
 So that worked just perfectly.

00:00:00.000 --> 00:00:00.000
 Okay, so we went a little over an hour today.

00:00:00.000 --> 00:00:00.000
 But we covered structured types and enumerated types.

00:00:00.000 --> 00:00:00.000
 And you were introduced to overloaded operators.

00:00:00.000 --> 00:00:00.000
 I'll see you in lecture 16.

