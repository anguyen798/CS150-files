1
00:00:00,000 --> 00:00:00,000
Hello folks, welcome to our last lecture, lecture 28 on polymorphism.

2
00:00:00,000 --> 00:00:00,000
So this is continuing the idea of inheritance.

3
00:00:00,000 --> 00:00:00,000
In the last lecture we looked at what's called specialization inheritance.

4
00:00:00,000 --> 00:00:00,000
With specialization inheritance, a derived class adds new features, it's a specialized

5
00:00:00,000 --> 00:00:00,000
kind of a base class.

6
00:00:00,000 --> 00:00:00,000
So it may have new member functions, it may have new data members, such as the instructor

7
00:00:00,000 --> 00:00:00,000
and the student did in our last exercise.

8
00:00:00,000 --> 00:00:00,000
With specification inheritance, what we want to do is not add new features, but change

9
00:00:00,000 --> 00:00:00,000
behavior so that when we send the same message to different classes, they will interact according

10
00:00:00,000 --> 00:00:00,000
to their nature.

11
00:00:00,000 --> 00:00:00,000
So I have three animals here, and if I ask them to speak, the animal that's a dog says

12
00:00:00,000 --> 00:00:00,000
woof, the animal that's a cat says meow, the animal that is a cow says moo.

13
00:00:00,000 --> 00:00:00,000
So that's the basic idea behind polymorphism.

14
00:00:00,000 --> 00:00:00,000
So if you go ahead and look in our, in the downloaded IC28 folder in pet01, you'll see

15
00:00:00,000 --> 00:00:00,000
that I have a header file with pets, and you'll see that if you look through that, you'll

16
00:00:00,000 --> 00:00:00,000
see that there are three different kinds of pets.

17
00:00:00,000 --> 00:00:00,000
There is a base class pet, and then two derived classes.

18
00:00:00,000 --> 00:00:00,000
Every cat and every dog, of course, is a pet, so we use public inheritance for this.

19
00:00:00,000 --> 00:00:00,000
Now our cat inherits two member functions, license and getID, and it redefines speak.

20
00:00:00,000 --> 00:00:00,000
It doesn't override it, it redefines it.

21
00:00:00,000 --> 00:00:00,000
The dog inherits getID, and it redefines speak and license.

22
00:00:00,000 --> 00:00:00,000
So this is the basic picture we have of that.

23
00:00:00,000 --> 00:00:00,000
Now if you go over to the, if you go over to your IDE and you just open the client program,

24
00:00:00,000 --> 00:00:00,000
you'll see that I create a pet, a cat and a dog, and I send the same message to each

25
00:00:00,000 --> 00:00:00,000
of them.

26
00:00:00,000 --> 00:00:00,000
And when we run this program, what you'll see is that the generic pet acts differently

27
00:00:00,000 --> 00:00:00,000
than the cat and the dog.

28
00:00:00,000 --> 00:00:00,000
Each one of them acts according to its nature.

29
00:00:00,000 --> 00:00:00,000
And so each object responds appropriately to exactly the same request.

30
00:00:00,000 --> 00:00:00,000
So how does that work?

31
00:00:00,000 --> 00:00:00,000
This is called static polymorphism, and this works because the compiler looks at the declared

32
00:00:00,000 --> 00:00:00,000
type of the variables P, C, and D.

33
00:00:00,000 --> 00:00:00,000
P is of type pet, C is of type cat, and D is of type dog.

34
00:00:00,000 --> 00:00:00,000
And it calls the correct function based on that type, and this binding together of the

35
00:00:00,000 --> 00:00:00,000
function call, the function that is actually called, happens at compile time.

36
00:00:00,000 --> 00:00:00,000
And so this is called static polymorphism or early binding.

37
00:00:00,000 --> 00:00:00,000
Early binding.

38
00:00:00,000 --> 00:00:00,000
Now what we would prefer instead of static polymorphism is polymorphic functions.

39
00:00:00,000 --> 00:00:00,000
Instead of writing several overloaded functions like this, show and passing it a cat, show

40
00:00:00,000 --> 00:00:00,000
passing it a dog, why can't I do this?

41
00:00:00,000 --> 00:00:00,000
Why can't I simply write a function show pet or show pet pointer and ask it to speak and

42
00:00:00,000 --> 00:00:00,000
then call the function like show my dog.

43
00:00:00,000 --> 00:00:00,000
After all, every dog is a pet, right?

44
00:00:00,000 --> 00:00:00,000
So that should work.

45
00:00:00,000 --> 00:00:00,000
So let's go ahead and look and see what happens.

46
00:00:00,000 --> 00:00:00,000
And this is not in A. This is in, let's close that one, this is in B, pet 2.

47
00:00:00,000 --> 00:00:00,000
And if we look up the client, we see we have a speak with a pet and a speak with a pet

48
00:00:00,000 --> 00:00:00,000
pointer.

49
00:00:00,000 --> 00:00:00,000
I have a cat, a dog, and so we can get their IDs to make sure that we in fact have a cat

50
00:00:00,000 --> 00:00:00,000
or a dog.

51
00:00:00,000 --> 00:00:00,000
And in section 1, I pass a dog object to speak and a cat object to speak.

52
00:00:00,000 --> 00:00:00,000
So let's go ahead and open a terminal and see if that works.

53
00:00:00,000 --> 00:00:00,000
So I'm going to do make run.

54
00:00:00,000 --> 00:00:00,000
Ok so the cat had an ID of 101, the dog had an ID of 102, but when I pass 101 and 102,

55
00:00:00,000 --> 00:00:00,000
the cat and the dog, they forget what kind of pet they are and they forget how to do

56
00:00:00,000 --> 00:00:00,000
any dog or cat stuff.

57
00:00:00,000 --> 00:00:00,000
Somehow they've lost their memory of their catness and dogness.

58
00:00:00,000 --> 00:00:00,000
They have amnesia, so to speak.

59
00:00:00,000 --> 00:00:00,000
They have amnesia, so to speak.

60
00:00:00,000 --> 00:00:00,000
Now if I change it so that I don't have a cat and dog and I use a pointer and I pass

61
00:00:00,000 --> 00:00:00,000
the address of my dog and the address to my cat, again they don't remember they're a cat

62
00:00:00,000 --> 00:00:00,000
and a dog.

63
00:00:00,000 --> 00:00:00,000
They remember their ID number, right?

64
00:00:00,000 --> 00:00:00,000
So they remember the pet part of themselves, but they don't remember the cat and dog point.

65
00:00:00,000 --> 00:00:00,000
And if I call pet through a base pointer, so here notice c_ptr and d_ptr are not cat

66
00:00:00,000 --> 00:00:00,000
and dog pointers, they're pet pointers, but they're storing the address of the cat and

67
00:00:00,000 --> 00:00:00,000
the address of the dog.

68
00:00:00,000 --> 00:00:00,000
Again that doesn't seem to work.

69
00:00:00,000 --> 00:00:00,000
Finally the last section here, I wanted to look at how big each object is.

70
00:00:00,000 --> 00:00:00,000
Each object is just big enough to store the size of their ID.

71
00:00:00,000 --> 00:00:00,000
So the question we really have is how come this didn't work?

72
00:00:00,000 --> 00:00:00,000
By the way, if we did this in Java it would work perfectly.

73
00:00:00,000 --> 00:00:00,000
In C++ it doesn't seem to work and the question is why.

74
00:00:00,000 --> 00:00:00,000
So for part one, when we had a function called show_pet_p and we pass a dog object by value

75
00:00:00,000 --> 00:00:00,000
to the show function, what happens is the dog object passed by value is sliced into

76
00:00:00,000 --> 00:00:00,000
two parts.

77
00:00:00,000 --> 00:00:00,000
So imagine that a dog has a pet part and a dog part, but the variable over here only

78
00:00:00,000 --> 00:00:00,000
has enough room for the pet part.

79
00:00:00,000 --> 00:00:00,000
The dog part is just discarded.

80
00:00:00,000 --> 00:00:00,000
So this is similar to what happens when you pass a double value to an int variable or

81
00:00:00,000 --> 00:00:00,000
you assign a double value to an int variable.

82
00:00:00,000 --> 00:00:00,000
The fractional part is sliced off and thrown away or truncated.

83
00:00:00,000 --> 00:00:00,000
So this is called the slicing problem.

84
00:00:00,000 --> 00:00:00,000
This is one reason we never write functions that take objects by value.

85
00:00:00,000 --> 00:00:00,000
It also means that in C++ you cannot assign a derived object to a base variable.

86
00:00:00,000 --> 00:00:00,000
It will get sliced off and thrown away.

87
00:00:00,000 --> 00:00:00,000
Now notice the second part of this though.

88
00:00:00,000 --> 00:00:00,000
I had pointers and derived objects.

89
00:00:00,000 --> 00:00:00,000
So notice I said speak with the address of the dog and speak with the address of the

90
00:00:00,000 --> 00:00:00,000
cat.

91
00:00:00,000 --> 00:00:00,000
Why didn't that work?

92
00:00:00,000 --> 00:00:00,000
There was no slicing.

93
00:00:00,000 --> 00:00:00,000
Obviously the pointer is the same size for a cat or a dog pointer.

94
00:00:00,000 --> 00:00:00,000
The pointer is the same, but it still doesn't work.

95
00:00:00,000 --> 00:00:00,000
It still doesn't work.

96
00:00:00,000 --> 00:00:00,000
And it doesn't work because the function calls are still linked together, what we say they

97
00:00:00,000 --> 00:00:00,000
are bound, based on the declared pointer type.

98
00:00:00,000 --> 00:00:00,000
And the type of the pointer in the speak member function is not a cat or a dog.

99
00:00:00,000 --> 00:00:00,000
Remember it is a pet pointer.

100
00:00:00,000 --> 00:00:00,000
So the fact that this is a pet pointer means that this is always going to call the pet

101
00:00:00,000 --> 00:00:00,000
version of speak, not the cat or the dog.

102
00:00:00,000 --> 00:00:00,000
And that information has to be known at compile time.

103
00:00:00,000 --> 00:00:00,000
That information knows at compile time.

104
00:00:00,000 --> 00:00:00,000
So it sounds like polymorphic functions that we have in Java are impossible.

105
00:00:00,000 --> 00:00:00,000
That's not the case.

106
00:00:00,000 --> 00:00:00,000
What we want is a way to tell the function that the pet pointer p parameter actually

107
00:00:00,000 --> 00:00:00,000
points to a cat or dog object.

108
00:00:00,000 --> 00:00:00,000
Well when will we know that?

109
00:00:00,000 --> 00:00:00,000
We'll know it when we call the function.

110
00:00:00,000 --> 00:00:00,000
We'll know it at run time.

111
00:00:00,000 --> 00:00:00,000
We want to wait until run time, not at compile time, to decide which function to call.

112
00:00:00,000 --> 00:00:00,000
And this is called late binding.

113
00:00:00,000 --> 00:00:00,000
And that is what the keyword virtual in a class does.

114
00:00:00,000 --> 00:00:00,000
The keyword virtual enables late binding.

115
00:00:00,000 --> 00:00:00,000
Now as I mentioned, you may, but don't need to, repeat that virtual in the derive class.

116
00:00:00,000 --> 00:00:00,000
If a function is virtual in the base class, it is virtual and it will use this late binding.

117
00:00:00,000 --> 00:00:00,000
Now you might wonder why you didn't have this complication in Java.

118
00:00:00,000 --> 00:00:00,000
That's because in C++ you can have both early and late binding.

119
00:00:00,000 --> 00:00:00,000
In Java, all binding happens at run time.

120
00:00:00,000 --> 00:00:00,000
The reason is because in C++ they want to allow you to use the more efficient binding.

121
00:00:00,000 --> 00:00:00,000
And because the default in C++ is always to use the most efficient way, early binding

122
00:00:00,000 --> 00:00:00,000
is the default.

123
00:00:00,000 --> 00:00:00,000
Late binding uses indirection to call the function, which is a little bit slower.

124
00:00:00,000 --> 00:00:00,000
And it also uses a little bit more memory.

125
00:00:00,000 --> 00:00:00,000
Each object has a v pointer, which points to a v table.

126
00:00:00,000 --> 00:00:00,000
So let's go see how that works.

127
00:00:00,000 --> 00:00:00,000
And to see how that works we'll go to our pet3.

128
00:00:00,000 --> 00:00:00,000
And the only difference between pets2 and pets3 is that I have added this keyword virtual

129
00:00:00,000 --> 00:00:00,000
only in the header file.

130
00:00:00,000 --> 00:00:00,000
The rest of the code is exactly the same.

131
00:00:00,000 --> 00:00:00,000
You notice this pet pointer calling pet speaking through the base pointers and so forth.

132
00:00:00,000 --> 00:00:00,000
Actually it's not exactly the same, but it works exactly the same.

133
00:00:00,000 --> 00:00:00,000
So in pets3, let's do make run.

134
00:00:00,000 --> 00:00:00,000
So now calling the virtual functions through the base pointer, the cat remembers that it's

135
00:00:00,000 --> 00:00:00,000
a cat.

136
00:00:00,000 --> 00:00:00,000
It remembers it's type cat.

137
00:00:00,000 --> 00:00:00,000
And it remembers to say meow.

138
00:00:00,000 --> 00:00:00,000
The size of each object, notice, has changed though.

139
00:00:00,000 --> 00:00:00,000
So it went from 4 bytes to 16 bytes.

140
00:00:00,000 --> 00:00:00,000
Why is that?

141
00:00:00,000 --> 00:00:00,000
We have the 4 bytes for the ID, and then we have 8 bytes because this is Unix for a pointer.

142
00:00:00,000 --> 00:00:00,000
There's 4 bytes that are unused in each object.

143
00:00:00,000 --> 00:00:00,000
Now notice in my client program, if I call a function with an object, even though it's

144
00:00:00,000 --> 00:00:00,000
a virtual function, it's not polymorphic.

145
00:00:00,000 --> 00:00:00,000
So polymorphic functions cannot take objects.

146
00:00:00,000 --> 00:00:00,000
In other words, this will not work.

147
00:00:00,000 --> 00:00:00,000
If we made it a const pet reference, that would be perfectly fine.

148
00:00:00,000 --> 00:00:00,000
It would work.

149
00:00:00,000 --> 00:00:00,000
If we make it a pet by value, you cannot pass an object.

150
00:00:00,000 --> 00:00:00,000
You cannot pass an object.

151
00:00:00,000 --> 00:00:00,000
Can you call a polymorphic function with a pointer?

152
00:00:00,000 --> 00:00:00,000
Yes.

153
00:00:00,000 --> 00:00:00,000
It looks like we can see meow and arf.

154
00:00:00,000 --> 00:00:00,000
Can you call a polymorphic function with a base pointer?

155
00:00:00,000 --> 00:00:00,000
Yes, it works perfectly fine.

156
00:00:00,000 --> 00:00:00,000
When we call speak with a base pointer, remember cpointer is a pet pointer, not a pointer.

157
00:00:00,000 --> 00:00:00,000
It's a pointer to a cat that happens to be pointing to a cat.

158
00:00:00,000 --> 00:00:00,000
And so it waits until runtime to determine that.

159
00:00:00,000 --> 00:00:00,000
OK, so that's the basic idea behind polymorphism.

160
00:00:00,000 --> 00:00:00,000
With polymorphism, you have to call it through a base pointer.

161
00:00:00,000 --> 00:00:00,000
So for instance, if I have a cat and a pet pointer p, so this pointer is of type pet,

162
00:00:00,000 --> 00:00:00,000
but it points to a cat.

163
00:00:00,000 --> 00:00:00,000
When we call pspeak, if the function is virtual, it will call catspeak.

164
00:00:00,000 --> 00:00:00,000
You call a polymorphic function only with a pointer or reference.

165
00:00:00,000 --> 00:00:00,000
So this is not polymorphic.

166
00:00:00,000 --> 00:00:00,000
This is polymorphic.

167
00:00:00,000 --> 00:00:00,000
The polymorphic function, of course, must call a virtual function.

168
00:00:00,000 --> 00:00:00,000
In other words, if speak isn't virtual, it's still not polymorphic.

169
00:00:00,000 --> 00:00:00,000
When we call speak with the address of c, the compiler uses the dynamic type to decide

170
00:00:00,000 --> 00:00:00,000
which function to call catspeak.

171
00:00:00,000 --> 00:00:00,000
And again, the decision is made at runtime.

172
00:00:00,000 --> 00:00:00,000
OK, so let's do an exercise.

173
00:00:00,000 --> 00:00:00,000
This is exercise A. We have four different kinds of cards, like an ID card or what in

174
00:00:00,000 --> 00:00:00,000
old-fashioned movies someone would-- a calling card, right?

175
00:00:00,000 --> 00:00:00,000
We have an ID card that has an ID number on it, like your student ID card.

176
00:00:00,000 --> 00:00:00,000
We have a calling card that doesn't have your name on it, but it has a card number on it,

177
00:00:00,000 --> 00:00:00,000
and we have a driver's license.

178
00:00:00,000 --> 00:00:00,000
So four different kinds of cards.

179
00:00:00,000 --> 00:00:00,000
So let's put away this client.

180
00:00:00,000 --> 00:00:00,000
Let's put away pets3.

181
00:00:00,000 --> 00:00:00,000
Let's go look at A. And let's go look at cards.h.

182
00:00:00,000 --> 00:00:00,000
So here's the card.

183
00:00:00,000 --> 00:00:00,000
Here is the ID card.

184
00:00:00,000 --> 00:00:00,000
Here is the calling card.

185
00:00:00,000 --> 00:00:00,000
Here is a driver's license.

186
00:00:00,000 --> 00:00:00,000
It's like a phone card, a calling card, not something you would call somebody on.

187
00:00:00,000 --> 00:00:00,000
And here is our client program over here.

188
00:00:00,000 --> 00:00:00,000
So we have a Billful class.

189
00:00:00,000 --> 00:00:00,000
It creates a base class pointer and initializes that base class pointer cp to a new plain

190
00:00:00,000 --> 00:00:00,000
card that says John Doe.

191
00:00:00,000 --> 00:00:00,000
Then it adds that to this Billfold object.

192
00:00:00,000 --> 00:00:00,000
Now the Billfold will accept-- it has a vector inside it that takes an array of cards.

193
00:00:00,000 --> 00:00:00,000
Then we initialize this base pointer a second time with a new ID card and add it to the

194
00:00:00,000 --> 00:00:00,000
Billfold, a new calling card, and a new driver's license, and then we call printCards.

195
00:00:00,000 --> 00:00:00,000
And again, what is supposed to happen is it's supposed to print the regular card, the ID

196
00:00:00,000 --> 00:00:00,000
card, the calling card, and the driver's license.

197
00:00:00,000 --> 00:00:00,000
So the problem is it only prints-- it doesn't print the right thing-- and it leaks memory.

198
00:00:00,000 --> 00:00:00,000
So we're going to do make check or make grind to see the errors.

199
00:00:00,000 --> 00:00:00,000
So let me open up a-- let me do make grind-- I'll do make check.

200
00:00:00,000 --> 00:00:00,000
And notice, number one, the output is wrong.

201
00:00:00,000 --> 00:00:00,000
Compare that to this.

202
00:00:00,000 --> 00:00:00,000
This is what the output is supposed to look like.

203
00:00:00,000 --> 00:00:00,000
And secondly, look at all this memory leaks inside here.

204
00:00:00,000 --> 00:00:00,000
Memory leaks inside the program.

205
00:00:00,000 --> 00:00:00,000
So let's see what the problem is and let's see how we can fix it.

206
00:00:00,000 --> 00:00:00,000
Now the Billfold class stores pointers to objects in a vector.

207
00:00:00,000 --> 00:00:00,000
The objects themselves have been created on the heap with new, but never deleted.

208
00:00:00,000 --> 00:00:00,000
And so while the vector, all the memory that the vector uses, is destroyed when the Billfold

209
00:00:00,000 --> 00:00:00,000
is destroyed, because vector has its own destructor, the Billfold class, the objects that it creates,

210
00:00:00,000 --> 00:00:00,000
the objects that it has created, have not been destroyed.

211
00:00:00,000 --> 00:00:00,000
So any class that manages dynamic memory needs a destructor.

212
00:00:00,000 --> 00:00:00,000
Each class can have only one destructor.

213
00:00:00,000 --> 00:00:00,000
It's not overloaded.

214
00:00:00,000 --> 00:00:00,000
And the syntax is simply the same name as the default constructor with a tilde in front

215
00:00:00,000 --> 00:00:00,000
of it.

216
00:00:00,000 --> 00:00:00,000
An r destructor for the Billfold class should walk through the vector and delete each pointer.

217
00:00:00,000 --> 00:00:00,000
So let's see if we can fix the memory problems first.

218
00:00:00,000 --> 00:00:00,000
Move that down there.

219
00:00:00,000 --> 00:00:00,000
So we'll go to the Billfold H. We'll add a destructor to it.

220
00:00:00,000 --> 00:00:00,000
So tilde Billfold.

221
00:00:00,000 --> 00:00:00,000
We'll copy that to Billfold.cpp.

222
00:00:00,000 --> 00:00:00,000
We'll qualify that name.

223
00:00:00,000 --> 00:00:00,000
So there's the destructor.

224
00:00:00,000 --> 00:00:00,000
And we'll do exactly the same thing that print cards does, is we'll walk through all of the

225
00:00:00,000 --> 00:00:00,000
cards and we'll simply delete each pointer.

226
00:00:00,000 --> 00:00:00,000
OK.

227
00:00:00,000 --> 00:00:00,000
So we have added a destructor to the Billfold class to make sure that all of the dynamic

228
00:00:00,000 --> 00:00:00,000
memory that that vector contains isn't destroyed, doesn't leak.

229
00:00:00,000 --> 00:00:00,000
Let's do control L. Let's do make check again.

230
00:00:00,000 --> 00:00:00,000
We still had a lot of memory leaks inside here.

231
00:00:00,000 --> 00:00:00,000
OK.

232
00:00:00,000 --> 00:00:00,000
Look at this stuff.

233
00:00:00,000 --> 00:00:00,000
That's kind of weird.

234
00:00:00,000 --> 00:00:00,000
So it looks like it's saying that object passed to delete has the wrong time.

235
00:00:00,000 --> 00:00:00,000
The size of the allocated byte is 32 bytes.

236
00:00:00,000 --> 00:00:00,000
The size of the deallocated type is 32 bytes.

237
00:00:00,000 --> 00:00:00,000
Now look at cards.h.

238
00:00:00,000 --> 00:00:00,000
Notice that this object only has one data member.

239
00:00:00,000 --> 00:00:00,000
This object has a different one data member and this data member.

240
00:00:00,000 --> 00:00:00,000
So this one's got two.

241
00:00:00,000 --> 00:00:00,000
This one has three.

242
00:00:00,000 --> 00:00:00,000
And so each of these objects we put on the heap is actually a different size.

243
00:00:00,000 --> 00:00:00,000
So it says that somehow we're deleting the wrong kind of thing.

244
00:00:00,000 --> 00:00:00,000
Notice also one other problem.

245
00:00:00,000 --> 00:00:00,000
Still doesn't print the right thing, right?

246
00:00:00,000 --> 00:00:00,000
So let's see if we can print the right thing and let's see if that helps us to get back

247
00:00:00,000 --> 00:00:00,000
to the fact that we're still leaking some memory here because of this new delete type

248
00:00:00,000 --> 00:00:00,000
mismatch.

249
00:00:00,000 --> 00:00:00,000
The fact that we actually allocated 64 bytes in one case but only deleted 32 bytes.

250
00:00:00,000 --> 00:00:00,000
Now even though each specific card has its own print member function, it actually isn't

251
00:00:00,000 --> 00:00:00,000
being called.

252
00:00:00,000 --> 00:00:00,000
So let's go look.

253
00:00:00,000 --> 00:00:00,000
Notice when we look at cards.cpp, when we look at print for an ID card, it's supposed

254
00:00:00,000 --> 00:00:00,000
to print the ID number.

255
00:00:00,000 --> 00:00:00,000
That's not being called, obviously.

256
00:00:00,000 --> 00:00:00,000
So what would cause the functions not to be called?

257
00:00:00,000 --> 00:00:00,000
Because print isn't declared virtual in the base class card.

258
00:00:00,000 --> 00:00:00,000
So let's make print virtual.

259
00:00:00,000 --> 00:00:00,000
Let's rebuild and see if that fixes all of our problems.

260
00:00:00,000 --> 00:00:00,000
So we'll go to cards.h.

261
00:00:00,000 --> 00:00:00,000
We'll change print in card.

262
00:00:00,000 --> 00:00:00,000
Nowhere else, we'll just make it virtual here.

263
00:00:00,000 --> 00:00:00,000
We'll rebuild.

264
00:00:00,000 --> 00:00:00,000
We'll do a make check.

265
00:00:00,000 --> 00:00:00,000
Whoa, it won't even compile now.

266
00:00:00,000 --> 00:00:00,000
It won't even compile now.

267
00:00:00,000 --> 00:00:00,000
And actually it's our bill phone that won't compile now.

268
00:00:00,000 --> 00:00:00,000
So why is that case?

269
00:00:00,000 --> 00:00:00,000
Why do we have this new error?

270
00:00:00,000 --> 00:00:00,000
So think about what happens when we delete a card pointer.

271
00:00:00,000 --> 00:00:00,000
It's going to look at the heap.

272
00:00:00,000 --> 00:00:00,000
It's going to find the size of a card object and delete that amount of memory from a heap.

273
00:00:00,000 --> 00:00:00,000
So we kind of got an intimation in the last set of errors we got when it said, oh, you

274
00:00:00,000 --> 00:00:00,000
allocated 64 bytes, but you only deleted 32.

275
00:00:00,000 --> 00:00:00,000
With virtual functions, the objects on the heap may not be a card.

276
00:00:00,000 --> 00:00:00,000
We have to add a virtual destructor to classes with virtual members.

277
00:00:00,000 --> 00:00:00,000
Now in our case, the only reason we add a virtual destructor is to tell the destructor

278
00:00:00,000 --> 00:00:00,000
to actually look on the heap and see how much memory was added.

279
00:00:00,000 --> 00:00:00,000
So in the card class, we're going to add virtual tilde card.

280
00:00:00,000 --> 00:00:00,000
And then we're not even going to write anything.

281
00:00:00,000 --> 00:00:00,000
We're just going to do equals default.

282
00:00:00,000 --> 00:00:00,000
We're not going to do anything special.

283
00:00:00,000 --> 00:00:00,000
The only thing that's doing is telling the card class, when it's destroyed, to actually

284
00:00:00,000 --> 00:00:00,000
look on the heap and see what kind of card is actually there.

285
00:00:00,000 --> 00:00:00,000
OK, let's try it once more.

286
00:00:00,000 --> 00:00:00,000
I'm not quite sure what I did.

287
00:00:00,000 --> 00:00:00,000
I think I accidentally killed my code space accidentally somehow.

288
00:00:00,000 --> 00:00:00,000
So we're going to wait to see if it will start it.

289
00:00:00,000 --> 00:00:00,000
And word elitist.

290
00:00:00,000 --> 00:00:00,000
I probably pressed the wrong-- I meant to press Control-L to just clear the screen,

291
00:00:00,000 --> 00:00:00,000
but I did something else instead of that.

292
00:00:00,000 --> 00:00:00,000
I'm going to close that terminal.

293
00:00:00,000 --> 00:00:00,000
I'm not sure what happens.

294
00:00:00,000 --> 00:00:00,000
So I'm going to do Control-A again.

295
00:00:00,000 --> 00:00:00,000
I'm going to update later.

296
00:00:00,000 --> 00:00:00,000
Oh, by the way, when you get that update message and you update, make sure every time you update,

297
00:00:00,000 --> 00:00:00,000
you rerun the 150 config.py.

298
00:00:00,000 --> 00:00:00,000
Just go to the root directory, type Python, 150config.py, and enter in your information once again.

299
00:00:00,000 --> 00:00:00,000
OK, so I need to be in A. Open in an integrated terminal.

300
00:00:00,000 --> 00:00:00,000
And let's do make check once again.

301
00:00:00,000 --> 00:00:00,000
OK, notice we didn't get any memory leaks now, and it actually prints each of the correct

302
00:00:00,000 --> 00:00:00,000
values.

303
00:00:00,000 --> 00:00:00,000
All right, folks, we're going to do one more thing here.

304
00:00:00,000 --> 00:00:00,000
I want to talk about class relationships.

305
00:00:00,000 --> 00:00:00,000
And to do that, we're going to create a class called the stack.

306
00:00:00,000 --> 00:00:00,000
Now a stack is a classic data structure, or what we call an abstract data type.

307
00:00:00,000 --> 00:00:00,000
It's fundamental for many different algorithms.

308
00:00:00,000 --> 00:00:00,000
And it is a sequence, like a vector, except you can only add things at the end, or the

309
00:00:00,000 --> 00:00:00,000
top of the stack, we say.

310
00:00:00,000 --> 00:00:00,000
And you can only remove them from the top.

311
00:00:00,000 --> 00:00:00,000
So you're not allowed to look through the items inside the stack.

312
00:00:00,000 --> 00:00:00,000
There are really only four operations on this type.

313
00:00:00,000 --> 00:00:00,000
This is called push, add an item to the stack.

314
00:00:00,000 --> 00:00:00,000
Top, remove the item that's at the top of the stack.

315
00:00:00,000 --> 00:00:00,000
Top, retrieve a copy of the item that's on the top of the stack.

316
00:00:00,000 --> 00:00:00,000
And empty, see if there are any things in the stack.

317
00:00:00,000 --> 00:00:00,000
Now for this stack class, in exercise B over here, so let's close that, close that, close

318
00:00:00,000 --> 00:00:00,000
that, go to B, and let's go to stack.h.

319
00:00:00,000 --> 00:00:00,000
Let's go to RPN.

320
00:00:00,000 --> 00:00:00,000
What I've done here is I've created a program that creates a reverse Polish notation calculator.

321
00:00:00,000 --> 00:00:00,000
So normally, when we write an expression, we write an expression that looks like this.

322
00:00:00,000 --> 00:00:00,000
1 + 2 * 3.

323
00:00:00,000 --> 00:00:00,000
This is called infix notation.

324
00:00:00,000 --> 00:00:00,000
Now in reverse Polish notation, what we do is write that like this.

325
00:00:00,000 --> 00:00:00,000
1, 2, 3 * +.

326
00:00:00,000 --> 00:00:00,000
1, 2, 3 * +.

327
00:00:00,000 --> 00:00:00,000
Now the way reverse Polish notation works is that we, as we get input, we add it onto

328
00:00:00,000 --> 00:00:00,000
the top of the stack.

329
00:00:00,000 --> 00:00:00,000
If the input happens to be one of the operators, what we do is we pop the values off the stack.

330
00:00:00,000 --> 00:00:00,000
So if it's a plus or a minus or a multiply or divide, we pop the items off the stack.

331
00:00:00,000 --> 00:00:00,000
And then we add them together and put the answer back on the stack.

332
00:00:00,000 --> 00:00:00,000
So let me go open a shell for this, for B. Let me do make run.

333
00:00:00,000 --> 00:00:00,000
And notice that this calculator allows me to add in values.

334
00:00:00,000 --> 00:00:00,000
So what this expression means is multiply 2 * 4 and then add the result of that, 8,

335
00:00:00,000 --> 00:00:00,000
to 1.

336
00:00:00,000 --> 00:00:00,000
And then P will print the current value or Q will quit.

337
00:00:00,000 --> 00:00:00,000
So I'll say P and Q. And so that will print out the value 9 and quit the calculator.

338
00:00:00,000 --> 00:00:00,000
So our goal here is not to really learn how this works, but this is an interesting algorithm

339
00:00:00,000 --> 00:00:00,000
to see how a calculator works.

340
00:00:00,000 --> 00:00:00,000
Our goal is to look at this class stack.

341
00:00:00,000 --> 00:00:00,000
So we want to create this class which adds or removes things from the top of the stack.

342
00:00:00,000 --> 00:00:00,000
Now in this example, in this version, I'm going to open stack.h.

343
00:00:00,000 --> 00:00:00,000
In this version, we're using a stack from the standard library.

344
00:00:00,000 --> 00:00:00,000
So there is a header called stack and I am using this alias, this type alias, to say

345
00:00:00,000 --> 00:00:00,000
that a stack equals the standard stack.

346
00:00:00,000 --> 00:00:00,000
And so you can see that our code works.

347
00:00:00,000 --> 00:00:00,000
Our exercises today are to use different kinds of inheritance to get something so the same

348
00:00:00,000 --> 00:00:00,000
thing works.

349
00:00:00,000 --> 00:00:00,000
So we're going to comment out this and we're going to get it to work for the different

350
00:00:00,000 --> 00:00:00,000
types.

351
00:00:00,000 --> 00:00:00,000
So the starting code uses the standard library stack double.

352
00:00:00,000 --> 00:00:00,000
A type alias allows us to use the simpler name stack.

353
00:00:00,000 --> 00:00:00,000
So I won't need to change anything except what I put in the header file.

354
00:00:00,000 --> 00:00:00,000
So we're going to start with regular inheritance.

355
00:00:00,000 --> 00:00:00,000
So we're going to inherit from a vector of double.

356
00:00:00,000 --> 00:00:00,000
We're going to add inline members for push, pop, and top.

357
00:00:00,000 --> 00:00:00,000
We don't need empty because with public inheritance we inherit public.

358
00:00:00,000 --> 00:00:00,000
We inherit empty from vector.

359
00:00:00,000 --> 00:00:00,000
And then we'll call the inherited methods in the definitions of the unlined members.

360
00:00:00,000 --> 00:00:00,000
So let's look at that, how we could create this class.

361
00:00:00,000 --> 00:00:00,000
So we're going to comment that out.

362
00:00:00,000 --> 00:00:00,000
And then we're going to say class stack is a kind of public standard vector of double.

363
00:00:00,000 --> 00:00:00,000
Open brace, close brace, semicolon.

364
00:00:00,000 --> 00:00:00,000
Now in the public section we're going to add double top and cost.

365
00:00:00,000 --> 00:00:00,000
And we're simply going to return back.

366
00:00:00,000 --> 00:00:00,000
Whoever is at the back of that vector.

367
00:00:00,000 --> 00:00:00,000
Remember we are a vector.

368
00:00:00,000 --> 00:00:00,000
Void pop.

369
00:00:00,000 --> 00:00:00,000
And this is going to say pop back.

370
00:00:00,000 --> 00:00:00,000
That's the name of the function in the vector that we're using.

371
00:00:00,000 --> 00:00:00,000
And void push double n.

372
00:00:00,000 --> 00:00:00,000
We're going to say push back n.

373
00:00:00,000 --> 00:00:00,000
So here is our version of the stack where we've used inheritance just to reuse that.

374
00:00:00,000 --> 00:00:00,000
Now if that worked, we'll be able to say make run.

375
00:00:00,000 --> 00:00:00,000
And now we're no longer using the built in stack from the library.

376
00:00:00,000 --> 00:00:00,000
We're using one that we built by using the vector to do this.

377
00:00:00,000 --> 00:00:00,000
So we're going to say 1, 2, 4 times plus and then p.

378
00:00:00,000 --> 00:00:00,000
And then I'm going to do q to quit that.

379
00:00:00,000 --> 00:00:00,000
So it gives me the same thing.

380
00:00:00,000 --> 00:00:00,000
It works exactly the same.

381
00:00:00,000 --> 00:00:00,000
Now that works.

382
00:00:00,000 --> 00:00:00,000
But there is a major logical problem.

383
00:00:00,000 --> 00:00:00,000
Because the stack can use all of the vector methods, that means it can access other elements

384
00:00:00,000 --> 00:00:00,000
beside the top.

385
00:00:00,000 --> 00:00:00,000
And it can change the contents of the stack.

386
00:00:00,000 --> 00:00:00,000
So imagine that if you were writing a gambling application and you wanted to use a stack

387
00:00:00,000 --> 00:00:00,000
because you know it promises it can only access the card that's on top.

388
00:00:00,000 --> 00:00:00,000
Check what happens if someone would use your stack here that you just wrote.

389
00:00:00,000 --> 00:00:00,000
It would allow people to cheat.

390
00:00:00,000 --> 00:00:00,000
That means that we are really violating the contract of the stack interface.

391
00:00:00,000 --> 00:00:00,000
The stack interface guarantees that you can only push, pop, top, and empty.

392
00:00:00,000 --> 00:00:00,000
That you can't do anything else to it.

393
00:00:00,000 --> 00:00:00,000
So really in this case, using public inheritance, it says that a stack is a vector.

394
00:00:00,000 --> 00:00:00,000
And a stack is not really a vector.

395
00:00:00,000 --> 00:00:00,000
A stack can do some of the things that a vector can do.

396
00:00:00,000 --> 00:00:00,000
It's like a vector, but it's not a vector.

397
00:00:00,000 --> 00:00:00,000
The vector can do more than a stack can.

398
00:00:00,000 --> 00:00:00,000
So public inheritance is really inappropriate to use in this situation.

399
00:00:00,000 --> 00:00:00,000
So let's try another one.

400
00:00:00,000 --> 00:00:00,000
We'll try composition or layering.

401
00:00:00,000 --> 00:00:00,000
Instead of inheriting from vector, what we're going to do is add a private vector data member.

402
00:00:00,000 --> 00:00:00,000
Add the inline members.

403
00:00:00,000 --> 00:00:00,000
Now again, because we're not using public inheritance, there is no inherited methods.

404
00:00:00,000 --> 00:00:00,000
So we'll have to add inline member functions for push, pop, top, and empty.

405
00:00:00,000 --> 00:00:00,000
And then we'll forward all the requests to that embedded member.

406
00:00:00,000 --> 00:00:00,000
So let's go ahead and let's copy this right here.

407
00:00:00,000 --> 00:00:00,000
Put it down in stack.

408
00:00:00,000 --> 00:00:00,000
Comment out the one we had up here under exercise one, so it won't interfere with what we're

409
00:00:00,000 --> 00:00:00,000
doing now.

410
00:00:00,000 --> 00:00:00,000
We're going to get rid of this inheritance part.

411
00:00:00,000 --> 00:00:00,000
We're going to add a data member, so private standard vector double v.

412
00:00:00,000 --> 00:00:00,000
And now for these functions, we're going to call that data member vback, vpopback, vpushback.

413
00:00:00,000 --> 00:00:00,000
We'll have to add empty there.

414
00:00:00,000 --> 00:00:00,000
Empty const return vempty.

415
00:00:00,000 --> 00:00:00,000
And we may also need size here.

416
00:00:00,000 --> 00:00:00,000
Let's see if we do need size.

417
00:00:00,000 --> 00:00:00,000
Let's do matron.

418
00:00:00,000 --> 00:00:00,000
Yeah, it needs size.

419
00:00:00,000 --> 00:00:00,000
So size p size const return vsize.

420
00:00:00,000 --> 00:00:00,000
Ok, so again we can do 1, 2, 4 times plus p and it gives us 9q and it quits.

421
00:00:00,000 --> 00:00:00,000
So this kind of class is called an adapter class.

422
00:00:00,000 --> 00:00:00,000
That's because what it does is it adapts the interface or changes the interface of one

423
00:00:00,000 --> 00:00:00,000
class to another class.

424
00:00:00,000 --> 00:00:00,000
And this use of composition is known as layering, where we're not really using all of the features

425
00:00:00,000 --> 00:00:00,000
of the vector, we're just picking out some of those features.

426
00:00:00,000 --> 00:00:00,000
And so it's slightly different than a hasa or a whole part, where we're letting the part

427
00:00:00,000 --> 00:00:00,000
do all of the work.

428
00:00:00,000 --> 00:00:00,000
Now with private inheritance, the derived class inherits the implementation but not

429
00:00:00,000 --> 00:00:00,000
the interface.

430
00:00:00,000 --> 00:00:00,000
We say that private inheritance is an implemented with relationship.

431
00:00:00,000 --> 00:00:00,000
So let's go ahead and try that third one here.

432
00:00:00,000 --> 00:00:00,000
We're going to grab this.

433
00:00:00,000 --> 00:00:00,000
I'm going to copy it down here and we're going to comment out exercise 2.

434
00:00:00,000 --> 00:00:00,000
And here we're going to say our class inherits privately from standard vector double.

435
00:00:00,000 --> 00:00:00,000
So now we no longer have this data member inside here.

436
00:00:00,000 --> 00:00:00,000
We no longer have this data member inside here.

437
00:00:00,000 --> 00:00:00,000
And we would simply say top is returned back.

438
00:00:00,000 --> 00:00:00,000
We don't need those two because they are inherited.

439
00:00:00,000 --> 00:00:00,000
The problem is if we try and compile this now, if we try and compile it now, if I do

440
00:00:00,000 --> 00:00:00,000
make, it'll tell me I'm sorry, those functions are inaccessible inside here.

441
00:00:00,000 --> 00:00:00,000
And so what we need to do is we need to selectively import the base class interface.

442
00:00:00,000 --> 00:00:00,000
In other words, unlike public inheritance, it's not entirely included.

443
00:00:00,000 --> 00:00:00,000
And so all of the member functions we call, we need to add this using vector pushback.

444
00:00:00,000 --> 00:00:00,000
Using vector back.

445
00:00:00,000 --> 00:00:00,000
Using vector popback.

446
00:00:00,000 --> 00:00:00,000
So anything that we use inside here, we have to, anything we use as part of our implementation,

447
00:00:00,000 --> 00:00:00,000
we have to bring in as part of the interface.

448
00:00:00,000 --> 00:00:00,000
So this is used much less because it's a little bit more complex.

449
00:00:00,000 --> 00:00:00,000
So 1, 2, 4 times plus P, we get our 9, Q, we get our quit.

450
00:00:00,000 --> 00:00:00,000
Because this is a little bit more complex using private inheritance than using composition

451
00:00:00,000 --> 00:00:00,000
or layering, composition or layering is probably preferred.

452
00:00:00,000 --> 00:00:00,000
Notice with private inheritance, this prevents, unlike unwanted members being called, unlike

453
00:00:00,000 --> 00:00:00,000
ISA, when we use public inheritance, unwanted members could be called.

454
00:00:00,000 --> 00:00:00,000
They can't be called now with this stat class.

455
00:00:00,000 --> 00:00:00,000
You can't automatically change the function names, which would be nice.

456
00:00:00,000 --> 00:00:00,000
You must use inline delegated functions, just like layering.

457
00:00:00,000 --> 00:00:00,000
And since we have to do the same thing we had to do with layering, in other words, add

458
00:00:00,000 --> 00:00:00,000
these delegating functions here, and we have to import the interface as well, it's generally

459
00:00:00,000 --> 00:00:00,000
easier just to use layering.

460
00:00:00,000 --> 00:00:00,000
I think that's easier.

461
00:00:00,000 --> 00:00:00,000
So what do these features mean?

462
00:00:00,000 --> 00:00:00,000
So public inheritance means ISA.

463
00:00:00,000 --> 00:00:00,000
If a class D publicly inherits from B, every object of type D is also an object of type

464
00:00:00,000 --> 00:00:00,000
B, but not vice versa.

465
00:00:00,000 --> 00:00:00,000
So an ostrich is a bird, but not every bird is an ostrich.

466
00:00:00,000 --> 00:00:00,000
Private inheritance does not mean ISA.

467
00:00:00,000 --> 00:00:00,000
Public inheritance means substitutability.

468
00:00:00,000 --> 00:00:00,000
I can pass a, I can assign a, the address of an ostrich to a bird pointer.

469
00:00:00,000 --> 00:00:00,000
Private inheritance means implemented with.

470
00:00:00,000 --> 00:00:00,000
There is no substitutability.

471
00:00:00,000 --> 00:00:00,000
There is no conceptual relationship between the classes.

472
00:00:00,000 --> 00:00:00,000
It simply means I want to use the implementation of the base class in my derived class.

473
00:00:00,000 --> 00:00:00,000
And composition is either a has a relationship or an implemented with relationship.

474
00:00:00,000 --> 00:00:00,000
You can use it as a whole part where something has a specific part that does its work, or

475
00:00:00,000 --> 00:00:00,000
you can use it for layering, like we've done here, where we've just used the vector to

476
00:00:00,000 --> 00:00:00,000
implement the part we needed.

477
00:00:00,000 --> 00:00:00,000
I have one other topic I want to talk about.

478
00:00:00,000 --> 00:00:00,000
This is back to our pet class.

479
00:00:00,000 --> 00:00:00,000
My pet hierarchy has a problem.

480
00:00:00,000 --> 00:00:00,000
My generic pet says, what's my motivation?

481
00:00:00,000 --> 00:00:00,000
But generic pets really can't speak.

482
00:00:00,000 --> 00:00:00,000
They don't have mouths, for instance, right?

483
00:00:00,000 --> 00:00:00,000
My pet could be a plant.

484
00:00:00,000 --> 00:00:00,000
But I can't remove the speak member function because then I'd lose the ability to call

485
00:00:00,000 --> 00:00:00,000
speak polymorphically, which is what I want.

486
00:00:00,000 --> 00:00:00,000
And so the solution is to create an abstract function.

487
00:00:00,000 --> 00:00:00,000
In Java, you do this using the keyword abstract.

488
00:00:00,000 --> 00:00:00,000
In C++ terminology, even though this is generically known as an abstract function, it's called

489
00:00:00,000 --> 00:00:00,000
a pure virtual function.

490
00:00:00,000 --> 00:00:00,000
The syntax looks like this.

491
00:00:00,000 --> 00:00:00,000
It must be virtual.

492
00:00:00,000 --> 00:00:00,000
And then it must be assigned a value zero.

493
00:00:00,000 --> 00:00:00,000
This is simply kind of saying, if you think of it logically, that this function is not

494
00:00:00,000 --> 00:00:00,000
going to have an implementation.

495
00:00:00,000 --> 00:00:00,000
All we're keeping is the prototype.

496
00:00:00,000 --> 00:00:00,000
Now once you have done this, the class that contains a pure virtual function or an abstract

497
00:00:00,000 --> 00:00:00,000
function becomes an abstract base class, what we call an ABC.

498
00:00:00,000 --> 00:00:00,000
If you have an abstract base class, you cannot instantiate from it.

499
00:00:00,000 --> 00:00:00,000
You can only inherit from it.

500
00:00:00,000 --> 00:00:00,000
And the classes that you derive from it are called concrete classes.

501
00:00:00,000 --> 00:00:00,000
And they are required to implement that function.

502
00:00:00,000 --> 00:00:00,000
So let's look at our last example here in our IDE in pet4.

503
00:00:00,000 --> 00:00:00,000
So you notice now in pets.h, I have my virtual functions like I had before.

504
00:00:00,000 --> 00:00:00,000
I have my class cat.

505
00:00:00,000 --> 00:00:00,000
But the speak function is turned into an abstract function or a pure virtual function.

506
00:00:00,000 --> 00:00:00,000
That means that I could not create a pet object.

507
00:00:00,000 --> 00:00:00,000
And it means that any classes I created like elephant would be required to add the speak

508
00:00:00,000 --> 00:00:00,000
function.

509
00:00:00,000 --> 00:00:00,000
So in my client over here, notice if I try and compile this, let's kill that, let's open

510
00:00:00,000 --> 00:00:00,000
up pets4.

511
00:00:00,000 --> 00:00:00,000
If I try and compile this, I'm not sure why I have a syntax error here.

512
00:00:00,000 --> 00:00:00,000
The x and z is called client.

513
00:00:00,000 --> 00:00:00,000
I see.

514
00:00:00,000 --> 00:00:00,000
Actually let me go ahead and kill this make file.

515
00:00:00,000 --> 00:00:00,000
Hopefully by the time you get it, it will be fixed.

516
00:00:00,000 --> 00:00:00,000
Let me delete that make file.

517
00:00:00,000 --> 00:00:00,000
Let me get the make file from pet3.

518
00:00:00,000 --> 00:00:00,000
Move it to pet4.

519
00:00:00,000 --> 00:00:00,000
And I'm missing the .o in the pet4 one, the one I had before.

520
00:00:00,000 --> 00:00:00,000
So let's do make on this.

521
00:00:00,000 --> 00:00:00,000
So in pet4, I'm trying to build this program.

522
00:00:00,000 --> 00:00:00,000
I'm going to do make.

523
00:00:00,000 --> 00:00:00,000
And it says I cannot create this elephant.

524
00:00:00,000 --> 00:00:00,000
That's because the elephant is an abstract type.

525
00:00:00,000 --> 00:00:00,000
Why is it an abstract?

526
00:00:00,000 --> 00:00:00,000
Because the following virtual functions are pure within elephant.

527
00:00:00,000 --> 00:00:00,000
Virtual void pet speak.

528
00:00:00,000 --> 00:00:00,000
So I cannot create that elephant.

529
00:00:00,000 --> 00:00:00,000
I could not create the pet.

530
00:00:00,000 --> 00:00:00,000
Let's do that, try that and do make again.

531
00:00:00,000 --> 00:00:00,000
Cannot declare variable p to be of abstract type pet.

532
00:00:00,000 --> 00:00:00,000
So if the child class, the derived class does not implement the pure virtual function, then

533
00:00:00,000 --> 00:00:00,000
it will not compile.

534
00:00:00,000 --> 00:00:00,000
You also cannot instantiate a pure virtual, an abstract class.

535
00:00:00,000 --> 00:00:00,000
The only thing you can do with it is you can derive from it.

536
00:00:00,000 --> 00:00:00,000
So let's do make run.

537
00:00:00,000 --> 00:00:00,000
And notice now this works perfectly fine.

538
00:00:00,000 --> 00:00:00,000
The cats and dogs can speak, but the pet can no longer speak.

539
00:00:00,000 --> 00:00:00,000
And this works polymorphically.

540
00:00:00,000 --> 00:00:00,000
These are polymorphic member functions.

541
00:00:00,000 --> 00:00:00,000
Okay, so what's the upshot from this last thing?

542
00:00:00,000 --> 00:00:00,000
A regular virtual function means the children inherit the interface plus a default implementation.

543
00:00:00,000 --> 00:00:00,000
The child may change it, but it's not required to change it.

544
00:00:00,000 --> 00:00:00,000
A non-virtual function means that the children inherit the interface plus a mandatory implementation.

545
00:00:00,000 --> 00:00:00,000
The child or the derived class cannot override it.

546
00:00:00,000 --> 00:00:00,000
It can replace it, but it really shouldn't do that.

547
00:00:00,000 --> 00:00:00,000
It creates what are called schizophrenic classes.

548
00:00:00,000 --> 00:00:00,000
Finally, if we have a pure virtual function, it means the parent is declaring that the

549
00:00:00,000 --> 00:00:00,000
child must override it.

550
00:00:00,000 --> 00:00:00,000
It's a mandatory override for the derived class.

551
00:00:00,000 --> 00:00:00,000
Alright folks, that's everything for this semester.

552
00:00:00,000 --> 00:00:00,000
I'll see you online, or I'll see you in class.

553
00:00:00,000 --> 00:00:00,000
Bye bye.

554
00:00:00,000 --> 00:00:00,000
Bye.

