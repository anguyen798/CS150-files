1
00:00:00,000 --> 00:00:00,000
Hello everyone, this is Steve Gilbert. Welcome to lecture 11, where we're going to talk about streams and filters.

2
00:00:00,000 --> 00:00:00,000
So what is a stream? A stream is an abstract data flow. So data comes into your program from something called a source.

3
00:00:00,000 --> 00:00:00,000
So that may be your keyboard, you may read data from a file, it may be a satellite if your program is reading data from a GPS satellite,

4
00:00:00,000 --> 00:00:00,000
it may be a little sensor on the brakes of your car or somewhere in the engine of your car.

5
00:00:00,000 --> 00:00:00,000
The data flows from that source, wherever the data comes from, and it flows into your program where your program processes the data.

6
00:00:00,000 --> 00:00:00,000
When your program is done processing the data, then it sends it out of your program to some kind of sync.

7
00:00:00,000 --> 00:00:00,000
Now that again may be your screen, it may be a printer, it may be an internet connection somewhere out on the internet,

8
00:00:00,000 --> 00:00:00,000
it may be a little light or a dial on the dashboard of your car, it may be some numbers that appear in your GPS machine.

9
00:00:00,000 --> 00:00:00,000
So the sync is where the data appears, the output appears. So you notice this is the input/output processing cycle that we've done from the very beginning.

10
00:00:00,000 --> 00:00:00,000
Now sending information to a sync is called writing to the sync, and getting information from a source is called reading from a source.

11
00:00:00,000 --> 00:00:00,000
So how do we do that in the C++ program? Well, your operating system, not C++, but your operating system has three global stream objects.

12
00:00:00,000 --> 00:00:00,000
These are called standard in, standard out, and standard error, where the error messages are sent.

13
00:00:00,000 --> 00:00:00,000
Now C++ has specialized classes which interact with these global stream objects.

14
00:00:00,000 --> 00:00:00,000
And these classes know how to do input, in other words read, and how to do output, in other words write.

15
00:00:00,000 --> 00:00:00,000
And those two classes in the header file Iostream are called Istream, which are objects that know how to read information.

16
00:00:00,000 --> 00:00:00,000
In Java this class is generally called InputStream.

17
00:00:00,000 --> 00:00:00,000
And Ostream, objects which know how to write information.

18
00:00:00,000 --> 00:00:00,000
Now, as you remember from Java, a class is a blueprint for creating objects. And the objects are what actually do the work in your program.

19
00:00:00,000 --> 00:00:00,000
So we can't do anything with Istream or Ostream, we need to create some objects.

20
00:00:00,000 --> 00:00:00,000
And C++ will automatically create several global stream objects every time you run a program.

21
00:00:00,000 --> 00:00:00,000
So cin is the type of Istream, it's the input object, and it wraps or connects to the operating system object called standard in.

22
00:00:00,000 --> 00:00:00,000
cout is the output object, and it wraps standard out, and cerror wraps standard error.

23
00:00:00,000 --> 00:00:00,000
So these three objects, cin, cout, and cerror, are automatically created for you whenever you include Iostream.h.

24
00:00:00,000 --> 00:00:00,000
You don't need to do anything else to create them.

25
00:00:00,000 --> 00:00:00,000
Now, these are objects, cin and cout and cerror, of course, are all objects so they have member functions, or methods as we call them in Java.

26
00:00:00,000 --> 00:00:00,000
And so the get member function reads a single character from standard in.

27
00:00:00,000 --> 00:00:00,000
The put member function writes a single character to standard out.

28
00:00:00,000 --> 00:00:00,000
And if we use cerrorput, we'll write a single character to standard error.

29
00:00:00,000 --> 00:00:00,000
So you notice I'm using the object and telling it to put the character, or asking it to get the character.

30
00:00:00,000 --> 00:00:00,000
Notice we use the input object cin to get the characters, and cout or cerror to put the characters.

31
00:00:00,000 --> 00:00:00,000
Now, using these single member functions is much more efficient than using the insertion or extraction operators,

32
00:00:00,000 --> 00:00:00,000
the little arrow arrow that we've been using so far, because they don't have to, these methods just read raw characters.

33
00:00:00,000 --> 00:00:00,000
They don't have to convert, and so much, much more efficient, much, much faster.

34
00:00:00,000 --> 00:00:00,000
So to use these to read more than a single character, what we do is we use a loop.

35
00:00:00,000 --> 00:00:00,000
And this kind of loop is called a data loop.

36
00:00:00,000 --> 00:00:00,000
And so we create a character object, we pass that character object to cin get.

37
00:00:00,000 --> 00:00:00,000
When cin get fails, then this loop will end, and each time we get a character, we print it out.

38
00:00:00,000 --> 00:00:00,000
So this kind of loop, a data loop, is a loop that stops processing, stops running, when there's no more data to process.

39
00:00:00,000 --> 00:00:00,000
Now let's look at those two member functions.

40
00:00:00,000 --> 00:00:00,000
So both the get and put member functions return the stream that they're used to call them on.

41
00:00:00,000 --> 00:00:00,000
That means that stream is modified.

42
00:00:00,000 --> 00:00:00,000
So when we read a stream with get, it takes in this character, reads the character, and returns the stream after it's read the character,

43
00:00:00,000 --> 00:00:00,000
returns the input stream.

44
00:00:00,000 --> 00:00:00,000
Now, the character c is an output parameter.

45
00:00:00,000 --> 00:00:00,000
That means we must pass it a variable.

46
00:00:00,000 --> 00:00:00,000
And we can use this stream that we get back to check to see if there's more data.

47
00:00:00,000 --> 00:00:00,000
And so this is the basic input data loop.

48
00:00:00,000 --> 00:00:00,000
While cin get ch, process whatever we got.

49
00:00:00,000 --> 00:00:00,000
To write a character, we use the put member function.

50
00:00:00,000 --> 00:00:00,000
This also returns a stream that was written, in other words, c out or c error.

51
00:00:00,000 --> 00:00:00,000
But notice that the argument is slightly different.

52
00:00:00,000 --> 00:00:00,000
Up here we add a character by reference, an output parameter, which must be a variable.

53
00:00:00,000 --> 00:00:00,000
Here we have an input or value parameter.

54
00:00:00,000 --> 00:00:00,000
That means it's convertible.

55
00:00:00,000 --> 00:00:00,000
That means I can call put with not only a character, like a, and print out a,

56
00:00:00,000 --> 00:00:00,000
I can call it with a number, and that number will be converted to a character.

57
00:00:00,000 --> 00:00:00,000
In this case, this number is just going to represent the ASCII character.

58
00:00:00,000 --> 00:00:00,000
So this will also print out an a.

59
00:00:00,000 --> 00:00:00,000
OK, so let's put those to work. That seems kind of theoretical.

60
00:00:00,000 --> 00:00:00,000
We're going to write what's called the basic text echo filter program.

61
00:00:00,000 --> 00:00:00,000
And the basic echo text filter program is simply this.

62
00:00:00,000 --> 00:00:00,000
I've already showed it to you.

63
00:00:00,000 --> 00:00:00,000
Create a character.

64
00:00:00,000 --> 00:00:00,000
While cin get ch, c output ch.

65
00:00:00,000 --> 00:00:00,000
So this reads a character and it stores it in the variable ch,

66
00:00:00,000 --> 00:00:00,000
and then it prints it to the output.

67
00:00:00,000 --> 00:00:00,000
And this, the cin get ch, returns a stream, which is false when there is no more data.

68
00:00:00,000 --> 00:00:00,000
So let's flip over to our exercises here.

69
00:00:00,000 --> 00:00:00,000
So again, make sure you're in week three.

70
00:00:00,000 --> 00:00:00,000
Make sure you have gone to the streams and filters lecture exercise.

71
00:00:00,000 --> 00:00:00,000
Make sure you've gone to lecture 11.

72
00:00:00,000 --> 00:00:00,000
Of course, if you're watching this, you have already.

73
00:00:00,000 --> 00:00:00,000
And make sure you've started the lecture 11 exercise.

74
00:00:00,000 --> 00:00:00,000
And we'll look at this data loop.

75
00:00:00,000 --> 00:00:00,000
So let's get IC11.

76
00:00:00,000 --> 00:00:00,000
Let's right click on this folder A

77
00:00:00,000 --> 00:00:00,000
and open a terminal there.

78
00:00:00,000 --> 00:00:00,000
So there I have a terminal.

79
00:00:00,000 --> 00:00:00,000
And let's open up this ceco.cpp.

80
00:00:00,000 --> 00:00:00,000
So open it up. Here's our basic data loop.

81
00:00:00,000 --> 00:00:00,000
And let's just do make run.

82
00:00:00,000 --> 00:00:00,000
So notice the program doesn't appear to be doing anything.

83
00:00:00,000 --> 00:00:00,000
It's just sitting there.

84
00:00:00,000 --> 00:00:00,000
And what it's doing is it's waiting for a character from input.

85
00:00:00,000 --> 00:00:00,000
So let's type a character, A.

86
00:00:00,000 --> 00:00:00,000
That didn't seem to do anything, right?

87
00:00:00,000 --> 00:00:00,000
B, C, D, E, F.

88
00:00:00,000 --> 00:00:00,000
So when C++ asks for a character,

89
00:00:00,000 --> 00:00:00,000
what it does is it turns over the request to a program that is at the source.

90
00:00:00,000 --> 00:00:00,000
In our case, since standard in is reading from the keyboard,

91
00:00:00,000 --> 00:00:00,000
that's called the keyboard driver or the terminal driver.

92
00:00:00,000 --> 00:00:00,000
And so the terminal driver gets a request.

93
00:00:00,000 --> 00:00:00,000
And what it does is it allows you to type in different characters, edit them.

94
00:00:00,000 --> 00:00:00,000
And only sends the programs to your program when you hit the enter key.

95
00:00:00,000 --> 00:00:00,000
So I'm hitting the enter key. This is called buffered input.

96
00:00:00,000 --> 00:00:00,000
I'm hitting the enter key.

97
00:00:00,000 --> 00:00:00,000
And notice that it then went and read the A from input.

98
00:00:00,000 --> 00:00:00,000
It asked for input.

99
00:00:00,000 --> 00:00:00,000
Now my keyboard driver had already gotten some input from me.

100
00:00:00,000 --> 00:00:00,000
And so only when it exhausted all the input that I had sent to it

101
00:00:00,000 --> 00:00:00,000
in my one input, my one buffer, did it stop and ask for more input.

102
00:00:00,000 --> 00:00:00,000
So this is called a data loop.

103
00:00:00,000 --> 00:00:00,000
This is called a data loop.

104
00:00:00,000 --> 00:00:00,000
It stops when the input is exhausted.

105
00:00:00,000 --> 00:00:00,000
Now you might wonder why it hasn't stopped.

106
00:00:00,000 --> 00:00:00,000
It's still running.

107
00:00:00,000 --> 00:00:00,000
How do we make it stop?

108
00:00:00,000 --> 00:00:00,000
Well, at the console, there really is no running out of data.

109
00:00:00,000 --> 00:00:00,000
The keyboard driver will simply say, "Do you want to type in any more?"

110
00:00:00,000 --> 00:00:00,000
So from the console, we can simulate that out of data

111
00:00:00,000 --> 00:00:00,000
simply by holding down the control key and pressing D in Unix,

112
00:00:00,000 --> 00:00:00,000
which we're in, like that.

113
00:00:00,000 --> 00:00:00,000
And notice the program ended when it tried to get a character,

114
00:00:00,000 --> 00:00:00,000
it got the symbol, it was out of file, out of data.

115
00:00:00,000 --> 00:00:00,000
So on Windows, we would do this with Control and Z on Windows.

116
00:00:00,000 --> 00:00:00,000
Now this is not normally how we use an input file like this.

117
00:00:00,000 --> 00:00:00,000
It's not meant to be used interactively in an IPO program.

118
00:00:00,000 --> 00:00:00,000
Instead, it's meant to process data using redirection

119
00:00:00,000 --> 00:00:00,000
to open and process files.

120
00:00:00,000 --> 00:00:00,000
So the operating system facility, which connects standard in and standard out

121
00:00:00,000 --> 00:00:00,000
to different files, devices, or processes, is called redirection.

122
00:00:00,000 --> 00:00:00,000
So if we want to redirect C out, in other words,

123
00:00:00,000 --> 00:00:00,000
so the source that C out is writing to is no longer the screen,

124
00:00:00,000 --> 00:00:00,000
but something else, we use a little symbol here when we run the program.

125
00:00:00,000 --> 00:00:00,000
So this would run the program, this would redirect it to output.txt,

126
00:00:00,000 --> 00:00:00,000
this would create output.txt, erase it if it already exists,

127
00:00:00,000 --> 00:00:00,000
and anything written to C out would appear in output.txt.

128
00:00:00,000 --> 00:00:00,000
If we wanted to not erase it, and we wanted to run the program several times,

129
00:00:00,000 --> 00:00:00,000
and simply append to the output, we'd simply use a couple of different arrows.

130
00:00:00,000 --> 00:00:00,000
So two arrows instead of one arrow.

131
00:00:00,000 --> 00:00:00,000
Now don't confuse these with the arrows we use for C in or C out.

132
00:00:00,000 --> 00:00:00,000
Don't confuse them with the arrows we use for C in or C out.

133
00:00:00,000 --> 00:00:00,000
Because first, those arrows go the opposite direction.

134
00:00:00,000 --> 00:00:00,000
And secondly, this happens when you run the program, not from inside your program.

135
00:00:00,000 --> 00:00:00,000
Now we can send the output that's sent to C out in your program,

136
00:00:00,000 --> 00:00:00,000
and the output that's sent to C air to different files.

137
00:00:00,000 --> 00:00:00,000
And we do that by putting a little number before the little arrow.

138
00:00:00,000 --> 00:00:00,000
So one is called the standard out, and two is the standard air.

139
00:00:00,000 --> 00:00:00,000
So we're saying run this program, anything that goes to standard out,

140
00:00:00,000 --> 00:00:00,000
open and put the data in out.txt,

141
00:00:00,000 --> 00:00:00,000
anything that was sent to standard air, put in the air.txt.

142
00:00:00,000 --> 00:00:00,000
Now normally, when you run a program, both standard air and standard out appear on the screen.

143
00:00:00,000 --> 00:00:00,000
There's no difference to them. You can't tell which one is which.

144
00:00:00,000 --> 00:00:00,000
And if you want that same thing, but you want to combine the two and have it appear in one file,

145
00:00:00,000 --> 00:00:00,000
you have to combine the two files.

146
00:00:00,000 --> 00:00:00,000
So here I'm running the output. I'm sending all of it, or I'm running the executable.

147
00:00:00,000 --> 00:00:00,000
I'm sending all of its output to combo.txt,

148
00:00:00,000 --> 00:00:00,000
but I'm combining the error stream two on the output stream one.

149
00:00:00,000 --> 00:00:00,000
So those are combined or duped together.

150
00:00:00,000 --> 00:00:00,000
Now sometimes you might want to discard the output.

151
00:00:00,000 --> 00:00:00,000
For instance, we ran the program Doxygen,

152
00:00:00,000 --> 00:00:00,000
which produces a lot of output that isn't really useful when you're running the program.

153
00:00:00,000 --> 00:00:00,000
I would rather only see the errors.

154
00:00:00,000 --> 00:00:00,000
And you can do that by sending the output to the null device.

155
00:00:00,000 --> 00:00:00,000
Now, unlike these ones right here, which work in Windows or the Mac,

156
00:00:00,000 --> 00:00:00,000
this changes depending on the operating system.

157
00:00:00,000 --> 00:00:00,000
So this is the Unix or the Mac version.

158
00:00:00,000 --> 00:00:00,000
In Windows, instead of /dev/null,

159
00:00:00,000 --> 00:00:00,000
you would simply use nul colon.

160
00:00:00,000 --> 00:00:00,000
That's called the null device in Windows.

161
00:00:00,000 --> 00:00:00,000
But it would work exactly the same way.

162
00:00:00,000 --> 00:00:00,000
Now, what if we wanted to run the program,

163
00:00:00,000 --> 00:00:00,000
send its output, and have another program run that output,

164
00:00:00,000 --> 00:00:00,000
or eat that output, you know, read that output?

165
00:00:00,000 --> 00:00:00,000
We do this by doing exe.

166
00:00:00,000 --> 00:00:00,000
All of our output is not sent to the screen.

167
00:00:00,000 --> 00:00:00,000
It's not sent to the file.

168
00:00:00,000 --> 00:00:00,000
It's simply kept in memory until this program runs.

169
00:00:00,000 --> 00:00:00,000
And when this program runs, every piece of output,

170
00:00:00,000 --> 00:00:00,000
every CN statement inside this program,

171
00:00:00,000 --> 00:00:00,000
would consume the data that was sitting there in memory.

172
00:00:00,000 --> 00:00:00,000
This is called a pipe.

173
00:00:00,000 --> 00:00:00,000
And a combination of different programs running one program,

174
00:00:00,000 --> 00:00:00,000
sending its output as the input to the next program,

175
00:00:00,000 --> 00:00:00,000
and sending the output of that as the input to the next program,

176
00:00:00,000 --> 00:00:00,000
is called a pipeline.

177
00:00:00,000 --> 00:00:00,000
Finally, for input.

178
00:00:00,000 --> 00:00:00,000
So this would be a way to run this program,

179
00:00:00,000 --> 00:00:00,000
and then pipe its output as the input to this program.

180
00:00:00,000 --> 00:00:00,000
Or, if we want to run the program and get its input from a text file,

181
00:00:00,000 --> 00:00:00,000
we can use the input redirection with the arrows that go the other way.

182
00:00:00,000 --> 00:00:00,000
So we're going to modify our program to read aliceinwonderland.txt.

183
00:00:00,000 --> 00:00:00,000
So, let's go back and look at our code.

184
00:00:00,000 --> 00:00:00,000
So what do you suppose I need to change inside here

185
00:00:00,000 --> 00:00:00,000
to get it to read aliceinwonderland.txt?

186
00:00:00,000 --> 00:00:00,000
Well, that's kind of the magic of filter programs.

187
00:00:00,000 --> 00:00:00,000
We don't need to change anything.

188
00:00:00,000 --> 00:00:00,000
It's ready to run aliceinwonderland.txt.

189
00:00:00,000 --> 00:00:00,000
All we have to do is change our make file and tell it.

190
00:00:00,000 --> 00:00:00,000
So when we do make run, it runs from the keyboard.

191
00:00:00,000 --> 00:00:00,000
If we want to do make read alice,

192
00:00:00,000 --> 00:00:00,000
we run the program and we tell it,

193
00:00:00,000 --> 00:00:00,000
"I want you to get your input from alice.txt."

194
00:00:00,000 --> 00:00:00,000
Get your input from alice.txt.

195
00:00:00,000 --> 00:00:00,000
Now notice we have not changed our program, CECO, at all.

196
00:00:00,000 --> 00:00:00,000
All we've done is change how we're running the program.

197
00:00:00,000 --> 00:00:00,000
So let's come over here.

198
00:00:00,000 --> 00:00:00,000
Let's do make read alice, our pseudo target,

199
00:00:00,000 --> 00:00:00,000
and now it's going to run exactly the same code that we ran here.

200
00:00:00,000 --> 00:00:00,000
No change to our code, but it's going to get its input

201
00:00:00,000 --> 00:00:00,000
when we run it from aliceinwonderland.txt.

202
00:00:00,000 --> 00:00:00,000
And so there is the whole text of aliceinwonderland

203
00:00:00,000 --> 00:00:00,000
printed to the screen, character by character.

204
00:00:00,000 --> 00:00:00,000
We read each line one piece at a time and printed it.

205
00:00:00,000 --> 00:00:00,000
Okay, now that's somewhat useful, right?

206
00:00:00,000 --> 00:00:00,000
It's like the type program in Windows

207
00:00:00,000 --> 00:00:00,000
or the cat program in Unix.

208
00:00:00,000 --> 00:00:00,000
Basically, that is what the program looks like inside.

209
00:00:00,000 --> 00:00:00,000
Now, and so basically I could do the same thing.

210
00:00:00,000 --> 00:00:00,000
Let me just show you.

211
00:00:00,000 --> 00:00:00,000
Let me clear that.

212
00:00:00,000 --> 00:00:00,000
I could simply run the program cat, which is built in,

213
00:00:00,000 --> 00:00:00,000
which looks just like our CECO program, basically.

214
00:00:00,000 --> 00:00:00,000
And I could say alice.txt,

215
00:00:00,000 --> 00:00:00,000
and we would get exactly the same output as we had before

216
00:00:00,000 --> 00:00:00,000
from our own program, right?

217
00:00:00,000 --> 00:00:00,000
So cat is a filter program.

218
00:00:00,000 --> 00:00:00,000
So let's talk about filter programs.

219
00:00:00,000 --> 00:00:00,000
So filter programs are programs that read from standard input

220
00:00:00,000 --> 00:00:00,000
and write to standard output,

221
00:00:00,000 --> 00:00:00,000
so they can be used with redirection.

222
00:00:00,000 --> 00:00:00,000
And there are two general categories of filters.

223
00:00:00,000 --> 00:00:00,000
A state filter will examine ch for changes,

224
00:00:00,000 --> 00:00:00,000
and when it sees a change, it will take some action,

225
00:00:00,000 --> 00:00:00,000
ch meaning the character as it goes by.

226
00:00:00,000 --> 00:00:00,000
A process filter will modify ch.

227
00:00:00,000 --> 00:00:00,000
So let me go ahead and just show you what I mean by that.

228
00:00:00,000 --> 00:00:00,000
I'm going to modify CECO.

229
00:00:00,000 --> 00:00:00,000
So I'm just going to say instead of printing out ch,

230
00:00:00,000 --> 00:00:00,000
I'm going to print out QUIPR.

231
00:00:00,000 --> 00:00:00,000
So I'm getting a character, I'm modifying as it goes through.

232
00:00:00,000 --> 00:00:00,000
And now I'm going to say down here,

233
00:00:00,000 --> 00:00:00,000
I'm going to say CECO,

234
00:00:00,000 --> 00:00:00,000
and I'm going to read alice.txt,

235
00:00:00,000 --> 00:00:00,000
the text from Alice in Wonderland.

236
00:00:00,000 --> 00:00:00,000
So notice we haven't changed Alice in text.

237
00:00:00,000 --> 00:00:00,000
I'm filtering the data and turning it into--

238
00:00:00,000 --> 00:00:00,000
oh, it didn't work, did it?

239
00:00:00,000 --> 00:00:00,000
Oh, I didn't build--sorry, I didn't make to echo,

240
00:00:00,000 --> 00:00:00,000
so make CECO.

241
00:00:00,000 --> 00:00:00,000
And let me do it once again.

242
00:00:00,000 --> 00:00:00,000
So now I'm doing it with Alice.txt,

243
00:00:00,000 --> 00:00:00,000
and so now notice we have created a filter.

244
00:00:00,000 --> 00:00:00,000
This is called a process filter

245
00:00:00,000 --> 00:00:00,000
that looks at each character and input

246
00:00:00,000 --> 00:00:00,000
and makes a change to it, right?

247
00:00:00,000 --> 00:00:00,000
Does something or processes or modifies that character.

248
00:00:00,000 --> 00:00:00,000
OK, instead of that, let's go ahead and look for changes.

249
00:00:00,000 --> 00:00:00,000
Now what we want to do is print the chapter headings only,

250
00:00:00,000 --> 00:00:00,000
and what we're going to look for is a new line

251
00:00:00,000 --> 00:00:00,000
followed by a capital C.

252
00:00:00,000 --> 00:00:00,000
We'll continue printing until we encounter the next new line.

253
00:00:00,000 --> 00:00:00,000
And so this is called a process filter.

254
00:00:00,000 --> 00:00:00,000
We're not doing anything with every character.

255
00:00:00,000 --> 00:00:00,000
We're only doing something when we're in a particular state,

256
00:00:00,000 --> 00:00:00,000
when we're in the printing state.

257
00:00:00,000 --> 00:00:00,000
So one of the things with state filters

258
00:00:00,000 --> 00:00:00,000
is that we will always want to--

259
00:00:00,000 --> 00:00:00,000
we will always want to have some way of maintaining the state.

260
00:00:00,000 --> 00:00:00,000
So the state we're trying to maintain

261
00:00:00,000 --> 00:00:00,000
is whether we're printing or not.

262
00:00:00,000 --> 00:00:00,000
So we'll create a variable

263
00:00:00,000 --> 00:00:00,000
and say we're never printing.

264
00:00:00,000 --> 00:00:00,000
Now whenever we read a character,

265
00:00:00,000 --> 00:00:00,000
what we'll need to decide is that are we going to start printing

266
00:00:00,000 --> 00:00:00,000
or are we not going to start printing.

267
00:00:00,000 --> 00:00:00,000
So what we're going to need to do is we're going to say

268
00:00:00,000 --> 00:00:00,000
if ch equals a capital C, printing equals true.

269
00:00:00,000 --> 00:00:00,000
And then if we're printing,

270
00:00:00,000 --> 00:00:00,000
we're going to print the character.

271
00:00:00,000 --> 00:00:00,000
And finally, if ch equals the new line,

272
00:00:00,000 --> 00:00:00,000
we're going to turn printing off.

273
00:00:00,000 --> 00:00:00,000
So notice how I'm going from printing on to printing off.

274
00:00:00,000 --> 00:00:00,000
I'm monitoring the state and only printing the characters

275
00:00:00,000 --> 00:00:00,000
under certain circumstances.

276
00:00:00,000 --> 00:00:00,000
So this is not really what we want yet, but let's try it.

277
00:00:00,000 --> 00:00:00,000
Let's do make read Alice.

278
00:00:00,000 --> 00:00:00,000
Well, it looks like there are a lot of capital C's here.

279
00:00:00,000 --> 00:00:00,000
So we really need to, in this filter,

280
00:00:00,000 --> 00:00:00,000
keep track of only capital C's that precede a new line.

281
00:00:00,000 --> 00:00:00,000
And so for that we're going to need another variable.

282
00:00:00,000 --> 00:00:00,000
So here's my char ch.

283
00:00:00,000 --> 00:00:00,000
I'm going to create a char.

284
00:00:00,000 --> 00:00:00,000
I call it prev for previous.

285
00:00:00,000 --> 00:00:00,000
I'm going to set it to a value that is not meaningful.

286
00:00:00,000 --> 00:00:00,000
I don't want a random value.

287
00:00:00,000 --> 00:00:00,000
And so we'll say if previous is the new line

288
00:00:00,000 --> 00:00:00,000
and ch is that, then printing is true.

289
00:00:00,000 --> 00:00:00,000
And of course, previous is never going to be the new line

290
00:00:00,000 --> 00:00:00,000
unless we change it.

291
00:00:00,000 --> 00:00:00,000
So at the end of every go round in the loop,

292
00:00:00,000 --> 00:00:00,000
we want to say previous equals ch.

293
00:00:00,000 --> 00:00:00,000
So this will let us look at the character before the one

294
00:00:00,000 --> 00:00:00,000
we're processing.

295
00:00:00,000 --> 00:00:00,000
OK, let's try that now.

296
00:00:00,000 --> 00:00:00,000
Make read Alice.

297
00:00:00,000 --> 00:00:00,000
Whoa, it looked like it works pretty good,

298
00:00:00,000 --> 00:00:00,000
except for one sentence right here.

299
00:00:00,000 --> 00:00:00,000
One sentence looks like it's broken.

300
00:00:00,000 --> 00:00:00,000
So that looks like it almost does what we want,

301
00:00:00,000 --> 00:00:00,000
but not quite.

302
00:00:00,000 --> 00:00:00,000
So what we'd really like to do is now, in our example,

303
00:00:00,000 --> 00:00:00,000
it looks like I need to look ahead to make sure

304
00:00:00,000 --> 00:00:00,000
I'm not only getting a C, but that the next character

305
00:00:00,000 --> 00:00:00,000
is an H.

306
00:00:00,000 --> 00:00:00,000
If it's an H, it looks like I have chapter 1, 2, 3, 4, 5, 6,

307
00:00:00,000 --> 00:00:00,000
7, 8, 9, 10, 11.

308
00:00:00,000 --> 00:00:00,000
So it looks like that filter will work OK

309
00:00:00,000 --> 00:00:00,000
for this particular program.

310
00:00:00,000 --> 00:00:00,000
And so let's talk about how we would look ahead.

311
00:00:00,000 --> 00:00:00,000
So we can look at the next character in the stream

312
00:00:00,000 --> 00:00:00,000
by calling in peak, cnpeak.

313
00:00:00,000 --> 00:00:00,000
Now notice this doesn't take any arguments.

314
00:00:00,000 --> 00:00:00,000
It doesn't take a ch like the other one did.

315
00:00:00,000 --> 00:00:00,000
Instead, it returns the character

316
00:00:00,000 --> 00:00:00,000
embedded inside an integer.

317
00:00:00,000 --> 00:00:00,000
So if the integer is OK,

318
00:00:00,000 --> 00:00:00,000
three of those four bytes will be zeros,

319
00:00:00,000 --> 00:00:00,000
and the lower byte will be the ASCII character we want.

320
00:00:00,000 --> 00:00:00,000
If we are out of data,

321
00:00:00,000 --> 00:00:00,000
it will return minus 1 in all four of those bytes.

322
00:00:00,000 --> 00:00:00,000
So notice it's an int, not a character,

323
00:00:00,000 --> 00:00:00,000
but we use it to read a character.

324
00:00:00,000 --> 00:00:00,000
We can put a character that we've read back into the stream.

325
00:00:00,000 --> 00:00:00,000
This supports at least one character,

326
00:00:00,000 --> 00:00:00,000
and we don't need to put the same character that we read back.

327
00:00:00,000 --> 00:00:00,000
So I could read a character.

328
00:00:00,000 --> 00:00:00,000
If it's uppercase, I could change the character to lowercase

329
00:00:00,000 --> 00:00:00,000
and put it back in the stream, and then try reading it again.

330
00:00:00,000 --> 00:00:00,000
I could read a digit. If the digit I read is a digit,

331
00:00:00,000 --> 00:00:00,000
I might want to push it back into the stream

332
00:00:00,000 --> 00:00:00,000
and use it to then read with formatted input

333
00:00:00,000 --> 00:00:00,000
to read a larger number from the stream.

334
00:00:00,000 --> 00:00:00,000
If you want to put back the same character,

335
00:00:00,000 --> 00:00:00,000
you can just do cn_unget, and you don't have to pass an argument.

336
00:00:00,000 --> 00:00:00,000
Finally, we might want to read and discard unwanted input.

337
00:00:00,000 --> 00:00:00,000
And so this is the method called ignore.

338
00:00:00,000 --> 00:00:00,000
You tell it the maximum number of characters you want to ignore

339
00:00:00,000 --> 00:00:00,000
and the delimiter you want to stop on.

340
00:00:00,000 --> 00:00:00,000
So this is usually when you're doing line-by-line input

341
00:00:00,000 --> 00:00:00,000
and you want to discard the rest of the line.

342
00:00:00,000 --> 00:00:00,000
The delimiter would be the new line.

343
00:00:00,000 --> 00:00:00,000
So let's go ahead and do that, and we're going to read from Alice.txt,

344
00:00:00,000 --> 00:00:00,000
and then we're going to change it so the output is toc.txt.

345
00:00:00,000 --> 00:00:00,000
So that's going to require a couple of changes.

346
00:00:00,000 --> 00:00:00,000
First, in our program, we're going to have to not only say

347
00:00:00,000 --> 00:00:00,000
is the previous the new line, and is the current character the c,

348
00:00:00,000 --> 00:00:00,000
but also and cn_peak equals a capital H.

349
00:00:00,000 --> 00:00:00,000
Then I'll put the printing down like that.

350
00:00:00,000 --> 00:00:00,000
So all three of these have to happen.

351
00:00:00,000 --> 00:00:00,000
Let's go ahead and try that now and do make read Alice.

352
00:00:00,000 --> 00:00:00,000
Ooh, that looks pretty good.

353
00:00:00,000 --> 00:00:00,000
Now, that's all we have to do, but we want to put the output in a text file.

354
00:00:00,000 --> 00:00:00,000
And so for that, we're going to need to go back to our make file.

355
00:00:00,000 --> 00:00:00,000
And I've written you a stub here for the write toc version.

356
00:00:00,000 --> 00:00:00,000
So to read, we're going to need to read from Alice.txt.

357
00:00:00,000 --> 00:00:00,000
And then we're going to write to toc.txt.

358
00:00:00,000 --> 00:00:00,000
Now, we might want to print some extra information on that,

359
00:00:00,000 --> 00:00:00,000
so I'm going to do that.

360
00:00:00,000 --> 00:00:00,000
I'm going to do tab, and I'm going to write some code out

361
00:00:00,000 --> 00:00:00,000
just by using the operating system, the echo function,

362
00:00:00,000 --> 00:00:00,000
and I'm going to pass echo Alice in Wonderland,

363
00:00:00,000 --> 00:00:00,000
and I'm going to send that to toc.txt.

364
00:00:00,000 --> 00:00:00,000
And then I'm going to print table of contents,

365
00:00:00,000 --> 00:00:00,000
and I'm going to try and print that out.

366
00:00:00,000 --> 00:00:00,000
So it's centered. I'm not quite sure if that will work.

367
00:00:00,000 --> 00:00:00,000
And I'm going to send that out to toc.txt.

368
00:00:00,000 --> 00:00:00,000
Okay, now I have a problem, because when I do this second line,

369
00:00:00,000 --> 00:00:00,000
and when I do the third line, each one is going to reopen toc.txt and erase it.

370
00:00:00,000 --> 00:00:00,000
So I really don't want that line or this line to erase my table of contents.

371
00:00:00,000 --> 00:00:00,000
I want to append to it.

372
00:00:00,000 --> 00:00:00,000
Let's do one more, and I'll simply do a dash dash like that.

373
00:00:00,000 --> 00:00:00,000
So this is our pseudo target, write toc,

374
00:00:00,000 --> 00:00:00,000
so we'd run it with make write toc.

375
00:00:00,000 --> 00:00:00,000
Of course, we could just type in these commands manually, right?

376
00:00:00,000 --> 00:00:00,000
In other words, the make file is only typing the commands for us,

377
00:00:00,000 --> 00:00:00,000
so we can type a simpler command.

378
00:00:00,000 --> 00:00:00,000
Okay, let's do make toc, make write toc, table of contents.

379
00:00:00,000 --> 00:00:00,000
It didn't do anything.

380
00:00:00,000 --> 00:00:00,000
Oh, no, that's because all the output didn't go to our screen this time.

381
00:00:00,000 --> 00:00:00,000
Instead, our output went to this file, toc.txt,

382
00:00:00,000 --> 00:00:00,000
and notice that we not only have this in here,

383
00:00:00,000 --> 00:00:00,000
we have the other lines that we wrote to it as well.

384
00:00:00,000 --> 00:00:00,000
Other lines we wrote to it as well.

385
00:00:00,000 --> 00:00:00,000
So that's it for our initial exercise on streams and filters.

386
00:00:00,000 --> 00:00:00,000
When we come back in the next lecture, lecture 12,

387
00:00:00,000 --> 00:00:00,000
we'll continue and we'll look at reading and writing files.

388
00:00:00,000 --> 00:00:00,000
See you then.

389
00:00:00,000 --> 00:00:00,000
[END]

