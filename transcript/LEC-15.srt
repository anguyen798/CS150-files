1
00:00:00,000 --> 00:00:00,000
Hello everyone, this is Steve Gilbert. Welcome to lecture 15 on user-defined data types.

2
00:00:00,000 --> 00:00:00,000
We're going to start out today by doing a little stream review.

3
00:00:00,000 --> 00:00:00,000
We're going to read a text file that contains star information.

4
00:00:00,000 --> 00:00:00,000
This is a star catalog. And so we're going to open and read the input file.

5
00:00:00,000 --> 00:00:00,000
And so we're going to look at stars.txt. Now in the input file, we'll see several different values.

6
00:00:00,000 --> 00:00:00,000
Let's just go ahead and do that right now. So we're in lecture 15 and I have opened the starcat.cpp here.

7
00:00:00,000 --> 00:00:00,000
I'm going to put my name on it. And I'm also going to open up stars.txt so I can see the data file that I'm reading.

8
00:00:00,000 --> 00:00:00,000
So you notice that I have three doubles starting each line of text.

9
00:00:00,000 --> 00:00:00,000
And those represent the location in space of that particular star.

10
00:00:00,000 --> 00:00:00,000
That number is followed by an integer, 28 here in this first case.

11
00:00:00,000 --> 00:00:00,000
This is called the Draper number. The Draper number. What it is, it's a catalog identifier.

12
00:00:00,000 --> 00:00:00,000
In a star catalog, kind of like the Dewey Decimal number you'd have on a book in the library.

13
00:00:00,000 --> 00:00:00,000
Following that, we have a third double. Let me go take a look right here.

14
00:00:00,000 --> 00:00:00,000
4.61. And this represents the magnitude or brightness of the star.

15
00:00:00,000 --> 00:00:00,000
Following that, we have another identifier, that integer 3.

16
00:00:00,000 --> 00:00:00,000
And that represents a different catalog number in a catalog called the Harvard catalog.

17
00:00:00,000 --> 00:00:00,000
So this number is called the Harvard Revised number.

18
00:00:00,000 --> 00:00:00,000
Now some stars, like this star on line 6, and this star on line 7, have a string at the end of it. Some kind of name.

19
00:00:00,000 --> 00:00:00,000
Those are what we call the name stars. If you scroll through them, you may recognize some of the stars.

20
00:00:00,000 --> 00:00:00,000
Let's see if I can find one I recognize. I don't actually recognize any of those names.

21
00:00:00,000 --> 00:00:00,000
Here's Polaris. I recognize the North star.

22
00:00:00,000 --> 00:00:00,000
Now the stars that have a name may actually have two names.

23
00:00:00,000 --> 00:00:00,000
They may have a Latin name and a common name and so forth.

24
00:00:00,000 --> 00:00:00,000
Or they may just have a common name. And if they have two names, the first name is ended with a semicolon, like that.

25
00:00:00,000 --> 00:00:00,000
So our job here today is to read the stars and print only the name stars. Print the primary name, a comma, an X and a Y in space.

26
00:00:00,000 --> 00:00:00,000
We're going to skip the Z and the magnitude.

27
00:00:00,000 --> 00:00:00,000
So let's go ahead and do that.

28
00:00:00,000 --> 00:00:00,000
So let's go to StarCat. As I mentioned, you want to put your name. And I'm going to move that over there just to kind of clear up the screen.

29
00:00:00,000 --> 00:00:00,000
So the catalog number is coming in as a string and we want to open it.

30
00:00:00,000 --> 00:00:00,000
We've included fstream here so we know how to open file streams.

31
00:00:00,000 --> 00:00:00,000
So we're going to create an input file stream. And I have stream. I'll call it in.

32
00:00:00,000 --> 00:00:00,000
And I'm going to open it with cat name.

33
00:00:00,000 --> 00:00:00,000
Now, if we can't open the file, then we want to print an error message and exit.

34
00:00:00,000 --> 00:00:00,000
So if in fail, CR cannot open cat name, capital N on cat name.

35
00:00:00,000 --> 00:00:00,000
And since this is a void function, I'm just going to return.

36
00:00:00,000 --> 00:00:00,000
Ok, now let's read the file. So basically, notice that every line has X, Y, Z, a Draper number, a magnitude, and a Harvard number.

37
00:00:00,000 --> 00:00:00,000
So that means I need to create variables for that, right?

38
00:00:00,000 --> 00:00:00,000
So I'm going to say double X, Y, Z, magnitude. Those are my four doubles.

39
00:00:00,000 --> 00:00:00,000
And Harvard and Draper. Or Draper and Harvard. Let me put them in the order they're in.

40
00:00:00,000 --> 00:00:00,000
And to read the file using streams, I just use formatted input.

41
00:00:00,000 --> 00:00:00,000
So while in X, Y, Z, Draper number's next, so make sure you don't put magnitude there.

42
00:00:00,000 --> 00:00:00,000
Then the magnitude. And then the Harvard number.

43
00:00:00,000 --> 00:00:00,000
Ok, well that's true.

44
00:00:00,000 --> 00:00:00,000
So this will process some of the file. So let's go to the top of this text file.

45
00:00:00,000 --> 00:00:00,000
So that would process that line.

46
00:00:00,000 --> 00:00:00,000
And then, when we read the next line, that would process it. That would process the next line.

47
00:00:00,000 --> 00:00:00,000
That would process this amount of data in line six.

48
00:00:00,000 --> 00:00:00,000
But when we came around again, this is what it would read for X.

49
00:00:00,000 --> 00:00:00,000
And what would happen when it tried to read that? It would stop working.

50
00:00:00,000 --> 00:00:00,000
So we have to see if there's any extra text at the end of each line.

51
00:00:00,000 --> 00:00:00,000
So after we've read the numbers off from the line, we're going to have to create a variable.

52
00:00:00,000 --> 00:00:00,000
So string line. I'll call it rest.

53
00:00:00,000 --> 00:00:00,000
So string rest and get line in rest.

54
00:00:00,000 --> 00:00:00,000
So when we finish reading this first line, we've read the three,

55
00:00:00,000 --> 00:00:00,000
there is still an invisible new line sitting out here waiting to be read.

56
00:00:00,000 --> 00:00:00,000
And we haven't displayed that yet.

57
00:00:00,000 --> 00:00:00,000
We could turn on with the editor. I'm sure there's a way to display these hidden files.

58
00:00:00,000 --> 00:00:00,000
I'm not displaying them right now.

59
00:00:00,000 --> 00:00:00,000
But there's a new line.

60
00:00:00,000 --> 00:00:00,000
And so get line reads everything up to, including the new line, to clear off to go to the next line.

61
00:00:00,000 --> 00:00:00,000
Now that's not important if we don't have a string, but if it is a string, we want to read that.

62
00:00:00,000 --> 00:00:00,000
Alpha Hertz or cath semicolon space casp beta.

63
00:00:00,000 --> 00:00:00,000
And so what we want to do now is after we've read the rest of the line, we want to see if it's if it's not empty.

64
00:00:00,000 --> 00:00:00,000
So if rest if not rest empty.

65
00:00:00,000 --> 00:00:00,000
That means I have a first name, a name one and possibly a name to possibly a name to.

66
00:00:00,000 --> 00:00:00,000
So we're going to need to use those. Actually, I'm going to use them only inside here.

67
00:00:00,000 --> 00:00:00,000
So let me move that down here.

68
00:00:00,000 --> 00:00:00,000
So because I'm only going to print the name stars, which means that I only need to print inside this if statement.

69
00:00:00,000 --> 00:00:00,000
If it's if it's not a name star, I'm not going to print it.

70
00:00:00,000 --> 00:00:00,000
So let me create a couple of variables. String name one, name two.

71
00:00:00,000 --> 00:00:00,000
Let me find out if there's a semicolon. So size T pause or auto pause equals rest.

72
00:00:00,000 --> 00:00:00,000
Find a semicolon.

73
00:00:00,000 --> 00:00:00,000
Now, two possibilities. One possibility is that it is set to string in pause.

74
00:00:00,000 --> 00:00:00,000
So if pause is equal to string colon colon and pause.

75
00:00:00,000 --> 00:00:00,000
In other words, it wasn't found. That means we have one name.

76
00:00:00,000 --> 00:00:00,000
So name one equals rest substring.

77
00:00:00,000 --> 00:00:00,000
Why? Why substring one? Because in this case where I have one, notice when I do get line, that'll be space alpha hertz.

78
00:00:00,000 --> 00:00:00,000
Right. Because there's always a space at the end of the Harvard number.

79
00:00:00,000 --> 00:00:00,000
And so name two will just be the empty string.

80
00:00:00,000 --> 00:00:00,000
If that's not the case, I have two names. So name one equals rest substring starting at position one and going up to pause.

81
00:00:00,000 --> 00:00:00,000
And name two equals rest substring starting at pause plus one.

82
00:00:00,000 --> 00:00:00,000
No, no, actually starting at pause plus two. If we started at pause plus one.

83
00:00:00,000 --> 00:00:00,000
So here's pause, right? We started at pause plus one. I'd have a space in front of the second name.

84
00:00:00,000 --> 00:00:00,000
And I don't want that. So I'm starting at pause plus two. So I only have CAS beta inside there.

85
00:00:00,000 --> 00:00:00,000
OK, so we know that this is extracted the name part of it. Now we're going to print the primary name. Name one.

86
00:00:00,000 --> 00:00:00,000
X and a Y and the magnitude.

87
00:00:00,000 --> 00:00:00,000
So I'm going to say C out. Name one. Comma space parenthesis.

88
00:00:00,000 --> 00:00:00,000
X comma space or comma space. Y.

89
00:00:00,000 --> 00:00:00,000
Right print. A comma, a space and the magnitude.

90
00:00:00,000 --> 00:00:00,000
Print a new line. We might want to bring that down to two lines.

91
00:00:00,000 --> 00:00:00,000
I don't know where you want to split it. Maybe right there.

92
00:00:00,000 --> 00:00:00,000
Maybe that'll look a little bit better.

93
00:00:00,000 --> 00:00:00,000
Now if we do make run, it'll just call our function star cat and pass in stars dot text.

94
00:00:00,000 --> 00:00:00,000
So let's just do alt L.

95
00:00:00,000 --> 00:00:00,000
Oh, you can't do alt L. This is the new version of the IDE. So we have to come over here to A, open a terminal there.

96
00:00:00,000 --> 00:00:00,000
And then let's go ahead and do make run.

97
00:00:00,000 --> 00:00:00,000
And here we have the name. We've read the entire catalog of stars. We have the name, X, Y and the magnitude of each of those stars.

98
00:00:00,000 --> 00:00:00,000
So make run just does it all. Make test tests to make sure that you've actually done it correctly.

99
00:00:00,000 --> 00:00:00,000
So if we do make test.

100
00:00:00,000 --> 00:00:00,000
Notice that it will test several different things. It looks like make test, some of them are failing.

101
00:00:00,000 --> 00:00:00,000
So if we read that. If you read O zero. Oh, it looks like we're actually getting a semicolon after our name.

102
00:00:00,000 --> 00:00:00,000
OK, for some of those stars that have two names. So we have some debugging to do on that.

103
00:00:00,000 --> 00:00:00,000
So name one, pause.

104
00:00:00,000 --> 00:00:00,000
Does this look like pause minus one?

105
00:00:00,000 --> 00:00:00,000
I think it does, because if we want to pause, we're not counting for the fact that we're starting here from one.

106
00:00:00,000 --> 00:00:00,000
So that's what testing is for, to make sure that you got all of them correct.

107
00:00:00,000 --> 00:00:00,000
And I have some inputs here that in fact should have been Polaris, but in fact was Polaris semicolon.

108
00:00:00,000 --> 00:00:00,000
Should have been Ruchba, in fact was Ruchba with a semicolon.

109
00:00:00,000 --> 00:00:00,000
Let's try it again.

110
00:00:00,000 --> 00:00:00,000
OK, so that passes all of the tests. That looks OK.

111
00:00:00,000 --> 00:00:00,000
All right, so let's go on now and get to today's topic.

112
00:00:00,000 --> 00:00:00,000
So what we have here is each line in stars.txt consists of related information, related information.

113
00:00:00,000 --> 00:00:00,000
The X and the Y and the Z about one particular star.

114
00:00:00,000 --> 00:00:00,000
And just to print out that data, variables work fine. But what if I wanted to gather up all the information about a star

115
00:00:00,000 --> 00:00:00,000
and pass it to a bunch of functions that would analyze different characteristics of those stars?

116
00:00:00,000 --> 00:00:00,000
Well, simple variables aren't flexible enough for this.

117
00:00:00,000 --> 00:00:00,000
What we need is we need a way to package up all the parts into some kind of more complex structured data of different types.

118
00:00:00,000 --> 00:00:00,000
So in computer science and in programming languages, we call such structured types records.

119
00:00:00,000 --> 00:00:00,000
And in C++, records are called structures or the keyword is struct we'll use to create them.

120
00:00:00,000 --> 00:00:00,000
So basically, it's just a collection of data where each collection represents one item of a particular user defined kind, like a star in this case.

121
00:00:00,000 --> 00:00:00,000
We say that the data is heterogeneous, meaning that we can have integers and strings and doubles all together wrapped up in one record.

122
00:00:00,000 --> 00:00:00,000
It doesn't need to be all of the same type like an array does.

123
00:00:00,000 --> 00:00:00,000
We say that it's accessible, meaning that we can directly access each of the parts.

124
00:00:00,000 --> 00:00:00,000
So here's the syntax for creating a structure definition.

125
00:00:00,000 --> 00:00:00,000
It's the keyword struct instead of class.

126
00:00:00,000 --> 00:00:00,000
The name of the struct, which we call formally a structure tag, but other than me formally telling you this, we'll just call it the structure name.

127
00:00:00,000 --> 00:00:00,000
Inside the structure, we have named members.

128
00:00:00,000 --> 00:00:00,000
So members are like variable definitions, but they're not actually variable definitions.

129
00:00:00,000 --> 00:00:00,000
They're potential variable definitions.

130
00:00:00,000 --> 00:00:00,000
So notice I've named one PID, the person ID.

131
00:00:00,000 --> 00:00:00,000
I've named one name.

132
00:00:00,000 --> 00:00:00,000
I've named one DOB.

133
00:00:00,000 --> 00:00:00,000
And notice that the structures can be the built-in types, library types, or other structured types.

134
00:00:00,000 --> 00:00:00,000
Now this might look like creating a class in Java and adding data members or adding instance variables.

135
00:00:00,000 --> 00:00:00,000
It's very, very similar.

136
00:00:00,000 --> 00:00:00,000
We don't use the keywords public or private here in front of the things like you would do in Java.

137
00:00:00,000 --> 00:00:00,000
But there's one difference that's going to trip you up.

138
00:00:00,000 --> 00:00:00,000
That difference is in C++, we always need to put a semicolon at the end of the structure definition.

139
00:00:00,000 --> 00:00:00,000
In Java you don't. In C++ you must.

140
00:00:00,000 --> 00:00:00,000
Now, structures are a new user-defined type.

141
00:00:00,000 --> 00:00:00,000
They're a definition.

142
00:00:00,000 --> 00:00:00,000
They're a definition for a type.

143
00:00:00,000 --> 00:00:00,000
They're not a definition for a variable.

144
00:00:00,000 --> 00:00:00,000
So since they're a definition for a type, we usually place that definition in a header file.

145
00:00:00,000 --> 00:00:00,000
Now there's a problem though.

146
00:00:00,000 --> 00:00:00,000
What if that header file was included twice?

147
00:00:00,000 --> 00:00:00,000
It's an error if the definition is included twice, is seen twice.

148
00:00:00,000 --> 00:00:00,000
Your code will not compile.

149
00:00:00,000 --> 00:00:00,000
And so just like we did with functions, we'll use header guards to prevent that.

150
00:00:00,000 --> 00:00:00,000
So let's go ahead and add our structure definition to stars.h.

151
00:00:00,000 --> 00:00:00,000
And this is the definition I'm going to use.

152
00:00:00,000 --> 00:00:00,000
Struct star. I'm going to put all my doubles together just like I had them in the file.

153
00:00:00,000 --> 00:00:00,000
My two integers together and my two strings.

154
00:00:00,000 --> 00:00:00,000
So all of this data will store the data about one star.

155
00:00:00,000 --> 00:00:00,000
So we're simply going to change this program.

156
00:00:00,000 --> 00:00:00,000
We're going to add the structure definition in stars.h.

157
00:00:00,000 --> 00:00:00,000
So I'm going to say struct star.

158
00:00:00,000 --> 00:00:00,000
I'm going to open and close it and put the semicolon on all at once so I don't forget it.

159
00:00:00,000 --> 00:00:00,000
I'm going to add the data members, so double, x, y, z, magnitude, int draper, Harvard,

160
00:00:00,000 --> 00:00:00,000
and standard string, name one and name two.

161
00:00:00,000 --> 00:00:00,000
So notice my header file already includes this.

162
00:00:00,000 --> 00:00:00,000
And remember in a header file we cannot use using namespace standard.

163
00:00:00,000 --> 00:00:00,000
So for a structure, if you want to use a type, just like for a prototype in header file,

164
00:00:00,000 --> 00:00:00,000
you have to fully qualify the library type.

165
00:00:00,000 --> 00:00:00,000
So there is our star structure.

166
00:00:00,000 --> 00:00:00,000
What can we do with that star structure?

167
00:00:00,000 --> 00:00:00,000
Well, what we can do is we can create variables of that type.

168
00:00:00,000 --> 00:00:00,000
So if you have a type, its purpose is to create variables.

169
00:00:00,000 --> 00:00:00,000
These are called structure variables.

170
00:00:00,000 --> 00:00:00,000
Like primitive types, such variables are uninitialized.

171
00:00:00,000 --> 00:00:00,000
So star a and b, both of them would be star objects with x, y, z, and so forth.

172
00:00:00,000 --> 00:00:00,000
But x, y, z, and all the other members would be set to random numbers.

173
00:00:00,000 --> 00:00:00,000
The two names, name one and name two, would be okay.

174
00:00:00,000 --> 00:00:00,000
They'd be the empty string.

175
00:00:00,000 --> 00:00:00,000
So you can initialize such a variable in several ways.

176
00:00:00,000 --> 00:00:00,000
One, you can give it the default value.

177
00:00:00,000 --> 00:00:00,000
So just when you create the variable, put the curly braces after it,

178
00:00:00,000 --> 00:00:00,000
and that will default initialize it.

179
00:00:00,000 --> 00:00:00,000
In other words, all the x's and y's will be zero.

180
00:00:00,000 --> 00:00:00,000
You can aggregate initialize it, meaning you supply a value for each of the data members.

181
00:00:00,000 --> 00:00:00,000
So in this case, x is .873, y is .032, z is .486, magnitude is 2.07.

182
00:00:00,000 --> 00:00:00,000
The Draper number is .358, the Harvard number is 15, name one is Rigel, name two is Beta.

183
00:00:00,000 --> 00:00:00,000
Now, notice that the order that you put the data members depends on the order that the data members are defined in the structure.

184
00:00:00,000 --> 00:00:00,000
Notice that this order is different than what we read the data in.

185
00:00:00,000 --> 00:00:00,000
Notice that we read x, y, z, then the Draper number,

186
00:00:00,000 --> 00:00:00,000
but in the structure we put the x, y, z and the magnitude all together.

187
00:00:00,000 --> 00:00:00,000
And so that's the way you have to initialize it.

188
00:00:00,000 --> 00:00:00,000
Finally, we can initialize it one third way.

189
00:00:00,000 --> 00:00:00,000
If we have another star, we can either assign to it or we can copy initialize it.

190
00:00:00,000 --> 00:00:00,000
In other words, I can create a star E and it will have the same values that star C has.

191
00:00:00,000 --> 00:00:00,000
Now, structures can contain other structures, so if we create some useful, say, utility structures,

192
00:00:00,000 --> 00:00:00,000
a point 3D that has x, y, and z, a names structure that contained a couple of names,

193
00:00:00,000 --> 00:00:00,000
and a catalog structure that contained two catalogs, we could then use these structures inside another structure.

194
00:00:00,000 --> 00:00:00,000
We could nest them and we could define our star like this.

195
00:00:00,000 --> 00:00:00,000
So, this might be a little bit more readable.

196
00:00:00,000 --> 00:00:00,000
You can see what those x, y, and z represent, the location, then the magnitude,

197
00:00:00,000 --> 00:00:00,000
then the catalog numbers, and then the names of the stars.

198
00:00:00,000 --> 00:00:00,000
So, this might be a little bit more readable.

199
00:00:00,000 --> 00:00:00,000
Now, to access the data members, we simply use the dot operator,

200
00:00:00,000 --> 00:00:00,000
very similar to what you do in Java if you had a public instance variable.

201
00:00:00,000 --> 00:00:00,000
So, if I want to access the name in the structure variable A, I just say a.name1 or a.name2.

202
00:00:00,000 --> 00:00:00,000
You can also print it out, of course. So, just the name of the structure variable,

203
00:00:00,000 --> 00:00:00,000
and then the name of the data member inside the structure variable.

204
00:00:00,000 --> 00:00:00,000
For a nested structure, you just keep adding dots.

205
00:00:00,000 --> 00:00:00,000
So, you remember I created a structure, a different star structure that had a location in it.

206
00:00:00,000 --> 00:00:00,000
So, s.location would bring back a .3D structure, and then I'd select x out of it.

207
00:00:00,000 --> 00:00:00,000
So, I'm selecting members from a structure using the dot, the member selection operator.

208
00:00:00,000 --> 00:00:00,000
You can also assign and copy entire structure variables.

209
00:00:00,000 --> 00:00:00,000
You cannot compare them. You can assign them and copy them.

210
00:00:00,000 --> 00:00:00,000
So, let's go ahead and modify our star cat to use our structure variable

211
00:00:00,000 --> 00:00:00,000
instead of the individual variables we used before.

212
00:00:00,000 --> 00:00:00,000
So, let's come back to star cat.

213
00:00:00,000 --> 00:00:00,000
First, let's come up here and say I want to include stars.h.

214
00:00:00,000 --> 00:00:00,000
Notice now my program knows about the user defined type.

215
00:00:00,000 --> 00:00:00,000
So, instead of these variables on line 21 and 22, I can create a star variable.

216
00:00:00,000 --> 00:00:00,000
So, I can say star s.

217
00:00:00,000 --> 00:00:00,000
So, I no longer have individual variables. I have them grouped together in this record.

218
00:00:00,000 --> 00:00:00,000
Now, when I read them, these parts, these members are inside the variable s.

219
00:00:00,000 --> 00:00:00,000
So, I'd say sx, sy, sz, sdraper, smagnitude, and sharper.

220
00:00:00,000 --> 00:00:00,000
Now, notice that when I do this, these are in the order that the members are defined inside the stars.txt file,

221
00:00:00,000 --> 00:00:00,000
not the order they're defined inside the structure.

222
00:00:00,000 --> 00:00:00,000
So, this extracts it from the text file and puts it in the structure.

223
00:00:00,000 --> 00:00:00,000
So, even though x, y, z, and magnitude are together, we don't read the magnitude before the draper number

224
00:00:00,000 --> 00:00:00,000
because in the text file, the draper number appears first.

225
00:00:00,000 --> 00:00:00,000
So, we're going to get the rest from the file.

226
00:00:00,000 --> 00:00:00,000
And if it's not empty, so first, notice we have a name1 and name2,

227
00:00:00,000 --> 00:00:00,000
but we want to make sure that every time we come through here,

228
00:00:00,000 --> 00:00:00,000
since I'm not reading into name1 and name2,

229
00:00:00,000 --> 00:00:00,000
every time I come through here, I reset name1 and name2.

230
00:00:00,000 --> 00:00:00,000
So, s.name1 = s.name2, and both of those are going to be equal to the empty string.

231
00:00:00,000 --> 00:00:00,000
Okay, so I no longer need this line on line 32, right there, name1 and name2.

232
00:00:00,000 --> 00:00:00,000
And so, I'm going to say if I find this semicolon, then s.name1 is that,

233
00:00:00,000 --> 00:00:00,000
and s.name1 and s.name2.

234
00:00:00,000 --> 00:00:00,000
And when I print them out, finally, I'm printing out s.name1, s.x,

235
00:00:00,000 --> 00:00:00,000
s.y, and s.magnitude.

236
00:00:00,000 --> 00:00:00,000
Okay, so let's try that out.

237
00:00:00,000 --> 00:00:00,000
And all we're going to do is do make test again.

238
00:00:00,000 --> 00:00:00,000
Okay, and we still got 100%, so in this case,

239
00:00:00,000 --> 00:00:00,000
we're not using the individual variables.

240
00:00:00,000 --> 00:00:00,000
We have encapsulated all of the variables into this single star object right here,

241
00:00:00,000 --> 00:00:00,000
this single star.

242
00:00:00,000 --> 00:00:00,000
Now, probably most of you are thinking, "Well, yeah, so what?

243
00:00:00,000 --> 00:00:00,000
That didn't seem any better."

244
00:00:00,000 --> 00:00:00,000
But now that we've encapsulated the data inside the structure,

245
00:00:00,000 --> 00:00:00,000
we can write functions that take and produce structure variables.

246
00:00:00,000 --> 00:00:00,000
And so that's our next step.

247
00:00:00,000 --> 00:00:00,000
So for our next step, what we want to do is write functions that take structures.

248
00:00:00,000 --> 00:00:00,000
Now, in the C language, where structures were developed,

249
00:00:00,000 --> 00:00:00,000
they were known as second-class types.

250
00:00:00,000 --> 00:00:00,000
That's because they don't always act the same way as the built-in types.

251
00:00:00,000 --> 00:00:00,000
The built-in types are the natives.

252
00:00:00,000 --> 00:00:00,000
The second-class types don't have all the features of the built-in types.

253
00:00:00,000 --> 00:00:00,000
So if A and B are structure variables, say stars,

254
00:00:00,000 --> 00:00:00,000
this would be illegal if A and B are structure types.

255
00:00:00,000 --> 00:00:00,000
But the built-in types get to do this.

256
00:00:00,000 --> 00:00:00,000
And so we can fix this by writing functions to supply the missing operations.

257
00:00:00,000 --> 00:00:00,000
So I could write a method called equals, and I could say if equal A, B,

258
00:00:00,000 --> 00:00:00,000
and get back true and false, and use that instead.

259
00:00:00,000 --> 00:00:00,000
So we can pass structure variables to functions.

260
00:00:00,000 --> 00:00:00,000
We can also write a function that returns a structure.

261
00:00:00,000 --> 00:00:00,000
We're going to use the same rules for variable passing as for strings.

262
00:00:00,000 --> 00:00:00,000
So structure types we're going to pass by reference or const reference.

263
00:00:00,000 --> 00:00:00,000
We'll never pass structure types by value.

264
00:00:00,000 --> 00:00:00,000
So if I wanted to write my equal function that I would use in place of this,

265
00:00:00,000 --> 00:00:00,000
that the first-class types do, I'd pass a const string ref A and a const string ref B.

266
00:00:00,000 --> 00:00:00,000
And if they were equal, I'd return true in that case.

267
00:00:00,000 --> 00:00:00,000
So we're going to do that.

268
00:00:00,000 --> 00:00:00,000
We're going to write some functions to print and read star objects.

269
00:00:00,000 --> 00:00:00,000
And so my print function is going to take the stream that I'm going to read from,

270
00:00:00,000 --> 00:00:00,000
and a write to, and a star that I'm going to display.

271
00:00:00,000 --> 00:00:00,000
And it's going to return the stream after it's done.

272
00:00:00,000 --> 00:00:00,000
And my read function is going to take the stream I'm going to read from,

273
00:00:00,000 --> 00:00:00,000
and a star by reference that I'm going to fill in when I read.

274
00:00:00,000 --> 00:00:00,000
Now, notice the functions are returning the modified stream so we can test it.

275
00:00:00,000 --> 00:00:00,000
In other words, I want to be able to do this.

276
00:00:00,000 --> 00:00:00,000
I want to say I have stream in stars.text, star.s, and I'll read in s.

277
00:00:00,000 --> 00:00:00,000
So for our next exercise, let's do in B, let's prototype and implement these two functions, print and read.

278
00:00:00,000 --> 00:00:00,000
Then we'll uncomment the first section of run and do make run.

279
00:00:00,000 --> 00:00:00,000
So let's close these.

280
00:00:00,000 --> 00:00:00,000
Let's open B.

281
00:00:00,000 --> 00:00:00,000
Let me right click it.

282
00:00:00,000 --> 00:00:00,000
Open it in the integrated terminal there.

283
00:00:00,000 --> 00:00:00,000
And we'll have stars.h and stars.cpp.

284
00:00:00,000 --> 00:00:00,000
Put your names in stars.cpp.

285
00:00:00,000 --> 00:00:00,000
And then in stars.h, notice I already have my struct star.

286
00:00:00,000 --> 00:00:00,000
I already have my struct star.

287
00:00:00,000 --> 00:00:00,000
I've included string and iostream.

288
00:00:00,000 --> 00:00:00,000
So let's just put in the prototypes for those two functions.

289
00:00:00,000 --> 00:00:00,000
So for my print function, it's an ostream ref.

290
00:00:00,000 --> 00:00:00,000
But I'm inside a header file.

291
00:00:00,000 --> 00:00:00,000
I can't use using namespace standard.

292
00:00:00,000 --> 00:00:00,000
So the compiler is not going to understand that.

293
00:00:00,000 --> 00:00:00,000
So I have to write standard colon ostream ref.

294
00:00:00,000 --> 00:00:00,000
Print is the name of the function.

295
00:00:00,000 --> 00:00:00,000
It's going to take a standard ostream ref for the output.

296
00:00:00,000 --> 00:00:00,000
And it's going to take a const star ref s for the star.

297
00:00:00,000 --> 00:00:00,000
And for our input, it's going to take a standard iostream ref.

298
00:00:00,000 --> 00:00:00,000
We're going to call the function read.

299
00:00:00,000 --> 00:00:00,000
I'm going to take an iostream ref in as my input stream.

300
00:00:00,000 --> 00:00:00,000
And this time I'm going to take a star by reference s.

301
00:00:00,000 --> 00:00:00,000
Okay, so there's my two prototypes.

302
00:00:00,000 --> 00:00:00,000
Let's copy the two prototypes.

303
00:00:00,000 --> 00:00:00,000
Let's move them over to stars.cpp.

304
00:00:00,000 --> 00:00:00,000
Let's put a body on it.

305
00:00:00,000 --> 00:00:00,000
Remove the semicolon.

306
00:00:00,000 --> 00:00:00,000
And let's return the output stream and the input stream.

307
00:00:00,000 --> 00:00:00,000
Okay, now I haven't done any reading or printing in here.

308
00:00:00,000 --> 00:00:00,000
So what do we need to do to read from output?

309
00:00:00,000 --> 00:00:00,000
Basically we need to do what we did back up in A.

310
00:00:00,000 --> 00:00:00,000
So notice I have a star here.

311
00:00:00,000 --> 00:00:00,000
Now I'm going to print it exactly like we printed it before.

312
00:00:00,000 --> 00:00:00,000
So I'm going to say out name one, comma, space.

313
00:00:00,000 --> 00:00:00,000
It's not name one, is it?

314
00:00:00,000 --> 00:00:00,000
It's s.name one.

315
00:00:00,000 --> 00:00:00,000
And s.x, a comma and a space, and s.y.

316
00:00:00,000 --> 00:00:00,000
And a closing parenthesis and a comma and a space.

317
00:00:00,000 --> 00:00:00,000
And s.magnitude.

318
00:00:00,000 --> 00:00:00,000
Now we don't want to use a new line like we did when we were printing it out ourselves.

319
00:00:00,000 --> 00:00:00,000
When you call the print function, they'll use the new line on it at that point.

320
00:00:00,000 --> 00:00:00,000
They'll use the new line on it at that point.

321
00:00:00,000 --> 00:00:00,000
Now to read the data, we have a star object here.

322
00:00:00,000 --> 00:00:00,000
I have start there, of course it should be a star.

323
00:00:00,000 --> 00:00:00,000
You can see the difference in the coloring here.

324
00:00:00,000 --> 00:00:00,000
And did I make that mistake over in the header file?

325
00:00:00,000 --> 00:00:00,000
Yeah, I did.

326
00:00:00,000 --> 00:00:00,000
So that should be a star, not a start.

327
00:00:00,000 --> 00:00:00,000
So to read, what we're going to do is we're going to say in s.x, s.y, s.z.

328
00:00:00,000 --> 00:00:00,000
Even though we're not printing z, we still need to read it.

329
00:00:00,000 --> 00:00:00,000
s.draper, s.magnitude, and s.harvard.

330
00:00:00,000 --> 00:00:00,000
We need to set the name one and name two to nothing.

331
00:00:00,000 --> 00:00:00,000
So s.name1 equals s.name2 equals the empty string.

332
00:00:00,000 --> 00:00:00,000
Then we need to put exactly the same code we had before.

333
00:00:00,000 --> 00:00:00,000
So if we need to read, we need to do git line in.

334
00:00:00,000 --> 00:00:00,000
We need to create a string, I'll call it name.

335
00:00:00,000 --> 00:00:00,000
So now if that name has something in it, we need to transfer it to our strings.

336
00:00:00,000 --> 00:00:00,000
So if not name empty, or let me write it the other way, it's probably more easier for you.

337
00:00:00,000 --> 00:00:00,000
So if name not equal to that, the name's not empty, we're going to say auto pause equals name find.

338
00:00:00,000 --> 00:00:00,000
Notice this time we used double quotes, you can use double quotes or single quotes there.

339
00:00:00,000 --> 00:00:00,000
So if pause equals equals string end pause, if it's not found, that means we only have one name.

340
00:00:00,000 --> 00:00:00,000
So if pause equals equals end pause, it means we only have one name.

341
00:00:00,000 --> 00:00:00,000
So, and I think I did this wrong in the last exercise we did in A.

342
00:00:00,000 --> 00:00:00,000
So I'm going to say s.name1 equals name substring.

343
00:00:00,000 --> 00:00:00,000
Let's put that up here so it's a little easier to read.

344
00:00:00,000 --> 00:00:00,000
And if that's not the case, name1 equals name substring1 and pause minus 1.

345
00:00:00,000 --> 00:00:00,000
Again, to count for the space at the beginning of it.

346
00:00:00,000 --> 00:00:00,000
And whenever I have two lines, I don't like to put two statements on one line.

347
00:00:00,000 --> 00:00:00,000
I only use one line here when I can fit the whole thing on the side there.

348
00:00:00,000 --> 00:00:00,000
So name2 equals name substring pause plus 2.

349
00:00:00,000 --> 00:00:00,000
And we're going to return in.

350
00:00:00,000 --> 00:00:00,000
So let's come down here and let's uncomment part 1 here.

351
00:00:00,000 --> 00:00:00,000
So notice we're opening stars.txt, we're creating a star, and we're calling the read function.

352
00:00:00,000 --> 00:00:00,000
While read in, if not name empty and s magnitude greater than 6, print cout s.

353
00:00:00,000 --> 00:00:00,000
And we're printing an end out at the end of that.

354
00:00:00,000 --> 00:00:00,000
So notice that this is, this code right here, is almost the same thing as star cat that we did in part A.

355
00:00:00,000 --> 00:00:00,000
In other words, because we have functions now, we've been able to compress it down to these two pieces.

356
00:00:00,000 --> 00:00:00,000
And so it's much easier to read, much more flexible, much easier to use.

357
00:00:00,000 --> 00:00:00,000
So let's try that. Let's do make run.

358
00:00:00,000 --> 00:00:00,000
Okay, so name1, so I have a syntax error there, and name2.

359
00:00:00,000 --> 00:00:00,000
And of course, that's because this is not name1, right?

360
00:00:00,000 --> 00:00:00,000
It's s.name1 and s.name2.

361
00:00:00,000 --> 00:00:00,000
Let me clear it and run it again.

362
00:00:00,000 --> 00:00:00,000
Okay, so these are all the stars that are named that have a magnitude greater than 6.

363
00:00:00,000 --> 00:00:00,000
So again, writing functions, you can see how easy it is to use them after you've written the function.

364
00:00:00,000 --> 00:00:00,000
And how easy it is to use it after you've written the function.

365
00:00:00,000 --> 00:00:00,000
Now, it would be nicer if we could use the regular operators for our output.

366
00:00:00,000 --> 00:00:00,000
In other words, if there was no difference between a star and printing an int, that's what we're shooting for.

367
00:00:00,000 --> 00:00:00,000
And so for any user-defined type, you can overload most of the C++ operators to work with that type.

368
00:00:00,000 --> 00:00:00,000
So we're going to be covering this many, many times in this class.

369
00:00:00,000 --> 00:00:00,000
This is your first introduction to it.

370
00:00:00,000 --> 00:00:00,000
So, plus, equals, equals, greater than, all of those are called binary operators.

371
00:00:00,000 --> 00:00:00,000
Because we have a plus b, the operator plus takes two operands, the a and the b.

372
00:00:00,000 --> 00:00:00,000
One's on the left-hand side, one's on the right-hand side.

373
00:00:00,000 --> 00:00:00,000
The same through equals, equals, greater than, and so forth.

374
00:00:00,000 --> 00:00:00,000
So the syntax is whatever the return type, so greater than returns a bool, equals, equals returns a bool.

375
00:00:00,000 --> 00:00:00,000
Plus would return whatever type this object type is.

376
00:00:00,000 --> 00:00:00,000
So it could be an int, it could be a double, it could be a star.

377
00:00:00,000 --> 00:00:00,000
And so it's the return type, say bool, the operator, and then the symbol used for the operator.

378
00:00:00,000 --> 00:00:00,000
The symbol used for the operator, so operator greater than, operator equals, equals.

379
00:00:00,000 --> 00:00:00,000
And then the two arguments that will appear on the left-hand side and the right.

380
00:00:00,000 --> 00:00:00,000
So LHS here just means the left-hand side, RHS just means the right-hand side.

381
00:00:00,000 --> 00:00:00,000
And again, we replace the question mark here with the operator symbol.

382
00:00:00,000 --> 00:00:00,000
So, suppose we wanted to compare star operators by magnitude.

383
00:00:00,000 --> 00:00:00,000
If we wanted to do that, we'd use the less than operator.

384
00:00:00,000 --> 00:00:00,000
So notice the function is named operator less than.

385
00:00:00,000 --> 00:00:00,000
Less than returns a bool, true or false.

386
00:00:00,000 --> 00:00:00,000
Would take two const stars, so const star ref LHS, const star ref RHS.

387
00:00:00,000 --> 00:00:00,000
And then would return true if the magnitude of the left-hand side was less than the magnitude on the right-hand side.

388
00:00:00,000 --> 00:00:00,000
Now, what we'd like to do now is we'd like to overload the input and output operators.

389
00:00:00,000 --> 00:00:00,000
So the output operators have this prototype.

390
00:00:00,000 --> 00:00:00,000
Now, that should look familiar to you as well as that one.

391
00:00:00,000 --> 00:00:00,000
The only difference between read and print and these operators is the name of the function.

392
00:00:00,000 --> 00:00:00,000
So, almost exactly the same signature as print and read, but with different names.

393
00:00:00,000 --> 00:00:00,000
And so we can implement those by using read and print to implement them.

394
00:00:00,000 --> 00:00:00,000
So we're going to go ahead and do that.

395
00:00:00,000 --> 00:00:00,000
We're going to complete our second exercise here by adding these two member functions,

396
00:00:00,000 --> 00:00:00,000
or these two overloaded operators to our code.

397
00:00:00,000 --> 00:00:00,000
So in stars.h, we're going to take, make a copy of these two.

398
00:00:00,000 --> 00:00:00,000
And I'm simply going to name this one operator output.

399
00:00:00,000 --> 00:00:00,000
It's an O-string.

400
00:00:00,000 --> 00:00:00,000
And this one I'm going to name operator input.

401
00:00:00,000 --> 00:00:00,000
It's an I-string.

402
00:00:00,000 --> 00:00:00,000
So notice that I used exactly the same prototype, just with a different name.

403
00:00:00,000 --> 00:00:00,000
I'm going to copy it over to stars.cpp.

404
00:00:00,000 --> 00:00:00,000
I'm going to paste them up here.

405
00:00:00,000 --> 00:00:00,000
Remove the semicolon.

406
00:00:00,000 --> 00:00:00,000
Remove the semicolon here.

407
00:00:00,000 --> 00:00:00,000
And since we've already implemented that functionality as a function, I can just say return print out s.

408
00:00:00,000 --> 00:00:00,000
And for this one I can just say return read in s.

409
00:00:00,000 --> 00:00:00,000
So I'm using these functions up here that we wrote by hand to implement our overloaded operators.

410
00:00:00,000 --> 00:00:00,000
And if you come down to run, now we can go ahead and comment out the remainder of this.

411
00:00:00,000 --> 00:00:00,000
The remainder of that. And we should be able to do make run again.

412
00:00:00,000 --> 00:00:00,000
And notice that the input and output operators work perfectly fine.

413
00:00:00,000 --> 00:00:00,000
And reading from a string works perfectly fine.

414
00:00:00,000 --> 00:00:00,000
So we can pass a string stream, you notice, for this third part.

415
00:00:00,000 --> 00:00:00,000
I've just created an I-string stream with some values in it.

416
00:00:00,000 --> 00:00:00,000
I pass it to read and it works perfectly fine.

417
00:00:00,000 --> 00:00:00,000
And the input operators, so notice for part two here, rather than saying while read in s, I'm saying while in arrow s.

418
00:00:00,000 --> 00:00:00,000
And here I'm saying cout arrow arrow s.

419
00:00:00,000 --> 00:00:00,000
So I'm using exactly the same syntax.

420
00:00:00,000 --> 00:00:00,000
So to finish this up, make sure the run part works.

421
00:00:00,000 --> 00:00:00,000
Go ahead and just do make test.

422
00:00:00,000 --> 00:00:00,000
And it will test running and looking at several different kinds of stars.

423
00:00:00,000 --> 00:00:00,000
Testing individually the output operator to make sure that it's correct.

424
00:00:00,000 --> 00:00:00,000
Testing individually the input operator.

425
00:00:00,000 --> 00:00:00,000
Again, this is what the input is. Here's one with two names.

426
00:00:00,000 --> 00:00:00,000
We test it with one name. Test it with one with no name.

427
00:00:00,000 --> 00:00:00,000
So we can test all those possibilities.

428
00:00:00,000 --> 00:00:00,000
And this is just testing read and print separately.

429
00:00:00,000 --> 00:00:00,000
So here's testing read. Here's testing print.

430
00:00:00,000 --> 00:00:00,000
Here's testing the input operator. Here's testing the output operator.

431
00:00:00,000 --> 00:00:00,000
Okay, so structured types are things like the date that you see on the right.

432
00:00:00,000 --> 00:00:00,000
It has January 3rd, 2009.

433
00:00:00,000 --> 00:00:00,000
It has a string and a couple of integers.

434
00:00:00,000 --> 00:00:00,000
So that's a structured type.

435
00:00:00,000 --> 00:00:00,000
We can also create user defined scalar types.

436
00:00:00,000 --> 00:00:00,000
Ones that have only a single value versus the structured type or the record that adds multiple values together.

437
00:00:00,000 --> 00:00:00,000
With scalar values, we can enumerate, meaning we can list or count each possible value.

438
00:00:00,000 --> 00:00:00,000
For instance, if I want to create a type that represents the weekdays,

439
00:00:00,000 --> 00:00:00,000
it's Monday, Tuesday, Wednesday, Thursday, and Friday.

440
00:00:00,000 --> 00:00:00,000
Saturday and Sunday wouldn't be one of the weekdays.

441
00:00:00,000 --> 00:00:00,000
We can write this two ways.

442
00:00:00,000 --> 00:00:00,000
In C++11, we use the words "anum" followed by "class".

443
00:00:00,000 --> 00:00:00,000
So anum, class, weekday.

444
00:00:00,000 --> 00:00:00,000
These are called scoped enumerations.

445
00:00:00,000 --> 00:00:00,000
They were introduced again in C++11.

446
00:00:00,000 --> 00:00:00,000
C++ and C, the older version of C++, that's what's called a plain enumeration.

447
00:00:00,000 --> 00:00:00,000
You generally want to use the scoped enumerations because they have less opportunities for errors.

448
00:00:00,000 --> 00:00:00,000
So let's look at defining an enumerated type.

449
00:00:00,000 --> 00:00:00,000
So an enumerated type is a set of related integer values which act like a type.

450
00:00:00,000 --> 00:00:00,000
You provide a name for each value.

451
00:00:00,000 --> 00:00:00,000
For example, the suit values for a deck of cards would include the clubs, the spades, the diamonds, and the hearts.

452
00:00:00,000 --> 00:00:00,000
Now notice the names are separated by commas.

453
00:00:00,000 --> 00:00:00,000
There's no ending semicolon. There's an ending semicolon at the end of the definition of the type.

454
00:00:00,000 --> 00:00:00,000
But there's no semicolon after the word "hearts".

455
00:00:00,000 --> 00:00:00,000
So no ending semicolon.

456
00:00:00,000 --> 00:00:00,000
You should use lowercase or propercase. Avoid using uppercase.

457
00:00:00,000 --> 00:00:00,000
Here are some of the things you can do with a scoped enumeration.

458
00:00:00,000 --> 00:00:00,000
I could create a suit variable, S, an enumerated type variable.

459
00:00:00,000 --> 00:00:00,000
I could initialize it. What would I initialize it with?

460
00:00:00,000 --> 00:00:00,000
I'd initialize it not with hearts, but with its fully qualified name, suit colon colon hearts.

461
00:00:00,000 --> 00:00:00,000
I could compare it to another enumerated type.

462
00:00:00,000 --> 00:00:00,000
I couldn't compare it to an integer, but I could compare it to suit clubs using not equals and equals.

463
00:00:00,000 --> 00:00:00,000
Now greater than and less than also kind of works, but it's not very, very useful.

464
00:00:00,000 --> 00:00:00,000
So generally we'll use equals or not equals.

465
00:00:00,000 --> 00:00:00,000
We can use that variable as a switch selector.

466
00:00:00,000 --> 00:00:00,000
So switch S, case suit clubs, return clubs. Case suit hearts, return hearts.

467
00:00:00,000 --> 00:00:00,000
So this is converting a suit type into a string type.

468
00:00:00,000 --> 00:00:00,000
If it wasn't one of the four clubs, which are the only things it could possibly be,

469
00:00:00,000 --> 00:00:00,000
would return some kind of error or have an assertion there or throw an exception, something like that.

470
00:00:00,000 --> 00:00:00,000
So why do we want to use enumerated types?

471
00:00:00,000 --> 00:00:00,000
Consider a playing card.

472
00:00:00,000 --> 00:00:00,000
A playing card has two things.

473
00:00:00,000 --> 00:00:00,000
It has a suit and a rank.

474
00:00:00,000 --> 00:00:00,000
We could represent that suit and that rank like ace, king, queen, jack is the rank,

475
00:00:00,000 --> 00:00:00,000
and diamonds, hearts, spades, and clubs are the suits.

476
00:00:00,000 --> 00:00:00,000
We could represent those by using strings or integers or something else.

477
00:00:00,000 --> 00:00:00,000
So imagine if we represented the rank and the suit using strings.

478
00:00:00,000 --> 00:00:00,000
There should be a comma between rank and suit here,

479
00:00:00,000 --> 00:00:00,000
and I will probably fix that on the slides that you'll see if you click the slides.

480
00:00:00,000 --> 00:00:00,000
Then I go and create a card object.

481
00:00:00,000 --> 00:00:00,000
And I create a card A and I pass it ace and clubs.

482
00:00:00,000 --> 00:00:00,000
Well, what's the problem?

483
00:00:00,000 --> 00:00:00,000
Well, cubs is the wrong spelling for the clubs,

484
00:00:00,000 --> 00:00:00,000
so instead of the ace of clubs, I get something that doesn't make any sense.

485
00:00:00,000 --> 00:00:00,000
In other words, my type is not very resilient.

486
00:00:00,000 --> 00:00:00,000
The compiler can't check the fact that I've passed the wrong values.

487
00:00:00,000 --> 00:00:00,000
Suppose instead I decide to make rank and suit integers.

488
00:00:00,000 --> 00:00:00,000
And then I create some constants like this, ace 101 and clubs 1001.

489
00:00:00,000 --> 00:00:00,000
So I start all the ranks at 1 and I start all the suits at 1000.

490
00:00:00,000 --> 00:00:00,000
And then I try and create a card B, clubs ace.

491
00:00:00,000 --> 00:00:00,000
Well, what's the problem?

492
00:00:00,000 --> 00:00:00,000
Again, my structure has rank and suit.

493
00:00:00,000 --> 00:00:00,000
What I've passed in is 1001 for the rank and 101 for the suit.

494
00:00:00,000 --> 00:00:00,000
Both of those are invalid values, and I would have to do some extra checking.

495
00:00:00,000 --> 00:00:00,000
Again, the compiler can't check to see that I have switched my rank and suit,

496
00:00:00,000 --> 00:00:00,000
where it's supposed to be rank suit, and I've passed in clubs.

497
00:00:00,000 --> 00:00:00,000
I've passed in suit and rank.

498
00:00:00,000 --> 00:00:00,000
Again, the compiler can't change that.

499
00:00:00,000 --> 00:00:00,000
Suppose, however, that I created an enumerated type for the rank,

500
00:00:00,000 --> 00:00:00,000
an enumerated type for the suit.

501
00:00:00,000 --> 00:00:00,000
Then I would create it like this, card rank ace, rank clubs.

502
00:00:00,000 --> 00:00:00,000
If I switch those, the compiler would tell me.

503
00:00:00,000 --> 00:00:00,000
I would know the moment I tried to compile my code, I've made a mistake.

504
00:00:00,000 --> 00:00:00,000
I would not have to ever worry about creating a card object with invalid values.

505
00:00:00,000 --> 00:00:00,000
It would be impossible.

506
00:00:00,000 --> 00:00:00,000
And so that's really why we want to use enumerated types.

507
00:00:00,000 --> 00:00:00,000
We say that we're creating strong types for our arguments and our parameters.

508
00:00:00,000 --> 00:00:00,000
Now, there is no built-in input/output with enumerated types.

509
00:00:00,000 --> 00:00:00,000
You may write a two-string function.

510
00:00:00,000 --> 00:00:00,000
You may want to convert it to a string for output with a function.

511
00:00:00,000 --> 00:00:00,000
So here's a two-string function that takes a rank.

512
00:00:00,000 --> 00:00:00,000
We'll switch on the rank, and then case rank ace, we'll return ace.

513
00:00:00,000 --> 00:00:00,000
Case rank two, we'll return two. Case rank three, we'll return three.

514
00:00:00,000 --> 00:00:00,000
So let's go ahead and do that.

515
00:00:00,000 --> 00:00:00,000
So for our exercise here with enumerated types,

516
00:00:00,000 --> 00:00:00,000
we're going to take the coin type and we're going to complete the two-string function for the coin type.

517
00:00:00,000 --> 00:00:00,000
So let me close that.

518
00:00:00,000 --> 00:00:00,000
Let me close this. Let me close this.

519
00:00:00,000 --> 00:00:00,000
Let's go down to C.

520
00:00:00,000 --> 00:00:00,000
And this will be in enumH.

521
00:00:00,000 --> 00:00:00,000
So here's our enumerated type.

522
00:00:00,000 --> 00:00:00,000
And we're going to write the two-string function.

523
00:00:00,000 --> 00:00:00,000
And let's see if we want to do the two-string and the value of function.

524
00:00:00,000 --> 00:00:00,000
So actually we're going to write two functions in this.

525
00:00:00,000 --> 00:00:00,000
And so this is in enumOps.cpp.

526
00:00:00,000 --> 00:00:00,000
So let's put your name in here.

527
00:00:00,000 --> 00:00:00,000
Notice I've included enum.h right here.

528
00:00:00,000 --> 00:00:00,000
I'm going to put my name at the top of this just to get the practice.

529
00:00:00,000 --> 00:00:00,000
So I'm going to put summer22 for this.

530
00:00:00,000 --> 00:00:00,000
Okay, let's go grab those two prototypes.

531
00:00:00,000 --> 00:00:00,000
And we'll see how we would add our implementation for that right here.

532
00:00:00,000 --> 00:00:00,000
Okay, so if I want to convert a coin object to string, I'm going to have to use a switch statement.

533
00:00:00,000 --> 00:00:00,000
So I'm going to have to say switch on C.

534
00:00:00,000 --> 00:00:00,000
Now I'm going to have to say case coin colon colon and then what the coin types are.

535
00:00:00,000 --> 00:00:00,000
So what are my coin types?

536
00:00:00,000 --> 00:00:00,000
I'll just copy them right here.

537
00:00:00,000 --> 00:00:00,000
So case coin penny colon.

538
00:00:00,000 --> 00:00:00,000
So that's the structure.

539
00:00:00,000 --> 00:00:00,000
The colon colon and the colon is kind of confusing here.

540
00:00:00,000 --> 00:00:00,000
I'm going to return penny.

541
00:00:00,000 --> 00:00:00,000
And this will be case coin dime, case coin quarter, case coin nickel.

542
00:00:00,000 --> 00:00:00,000
Let's put the colons on the end of each of those case labels.

543
00:00:00,000 --> 00:00:00,000
So here we're going to return nickel.

544
00:00:00,000 --> 00:00:00,000
Here we're going to return a dime.

545
00:00:00,000 --> 00:00:00,000
Here I'm going to return a quarter.

546
00:00:00,000 --> 00:00:00,000
And here I'm going to return half dollar.

547
00:00:00,000 --> 00:00:00,000
Okay, what if it is none of those?

548
00:00:00,000 --> 00:00:00,000
Well, technically it has to be one of those.

549
00:00:00,000 --> 00:00:00,000
I believe the code will compile without us putting a default in it.

550
00:00:00,000 --> 00:00:00,000
Let's just try it.

551
00:00:00,000 --> 00:00:00,000
Let's open up a shell on that.

552
00:00:00,000 --> 00:00:00,000
Let's just do make on it.

553
00:00:00,000 --> 00:00:00,000
Okay, value of, okay, control reaches end of non-void function.

554
00:00:00,000 --> 00:00:00,000
So it does require us to do something.

555
00:00:00,000 --> 00:00:00,000
And so what we could do here is we could just add an assert or a throw or just a return.

556
00:00:00,000 --> 00:00:00,000
Or you could add a throw statement.

557
00:00:00,000 --> 00:00:00,000
A throw would work fine.

558
00:00:00,000 --> 00:00:00,000
And we could put this, of course, inside the default.

559
00:00:00,000 --> 00:00:00,000
In which case we don't need it here.

560
00:00:00,000 --> 00:00:00,000
It's maybe a little more obvious over there that that is an error in that case.

561
00:00:00,000 --> 00:00:00,000
Okay, so now we've got a coin and we want to get its value.

562
00:00:00,000 --> 00:00:00,000
Now we could do a switch like this, case coin penny, return one.

563
00:00:00,000 --> 00:00:00,000
Case coin nickel, return two.

564
00:00:00,000 --> 00:00:00,000
But notice when I created my enumerated type,

565
00:00:00,000 --> 00:00:00,000
I provided an underlying value for each of the types that represents the type of the value.

566
00:00:00,000 --> 00:00:00,000
Now we want to return it as a double.

567
00:00:00,000 --> 00:00:00,000
And so what we're going to need to do is we're going to need to cast this to its underlying type.

568
00:00:00,000 --> 00:00:00,000
So I'm going to say static return static cast double C divided by 100.

569
00:00:00,000 --> 00:00:00,000
And this actually should be, you should cast it to an int, not a double.

570
00:00:00,000 --> 00:00:00,000
So static cast int divided by 100 will give us a double.

571
00:00:00,000 --> 00:00:00,000
And that should, in fact, pass all our tests.

572
00:00:00,000 --> 00:00:00,000
Make works, so make test.

573
00:00:00,000 --> 00:00:00,000
And to string, oh, it wanted half dollar to look slightly different, so let's fix that.

574
00:00:00,000 --> 00:00:00,000
It wants it to look like that.

575
00:00:00,000 --> 00:00:00,000
So let's say make test.

576
00:00:00,000 --> 00:00:00,000
Okay, so all of these work.

577
00:00:00,000 --> 00:00:00,000
Okay, so this was converting a type, an enumerated type to a two string,

578
00:00:00,000 --> 00:00:00,000
so we could do output on it and a value of,

579
00:00:00,000 --> 00:00:00,000
so we could use it in a calculation, a coin type rather than an integer.

580
00:00:00,000 --> 00:00:00,000
I could use it with other types.

581
00:00:00,000 --> 00:00:00,000
Okay, the last thing we want to look at today in this lecture is we want to look at I/O operators.

582
00:00:00,000 --> 00:00:00,000
So I've already seen these I/O operators for stars.

583
00:00:00,000 --> 00:00:00,000
We have const star ref.

584
00:00:00,000 --> 00:00:00,000
We can use them for any user defined types, including for enumerated types.

585
00:00:00,000 --> 00:00:00,000
So we're going to use the two string for rank and suit.

586
00:00:00,000 --> 00:00:00,000
Card, of course, is a structure in this case,

587
00:00:00,000 --> 00:00:00,000
so we can use the output operators for our cards just like we did with our stars.

588
00:00:00,000 --> 00:00:00,000
The input operator looks like this, just like the ones we used for stars.

589
00:00:00,000 --> 00:00:00,000
Our input is going to be in the form of AS for ace of spades, TH for ten of hearts,

590
00:00:00,000 --> 00:00:00,000
JC for jack of clubs, and so forth.

591
00:00:00,000 --> 00:00:00,000
So this is our last exercise. We're going to write the card I/O operators down in,

592
00:00:00,000 --> 00:00:00,000
let's close that,

593
00:00:00,000 --> 00:00:00,000
down in D.

594
00:00:00,000 --> 00:00:00,000
So let's open a shell on that.

595
00:00:00,000 --> 00:00:00,000
And let's close the previous shells.

596
00:00:00,000 --> 00:00:00,000
And so I only have one shell open on D.

597
00:00:00,000 --> 00:00:00,000
Let's open card I/O dot CVP. This is the one we're going to change.

598
00:00:00,000 --> 00:00:00,000
Cards dot H, I believe, already has our prototypes inside there.

599
00:00:00,000 --> 00:00:00,000
So we can just copy those prototypes, that's what we're going to write.

600
00:00:00,000 --> 00:00:00,000
It has these functions already written, the two string for the suit and the two string for the rank.

601
00:00:00,000 --> 00:00:00,000
So the output one is pretty easy.

602
00:00:00,000 --> 00:00:00,000
The output one, we're simply going to say out, two string, C dot rank.

603
00:00:00,000 --> 00:00:00,000
Then we're going to put of, and two string, C dot suit.

604
00:00:00,000 --> 00:00:00,000
And then we're going to return out.

605
00:00:00,000 --> 00:00:00,000
So that's pretty easy. We're taking two string, and again, that's already defined for us here.

606
00:00:00,000 --> 00:00:00,000
And here are the types for suits and ranks.

607
00:00:00,000 --> 00:00:00,000
So we don't need to use a switch statement for that.

608
00:00:00,000 --> 00:00:00,000
This is our structure for our card. It has a rank and a suit.

609
00:00:00,000 --> 00:00:00,000
So the output is pretty easy. The input is a little more difficult.

610
00:00:00,000 --> 00:00:00,000
So we're going to return in at the end of this.

611
00:00:00,000 --> 00:00:00,000
We're going to need to read two characters.

612
00:00:00,000 --> 00:00:00,000
So I'm going to call those R and C.

613
00:00:00,000 --> 00:00:00,000
So char R and C.

614
00:00:00,000 --> 00:00:00,000
And we're going to need to read in R and C.

615
00:00:00,000 --> 00:00:00,000
Now there is no easy way to compute, convert R to C, other than writing a switch.

616
00:00:00,000 --> 00:00:00,000
So we're going to write switch R, and then switch C.

617
00:00:00,000 --> 00:00:00,000
Now the parts that make up a rank, let's just go copy them over here.

618
00:00:00,000 --> 00:00:00,000
There's our suit.

619
00:00:00,000 --> 00:00:00,000
So let me just copy both of those over here.

620
00:00:00,000 --> 00:00:00,000
Okay, so here's our ranks.

621
00:00:00,000 --> 00:00:00,000
Now that's our suits.

622
00:00:00,000 --> 00:00:00,000
Let's paste them in there and comment them out.

623
00:00:00,000 --> 00:00:00,000
Here's our ranks.

624
00:00:00,000 --> 00:00:00,000
And I should have called this R and S, right? Rank and suit.

625
00:00:00,000 --> 00:00:00,000
Okay, so there's my ranks.

626
00:00:00,000 --> 00:00:00,000
Here's my suit.

627
00:00:00,000 --> 00:00:00,000
Okay, so let's put the syntax in there.

628
00:00:00,000 --> 00:00:00,000
So case rank colon colon ace.

629
00:00:00,000 --> 00:00:00,000
What we're going to say is C rank equals.

630
00:00:00,000 --> 00:00:00,000
Of course, let me put this. I'm really messing this up.

631
00:00:00,000 --> 00:00:00,000
Case ace, then C.rank equals rank.ace and break.

632
00:00:00,000 --> 00:00:00,000
Okay, so we're going to do the same thing. I'm just going to copy that code there.

633
00:00:00,000 --> 00:00:00,000
Let's put in all the ranks.

634
00:00:00,000 --> 00:00:00,000
Two, three, four, five, six, seven, eight, nine.

635
00:00:00,000 --> 00:00:00,000
Can't put ten as a character, so we're going to use T.

636
00:00:00,000 --> 00:00:00,000
Jack, queen, and one more.

637
00:00:00,000 --> 00:00:00,000
King.

638
00:00:00,000 --> 00:00:00,000
So this is going to be.

639
00:00:00,000 --> 00:00:00,000
So that's going to be two. Three. Four. Five. Six. Seven. Eight.

640
00:00:00,000 --> 00:00:00,000
Oops.

641
00:00:00,000 --> 00:00:00,000
Eight. Nine. Ten. Jack. Queen. King.

642
00:00:00,000 --> 00:00:00,000
And let's put a default.

643
00:00:00,000 --> 00:00:00,000
Let's throw an exception.

644
00:00:00,000 --> 00:00:00,000
Throw a string.

645
00:00:00,000 --> 00:00:00,000
Throw a bad rank.

646
00:00:00,000 --> 00:00:00,000
Okay, now let me copy one of these lines here.

647
00:00:00,000 --> 00:00:00,000
We'll use the same thing for the suit.

648
00:00:00,000 --> 00:00:00,000
Although, of course, it's much closer. It's very shorter.

649
00:00:00,000 --> 00:00:00,000
So the suits are going to be spades, clubs, C suit.

650
00:00:00,000 --> 00:00:00,000
That should be C, right?

651
00:00:00,000 --> 00:00:00,000
And this is going to be suit clubs.

652
00:00:00,000 --> 00:00:00,000
And we can just make. I'm not quite sure what I did.

653
00:00:00,000 --> 00:00:00,000
So here's spades, diamonds, hearts.

654
00:00:00,000 --> 00:00:00,000
And this, of course, is S, D, and H.

655
00:00:00,000 --> 00:00:00,000
And we'll do the same thing for the default.

656
00:00:00,000 --> 00:00:00,000
I'll just throw a bad suit instead of a bad rank.

657
00:00:00,000 --> 00:00:00,000
Okay, let's try it here.

658
00:00:00,000 --> 00:00:00,000
So let's do make.

659
00:00:00,000 --> 00:00:00,000
And let's do make test.

660
00:00:00,000 --> 00:00:00,000
Okay, so here's my output operator. I created this car with rank of ace.

661
00:00:00,000 --> 00:00:00,000
It prints out ace of spades.

662
00:00:00,000 --> 00:00:00,000
Queen of hearts. Jack of diamonds.

663
00:00:00,000 --> 00:00:00,000
Now I've created a, I've got in seven of clubs.

664
00:00:00,000 --> 00:00:00,000
If you want to see what I'm processing, I'm processing this file.

665
00:00:00,000 --> 00:00:00,000
Seven of clubs, two of diamonds, ten of diamonds, ten of clubs, queen of hearts.

666
00:00:00,000 --> 00:00:00,000
And if we look at the output,

667
00:00:00,000 --> 00:00:00,000
what we got is seven of clubs, two of diamonds, ten of diamonds, ten of clubs, queen of hearts.

668
00:00:00,000 --> 00:00:00,000
So that worked just perfectly.

669
00:00:00,000 --> 00:00:00,000
Okay, so we went a little over an hour today.

670
00:00:00,000 --> 00:00:00,000
But we covered structured types and enumerated types.

671
00:00:00,000 --> 00:00:00,000
And you were introduced to overloaded operators.

672
00:00:00,000 --> 00:00:00,000
I'll see you in lecture 16.

