1
00:00:00,000 --> 00:00:00,000
Hello everyone, this is Steve Gilbert. Welcome to lecture 23, where we're going to talk about dynamic memory and the heap.

2
00:00:00,000 --> 00:00:00,000
Now before we do that, we aren't quite finished with C-style strings.

3
00:00:00,000 --> 00:00:00,000
And to do that we're going to talk about command line arguments.

4
00:00:00,000 --> 00:00:00,000
So if you run a program, you all know how you pass arguments to a function.

5
00:00:00,000 --> 00:00:00,000
But how do you pass arguments to the function named main?

6
00:00:00,000 --> 00:00:00,000
Because main isn't called from another one of your functions.

7
00:00:00,000 --> 00:00:00,000
So if you want to pass arguments from outside your program to the main function when your program starts, you use a different version of main.

8
00:00:00,000 --> 00:00:00,000
And so these are always passed as an array of C-style strings, just like the count matches program we used in the last exercise.

9
00:00:00,000 --> 00:00:00,000
Now to collect them you can use one of these versions of main.

10
00:00:00,000 --> 00:00:00,000
Now this kind of should look a little familiar with you because it's kind of similar to what Java does.

11
00:00:00,000 --> 00:00:00,000
In Java you have public static void main string bracket bracket args.

12
00:00:00,000 --> 00:00:00,000
Well these two arguments are the string bracket bracket args part.

13
00:00:00,000 --> 00:00:00,000
Now argc, that first argument, is the number of strings on the command lines.

14
00:00:00,000 --> 00:00:00,000
You remember in Java, arrays have a length field.

15
00:00:00,000 --> 00:00:00,000
And so string bracket bracket args knows how many strings are in it.

16
00:00:00,000 --> 00:00:00,000
In C, they don't.

17
00:00:00,000 --> 00:00:00,000
And so we have to pass the number of strings on the command line.

18
00:00:00,000 --> 00:00:00,000
And that includes the executing program name.

19
00:00:00,000 --> 00:00:00,000
So argc will always contain at least the value 1 anytime you run a program.

20
00:00:00,000 --> 00:00:00,000
Because the name of the program, of course, is what you use to execute the program.

21
00:00:00,000 --> 00:00:00,000
Argv is an array of character pointers.

22
00:00:00,000 --> 00:00:00,000
Now again you might wonder why it's not a const char star.

23
00:00:00,000 --> 00:00:00,000
And that's because in C they didn't have const char stars.

24
00:00:00,000 --> 00:00:00,000
They just had char stars.

25
00:00:00,000 --> 00:00:00,000
And so this again has been inherited from C and it's something we use.

26
00:00:00,000 --> 00:00:00,000
Now you can use argc to check the number of arguments passed.

27
00:00:00,000 --> 00:00:00,000
So if argc is 1, then no argument was passed.

28
00:00:00,000 --> 00:00:00,000
And then you can print out some kind of error message.

29
00:00:00,000 --> 00:00:00,000
Typically this is called a usage message.

30
00:00:00,000 --> 00:00:00,000
You notice when I'm doing the usage message, I'm printing out the name of the program

31
00:00:00,000 --> 00:00:00,000
and then whatever arguments they should pass here.

32
00:00:00,000 --> 00:00:00,000
And I'm exiting from the program.

33
00:00:00,000 --> 00:00:00,000
So you can use argv sub 0 to get the name of the program

34
00:00:00,000 --> 00:00:00,000
and you can use c error to print out a usage kind of message.

35
00:00:00,000 --> 00:00:00,000
You can use exit or you can use return if no argument is passed.

36
00:00:00,000 --> 00:00:00,000
For instance, if you're running a program, it requires arguments.

37
00:00:00,000 --> 00:00:00,000
You don't want to go on and do anything else.

38
00:00:00,000 --> 00:00:00,000
You don't want to allow them to enter the answer.

39
00:00:00,000 --> 00:00:00,000
The argument needs to be passed on the command line.

40
00:00:00,000 --> 00:00:00,000
So if you want to process all arguments, you can use a loop.

41
00:00:00,000 --> 00:00:00,000
So here I'm printing out the name of the program

42
00:00:00,000 --> 00:00:00,000
and I'm going through all the rest of the items from 1 to argc

43
00:00:00,000 --> 00:00:00,000
and I'm printing out the argument names.

44
00:00:00,000 --> 00:00:00,000
Now argc counts the number of words on the command line

45
00:00:00,000 --> 00:00:00,000
but it doesn't count redirection parameters.

46
00:00:00,000 --> 00:00:00,000
So obviously here there's only one word on the command line.

47
00:00:00,000 --> 00:00:00,000
I'm running the program ex and argc is 1.

48
00:00:00,000 --> 00:00:00,000
Here I'm running the program ex and I'm passing arg1 and arg2, so argc is 3.

49
00:00:00,000 --> 00:00:00,000
Here I'm running the program ex and I'm passing arg1

50
00:00:00,000 --> 00:00:00,000
but I'm redirecting it to out.txt.

51
00:00:00,000 --> 00:00:00,000
So the redirection parameters, the little ampersand and the out.txt don't count.

52
00:00:00,000 --> 00:00:00,000
So this still is argc sub 2 instead of 1, 2, 3, 4.

53
00:00:00,000 --> 00:00:00,000
OK, let's go ahead and try it.

54
00:00:00,000 --> 00:00:00,000
So we're going to write a program called frp, file replace.

55
00:00:00,000 --> 00:00:00,000
We're going to do this really simply, it's not going to be very, very fancy.

56
00:00:00,000 --> 00:00:00,000
But the purpose of the program is to open a file and print it

57
00:00:00,000 --> 00:00:00,000
replacing every instance of a given word with another.

58
00:00:00,000 --> 00:00:00,000
Now when I say every instance, we're only going to count if it's found once on a line

59
00:00:00,000 --> 00:00:00,000
rather than multiple times.

60
00:00:00,000 --> 00:00:00,000
So the command line arguments are the name of the file to open,

61
00:00:00,000 --> 00:00:00,000
the word we want to search for,

62
00:00:00,000 --> 00:00:00,000
and the word to use as a replacement, which is optional.

63
00:00:00,000 --> 00:00:00,000
If they don't supply the word to use as a replacement,

64
00:00:00,000 --> 00:00:00,000
then we'll just skip or delete that word from the output printing.

65
00:00:00,000 --> 00:00:00,000
Now there are some error messages and a sample dialog in the handout

66
00:00:00,000 --> 00:00:00,000
and you're going to test your program by writing make tester.

67
00:00:00,000 --> 00:00:00,000
Because obviously we can't say make frp because that simply wouldn't work.

68
00:00:00,000 --> 00:00:00,000
Frp is a program where we're testing the main function.

69
00:00:00,000 --> 00:00:00,000
So let's go ahead over here and look at frp.

70
00:00:00,000 --> 00:00:00,000
So if there are less than two arguments supplied, we're going to print an error message.

71
00:00:00,000 --> 00:00:00,000
Two arguments open the input file for reading the file line by line,

72
00:00:00,000 --> 00:00:00,000
displaying the entire file on the console.

73
00:00:00,000 --> 00:00:00,000
With all arguments, the second argument removed.

74
00:00:00,000 --> 00:00:00,000
If we can't open the file, print an error message and exit.

75
00:00:00,000 --> 00:00:00,000
Three arguments open the end file for reading.

76
00:00:00,000 --> 00:00:00,000
Read the file line by line, displaying the entire file on the console.

77
00:00:00,000 --> 00:00:00,000
With all instances, the second argument replaced by the third.

78
00:00:00,000 --> 00:00:00,000
As you read the file line by line, use find to see if the desired string exists in the line

79
00:00:00,000 --> 00:00:00,000
and then use substring to display all but the character you're replacing, the word you're replacing.

80
00:00:00,000 --> 00:00:00,000
So here are some sample runs.

81
00:00:00,000 --> 00:00:00,000
So I said ./frp and it doesn't have its arguments.

82
00:00:00,000 --> 00:00:00,000
So it gives me the usage message.

83
00:00:00,000 --> 00:00:00,000
Frp, you're supposed to pass the file to open, the word defined,

84
00:00:00,000 --> 00:00:00,000
and then optionally what you want to replace it with.

85
00:00:00,000 --> 00:00:00,000
Okay, I'm going to try it again. ./frp data a1.txt

86
00:00:00,000 --> 00:00:00,000
Again, I have supplied at least the three arguments and so it gives me the usage message.

87
00:00:00,000 --> 00:00:00,000
Here I've said .frp data.ax.txt her.

88
00:00:00,000 --> 00:00:00,000
Well, this is okay for the command lines,

89
00:00:00,000 --> 00:00:00,000
but when it tries to open ax.txt it says it can't open the input file a.txt.

90
00:00:00,000 --> 00:00:00,000
The rest of them, here I'm trying to say, here's the original file a1.txt,

91
00:00:00,000 --> 00:00:00,000
here I'm saying ./frp data a1.txt her,

92
00:00:00,000 --> 00:00:00,000
and it's going to remove all the copies of her from inside here.

93
00:00:00,000 --> 00:00:00,000
Here I'm going to remove, place all copy of her with Alice's in the output.

94
00:00:00,000 --> 00:00:00,000
Now again, this is very simplistic.

95
00:00:00,000 --> 00:00:00,000
We're not doing very complex where her could appear in the word there, for instance.

96
00:00:00,000 --> 00:00:00,000
We're not checking to make sure that doesn't happen.

97
00:00:00,000 --> 00:00:00,000
We're also not checking to see if her appeared multiple times on the line

98
00:00:00,000 --> 00:00:00,000
and replacing all of them.

99
00:00:00,000 --> 00:00:00,000
That would be more complex processing.

100
00:00:00,000 --> 00:00:00,000
So let's go ahead and go into IC23,

101
00:00:00,000 --> 00:00:00,000
go into frp.cpp,

102
00:00:00,000 --> 00:00:00,000
and let's just write our code.

103
00:00:00,000 --> 00:00:00,000
The first thing, we need a different version of main, don't we?

104
00:00:00,000 --> 00:00:00,000
So we need to have int argc,

105
00:00:00,000 --> 00:00:00,000
and we need to have char star argv, bracket bracket.

106
00:00:00,000 --> 00:00:00,000
Second, we need to check argc.

107
00:00:00,000 --> 00:00:00,000
So if argc is less than 3,

108
00:00:00,000 --> 00:00:00,000
then we don't have the right number of command lines.

109
00:00:00,000 --> 00:00:00,000
And so we can do "sr usage".

110
00:00:00,000 --> 00:00:00,000
I'm just going to write, I'll use the argv sub 0.

111
00:00:00,000 --> 00:00:00,000
We're file to open.

112
00:00:00,000 --> 00:00:00,000
Second argument, we're defined.

113
00:00:00,000 --> 00:00:00,000
Our optional argument, replace with.

114
00:00:00,000 --> 00:00:00,000
Notice I'm printing this on CR.

115
00:00:00,000 --> 00:00:00,000
And I'm going to return a value here, since this is a main function.

116
00:00:00,000 --> 00:00:00,000
I'm going to return a value -1 in this case.

117
00:00:00,000 --> 00:00:00,000
Now, if I get down to line 12 here,

118
00:00:00,000 --> 00:00:00,000
I know that I have at least 3 words on the command line, or 2 arguments.

119
00:00:00,000 --> 00:00:00,000
And so I'm going to try and open the file name.

120
00:00:00,000 --> 00:00:00,000
So I'm going to say "if stream in",

121
00:00:00,000 --> 00:00:00,000
and I'm going to do "argv sub 1".

122
00:00:00,000 --> 00:00:00,000
"argv sub 0" is the name of the file, "argv sub 1" is the file name.

123
00:00:00,000 --> 00:00:00,000
Now I'm going to check if that worked.

124
00:00:00,000 --> 00:00:00,000
If "in" failed,

125
00:00:00,000 --> 00:00:00,000
"sr could not open argv sub 1".

126
00:00:00,000 --> 00:00:00,000
This time I'll return a different number,

127
00:00:00,000 --> 00:00:00,000
so someone running this program could tell from the numbers I return what the value is,

128
00:00:00,000 --> 00:00:00,000
or what the error was.

129
00:00:00,000 --> 00:00:00,000
OK, so now I've opened the file.

130
00:00:00,000 --> 00:00:00,000
I know that I have found,

131
00:00:00,000 --> 00:00:00,000
I've been able to open the file, I have at least the right number of command lines.

132
00:00:00,000 --> 00:00:00,000
And so I'm going to, and I often do,

133
00:00:00,000 --> 00:00:00,000
use the C++ string class to make the rest of this easier.

134
00:00:00,000 --> 00:00:00,000
So even though "argv" is all C-style strings,

135
00:00:00,000 --> 00:00:00,000
I can construct C++ strings.

136
00:00:00,000 --> 00:00:00,000
So I'm going to say "string word = argv sub 2".

137
00:00:00,000 --> 00:00:00,000
I'm going to say "string replace",

138
00:00:00,000 --> 00:00:00,000
of course that's going to be the empty string,

139
00:00:00,000 --> 00:00:00,000
and if "argc" is greater than 3,

140
00:00:00,000 --> 00:00:00,000
in other words if we have four words on the command line,

141
00:00:00,000 --> 00:00:00,000
then I'm going to say "replace = argv sub 3".

142
00:00:00,000 --> 00:00:00,000
OK, the fourth thing in the array.

143
00:00:00,000 --> 00:00:00,000
OK, now the rest of this is pretty straightforward.

144
00:00:00,000 --> 00:00:00,000
We're going to say "file",

145
00:00:00,000 --> 00:00:00,000
let's get a line here, "string line",

146
00:00:00,000 --> 00:00:00,000
"get line in line".

147
00:00:00,000 --> 00:00:00,000
Well we can read a line.

148
00:00:00,000 --> 00:00:00,000
First we want to find out if we can find the word inside there.

149
00:00:00,000 --> 00:00:00,000
So we'll say "autopause" or "sizeT" pause

150
00:00:00,000 --> 00:00:00,000
equals "line find word".

151
00:00:00,000 --> 00:00:00,000
Now if "pause" is not equal to "string in pause",

152
00:00:00,000 --> 00:00:00,000
probably remember this from the first couple of weeks,

153
00:00:00,000 --> 00:00:00,000
then we want to make "line" equals "line substring 0",

154
00:00:00,000 --> 00:00:00,000
"pause characters",

155
00:00:00,000 --> 00:00:00,000
plus whatever the replacement string is,

156
00:00:00,000 --> 00:00:00,000
plus "line substring",

157
00:00:00,000 --> 00:00:00,000
"pause" plus "word size",

158
00:00:00,000 --> 00:00:00,000
and that's the rest of it.

159
00:00:00,000 --> 00:00:00,000
Now as I mentioned, suppose the word appears multiple times,

160
00:00:00,000 --> 00:00:00,000
we're not checking that.

161
00:00:00,000 --> 00:00:00,000
Suppose the word appears inside another word,

162
00:00:00,000 --> 00:00:00,000
we're not checking that.

163
00:00:00,000 --> 00:00:00,000
Suppose if the word doesn't appear inside another word,

164
00:00:00,000 --> 00:00:00,000
what about the space before and after?

165
00:00:00,000 --> 00:00:00,000
Again, we're not checking that, we're assuming that the space is going to be OK.

166
00:00:00,000 --> 00:00:00,000
So, very rudimentary, just to show you how to use the command lines.

167
00:00:00,000 --> 00:00:00,000
And then we'll do "cout line endo".

168
00:00:00,000 --> 00:00:00,000
OK, so let's do a terminal here,

169
00:00:00,000 --> 00:00:00,000
and then let's do "make tester",

170
00:00:00,000 --> 00:00:00,000
and that didn't work.

171
00:00:00,000 --> 00:00:00,000
Let's do "make test".

172
00:00:00,000 --> 00:00:00,000
OK, I should have just done "make test" instead of "make tester".

173
00:00:00,000 --> 00:00:00,000
I'll change that on the slides, and I'll check on that later.

174
00:00:00,000 --> 00:00:00,000
Let me just change the slide right now.

175
00:00:00,000 --> 00:00:00,000
OK, so it checks the different command lines here to make sure they work,

176
00:00:00,000 --> 00:00:00,000
they all do, then it checks some different files to make sure it replaces

177
00:00:00,000 --> 00:00:00,000
one word with another word throughout there.

178
00:00:00,000 --> 00:00:00,000
And that works OK.

179
00:00:00,000 --> 00:00:00,000
Alright, let's go on.

180
00:00:00,000 --> 00:00:00,000
And go to our second topic today, which is the heap.

181
00:00:00,000 --> 00:00:00,000
Now, like Java and Pascal, C++ places variables on the heap using the new operator.

182
00:00:00,000 --> 00:00:00,000
So look at this little piece of Java code here.

183
00:00:00,000 --> 00:00:00,000
We create an int a and put 3 in it. That's put on the stack.

184
00:00:00,000 --> 00:00:00,000
We create a double b and put 5 in it. That's put on the stack.

185
00:00:00,000 --> 00:00:00,000
By the way, Java and C++ work the same way here.

186
00:00:00,000 --> 00:00:00,000
Then we create a scanner variable in. That's put on the stack.

187
00:00:00,000 --> 00:00:00,000
But we put a scanner object on the heap and point that variable to that scanner object

188
00:00:00,000 --> 00:00:00,000
by using the new operator.

189
00:00:00,000 --> 00:00:00,000
We do the same thing in C++.

190
00:00:00,000 --> 00:00:00,000
So variables are allocated on the heap by using the operator called new.

191
00:00:00,000 --> 00:00:00,000
The result that you get back from new is an address.

192
00:00:00,000 --> 00:00:00,000
And we will store that address in a pointer.

193
00:00:00,000 --> 00:00:00,000
So here's an example.

194
00:00:00,000 --> 00:00:00,000
So int *pi. pi is a pointer to int.

195
00:00:00,000 --> 00:00:00,000
And we initialize it with a new int with a value 3 inside it.

196
00:00:00,000 --> 00:00:00,000
Here, ia is a pointer to an int.

197
00:00:00,000 --> 00:00:00,000
And we initialize it with the address of the first element of a new array of 3 ints.

198
00:00:00,000 --> 00:00:00,000
So very, very similar to what you do in Java.

199
00:00:00,000 --> 00:00:00,000
Slightly different, but similar.

200
00:00:00,000 --> 00:00:00,000
The big difference is in Java, when you put something on the heap with new,

201
00:00:00,000 --> 00:00:00,000
Java will take care of returning that memory to the operating system so it can be reused.

202
00:00:00,000 --> 00:00:00,000
In C++, that is not the case.

203
00:00:00,000 --> 00:00:00,000
In C++, you are responsible for returning the memory to the system.

204
00:00:00,000 --> 00:00:00,000
And so you do that with the operator delete, which is paired with the operator new.

205
00:00:00,000 --> 00:00:00,000
If you use a plain new, like new int, then you use delete on the pointer.

206
00:00:00,000 --> 00:00:00,000
Delete p1.

207
00:00:00,000 --> 00:00:00,000
If you use the array version of new, new int bracket bracket,

208
00:00:00,000 --> 00:00:00,000
you use the array version of delete.

209
00:00:00,000 --> 00:00:00,000
So I'm going to show you an example of this.

210
00:00:00,000 --> 00:00:00,000
And I'm not sure how this is going to work with this recording.

211
00:00:00,000 --> 00:00:00,000
So I'm going to try this.

212
00:00:00,000 --> 00:00:00,000
I may have to get the page off of another.

213
00:00:00,000 --> 00:00:00,000
I want to continue.

214
00:00:00,000 --> 00:00:00,000
So it dropped it over on another page here.

215
00:00:00,000 --> 00:00:00,000
So I have a program here that creates an int a1.

216
00:00:00,000 --> 00:00:00,000
Where is that variable going to be created?

217
00:00:00,000 --> 00:00:00,000
It's going to be created on the stack, and it's going to be initialized with 1.

218
00:00:00,000 --> 00:00:00,000
Now I'm going to create a new variable on the heap and a pointer on the stack.

219
00:00:00,000 --> 00:00:00,000
So b is a pointer.

220
00:00:00,000 --> 00:00:00,000
This new variable, which is unnamed, is pointed to by b.

221
00:00:00,000 --> 00:00:00,000
And so this is what we end up with.

222
00:00:00,000 --> 00:00:00,000
So this is a new object on the heap.

223
00:00:00,000 --> 00:00:00,000
Now in this visualizer here, it shows this as an array,

224
00:00:00,000 --> 00:00:00,000
but it's a single variable on the heap.

225
00:00:00,000 --> 00:00:00,000
Now I'm going to create a new array of 5 integers.

226
00:00:00,000 --> 00:00:00,000
I'm going to initialize the first 3.

227
00:00:00,000 --> 00:00:00,000
So notice I'm using new bracket bracket here, not just plain new.

228
00:00:00,000 --> 00:00:00,000
And so here I have my 5 elements on the heap.

229
00:00:00,000 --> 00:00:00,000
And finally I'm going to create an array of 3 variables on the stack.

230
00:00:00,000 --> 00:00:00,000
So int d bracket bracket equals 4, 5, and 6.

231
00:00:00,000 --> 00:00:00,000
And so you can see these are created on the heap.

232
00:00:00,000 --> 00:00:00,000
So this is what this looks like in memory.

233
00:00:00,000 --> 00:00:00,000
Now when I delete c, you remember c used the array version of new,

234
00:00:00,000 --> 00:00:00,000
and so I need to use the array version of delete.

235
00:00:00,000 --> 00:00:00,000
When I delete c, the memory on the heap is returned to the operating system.

236
00:00:00,000 --> 00:00:00,000
The pointer c is not changed, but it's no longer valid.

237
00:00:00,000 --> 00:00:00,000
That's why these visualizer people decided to use a poop emoji

238
00:00:00,000 --> 00:00:00,000
to show you that that pointer is no longer useful.

239
00:00:00,000 --> 00:00:00,000
The same thing with b. When I delete the pointer b,

240
00:00:00,000 --> 00:00:00,000
it doesn't really change the pointer, it makes it invalid,

241
00:00:00,000 --> 00:00:00,000
but it's just the same address, it's not really touched.

242
00:00:00,000 --> 00:00:00,000
But the thing that was on the heap goes away.

243
00:00:00,000 --> 00:00:00,000
And so that's what this new and delete works like.

244
00:00:00,000 --> 00:00:00,000
So let's introduce some dynamic variables and do an actual exercise.

245
00:00:00,000 --> 00:00:00,000
So we're going to request some memory on the heap.

246
00:00:00,000 --> 00:00:00,000
We're going to allocate memory on the heap with the new operator.

247
00:00:00,000 --> 00:00:00,000
So let me show you the different ways that we can use the new operator.

248
00:00:00,000 --> 00:00:00,000
We can say new and get an uninitialized variable.

249
00:00:00,000 --> 00:00:00,000
So new int will give me an int on the heap,

250
00:00:00,000 --> 00:00:00,000
p1 will point to it, but that int could have any value at all.

251
00:00:00,000 --> 00:00:00,000
If we say new int with braces around it,

252
00:00:00,000 --> 00:00:00,000
this is only available since C++11,

253
00:00:00,000 --> 00:00:00,000
we would get an int that was initialized to zero.

254
00:00:00,000 --> 00:00:00,000
If we say new int 3, here we can use either the braces or the parentheses,

255
00:00:00,000 --> 00:00:00,000
this will be directly initialized, one single integer.

256
00:00:00,000 --> 00:00:00,000
If we do new int square brackets, that's array new,

257
00:00:00,000 --> 00:00:00,000
that will give us an uninitialized array.

258
00:00:00,000 --> 00:00:00,000
If we use the braces around it, again only available since C++11,

259
00:00:00,000 --> 00:00:00,000
that will give us three integers that have the value zero.

260
00:00:00,000 --> 00:00:00,000
If we initialize it afterwards, we will get the 1, 2, 3, that will be initialized.

261
00:00:00,000 --> 00:00:00,000
If we did this with an object, like an employee,

262
00:00:00,000 --> 00:00:00,000
we would just do new employee and then initialize the employee like that.

263
00:00:00,000 --> 00:00:00,000
So let's go ahead to our exercise over here.

264
00:00:00,000 --> 00:00:00,000
Let's close firp and close that terminal.

265
00:00:00,000 --> 00:00:00,000
Let's go to B.

266
00:00:00,000 --> 00:00:00,000
Here are some automatic or stack based variables.

267
00:00:00,000 --> 00:00:00,000
An int, a double, a float, a char, a string, an array, an employee.

268
00:00:00,000 --> 00:00:00,000
Notice we print them just by using the name of the variable.

269
00:00:00,000 --> 00:00:00,000
We're going to create dynamic variables for each of these.

270
00:00:00,000 --> 00:00:00,000
Those dynamic variables are going to be unnamed,

271
00:00:00,000 --> 00:00:00,000
and they're going to be pointed to by a pointer.

272
00:00:00,000 --> 00:00:00,000
So I'm going to have int pointer ip for an int pointer equals new int.

273
00:00:00,000 --> 00:00:00,000
I'll initialize, what was my int up there initialized to?

274
00:00:00,000 --> 00:00:00,000
It was initialized to 3.

275
00:00:00,000 --> 00:00:00,000
I'll initialize mine to 4 for this new one.

276
00:00:00,000 --> 00:00:00,000
So then we have a double.

277
00:00:00,000 --> 00:00:00,000
So int star dp equals new double.

278
00:00:00,000 --> 00:00:00,000
That was 2.5.

279
00:00:00,000 --> 00:00:00,000
I'll do this 3.5.

280
00:00:00,000 --> 00:00:00,000
Int, that's a double.

281
00:00:00,000 --> 00:00:00,000
A double pointer dp.

282
00:00:00,000 --> 00:00:00,000
This is a float pointer.

283
00:00:00,000 --> 00:00:00,000
Fp equals new float.

284
00:00:00,000 --> 00:00:00,000
That was 2.5f.

285
00:00:00,000 --> 00:00:00,000
I'll make this 3.5f.

286
00:00:00,000 --> 00:00:00,000
I'll make that 4.5f.

287
00:00:00,000 --> 00:00:00,000
And then a char pointer.

288
00:00:00,000 --> 00:00:00,000
So char pointer cp equals new char.

289
00:00:00,000 --> 00:00:00,000
Again, we can use braces or parentheses.

290
00:00:00,000 --> 00:00:00,000
And we want the character s.

291
00:00:00,000 --> 00:00:00,000
We want a string pointer.

292
00:00:00,000 --> 00:00:00,000
New string.

293
00:00:00,000 --> 00:00:00,000
That's my last name there.

294
00:00:00,000 --> 00:00:00,000
I used the first name in this one up here.

295
00:00:00,000 --> 00:00:00,000
We'll use an array.

296
00:00:00,000 --> 00:00:00,000
Int star ia instead of ip equals new int.

297
00:00:00,000 --> 00:00:00,000
This time we have to put in a value.

298
00:00:00,000 --> 00:00:00,000
So I'll put 3.

299
00:00:00,000 --> 00:00:00,000
And I'll put 4, 5, and 6.

300
00:00:00,000 --> 00:00:00,000
Now unlike regular arrays, when you initialize a new array on the heap,

301
00:00:00,000 --> 00:00:00,000
you have to supply a value here.

302
00:00:00,000 --> 00:00:00,000
So if we were to do this, which would be perfectly legal for --

303
00:00:00,000 --> 00:00:00,000
if we left off the --

304
00:00:00,000 --> 00:00:00,000
that would be perfectly legal, right?

305
00:00:00,000 --> 00:00:00,000
But for a new array,

306
00:00:00,000 --> 00:00:00,000
you have to put the size in there.

307
00:00:00,000 --> 00:00:00,000
And finally we had an employee, right?

308
00:00:00,000 --> 00:00:00,000
So employee pointer ep equals new employee.

309
00:00:00,000 --> 00:00:00,000
And we'll do a bill.

310
00:00:00,000 --> 00:00:00,000
And we'll give him a slightly higher salary, $24,000.

311
00:00:00,000 --> 00:00:00,000
Okay, so this creates the dynamic variables.

312
00:00:00,000 --> 00:00:00,000
Now we want to go ahead and print those dynamic variables.

313
00:00:00,000 --> 00:00:00,000
So let's look at how we would print each of those.

314
00:00:00,000 --> 00:00:00,000
So what I'm going to do is I'm going to take this here.

315
00:00:00,000 --> 00:00:00,000
I'm going to copy it right down here.

316
00:00:00,000 --> 00:00:00,000
Star ip.

317
00:00:00,000 --> 00:00:00,000
Star ip.

318
00:00:00,000 --> 00:00:00,000
Star dp.

319
00:00:00,000 --> 00:00:00,000
Star dp.

320
00:00:00,000 --> 00:00:00,000
Star fp.

321
00:00:00,000 --> 00:00:00,000
Star fp.

322
00:00:00,000 --> 00:00:00,000
Star cp.

323
00:00:00,000 --> 00:00:00,000
Star cp.

324
00:00:00,000 --> 00:00:00,000
Star sp.

325
00:00:00,000 --> 00:00:00,000
Star sp.

326
00:00:00,000 --> 00:00:00,000
So ia.

327
00:00:00,000 --> 00:00:00,000
And remember with pointers, we can use the subscript just like with an array.

328
00:00:00,000 --> 00:00:00,000
So I can say ia sub zero.

329
00:00:00,000 --> 00:00:00,000
Ia sub i.

330
00:00:00,000 --> 00:00:00,000
And finally the last one is an employee.

331
00:00:00,000 --> 00:00:00,000
This one's a little bit different because I don't have an employee.

332
00:00:00,000 --> 00:00:00,000
I have an employee pointer.

333
00:00:00,000 --> 00:00:00,000
And so we'd have to say ep not dot name but arrow name.

334
00:00:00,000 --> 00:00:00,000
And ep not dot salary but ep arrow salary.

335
00:00:00,000 --> 00:00:00,000
Okay, so let's open a shell on that.

336
00:00:00,000 --> 00:00:00,000
And let's do make test.

337
00:00:00,000 --> 00:00:00,000
Let's just do make run.

338
00:00:00,000 --> 00:00:00,000
Okay.

339
00:00:00,000 --> 00:00:00,000
Okay, so I got an error.

340
00:00:00,000 --> 00:00:00,000
Let's see how we created the employee up here originally.

341
00:00:00,000 --> 00:00:00,000
Okay, so we created the employee like that.

342
00:00:00,000 --> 00:00:00,000
So let's put the braces because it's a structure.

343
00:00:00,000 --> 00:00:00,000
It doesn't have a constructor, which we'll learn about a little bit later.

344
00:00:00,000 --> 00:00:00,000
And let's try that again.

345
00:00:00,000 --> 00:00:00,000
Make run.

346
00:00:00,000 --> 00:00:00,000
Okay, so an int is three.

347
00:00:00,000 --> 00:00:00,000
IP is four, 350, 450.

348
00:00:00,000 --> 00:00:00,000
CP is S.

349
00:00:00,000 --> 00:00:00,000
SP is Gilbert.

350
00:00:00,000 --> 00:00:00,000
An array is 456.

351
00:00:00,000 --> 00:00:00,000
And ep is Bill.

352
00:00:00,000 --> 00:00:00,000
And that looks like it works perfectly fine.

353
00:00:00,000 --> 00:00:00,000
But there's a slight, slight problem.

354
00:00:00,000 --> 00:00:00,000
There is a slight, slight problem.

355
00:00:00,000 --> 00:00:00,000
So let's look at that problem.

356
00:00:00,000 --> 00:00:00,000
We didn't have any errors.

357
00:00:00,000 --> 00:00:00,000
Is everything okay?

358
00:00:00,000 --> 00:00:00,000
No.

359
00:00:00,000 --> 00:00:00,000
Unlike Java or unlike C#, we are responsible for returning any memory to the operating system.

360
00:00:00,000 --> 00:00:00,000
The memory that's allocated on the heap is not automatically collected and reused.

361
00:00:00,000 --> 00:00:00,000
And so we have additional programs.

362
00:00:00,000 --> 00:00:00,000
One is called Valgrind in Java.

363
00:00:00,000 --> 00:00:00,000
Windows has its own program that does this.

364
00:00:00,000 --> 00:00:00,000
There's no universal way to do it.

365
00:00:00,000 --> 00:00:00,000
I've also used some Google memory checkers to check that.

366
00:00:00,000 --> 00:00:00,000
And I've put those in the make file.

367
00:00:00,000 --> 00:00:00,000
So if we do make grind, you'll see that it runs a memory detector on it.

368
00:00:00,000 --> 00:00:00,000
And at the end, it tells us, it runs the program up here, right, just like it normally would.

369
00:00:00,000 --> 00:00:00,000
But at the end, it tells us, oh, we lost some memory.

370
00:00:00,000 --> 00:00:00,000
And it's kind of telling us where it was lost on line 44, line 41, line 43, and line 42 and so forth.

371
00:00:00,000 --> 00:00:00,000
And line 46.

372
00:00:00,000 --> 00:00:00,000
And each of those, we allocated some memory, but we didn't free the memory.

373
00:00:00,000 --> 00:00:00,000
Now, that's one way.

374
00:00:00,000 --> 00:00:00,000
That's actually running our program by running a separate program called Valgrind.

375
00:00:00,000 --> 00:00:00,000
If you look at the make file here, you can see that it runs Valgrind and then just runs the executable after the executable is built.

376
00:00:00,000 --> 00:00:00,000
If we do make check, what it does is recompiles our code with a special kind of code inside it.

377
00:00:00,000 --> 00:00:00,000
And then checks it that way.

378
00:00:00,000 --> 00:00:00,000
So let's go ahead and do make check.

379
00:00:00,000 --> 00:00:00,000
And it just depends which one you want to use.

380
00:00:00,000 --> 00:00:00,000
So make check.

381
00:00:00,000 --> 00:00:00,000
And let me close that over to that way.

382
00:00:00,000 --> 00:00:00,000
And so basically we get the same information.

383
00:00:00,000 --> 00:00:00,000
We don't get the startup thing at the bottom of it, but it tells us at the bottom where our code is leaking.

384
00:00:00,000 --> 00:00:00,000
And it tells us here, you look for your piece of code, dynamic CPP line 47, 46.

385
00:00:00,000 --> 00:00:00,000
So both of those will give us the same piece of information.

386
00:00:00,000 --> 00:00:00,000
They do it in a slightly different way.

387
00:00:00,000 --> 00:00:00,000
If you use Valgrind, you don't have to put any special code inside your program to do it.

388
00:00:00,000 --> 00:00:00,000
It works automatically on code that has already been compiled.

389
00:00:00,000 --> 00:00:00,000
If you use the checker, it automatically has to recompile your code and add this extra checking code inside your code.

390
00:00:00,000 --> 00:00:00,000
So how do we fix this?

391
00:00:00,000 --> 00:00:00,000
How do we fix this problem so that it works correctly?

392
00:00:00,000 --> 00:00:00,000
What we do is we use delete or delete to return the memory.

393
00:00:00,000 --> 00:00:00,000
You delete the pointer to free the heap object.

394
00:00:00,000 --> 00:00:00,000
Just like the visualization I just showed you.

395
00:00:00,000 --> 00:00:00,000
So let's go back to our code.

396
00:00:00,000 --> 00:00:00,000
Let's bring this down here.

397
00:00:00,000 --> 00:00:00,000
So I have delete IP, delete DP, delete FP, delete SP, delete CP, delete IP.

398
00:00:00,000 --> 00:00:00,000
No, EP.

399
00:00:00,000 --> 00:00:00,000
And finally, bracket bracket, IA.

400
00:00:00,000 --> 00:00:00,000
So you have to check and fix the run time errors for each one.

401
00:00:00,000 --> 00:00:00,000
So once we've done that, you can do either make grind or make check.

402
00:00:00,000 --> 00:00:00,000
So make check.

403
00:00:00,000 --> 00:00:00,000
If we got all of them, we won't have any errors at the end of it.

404
00:00:00,000 --> 00:00:00,000
Make grind would do the same thing.

405
00:00:00,000 --> 00:00:00,000
Now what if we use the wrong version of delete for this?

406
00:00:00,000 --> 00:00:00,000
What if I for instance said delete IP or delete IA there without the brackets?

407
00:00:00,000 --> 00:00:00,000
Let's see what happens when we do make check.

408
00:00:00,000 --> 00:00:00,000
So notice that creates an error.

409
00:00:00,000 --> 00:00:00,000
So we're using operator new versus operator delete with the brackets.

410
00:00:00,000 --> 00:00:00,000
That's an error.

411
00:00:00,000 --> 00:00:00,000
And this actually aborts because it would create more errors.

412
00:00:00,000 --> 00:00:00,000
Because we're actually trying to allocate.

413
00:00:00,000 --> 00:00:00,000
We're trying to deallocate memory that's on the stack, which is not legal.

414
00:00:00,000 --> 00:00:00,000
And so you have to be careful to make sure that you use the correct version of new with the correct version of delete.

415
00:00:00,000 --> 00:00:00,000
Let's do it one last time.

416
00:00:00,000 --> 00:00:00,000
And no errors on that at all.

