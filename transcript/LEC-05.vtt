WEBVTT

00:00:00.000 --> 00:00:00.000
 Hello everyone, this is Steve Gilbert. Welcome to lecture 5. In this lecture we're going to look at strings and characters.

00:00:00.000 --> 00:00:00.000
 Now characters are built in to the C++ language, just like ints are and just like doubles are.

00:00:00.000 --> 00:00:00.000
 Unlike Java though, or unlike Python, in C++ the C++ char type is a 7-bit ASCII character.

00:00:00.000 --> 00:00:00.000
 Now you might think, with 8 bits, how can you, with a byte being the smallest thing, how can you have a 7-bit character set?

00:00:00.000 --> 00:00:00.000
 Well, originally when C++ was created, they used the extra bit as part of the communication protocol, and so they only defined 7 bits from 0 to 127.

00:00:00.000 --> 00:00:00.000
 And so that means that in C++ only 128 characters are defined.

00:00:00.000 --> 00:00:00.000
 Now those extra 128 characters, or 127 characters, that you would have from 128 on to 255, those are what's called the extended ASCII character set.

00:00:00.000 --> 00:00:00.000
 But that is not standardized and it's not built in to C++, so you really can't rely on what those characters are.

00:00:00.000 --> 00:00:00.000
 Instead, for larger character sets, in other words for Unicode and so forth, C++ has always had the Wchar_t, or the Wchar type.

00:00:00.000 --> 00:00:00.000
 Now, because different versions of Unicode are represented different ways, since C++11, C++ has added two additional types for Unicode.

00:00:00.000 --> 00:00:00.000
 So Wchar_t, which is 16-bit Unicode, which is the same as Java's Unicode, and Wchar_t, which is the same as Python's Unicode.

00:00:00.000 --> 00:00:00.000
 Now, we also, remember, use the Wchar type for small numbers.

00:00:00.000 --> 00:00:00.000
 Java has the type byte, C++ does not, and instead of byte, it uses a signed char.

00:00:00.000 --> 00:00:00.000
 In C++, we can also use an unsigned char, which is actually useful, a byte that goes from 0 to 255.

00:00:00.000 --> 00:00:00.000
 Now, to deal with this built-in type, we inherited from C, all the headers that start with C, like C, C type, are inherited from the C library.

00:00:00.000 --> 00:00:00.000
 It has functions, actually they're called macros, we'll learn a little bit later what those are, that are used for char.

00:00:00.000 --> 00:00:00.000
 So again, the headers that start with C are inherited from the C library.

00:00:00.000 --> 00:00:00.000
 So there are some classification functions inside here.

00:00:00.000 --> 00:00:00.000
 So I can take a character, C, and I can ask, "Is it a digit?"

00:00:00.000 --> 00:00:00.000
 And I'll get back yes or no.

00:00:00.000 --> 00:00:00.000
 Actually, because it's C and they didn't have true or false, you get back 0 and 1, but you treat it as true or false.

00:00:00.000 --> 00:00:00.000
 Or, "Is it an alpha character?" or "Is it a space?" or "Is it punctuation?" and so forth.

00:00:00.000 --> 00:00:00.000
 There are two conversion functions in here that you can use to convert a character from lowercase to uppercase and from uppercase to lowercase.

00:00:00.000 --> 00:00:00.000
 These functions only convert if it's appropriate.

00:00:00.000 --> 00:00:00.000
 So it's perfectly legal to pass a lowercase character to C, a lowercase character to toLower, and it simply won't do the conversion.

00:00:00.000 --> 00:00:00.000
 It'll work just fine.

00:00:00.000 --> 00:00:00.000
 You don't have to say, "If it's upper, pass it to toLower."

00:00:00.000 --> 00:00:00.000
 Now, a sequence of characters we call a string.

00:00:00.000 --> 00:00:00.000
 So what we call text is called a string.

00:00:00.000 --> 00:00:00.000
 C++ has two kinds of strings.

00:00:00.000 --> 00:00:00.000
 The built-in string inherited from C is called a C-style or C-string.

00:00:00.000 --> 00:00:00.000
 It's an array of characters which are terminated with a null byte.

00:00:00.000 --> 00:00:00.000
 It's not a class. It's not a library type. It's built into the language.

00:00:00.000 --> 00:00:00.000
 Anytime you have a string literal, like "Hello, world," what you're working with is a C-style string.

00:00:00.000 --> 00:00:00.000
 We'll study these when we look at pointers and arrays.

00:00:00.000 --> 00:00:00.000
 We're going to kind of ignore them for right now.

00:00:00.000 --> 00:00:00.000
 The C++ standard library, however, has a type called string.

00:00:00.000 --> 00:00:00.000
 Now, remember in Java, it was uppercase string. It's lowercase in C++.

00:00:00.000 --> 00:00:00.000
 Just like in Java, this is a class type.

00:00:00.000 --> 00:00:00.000
 It's not built into the C++ language. It's part of the library.

00:00:00.000 --> 00:00:00.000
 And remember in C++, in Java, you can use the string type without doing any extra work.

00:00:00.000 --> 00:00:00.000
 But in C++, to use the string type, you have to remember to include the string header.

00:00:00.000 --> 00:00:00.000
 Remember, none of the library functions are included if you do not include them explicitly.

00:00:00.000 --> 00:00:00.000
 Now, a C++ string literal, starting in C++14, can be written as "Hello," just like a C-string literal, in double quotes,

00:00:00.000 --> 00:00:00.000
 with an "s" at the end of it. And that will be a string object.

00:00:00.000 --> 00:00:00.000
 So let me show you briefly. I'm going to do a little exploring here over in our example CPP.

00:00:00.000 --> 00:00:00.000
 I'm going to make sure I want to use the string class, so I'm going to include string.

00:00:00.000 --> 00:00:00.000
 And I'm going to create a couple of different things.

00:00:00.000 --> 00:00:00.000
 I'm going to try "Hello." I'm going to try and actually print out "cl hello.size."

00:00:00.000 --> 00:00:00.000
 And then I'm going to try and print out "cl hello s.size."

00:00:00.000 --> 00:00:00.000
 Now when I try and compile this, "make example," notice I get an error.

00:00:00.000 --> 00:00:00.000
 This is not a string object. I'm trying to ask for a member function on a C-style string.

00:00:00.000 --> 00:00:00.000
 So these are not string objects. However, let me comment that one that doesn't work out.

00:00:00.000 --> 00:00:00.000
 So, do "make example" again. Notice that that compiles. So "hello" with an "s" is a C++ string literal.

00:00:00.000 --> 00:00:00.000
 If I run "example," of course it prints out 5, because there are 5 characters in the word "hello."

00:00:00.000 --> 00:00:00.000
 Alright, let's go back and look at creating string variables.

00:00:00.000 --> 00:00:00.000
 Now, because this is a library type, all library types you create with a constructor.

00:00:00.000 --> 00:00:00.000
 So, the syntax is slightly different with C++ using a constructor than it is with Java.

00:00:00.000 --> 00:00:00.000
 So, in Java, we would write "string s = new string hello world."

00:00:00.000 --> 00:00:00.000
 Now, of course, there's a shorthand, so we don't have to do the new string. We could just put the "hello world."

00:00:00.000 --> 00:00:00.000
 But behind the scenes, Java is doing this new string "hello world."

00:00:00.000 --> 00:00:00.000
 In C++, you don't need to repeat the name "string," and you don't use the new operator.

00:00:00.000 --> 00:00:00.000
 So this is a string object. Now, if we did that in Java, we would have a string variable,

00:00:00.000 --> 00:00:00.000
 but the variable would not be a string object. It would not refer to a string object at that point.

00:00:00.000 --> 00:00:00.000
 In C++, when you create a class type, you do not need to call the constructor explicitly.

00:00:00.000 --> 00:00:00.000
 It is automatically implicitly called.

00:00:00.000 --> 00:00:00.000
 So this is the same as writing "string s = " the empty quote.

00:00:00.000 --> 00:00:00.000
 So, it is the empty string.

00:00:00.000 --> 00:00:00.000
 We can also do it exactly like we do in Java, "string s = hello world."

00:00:00.000 --> 00:00:00.000
 And, again, that works just the same in C++ as it does in Java, more or less.

00:00:00.000 --> 00:00:00.000
 You can also use parentheses or braces around it.

00:00:00.000 --> 00:00:00.000
 So I can say "string s," not use the equal sign, and use the new style, "uniform initialization," if I want.

00:00:00.000 --> 00:00:00.000
 I also have some more complex constructors.

00:00:00.000 --> 00:00:00.000
 For instance, I can tell it how many characters I want and tell it the character I want.

00:00:00.000 --> 00:00:00.000
 So here, this string is 50 dashes. That's really useful sometimes.

00:00:00.000 --> 00:00:00.000
 I can take a C-style string and extract part of it, like taking a substring.

00:00:00.000 --> 00:00:00.000
 So here I'm constructing a string from the literal "hello" and I'm getting the first through third characters.

00:00:00.000 --> 00:00:00.000
 I'm getting three characters from it.

00:00:00.000 --> 00:00:00.000
 So I'm getting "ell" starts at index 1, which is the "e," of course, and gives me three characters.

00:00:00.000 --> 00:00:00.000
 And finally, if you've ever had to use escape characters in Java, in C++ you can get around that by creating what's called a "raw" string.

00:00:00.000 --> 00:00:00.000
 So a raw string starts with a capital "R," a quote, and a left paren, and then what you want inside the parentheses.

00:00:00.000 --> 00:00:00.000
 So notice that this is not an escape character. This is not a delimiter.

00:00:00.000 --> 00:00:00.000
 This is literally the thing that will appear out.

00:00:00.000 --> 00:00:00.000
 So if you ever have to do something where you would need to escape a string, using a raw string is a useful thing.

00:00:00.000 --> 00:00:00.000
 Notice it ends with the parentheses and quote.

00:00:00.000 --> 00:00:00.000
 So quote, paren on the beginning, and paren, quote on the end of it.

00:00:00.000 --> 00:00:00.000
 Everything between is just passed through as if it were a raw string.

00:00:00.000 --> 00:00:00.000
 Now, a C++ string is a library type like it is in Java, but it's a value type.

00:00:00.000 --> 00:00:00.000
 In Java, the library types are all references types.

00:00:00.000 --> 00:00:00.000
 So that means that the C++ library types act like the built-in types when it comes to assignment and copying and all of those kinds of features when it comes to comparison.

00:00:00.000 --> 00:00:00.000
 So let's see how that works.

00:00:00.000 --> 00:00:00.000
 So here is a Java reference type.

00:00:00.000 --> 00:00:00.000
 Notice I've used the capital string for Java.

00:00:00.000 --> 00:00:00.000
 I've created a string "A," pointed it to "Hello," so I have a string variable.

00:00:00.000 --> 00:00:00.000
 That string variable points to the word "Hi," not "Hello."

00:00:00.000 --> 00:00:00.000
 Then I create a second string and assign it to "B."

00:00:00.000 --> 00:00:00.000
 That creates another variable, but it doesn't create another copy of the word "Hi."

00:00:00.000 --> 00:00:00.000
 We have one string object with Java.

00:00:00.000 --> 00:00:00.000
 C++ acts as if these strings were integers.

00:00:00.000 --> 00:00:00.000
 It uses value or copy assignment.

00:00:00.000 --> 00:00:00.000
 Java uses reference assignment.

00:00:00.000 --> 00:00:00.000
 And so when I write the same thing in C++, when I create the string "A," "A" contains "By."

00:00:00.000 --> 00:00:00.000
 It's not a variable that points to "Hi." It's a variable that points to "By." It contains "By."

00:00:00.000 --> 00:00:00.000
 When I say "B" equals "A," I get another copy of the "By."

00:00:00.000 --> 00:00:00.000
 I have two copies of strings, two string objects here, one string object in Java.

00:00:00.000 --> 00:00:00.000
 So how else are C++ strings like built-in types unlike Java's types?

00:00:00.000 --> 00:00:00.000
 Well, we can use native operator comparison.

00:00:00.000 --> 00:00:00.000
 In Java, you have to use the method equals or compareTo.

00:00:00.000 --> 00:00:00.000
 So if I have two string objects, "A" is Zebra, "B" is Aardvark, I can say if "A" less than "B," illegal in Java.

00:00:00.000 --> 00:00:00.000
 Or if "A" equals equals "B," that's legal in Java, but it's kind of meaningless.

00:00:00.000 --> 00:00:00.000
 You really should use equals in that case.

00:00:00.000 --> 00:00:00.000
 Now, strings in C++ may be modified.

00:00:00.000 --> 00:00:00.000
 Java strings may not. Java strings are immutable.

00:00:00.000 --> 00:00:00.000
 So it's legal to do this. I've created a string str that contains "Hello."

00:00:00.000 --> 00:00:00.000
 I've constructed it from this C-style string.

00:00:00.000 --> 00:00:00.000
 And then I've gone in and I've changed the zeroth element to the character "J."

00:00:00.000 --> 00:00:00.000
 So this string now contains "Jello."

00:00:00.000 --> 00:00:00.000
 Again, this is illegal in Java.

00:00:00.000 --> 00:00:00.000
 Now, like Java, C++ strings can be concatenated to either string literals or to characters.

00:00:00.000 --> 00:00:00.000
 So if I have two strings, "Hello" and "World," I can say str3 equals str1 plus, and this can be a string literal or it could be a character.

00:00:00.000 --> 00:00:00.000
 So notice I've got a character here at the end. That works fine.

00:00:00.000 --> 00:00:00.000
 I've got a string literal here. That works fine.

00:00:00.000 --> 00:00:00.000
 What you cannot do, though, because string literals are not string objects, you cannot concatenate C string literals.

00:00:00.000 --> 00:00:00.000
 You also cannot concatenate numbers.

00:00:00.000 --> 00:00:00.000
 So if I did this, str1 equals "Hello," a C string literal, plus another C string literal, plus "World," that would be illegal.

00:00:00.000 --> 00:00:00.000
 Now, just to tell you how you can actually do that without this, is if you leave off the plus signs,

00:00:00.000 --> 00:00:00.000
 any C string literals that appear in code that are adjacent to each other will be automatically concatenated.

00:00:00.000 --> 00:00:00.000
 You don't need the plus sign, and that would work perfectly fine.

00:00:00.000 --> 00:00:00.000
 Another thing we might want to do in Java that's illegal in C++ is we might want to say concatenate a string plus a number

00:00:00.000 --> 00:00:00.000
 and have a new string that says "amount 23.45" as a string.

00:00:00.000 --> 00:00:00.000
 That's, again, illegal in C++.

00:00:00.000 --> 00:00:00.000
 How about input and output? So with cin and cout, we can do that with strings.

00:00:00.000 --> 00:00:00.000
 Again, you have to include string when you do this.

00:00:00.000 --> 00:00:00.000
 So here's a string called "firstname." I've printed out "firstname" for my prompt.

00:00:00.000 --> 00:00:00.000
 Notice I've ended in a little space, and then I've just read it like that.

00:00:00.000 --> 00:00:00.000
 Now, that will read only the first name.

00:00:00.000 --> 00:00:00.000
 What if your first name has two words? It won't work.

00:00:00.000 --> 00:00:00.000
 It reads only one token. It stops on any whitespace character.

00:00:00.000 --> 00:00:00.000
 What if I wanted to read the whole name?

00:00:00.000 --> 00:00:00.000
 Well, to read the whole name, I need to use a function, not just cin, but I need to pass cin to a function called "getline."

00:00:00.000 --> 00:00:00.000
 This is a function in the string header. It's not in Iostream, so you have to include string.

00:00:00.000 --> 00:00:00.000
 And so here's a full name.

00:00:00.000 --> 00:00:00.000
 Then I've printed out "cout fullname," and I've given them a little example, last comma first, of what I want.

00:00:00.000 --> 00:00:00.000
 And then I've done "getline." The first argument to "getline" is where I want to get the data from.

00:00:00.000 --> 00:00:00.000
 In this case, I want to read from cin.

00:00:00.000 --> 00:00:00.000
 And the second argument is an empty string that is going to be filled in inside the function.

00:00:00.000 --> 00:00:00.000
 We call this a reference parameter or an output parameter.

00:00:00.000 --> 00:00:00.000
 So "getline" to read a line, just cin with the extraction operator here to read only a word.

00:00:00.000 --> 00:00:00.000
 Now, as in Java, objects have methods associated with them.

00:00:00.000 --> 00:00:00.000
 So when you create an object, there are functions associated with that object.

00:00:00.000 --> 00:00:00.000
 In C++, we actually call them member functions instead of methods.

00:00:00.000 --> 00:00:00.000
 But member functions and methods are synonymous with each other.

00:00:00.000 --> 00:00:00.000
 So the number of characters from a string you can get with str.size or str.length.

00:00:00.000 --> 00:00:00.000
 Size is shorter, it's less words, and if you remember in Java, if you had the string type,

00:00:00.000 --> 00:00:00.000
 you called str.length as a function, a member function or a method.

00:00:00.000 --> 00:00:00.000
 If you had an array, you called a.length but didn't put the parenthesis around it.

00:00:00.000 --> 00:00:00.000
 And if you had an array list to get the number of elements, you did list.size.

00:00:00.000 --> 00:00:00.000
 Well, in C++, you can use size for everything.

00:00:00.000 --> 00:00:00.000
 So size is shorter, it works for everything, so I just forget about using length at all, even though you can.

00:00:00.000 --> 00:00:00.000
 Now, another difference between Java, when we get the number of characters,

00:00:00.000 --> 00:00:00.000
 is in C++, the value that's returned is an unsigned number.

00:00:00.000 --> 00:00:00.000
 And it has its own type.

00:00:00.000 --> 00:00:00.000
 The type of the number returned from string is string colon colon size type.

00:00:00.000 --> 00:00:00.000
 Now, the colon colon here, you remember, is the scope operator.

00:00:00.000 --> 00:00:00.000
 And in this context, the scope operator means the size type that is defined inside the string class.

00:00:00.000 --> 00:00:00.000
 It tells us the size type from the string type.

00:00:00.000 --> 00:00:00.000
 And each type, if we had a vector, it would be vector colon colon size type.

00:00:00.000 --> 00:00:00.000
 Now, that's kind of a lot of typing.

00:00:00.000 --> 00:00:00.000
 To type string colon colon size type, len equals str.size.

00:00:00.000 --> 00:00:00.000
 And so you can reduce typing by using the general type, which is what I'll do normally,

00:00:00.000 --> 00:00:00.000
 and that is size underscore t.

00:00:00.000 --> 00:00:00.000
 This is the general size type.

00:00:00.000 --> 00:00:00.000
 Now, don't use int.

00:00:00.000 --> 00:00:00.000
 And don't compare int to a variable.

00:00:00.000 --> 00:00:00.000
 So, many of you in Java were used to doing something like this.

00:00:00.000 --> 00:00:00.000
 For int i equals zero, i less than s size.

00:00:00.000 --> 00:00:00.000
 You notice our compiler is set up so this will not even compile.

00:00:00.000 --> 00:00:00.000
 That's because i is an int, s.size is this unsigned type, and you cannot compare them legally.

00:00:00.000 --> 00:00:00.000
 You cannot compare them safely.

00:00:00.000 --> 00:00:00.000
 Okay, so we select an individual character in a string by indexing.

00:00:00.000 --> 00:00:00.000
 So you're probably familiar with this with arrays from both Java or Python.

00:00:00.000 --> 00:00:00.000
 So legal subscripts are from zero to the string size minus one.

00:00:00.000 --> 00:00:00.000
 So string size, of course, is outside the bounds of the array.

00:00:00.000 --> 00:00:00.000
 You can do this two ways.

00:00:00.000 --> 00:00:00.000
 You can use the subscript operator, the square brackets that you're familiar with with arrays.

00:00:00.000 --> 00:00:00.000
 So if I create a string hello, I can say str sub zero equals j.

00:00:00.000 --> 00:00:00.000
 Now, in Java, you would expect if you went outside the bounds of the array,

00:00:00.000 --> 00:00:00.000
 like str bracket bracket five, we pronounce this str subs five, or str sub five equals that.

00:00:00.000 --> 00:00:00.000
 Notice that that would be beyond the O.

00:00:00.000 --> 00:00:00.000
 It would be in this position out here, and we would get an exception thrown.

00:00:00.000 --> 00:00:00.000
 In C++, you will not.

00:00:00.000 --> 00:00:00.000
 It is not range checked.

00:00:00.000 --> 00:00:00.000
 It's up to you to say in bounds.

00:00:00.000 --> 00:00:00.000
 Because of that, because it's obvious that all of us frequently make mistakes when we're programming or when we're typing,

00:00:00.000 --> 00:00:00.000
 C++ has a simpler, the string class has a simpler and safer way to do it,

00:00:00.000 --> 00:00:00.000
 which is the method called at.

00:00:00.000 --> 00:00:00.000
 So this is range checked, and this is the preferred way to do this.

00:00:00.000 --> 00:00:00.000
 So string str equals hello, str at zero equals j, that's okay,

00:00:00.000 --> 00:00:00.000
 and str at five equals the exclamation point.

00:00:00.000 --> 00:00:00.000
 This is safe because just like Java, this will throw an exception.

00:00:00.000 --> 00:00:00.000
 So you want to use at instead of the square brackets.

00:00:00.000 --> 00:00:00.000
 So let's look at extracting substrings.

00:00:00.000 --> 00:00:00.000
 You can copy a portion of a string into another string.

00:00:00.000 --> 00:00:00.000
 That's called a substring.

00:00:00.000 --> 00:00:00.000
 In Java, you do this with a method called substring.

00:00:00.000 --> 00:00:00.000
 In Java, this method uses two indexes, pos1 and pos2.

00:00:00.000 --> 00:00:00.000
 So if I have the string, hello world, and I ask for the substring from six to 11,

00:00:00.000 --> 00:00:00.000
 it goes zero, one, two, three, four, five, six, so it's going to start at w,

00:00:00.000 --> 00:00:00.000
 seven, eight, nine, ten, and it's going to stop when it reaches 11.

00:00:00.000 --> 00:00:00.000
 So this will be world without the exclamation point.

00:00:00.000 --> 00:00:00.000
 C++ changes the name, it's substr, not with substring,

00:00:00.000 --> 00:00:00.000
 and it is simpler.

00:00:00.000 --> 00:00:00.000
 If we wanted the same characters world, we'd say start at six, which is the w,

00:00:00.000 --> 00:00:00.000
 and give me just five characters.

00:00:00.000 --> 00:00:00.000
 So to count one, two, three, four, five, and it'd give me world.

00:00:00.000 --> 00:00:00.000
 I don't need to figure out where this ending index is like I do with Java.

00:00:00.000 --> 00:00:00.000
 So if you're used to programming in Java, keep this in mind.

00:00:00.000 --> 00:00:00.000
 Now, there is only one exception thrown by substring,

00:00:00.000 --> 00:00:00.000
 and that is if this initial position is greater than the string size.

00:00:00.000 --> 00:00:00.000
 Well, you might ask, well, what if it is the string size?

00:00:00.000 --> 00:00:00.000
 Shouldn't that be out of range?

00:00:00.000 --> 00:00:00.000
 No, in that case, the substring will return an empty string to you.

00:00:00.000 --> 00:00:00.000
 So if pos1 is greater than the string size, you'll get an exception.

00:00:00.000 --> 00:00:00.000
 If the length, this five here, is larger than the numbers accepted,

00:00:00.000 --> 00:00:00.000
 it'll only give you the ones that are there.

00:00:00.000 --> 00:00:00.000
 You can also call substring with only one argument,

00:00:00.000 --> 00:00:00.000
 and if you do that, it'll just give you from that position

00:00:00.000 --> 00:00:00.000
 to the rest of the characters in the string.

00:00:00.000 --> 00:00:00.000
 So we're going to do an exercise with substrings,

00:00:00.000 --> 00:00:00.000
 but first I want to talk about references.

00:00:00.000 --> 00:00:00.000
 What is a reference?

00:00:00.000 --> 00:00:00.000
 Because we're going to write a function that works on a substring,

00:00:00.000 --> 00:00:00.000
 and so we have to learn how to pass strings to functions.

00:00:00.000 --> 00:00:00.000
 So a reference is a C++ derived type.

00:00:00.000 --> 00:00:00.000
 It's based on other types,

00:00:00.000 --> 00:00:00.000
 and it's basically a name that acts as an alias for a variable.

00:00:00.000 --> 00:00:00.000
 It is not a new variable.

00:00:00.000 --> 00:00:00.000
 So here I have one variable, a, that has the value 42,

00:00:00.000 --> 00:00:00.000
 and here I've given a a new name, b.

00:00:00.000 --> 00:00:00.000
 So I have two names for one object in memory.

00:00:00.000 --> 00:00:00.000
 I've said b is a reference to an int,

00:00:00.000 --> 00:00:00.000
 and the int it references is a.

00:00:00.000 --> 00:00:00.000
 b is just another name for a.

00:00:00.000 --> 00:00:00.000
 These are not references like in Java or C#.

00:00:00.000 --> 00:00:00.000
 References in Java and C# are much closer to what we call pointers in C++,

00:00:00.000 --> 00:00:00.000
 and we'll study those later.

00:00:00.000 --> 00:00:00.000
 Now, references can only refer to L values or variables.

00:00:00.000 --> 00:00:00.000
 So if I were to say n is a reference to an int,

00:00:00.000 --> 00:00:00.000
 and I refer it to 42,

00:00:00.000 --> 00:00:00.000
 42 is not an int variable.

00:00:00.000 --> 00:00:00.000
 It's not an object, so that would be illegal.

00:00:00.000 --> 00:00:00.000
 Now, there are also no conversions possible.

00:00:00.000 --> 00:00:00.000
 Only exact type matches.

00:00:00.000 --> 00:00:00.000
 So if I said pi is 3.1459,

00:00:00.000 --> 00:00:00.000
 and I tried to write int ref pi2 = pi,

00:00:00.000 --> 00:00:00.000
 I'd get an error. Why?

00:00:00.000 --> 00:00:00.000
 Because pi2 is a reference to an int,

00:00:00.000 --> 00:00:00.000
 and I've given it a double here.

00:00:00.000 --> 00:00:00.000
 Now, of course, if these were values,

00:00:00.000 --> 00:00:00.000
 if I said int pi2 = pi,

00:00:00.000 --> 00:00:00.000
 it would simply truncate this and give me a new value of 3 in pi.

00:00:00.000 --> 00:00:00.000
 But a reference is not a new variable.

00:00:00.000 --> 00:00:00.000
 It refers to something that already exists.

00:00:00.000 --> 00:00:00.000
 Of course, to get it right, I'd have to write double ref pi3 = pi.

00:00:00.000 --> 00:00:00.000
 This is an exact match. That works OK.

00:00:00.000 --> 00:00:00.000
 Now, what are references good for?

00:00:00.000 --> 00:00:00.000
 Well, references are useful because we pass them to functions.

00:00:00.000 --> 00:00:00.000
 A reference parameter, like this string ref s,

00:00:00.000 --> 00:00:00.000
 is not a new variable,

00:00:00.000 --> 00:00:00.000
 and you indicate that it's a reference by putting the ampersand

00:00:00.000 --> 00:00:00.000
 after the variable's type.

00:00:00.000 --> 00:00:00.000
 So that says the reverse function is not going to take,

00:00:00.000 --> 00:00:00.000
 as its argument, a copy of the string.

00:00:00.000 --> 00:00:00.000
 It's going to work on the string that you pass to it.

00:00:00.000 --> 00:00:00.000
 Now, if I were to change s inside this function,

00:00:00.000 --> 00:00:00.000
 which obviously the reverse function is going to do,

00:00:00.000 --> 00:00:00.000
 it would change the argument that s was used to call the function with.

00:00:00.000 --> 00:00:00.000
 These are called output parameters.

00:00:00.000 --> 00:00:00.000
 So here I've got string str = "hello",

00:00:00.000 --> 00:00:00.000
 and here I have reverse str.

00:00:00.000 --> 00:00:00.000
 We're going to ignore that phone that's ringing in the background here for a second.

00:00:00.000 --> 00:00:00.000
 There, it stopped.

00:00:00.000 --> 00:00:00.000
 So notice that I've called it with the function str,

00:00:00.000 --> 00:00:00.000
 but inside the function,

00:00:00.000 --> 00:00:00.000
 that str is simply s is simply another name for this function str.

00:00:00.000 --> 00:00:00.000
 When I print out str, of course the reverse function will reverse the arguments.

00:00:00.000 --> 00:00:00.000
 We're going to write this function a little bit later, not today.

00:00:00.000 --> 00:00:00.000
 Now, reference parameters, the reason we use reference parameters

00:00:00.000 --> 00:00:00.000
 is because they're much more efficient than value parameters

00:00:00.000 --> 00:00:00.000
 for large objects like string.

00:00:00.000 --> 00:00:00.000
 You remember in Java, when we make a copy of a string,

00:00:00.000 --> 00:00:00.000
 we actually don't make a copy of the string object.

00:00:00.000 --> 00:00:00.000
 We simply create another variable that points to the one variable.

00:00:00.000 --> 00:00:00.000
 Since C++ doesn't work like that,

00:00:00.000 --> 00:00:00.000
 if we had parameters that were strings,

00:00:00.000 --> 00:00:00.000
 every time you called the function, you'd make a copy of the entire string.

00:00:00.000 --> 00:00:00.000
 And so with references, no copies are made,

00:00:00.000 --> 00:00:00.000
 and so less memory is used.

00:00:00.000 --> 00:00:00.000
 And because no constructors are called to make those copies,

00:00:00.000 --> 00:00:00.000
 they run faster.

00:00:00.000 --> 00:00:00.000
 But there's a downside.

00:00:00.000 --> 00:00:00.000
 Reference parameters are also more dangerous,

00:00:00.000 --> 00:00:00.000
 and they're not quite as flexible.

00:00:00.000 --> 00:00:00.000
 That's because with a reference parameter,

00:00:00.000 --> 00:00:00.000
 you may accidentally change an argument

00:00:00.000 --> 00:00:00.000
 when you didn't mean to change that argument.

00:00:00.000 --> 00:00:00.000
 And so C++ prevents that

00:00:00.000 --> 00:00:00.000
 by providing you with constant references.

00:00:00.000 --> 00:00:00.000
 And so if I were writing a function called print,

00:00:00.000 --> 00:00:00.000
 and I wanted to print a string,

00:00:00.000 --> 00:00:00.000
 I wouldn't say "string s" because that would be expensive.

00:00:00.000 --> 00:00:00.000
 It would use more memory, and it would run slower.

00:00:00.000 --> 00:00:00.000
 I wouldn't say "string ref s"

00:00:00.000 --> 00:00:00.000
 because I don't expect the print function to change this string.

00:00:00.000 --> 00:00:00.000
 Instead, I'd write "const string ref s."

00:00:00.000 --> 00:00:00.000
 So any time we have a function that takes a string as an argument,

00:00:00.000 --> 00:00:00.000
 and we don't intend to change that string inside the function,

00:00:00.000 --> 00:00:00.000
 we're going to pass it as "const string ref."

00:00:00.000 --> 00:00:00.000
 So let's go ahead and do that,

00:00:00.000 --> 00:00:00.000
 and we'll do our first exercise, the substring member function.

00:00:00.000 --> 00:00:00.000
 So let me pull up my thing here.

00:00:00.000 --> 00:00:00.000
 I'm going to go over to IC05A,

00:00:00.000 --> 00:00:00.000
 and we're going to write the function called inside out.

00:00:00.000 --> 00:00:00.000
 So you're going to put your name on this.

00:00:00.000 --> 00:00:00.000
 And I'm going to look here at the starter code.

00:00:00.000 --> 00:00:00.000
 We're going to write a function called inside out

00:00:00.000 --> 00:00:00.000
 that takes a string as an argument and returns a new string

00:00:00.000 --> 00:00:00.000
 where the middle character, if the string length is odd, has been removed,

00:00:00.000 --> 00:00:00.000
 and placed both at the beginning and the end.

00:00:00.000 --> 00:00:00.000
 If the string length is even, then the middle two characters are removed

00:00:00.000 --> 00:00:00.000
 with the first placed before and the second placed after the string.

00:00:00.000 --> 00:00:00.000
 If the length of the string is less than three,

00:00:00.000 --> 00:00:00.000
 then we're going to return the original string.

00:00:00.000 --> 00:00:00.000
 And here are three examples that show you those possibilities.

00:00:00.000 --> 00:00:00.000
 So what we want now is just how we write this function.

00:00:00.000 --> 00:00:00.000
 So remember the six steps.

00:00:00.000 --> 00:00:00.000
 What does this function produce?

00:00:00.000 --> 00:00:00.000
 It's producing a new string.

00:00:00.000 --> 00:00:00.000
 What's the name of the function?

00:00:00.000 --> 00:00:00.000
 Inside out.

00:00:00.000 --> 00:00:00.000
 What is it going to take?

00:00:00.000 --> 00:00:00.000
 It's going to take a string that doesn't change.

00:00:00.000 --> 00:00:00.000
 So const string reference str.

00:00:00.000 --> 00:00:00.000
 What's it going to return?

00:00:00.000 --> 00:00:00.000
 A new string.

00:00:00.000 --> 00:00:00.000
 So string result;.

00:00:00.000 --> 00:00:00.000
 Notice we do not need to write equals quote, quote.

00:00:00.000 --> 00:00:00.000
 That will call the constructor automatically and create the empty string

00:00:00.000 --> 00:00:00.000
 and return result.

00:00:00.000 --> 00:00:00.000
 Okay, we have our stub.

00:00:00.000 --> 00:00:00.000
 We're going to right click on A here.

00:00:00.000 --> 00:00:00.000
 Open it terminal on A.

00:00:00.000 --> 00:00:00.000
 And we're going to do make test.

00:00:00.000 --> 00:00:00.000
 And I got a warning.

00:00:00.000 --> 00:00:00.000
 Now I'm going to move this over here to the side so we can see the whole thing.

00:00:00.000 --> 00:00:00.000
 I got a warning telling me I'm not using this parameter.

00:00:00.000 --> 00:00:00.000
 But notice my code compiles and it runs.

00:00:00.000 --> 00:00:00.000
 Compiles and it runs.

00:00:00.000 --> 00:00:00.000
 Okay, let's move that down to the bottom here.

00:00:00.000 --> 00:00:00.000
 And let's look at our code.

00:00:00.000 --> 00:00:00.000
 So we have three possibilities here, right?

00:00:00.000 --> 00:00:00.000
 Remember looking here, we have this case, it's less than three.

00:00:00.000 --> 00:00:00.000
 We have this case, it's odd.

00:00:00.000 --> 00:00:00.000
 And this case, it's even.

00:00:00.000 --> 00:00:00.000
 So let's write that skeleton out.

00:00:00.000 --> 00:00:00.000
 Remembering what we learned in the last lecture about selection.

00:00:00.000 --> 00:00:00.000
 So if something result equals str.

00:00:00.000 --> 00:00:00.000
 Else if something else, else this.

00:00:00.000 --> 00:00:00.000
 So what are these possibilities?

00:00:00.000 --> 00:00:00.000
 Well this is if str size is less than three.

00:00:00.000 --> 00:00:00.000
 The result is str.

00:00:00.000 --> 00:00:00.000
 This is if str size remainder two equals one.

00:00:00.000 --> 00:00:00.000
 This is odd.

00:00:00.000 --> 00:00:00.000
 And this one of course is even.

00:00:00.000 --> 00:00:00.000
 Okay, so what do we want to do if it's odd or even?

00:00:00.000 --> 00:00:00.000
 Now you notice I've used str size here, str size here.

00:00:00.000 --> 00:00:00.000
 And I'm going to have to use it again.

00:00:00.000 --> 00:00:00.000
 So you might want to say create a variable for it.

00:00:00.000 --> 00:00:00.000
 Now we can do this.

00:00:00.000 --> 00:00:00.000
 String colon colon size type.

00:00:00.000 --> 00:00:00.000
 Len equals str size.

00:00:00.000 --> 00:00:00.000
 Or both.

00:00:00.000 --> 00:00:00.000
 We can do size t.

00:00:00.000 --> 00:00:00.000
 Len equals str size.

00:00:00.000 --> 00:00:00.000
 I prefer this.

00:00:00.000 --> 00:00:00.000
 Or we can use auto len.

00:00:00.000 --> 00:00:00.000
 That's also okay.

00:00:00.000 --> 00:00:00.000
 So I'm going to actually use the last one here.

00:00:00.000 --> 00:00:00.000
 Okay, and now I can come along and I can say,

00:00:00.000 --> 00:00:00.000
 now I don't have to calculate the size again, right?

00:00:00.000 --> 00:00:00.000
 I can say if length is less than three.

00:00:00.000 --> 00:00:00.000
 If length remainder two equals one.

00:00:00.000 --> 00:00:00.000
 And now if I need to use len and these other ones, which I will,

00:00:00.000 --> 00:00:00.000
 I don't have to call str size again.

00:00:00.000 --> 00:00:00.000
 So in general, any time you call a member function,

00:00:00.000 --> 00:00:00.000
 if you're going to not change that value, save it inside a variable.

00:00:00.000 --> 00:00:00.000
 Cache it. Use it again later.

00:00:00.000 --> 00:00:00.000
 So let's look at our problem.

00:00:00.000 --> 00:00:00.000
 Okay, so if the length is odd,

00:00:00.000 --> 00:00:00.000
 we're going to take the middle character

00:00:00.000 --> 00:00:00.000
 and place it both at the beginning and the end.

00:00:00.000 --> 00:00:00.000
 So let's find out where the middle character.

00:00:00.000 --> 00:00:00.000
 So I'll do char mid equals str at len divided by two.

00:00:00.000 --> 00:00:00.000
 That's the middle character.

00:00:00.000 --> 00:00:00.000
 Notice I used len again so I didn't have to say str size.

00:00:00.000 --> 00:00:00.000
 I'm going to set result equals to the mid character.

00:00:00.000 --> 00:00:00.000
 Remember I'm putting it at the beginning and end.

00:00:00.000 --> 00:00:00.000
 Plus str, substr.

00:00:00.000 --> 00:00:00.000
 Starting at position zero,

00:00:00.000 --> 00:00:00.000
 I'm going up to len divided by two.

00:00:00.000 --> 00:00:00.000
 Not going up to, but taking that many characters.

00:00:00.000 --> 00:00:00.000
 And then I'm going to add to that the substring.

00:00:00.000 --> 00:00:00.000
 Starting at len divided by two plus one.

00:00:00.000 --> 00:00:00.000
 Right after the middle character.

00:00:00.000 --> 00:00:00.000
 Finally, I'm going to add on the middle character again.

00:00:00.000 --> 00:00:00.000
 Okay, so that's the odd one.

00:00:00.000 --> 00:00:00.000
 Now with the even one,

00:00:00.000 --> 00:00:00.000
 with the even one, we get the middle two characters.

00:00:00.000 --> 00:00:00.000
 So let's do ourselves a little example here.

00:00:00.000 --> 00:00:00.000
 Many times it helps me a lot.

00:00:00.000 --> 00:00:00.000
 So frog is a string that's larger than two,

00:00:00.000 --> 00:00:00.000
 or larger than three, and is even number.

00:00:00.000 --> 00:00:00.000
 And so the middle one, if I divide that size by four,

00:00:00.000 --> 00:00:00.000
 let me do this, size is four,

00:00:00.000 --> 00:00:00.000
 mid would be two.

00:00:00.000 --> 00:00:00.000
 Do I want the character at two?

00:00:00.000 --> 00:00:00.000
 Zero, one, two.

00:00:00.000 --> 00:00:00.000
 No, I want the middle two, so I want r.

00:00:00.000 --> 00:00:00.000
 So I want mid minus one, right for that.

00:00:00.000 --> 00:00:00.000
 And I want two characters, so I can't use a char type.

00:00:00.000 --> 00:00:00.000
 So I'm going to do string mid equals str, substring.

00:00:00.000 --> 00:00:00.000
 Starting at len minus two.

00:00:00.000 --> 00:00:00.000
 That would give me the o, len divided by two, I'm sorry.

00:00:00.000 --> 00:00:00.000
 Minus one.

00:00:00.000 --> 00:00:00.000
 That would give me the r in frog.

00:00:00.000 --> 00:00:00.000
 And again, do this on a piece of paper if you want,

00:00:00.000 --> 00:00:00.000
 but draw yourself a little picture so you know what these calculations are going to be each time.

00:00:00.000 --> 00:00:00.000
 And I want two characters.

00:00:00.000 --> 00:00:00.000
 Now, this time I'm going to create a couple of variables for it.

00:00:00.000 --> 00:00:00.000
 Here I just created the calculations without the variables.

00:00:00.000 --> 00:00:00.000
 Let me create the variables so you see what I was doing in this calculation.

00:00:00.000 --> 00:00:00.000
 So I'm going to say string front equals str, substring.

00:00:00.000 --> 00:00:00.000
 Starting at zero, going up to len minus two, divided by two, minus one.

00:00:00.000 --> 00:00:00.000
 And string back equals str, substring, len divided by two, plus one.

00:00:00.000 --> 00:00:00.000
 Which is exactly the same as this.

00:00:00.000 --> 00:00:00.000
 So this is the back part.

00:00:00.000 --> 00:00:00.000
 This is the front part of the string.

00:00:00.000 --> 00:00:00.000
 And here I can do result equals mid at zero, or like that.

00:00:00.000 --> 00:00:00.000
 Or in fact I can say mid front, like that.

00:00:00.000 --> 00:00:00.000
 Either of those work.

00:00:00.000 --> 00:00:00.000
 So I'm going to say mid at zero plus front plus back, plus mid at one.

00:00:00.000 --> 00:00:00.000
 And here of course I could write, or since there are only two characters, right?

00:00:00.000 --> 00:00:00.000
 Alright, that looks pretty good.

00:00:00.000 --> 00:00:00.000
 Let's go ahead and see if we got it correct.

00:00:00.000 --> 00:00:00.000
 Let's clear this with control L.

00:00:00.000 --> 00:00:00.000
 Do make test.

00:00:00.000 --> 00:00:00.000
 Ok, we didn't get any errors or any warnings this time.

00:00:00.000 --> 00:00:00.000
 And all of our tests pass.

00:00:00.000 --> 00:00:00.000
 All of our tests pass.

00:00:00.000 --> 00:00:00.000
 Alright, let's go ahead now

00:00:00.000 --> 00:00:00.000
 and look at searching for strings and characters.

00:00:00.000 --> 00:00:00.000
 So in Java, you search for a string or character using indexOf and lastIndexOf.

00:00:00.000 --> 00:00:00.000
 And you get back of course the index where that string exists.

00:00:00.000 --> 00:00:00.000
 The same thing with Java, but you use the member function find.

00:00:00.000 --> 00:00:00.000
 So find will return the position where arg is found in str.

00:00:00.000 --> 00:00:00.000
 And arg can be a character, it can be a C string literal, or it can be a string object.

00:00:00.000 --> 00:00:00.000
 Now in Java, when indexOf can't find the position, it returns minus one.

00:00:00.000 --> 00:00:00.000
 However, find, like size, doesn't return an integer.

00:00:00.000 --> 00:00:00.000
 It returns a string colon colon size type, which is an unsigned number.

00:00:00.000 --> 00:00:00.000
 Thus we have to have a special value that signifies that it wasn't found.

00:00:00.000 --> 00:00:00.000
 That special value is called string colon colon inpos.

00:00:00.000 --> 00:00:00.000
 Inpos says no position found.

00:00:00.000 --> 00:00:00.000
 That's how you think of it.

00:00:00.000 --> 00:00:00.000
 Now there's an optional second argument to find.

00:00:00.000 --> 00:00:00.000
 You can say string find arg pos.

00:00:00.000 --> 00:00:00.000
 This would be good in a loop where you want to continue to look through the loop and find different copies of this by passing in different positions.

00:00:00.000 --> 00:00:00.000
 So this search for arg starting at pos in the string position.

00:00:00.000 --> 00:00:00.000
 Finally, the equivalent of lastIndexOf is called rfind.

00:00:00.000 --> 00:00:00.000
 And that will search from the right and find the last instance of that in the string.

00:00:00.000 --> 00:00:00.000
 So let's go ahead and do an example with the file, our second exercise called initials.

00:00:00.000 --> 00:00:00.000
 Alright.

00:00:00.000 --> 00:00:00.000
 Let's put that down. Let's bring this over here.

00:00:00.000 --> 00:00:00.000
 Let's close inside out.

00:00:00.000 --> 00:00:00.000
 Let's open up B, get initials.

00:00:00.000 --> 00:00:00.000
 And let's open up a terminal there.

00:00:00.000 --> 00:00:00.000
 So I can work on get initials.

00:00:00.000 --> 00:00:00.000
 By the way, you can close the previous terminals you had open here. Like that.

00:00:00.000 --> 00:00:00.000
 Okay, let's put our name on this.

00:00:00.000 --> 00:00:00.000
 Okay, so write a function named initials that takes a string containing a person's name, return a new string consisting of the person's initials.

00:00:00.000 --> 00:00:00.000
 So let's go ahead and write our stub first.

00:00:00.000 --> 00:00:00.000
 So it's going to return a string.

00:00:00.000 --> 00:00:00.000
 It's going to name initials.

00:00:00.000 --> 00:00:00.000
 It's going to take a new string, so const string reference str.

00:00:00.000 --> 00:00:00.000
 It's going to return a string, string result, and return result.

00:00:00.000 --> 00:00:00.000
 Let's go ahead and do make test on that.

00:00:00.000 --> 00:00:00.000
 Again, we got a warning because we're not using this string.

00:00:00.000 --> 00:00:00.000
 But in fact it worked okay.

00:00:00.000 --> 00:00:00.000
 Okay, so now we can go and think about it. So we want the person's initials.

00:00:00.000 --> 00:00:00.000
 So it will return sdg. We're going to assume that there's no space.

00:00:00.000 --> 00:00:00.000
 We're going to assume there's exactly three words, before or after.

00:00:00.000 --> 00:00:00.000
 And so what I want to do is find the position of the first space, the position of the last space.

00:00:00.000 --> 00:00:00.000
 And that will allow me to get the initials, the s, d, and g.

00:00:00.000 --> 00:00:00.000
 So I can say, the initials are char, right? So I can say char first equals str at zero, or str sub zero, or str.

00:00:00.000 --> 00:00:00.000
 All three of those will give me the first character.

00:00:00.000 --> 00:00:00.000
 For the middle, I want auto. I'm going to use auto instead of size t, or I could use size t.

00:00:00.000 --> 00:00:00.000
 I'll use size t here. Size t first space equals first find.

00:00:00.000 --> 00:00:00.000
 Here I'm going to use a quote for the space.

00:00:00.000 --> 00:00:00.000
 So I know that my second initial equals str at first space plus one.

00:00:00.000 --> 00:00:00.000
 And my third one, I need the last space. So size p last space equals first r find.

00:00:00.000 --> 00:00:00.000
 Oh no, not first. I'm saying str r find.

00:00:00.000 --> 00:00:00.000
 Str find and str r find. Mistake there.

00:00:00.000 --> 00:00:00.000
 And this will be the position of the last space. And char third equals str at last space plus one.

00:00:00.000 --> 00:00:00.000
 And then the result equals first plus second plus third.

00:00:00.000 --> 00:00:00.000
 Okay, now this isn't going to work. Let's see why it doesn't work.

00:00:00.000 --> 00:00:00.000
 Let's do control L. I'm not sure it's even going to compile. Hit test.

00:00:00.000 --> 00:00:00.000
 Now it compiles. But look at I have a little weird thing inside here. What's that?

00:00:00.000 --> 00:00:00.000
 That's really pretty weird, isn't it?

00:00:00.000 --> 00:00:00.000
 Okay, so let me tell you what the problem is.

00:00:00.000 --> 00:00:00.000
 What kind of thing are first and second and third?

00:00:00.000 --> 00:00:00.000
 Those are chars. The built in type.

00:00:00.000 --> 00:00:00.000
 What do I get when I use this symbol with a char?

00:00:00.000 --> 00:00:00.000
 I don't get concatenation. I get addition.

00:00:00.000 --> 00:00:00.000
 So this is adding the ASCII value of this plus the ASCII value of that plus the ASCII value of that.

00:00:00.000 --> 00:00:00.000
 Obviously when we print it out, it doesn't think that it's any kind of printable character at all.

00:00:00.000 --> 00:00:00.000
 And so that doesn't work.

00:00:00.000 --> 00:00:00.000
 So we can get around this by doing quote quote S plus.

00:00:00.000 --> 00:00:00.000
 So now I have a string. Now I have concatenation.

00:00:00.000 --> 00:00:00.000
 Now I've got another string. I have concatenation. I have another string. And I have concatenation.

00:00:00.000 --> 00:00:00.000
 And so that would work. Make tests.

00:00:00.000 --> 00:00:00.000
 And so now all of them work. I get SDG, HST and so forth.

00:00:00.000 --> 00:00:00.000
 But that's really not a clean solution, is it?

00:00:00.000 --> 00:00:00.000
 It's kind of a "Oh, I did something wrong and I need to fix it."

00:00:00.000 --> 00:00:00.000
 The cleaner solution is not to make these chars in the first place.

00:00:00.000 --> 00:00:00.000
 Let's make those strings.

00:00:00.000 --> 00:00:00.000
 So string first.

00:00:00.000 --> 00:00:00.000
 Then it can't be string at. It needs to be string substring.

00:00:00.000 --> 00:00:00.000
 Zero. And one character. Same thing here.

00:00:00.000 --> 00:00:00.000
 String. Second equals third substring.

00:00:00.000 --> 00:00:00.000
 First base plus one. And we want one character inside that.

00:00:00.000 --> 00:00:00.000
 And string third.

00:00:00.000 --> 00:00:00.000
 Stir substring.

00:00:00.000 --> 00:00:00.000
 One.

00:00:00.000 --> 00:00:00.000
 OK. So this is clearer. Right?

00:00:00.000 --> 00:00:00.000
 And so this of course, we could not use those. That wouldn't work at all in that case.

00:00:00.000 --> 00:00:00.000
 OK. So let's try that.

00:00:00.000 --> 00:00:00.000
 Let's clear the thing and do a test again.

00:00:00.000 --> 00:00:00.000
 And we have a solution that works. And it's a little clearer when we look at it.

00:00:00.000 --> 00:00:00.000
 The last thing we're going to look at today before we end this lecture is we're going to look at range or iterator loops.

00:00:00.000 --> 00:00:00.000
 So C++11 introduced a new simplified called a range-based for loop.

00:00:00.000 --> 00:00:00.000
 And this will work with all collection types including string, including vector, and including the built-in array types.

00:00:00.000 --> 00:00:00.000
 Java has a similar loop called the simplified for loop introduced in Java 5.

00:00:00.000 --> 00:00:00.000
 But it doesn't work with string. It only works with the collection types in the library.

00:00:00.000 --> 00:00:00.000
 And so this is for the type of the element e and a colon and then the collection.

00:00:00.000 --> 00:00:00.000
 Now in Java, what this does is it goes into the collection, gets the first element, puts it in the local variable e,

00:00:00.000 --> 00:00:00.000
 and then you can work with that local variable e.

00:00:00.000 --> 00:00:00.000
 The next time through, it gets the second element, puts it in the e, and you work with the variable e.

00:00:00.000 --> 00:00:00.000
 So this is called value iteration.

00:00:00.000 --> 00:00:00.000
 So C++ has that.

00:00:00.000 --> 00:00:00.000
 You can use auto here or you could use the type. So you could use int or char, whatever the type is.

00:00:00.000 --> 00:00:00.000
 I frequently use auto so I don't have to think about it.

00:00:00.000 --> 00:00:00.000
 But that's the only kind you can do in Java.

00:00:00.000 --> 00:00:00.000
 In C++, you can actually not get each copy, but look at each element directly in the collection.

00:00:00.000 --> 00:00:00.000
 So this is called reference iteration.

00:00:00.000 --> 00:00:00.000
 This is what you want to do when you want to change each of the elements.

00:00:00.000 --> 00:00:00.000
 Finally, if you want to look at the elements, not make a copy, but you don't want to change them,

00:00:00.000 --> 00:00:00.000
 you want to make sure they're not changed, you can do a const reference.

00:00:00.000 --> 00:00:00.000
 So const auto ref e.

00:00:00.000 --> 00:00:00.000
 So we're going to do two exercises, flipper and upper.

00:00:00.000 --> 00:00:00.000
 OK, and for these, I'm going to look at the character functions to upper and to lower and is upper and is lower.

00:00:00.000 --> 00:00:00.000
 And we're going to skip those.

00:00:00.000 --> 00:00:00.000
 And we're going to look at how they're written.

00:00:00.000 --> 00:00:00.000
 So we're going to write a function flip case that takes a string as an argument and returns a new string.

00:00:00.000 --> 00:00:00.000
 Where every lower case character has been converted to upper case and vice versa.

00:00:00.000 --> 00:00:00.000
 We're not going to use any library functions at all.

00:00:00.000 --> 00:00:00.000
 That includes size or at or the square brackets or to upper or to lower.

00:00:00.000 --> 00:00:00.000
 Now normally we would use to upper and to lower.

00:00:00.000 --> 00:00:00.000
 OK, so let's bring that over. Let's drop that down.

00:00:00.000 --> 00:00:00.000
 Let's close up B.

00:00:00.000 --> 00:00:00.000
 Let's open up C and open up flipper.

00:00:00.000 --> 00:00:00.000
 And let me drop this over.

00:00:00.000 --> 00:00:00.000
 Put my name on that.

00:00:00.000 --> 00:00:00.000
 And I believe the thing was called flipper, right? No, flip case.

00:00:00.000 --> 00:00:00.000
 So string flip case.

00:00:00.000 --> 00:00:00.000
 We're not going to change this string. So it's constant string ref str.

00:00:00.000 --> 00:00:00.000
 We're going to have a string for the result.

00:00:00.000 --> 00:00:00.000
 And we're going to return the result.

00:00:00.000 --> 00:00:00.000
 OK, let's open a terminal there.

00:00:00.000 --> 00:00:00.000
 We'll go on C, right click, open an integrated folder.

00:00:00.000 --> 00:00:00.000
 And we will do make test.

00:00:00.000 --> 00:00:00.000
 And in fact it compiles and links. OK.

00:00:00.000 --> 00:00:00.000
 It compiles and links. OK.

00:00:00.000 --> 00:00:00.000
 We didn't get a warning this time. I'm not quite sure because we didn't use the str at all.

00:00:00.000 --> 00:00:00.000
 OK, so visit every element.

00:00:00.000 --> 00:00:00.000
 I'm going to look at every element. I'm not going to change it.

00:00:00.000 --> 00:00:00.000
 So for auto e in str.

00:00:00.000 --> 00:00:00.000
 Now because each thing is a character, let's call it C here.

00:00:00.000 --> 00:00:00.000
 So auto e in str.

00:00:00.000 --> 00:00:00.000
 Now there are three possibilities. Right?

00:00:00.000 --> 00:00:00.000
 Uppercase, lowercase, neither.

00:00:00.000 --> 00:00:00.000
 So if something

00:00:00.000 --> 00:00:00.000
 else if

00:00:00.000 --> 00:00:00.000
 else it's neither.

00:00:00.000 --> 00:00:00.000
 Now if it's neither, all we want to do is add result, add C to the result.

00:00:00.000 --> 00:00:00.000
 So result plus equals C.

00:00:00.000 --> 00:00:00.000
 Or result equals result plus C. It means the same thing.

00:00:00.000 --> 00:00:00.000
 Now how do I tell if it's uppercase?

00:00:00.000 --> 00:00:00.000
 Well, the uppercase characters look like A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, X, Y, Z.

00:00:00.000 --> 00:00:00.000
 And they're all contiguous.

00:00:00.000 --> 00:00:00.000
 It means they're right next to each other in memory.

00:00:00.000 --> 00:00:00.000
 So if C is greater or equal to the character A,

00:00:00.000 --> 00:00:00.000
 and C is less than or equal to the character Z,

00:00:00.000 --> 00:00:00.000
 then it's an uppercase. Right?

00:00:00.000 --> 00:00:00.000
 So that is in fact what the code is inside the isUpper function.

00:00:00.000 --> 00:00:00.000
 And the same thing for toLower.

00:00:00.000 --> 00:00:00.000
 isLower.

00:00:00.000 --> 00:00:00.000
 If C is greater or equal to the lowercase A,

00:00:00.000 --> 00:00:00.000
 and C is less than or equal to the lowercase Z,

00:00:00.000 --> 00:00:00.000
 then it's a lowercase character.

00:00:00.000 --> 00:00:00.000
 Now, let me put the lowercase characters here.

00:00:00.000 --> 00:00:00.000
 Okay, these characters start with the ASCII character 97.

00:00:00.000 --> 00:00:00.000
 That's the lowercase A.

00:00:00.000 --> 00:00:00.000
 And these characters start with the ASCII character 65.

00:00:00.000 --> 00:00:00.000
 So imagine that my character C here was the letter A.

00:00:00.000 --> 00:00:00.000
 It had the value 65.

00:00:00.000 --> 00:00:00.000
 I want to turn it to lowercase.

00:00:00.000 --> 00:00:00.000
 That means I have to change it to 97.

00:00:00.000 --> 00:00:00.000
 And so all I do is add the difference between 65 and 97 to that character.

00:00:00.000 --> 00:00:00.000
 So again, imagine it was a lowercase character.

00:00:00.000 --> 00:00:00.000
 I'd add, I'd say C plus equals, remember I'm turning it to lowercase, 97 minus 65.

00:00:00.000 --> 00:00:00.000
 In other words, that's the difference between this character and this character.

00:00:00.000 --> 00:00:00.000
 This character, right? This A.

00:00:00.000 --> 00:00:00.000
 That's the difference between the two.

00:00:00.000 --> 00:00:00.000
 Now, this is of course a magic number.

00:00:00.000 --> 00:00:00.000
 It would be nice if we had a constant that represented that.

00:00:00.000 --> 00:00:00.000
 It would also be nice that we didn't just have the numbers 97 and 65.

00:00:00.000 --> 00:00:00.000
 We had some meaning.

00:00:00.000 --> 00:00:00.000
 And so the way we can write that is const if equals the 97 minus the 65.

00:00:00.000 --> 00:00:00.000
 So this is the case difference.

00:00:00.000 --> 00:00:00.000
 And so now I can simply add C plus equals diff.

00:00:00.000 --> 00:00:00.000
 And I can say result plus equals C.

00:00:00.000 --> 00:00:00.000
 Now, notice I'm repeating this code here and here.

00:00:00.000 --> 00:00:00.000
 And I'm going to repeat it here in this third one.

00:00:00.000 --> 00:00:00.000
 So we'll see how we can simplify this a little bit in a moment.

00:00:00.000 --> 00:00:00.000
 So C plus equals diff.

00:00:00.000 --> 00:00:00.000
 Here we're going to do the same thing, except I'm going to say C,

00:00:00.000 --> 00:00:00.000
 in other words, I want to go from 97 down to 65.

00:00:00.000 --> 00:00:00.000
 So I'm going to say C minus equals diff and result C equals C.

00:00:00.000 --> 00:00:00.000
 And we add the new character.

00:00:00.000 --> 00:00:00.000
 So in each case I'm changing the character and then adding it to the end.

00:00:00.000 --> 00:00:00.000
 Now, I want to improve this a little bit for the efficiency part.

00:00:00.000 --> 00:00:00.000
 But let's just go see if it works right now.

00:00:00.000 --> 00:00:00.000
 Let's go control L, make test.

00:00:00.000 --> 00:00:00.000
 Yes, it does in fact flip all of these things and give us the correct output in all of those cases.

00:00:00.000 --> 00:00:00.000
 So redundant code.

00:00:00.000 --> 00:00:00.000
 What do we do when we have redundant code?

00:00:00.000 --> 00:00:00.000
 Is it in all three of these?

00:00:00.000 --> 00:00:00.000
 Yes, it is.

00:00:00.000 --> 00:00:00.000
 That means it can appear after this.

00:00:00.000 --> 00:00:00.000
 We don't need it here.

00:00:00.000 --> 00:00:00.000
 If there's nothing inside there, we don't need the else.

00:00:00.000 --> 00:00:00.000
 So this is still three branches.

00:00:00.000 --> 00:00:00.000
 One if it's uppercase, one if it's lowercase, and one if it's neither.

00:00:00.000 --> 00:00:00.000
 But now I don't need it there.

00:00:00.000 --> 00:00:00.000
 I don't need it there.

00:00:00.000 --> 00:00:00.000
 And we can see our code is much simpler.

00:00:00.000 --> 00:00:00.000
 More efficient, easier to maintain, and so forth.

00:00:00.000 --> 00:00:00.000
 And again, we can test that out once again to make sure we didn't make any mistakes.

00:00:00.000 --> 00:00:00.000
 And flip case still gives us the correct answer.

00:00:00.000 --> 00:00:00.000
 Okay, so let's close the flipper.

00:00:00.000 --> 00:00:00.000
 And let's go to our last one on D, which is upper.

00:00:00.000 --> 00:00:00.000
 Put your name on it.

00:00:00.000 --> 00:00:00.000
 Open a terminal on there.

00:00:00.000 --> 00:00:00.000
 And let's look at the function.

00:00:00.000 --> 00:00:00.000
 Write a procedure to upper.

00:00:00.000 --> 00:00:00.000
 Now, you remember a procedure is a function that doesn't return anything.

00:00:00.000 --> 00:00:00.000
 It's going to take a single string as an argument and modify the string so that every lowercase character has been converted to uppercase.

00:00:00.000 --> 00:00:00.000
 Again, we're going to not use any library functions here.

00:00:00.000 --> 00:00:00.000
 So a procedure is void to upper string reference because we're going to modify str.

00:00:00.000 --> 00:00:00.000
 That's our whole stub.

00:00:00.000 --> 00:00:00.000
 We don't need to return anything.

00:00:00.000 --> 00:00:00.000
 We can go ahead and do make test.

00:00:00.000 --> 00:00:00.000
 And you can see it compiles and runs.

00:00:00.000 --> 00:00:00.000
 It actually gives us the correct output if the string doesn't have any lowercase characters inside it.

00:00:00.000 --> 00:00:00.000
 So to upper means we're going to convert everything that's a lowercase character to upper.

00:00:00.000 --> 00:00:00.000
 So we're going to say for auto.

00:00:00.000 --> 00:00:00.000
 Or, again, we don't need to use auto here.

00:00:00.000 --> 00:00:00.000
 We can use char, right, because every character inside there.

00:00:00.000 --> 00:00:00.000
 So char ref for each character inside the string.

00:00:00.000 --> 00:00:00.000
 If it's a lower -- if it is uppercase, lowercase.

00:00:00.000 --> 00:00:00.000
 If -- and let's give that a name, char c.

00:00:00.000 --> 00:00:00.000
 If c is greater or equal to a and c is less than or equal to z.

00:00:00.000 --> 00:00:00.000
 It's lower.

00:00:00.000 --> 00:00:00.000
 Then what we want to do is we want to make it uppercase.

00:00:00.000 --> 00:00:00.000
 We want to make it -- give it a smaller ASCII character.

00:00:00.000 --> 00:00:00.000
 You remember from the last one.

00:00:00.000 --> 00:00:00.000
 So we want to add the difference to it.

00:00:00.000 --> 00:00:00.000
 So I can write the difference up there.

00:00:00.000 --> 00:00:00.000
 Or I can just say c minus equals a minus a.

00:00:00.000 --> 00:00:00.000
 That's the difference.

00:00:00.000 --> 00:00:00.000
 I can write it like that and that will work perfectly fine.

00:00:00.000 --> 00:00:00.000
 Or I could write it up here before my loop and create a const again.

00:00:00.000 --> 00:00:00.000
 So const int case difference equals a minus lowercase a minus capital A.

00:00:00.000 --> 00:00:00.000
 And maybe make my code a little bit readable.

00:00:00.000 --> 00:00:00.000
 Now, what do I need to do if it's an uppercase character already?

00:00:00.000 --> 00:00:00.000
 Nothing.

00:00:00.000 --> 00:00:00.000
 Punctuation, nothing.

00:00:00.000 --> 00:00:00.000
 So this one is slightly different.

00:00:00.000 --> 00:00:00.000
 This will turn everything into uppercase.

00:00:00.000 --> 00:00:00.000
 So let's try it.

00:00:00.000 --> 00:00:00.000
 Make test.

00:00:00.000 --> 00:00:00.000
 Ah, good.

00:00:00.000 --> 00:00:00.000
 All of our tests pass.

00:00:00.000 --> 00:00:00.000
 So you now have all your screenshots.

00:00:00.000 --> 00:00:00.000
 You have everything done.

00:00:00.000 --> 00:00:00.000
 And for chapter 5, you've got to read the chapter, take the quiz, do the reading exercises and so forth.

00:00:00.000 --> 00:00:00.000
 And I will see you back here for lecture 6.

