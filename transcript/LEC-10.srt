
1
00:00:00,000 --> 00:00:08,000
Hello everyone, this is Steve Gilbert. Welcome to lecture 10, where we're going to talk about recursion.

2
00:00:08,000 --> 00:00:17,000
Before we talk about recursion though, I want to look at the previous lecture, lecture 9, where we talked about writing functions.

3
00:00:17,000 --> 00:00:22,000
So programming exam 4, which you'll take next week, will ask you to write a function.

4
00:00:22,000 --> 00:00:30,000
And that function will have both input and output parameters, and so you need to be perfectly clear on that.

5
00:00:30,000 --> 00:00:36,000
Also, as a second problem, you'll be asked to write a group of prototypes.

6
00:00:36,000 --> 00:00:44,000
And you'll have to deduce the correct prototype based on the way that the function is called.

7
00:00:44,000 --> 00:00:49,000
And this will check your ability to apply the data flow checklists.

8
00:00:49,000 --> 00:00:56,000
Do you understand how data flows into a function, and how data flows out of a function?

9
00:00:56,000 --> 00:01:03,000
And if you understand that, do you understand how to write the prototypes so that they are correct?

10
00:01:03,000 --> 00:01:10,000
And so we're going to start with a review exercise before we get into recursion to test that.

11
00:01:10,000 --> 00:01:22,000
And so make sure that you have gone over to week 3, and on week 3 that you've gone to the recursion tab and clicked the lecture exercise tab.

12
00:01:22,000 --> 00:01:30,000
On the lecture exercise tab, make a copy of the starters, probably name it something rather than copy.

13
00:01:30,000 --> 00:01:36,000
And then we'll start by filling up this link.

14
00:01:36,000 --> 00:01:41,000
Ok, so I've been signed out, so it's going to ask me to sign in here for a second.

15
00:01:41,000 --> 00:01:45,000
And it signed me back in.

16
00:01:45,000 --> 00:01:51,000
Ok, so we're going to follow this link.

17
00:01:51,000 --> 00:01:54,000
Ok, I've made it a little larger.

18
00:01:54,000 --> 00:02:00,000
And so as you can see, we have a main function down here, the file called prototype_tester.cpp.

19
00:02:00,000 --> 00:02:04,000
And it calls five different functions.

20
00:02:04,000 --> 00:02:08,000
Your job is just to put the prototypes in the header file.

21
00:02:08,000 --> 00:02:11,000
So let's just look at the first one.

22
00:02:11,000 --> 00:02:15,000
Here on line 13, we're calling the function crypt.

23
00:02:15,000 --> 00:02:17,000
We're passing it false and a.

24
00:02:17,000 --> 00:02:21,000
As you can see on line 12, a is an int variable.

25
00:02:21,000 --> 00:02:25,000
Now my comment tells you what that's going to print. It's going to print 5.

26
00:02:25,000 --> 00:02:28,000
So that's going to tell us what's coming out of the function.

27
00:02:28,000 --> 00:02:33,000
And afterwards, it says that a, although it's an int, is going to be changed.

28
00:02:33,000 --> 00:02:38,000
It went in with the value 5 and it's coming out with the value 5.

29
00:02:38,000 --> 00:02:46,000
So let's prototype that, seeing that the first argument to crypt is an input parameter,

30
00:02:46,000 --> 00:02:50,000
because a literal must be an input parameter.

31
00:02:50,000 --> 00:02:55,000
The value false cannot be a reference or an output parameter.

32
00:02:55,000 --> 00:03:00,000
But a is an input. It goes in with 5 and it comes out with 10.

33
00:03:00,000 --> 00:03:04,000
And so this is an input/output parameter.

34
00:03:04,000 --> 00:03:10,000
And so the return type for this is crypt.

35
00:03:10,000 --> 00:03:13,000
The argument is bool.

36
00:03:13,000 --> 00:03:18,000
And the type of a is int.

37
00:03:18,000 --> 00:03:22,000
And since it's an input/output parameter, it's a primitive type.

38
00:03:22,000 --> 00:03:27,000
It's going to be changed in the function. It's passed by reference.

39
00:03:27,000 --> 00:03:35,000
Now you can give it name.

40
00:03:35,000 --> 00:03:40,000
Int reference t or something like that.

41
00:03:40,000 --> 00:03:45,000
But you don't have to give them names.

42
00:03:45,000 --> 00:03:51,000
Then each time you do each one, go ahead and check it.

43
00:03:51,000 --> 00:03:55,000
And so we're going to check that.

44
00:03:55,000 --> 00:03:59,000
And for each one, it will tell you whether it's syntactically correct.

45
00:03:59,000 --> 00:04:03,000
So we're checking the crypt prototype. We're checking the output.

46
00:04:03,000 --> 00:04:09,000
We're checking to see if it is syntactically correct and semantically correct.

47
00:04:09,000 --> 00:04:15,000
Now notice, you do not put on a body.

48
00:04:15,000 --> 00:04:20,000
We're not defining these. We're just implementing them.

49
00:04:20,000 --> 00:04:24,000
Now let's look at the second one. The second one is called ORD.

50
00:04:24,000 --> 00:04:28,000
It takes a string as its argument.

51
00:04:28,000 --> 00:04:32,000
It prints 3.0 so I can see the output is double.

52
00:04:32,000 --> 00:04:36,000
And notice the string went in with one value and out with another value.

53
00:04:36,000 --> 00:04:45,000
So ORD. It's going to return a double.

54
00:04:45,000 --> 00:04:49,000
The function is named ORD.

55
00:04:49,000 --> 00:04:53,000
And it takes a string as its parameter.

56
00:04:53,000 --> 00:04:56,000
Now let's try this.

57
00:04:56,000 --> 00:05:03,000
I'm doing things wrong to show you a couple of errors.

58
00:05:03,000 --> 00:05:06,000
And you will see that that doesn't even compile.

59
00:05:06,000 --> 00:05:11,000
It doesn't even compile. String was not declared in this scope.

60
00:05:11,000 --> 00:05:14,000
So I don't know why we're getting the error on line 32.

61
00:05:14,000 --> 00:05:20,000
But on line 7, we're getting an error. String was not declared.

62
00:05:20,000 --> 00:05:32,000
So because it's in the header file, all regular types, all library types, must be fully qualified.

63
00:05:32,000 --> 00:05:39,000
So we cannot use using namespace standard there. We have to put in the fully qualified name.

64
00:05:39,000 --> 00:05:42,000
So let's try it now.

65
00:05:42,000 --> 00:05:45,000
Okay, so now it compiled.

66
00:05:45,000 --> 00:05:53,000
Notice that it is syntactically correct, that type string was correct, but we didn't get the semantic part about it.

67
00:05:53,000 --> 00:05:57,000
Whether it's an input or output parameter.

68
00:05:57,000 --> 00:06:06,000
So we are passing our string here by value, when in fact we need to pass it by reference.

69
00:06:06,000 --> 00:06:11,000
So for all string types, we'll always pass them by reference.

70
00:06:11,000 --> 00:06:18,000
And when we just make that change and we test it again, you can see that it now is not only syntactically correct,

71
00:06:18,000 --> 00:06:23,000
but it is now semantically correct as well.

72
00:06:23,000 --> 00:06:28,000
So let's do the other ones real quick. ReadLink has no return value.

73
00:06:28,000 --> 00:06:33,000
It takes a literal for the first argument, so that's double.

74
00:06:33,000 --> 00:06:37,000
This literal again, that is bool.

75
00:06:37,000 --> 00:06:42,000
And this is a literal, so that is a const string reference.

76
00:06:42,000 --> 00:06:47,000
So it doesn't return anything, so it's void.

77
00:06:47,000 --> 00:06:50,000
This function is named ReadLink.

78
00:06:50,000 --> 00:06:59,000
It's a double const standard string reference and bool.

79
00:06:59,000 --> 00:07:12,000
The fourth one, dbclose, prints okay, so it's going to return a standard string.

80
00:07:12,000 --> 00:07:21,000
It takes a string literal, so that's a constant string ref.

81
00:07:21,000 --> 00:07:27,000
So const standard string reference.

82
00:07:27,000 --> 00:07:33,000
And it takes 42, again another literal, and its type is int.

83
00:07:33,000 --> 00:07:37,000
And finally require takes two arguments.

84
00:07:37,000 --> 00:07:41,000
S is a string down here, and okay is a bool.

85
00:07:41,000 --> 00:07:49,000
But notice that okay is not initialized, and so this must be an output parameter.

86
00:07:49,000 --> 00:07:52,000
So that must be a bool ref.

87
00:07:52,000 --> 00:07:58,000
This string sam goes in. Is it going to be an input parameter?

88
00:07:58,000 --> 00:08:04,000
No, afterwards S has sam, sam, sam, all proper case.

89
00:08:04,000 --> 00:08:10,000
And so it's an input/output parameter, and so that is a reference.

90
00:08:10,000 --> 00:08:16,000
So this returns a standard string.

91
00:08:16,000 --> 00:08:20,000
The function is named require.

92
00:08:20,000 --> 00:08:30,000
It takes a standard string by reference, and it takes a bool by reference.

93
00:08:30,000 --> 00:08:36,000
Okay, now I've done all three of them, just so that we don't spend a lot of time in the video here.

94
00:08:36,000 --> 00:08:40,000
But you should do them one at a time and make sure you get them correct.

95
00:08:40,000 --> 00:08:43,000
If one of them doesn't work, just skip that one.

96
00:08:43,000 --> 00:08:48,000
Comment it out, especially if you get syntax errors on this.

97
00:08:48,000 --> 00:08:51,000
Especially if you get syntax errors.

98
00:08:51,000 --> 00:08:55,000
Okay, so here is all of our tests working correctly.

99
00:08:55,000 --> 00:08:59,000
And you can shoot your screenshot for that.

100
00:08:59,000 --> 00:09:06,000
Okay, so let's go now and talk about recursion.

101
00:09:06,000 --> 00:09:08,000
What's recursion?

102
00:09:08,000 --> 00:09:11,000
So recursion is a mathematical concept.

103
00:09:11,000 --> 00:09:16,000
In math, a recursive function is one that's defined in terms of itself.

104
00:09:16,000 --> 00:09:19,000
Like the factorial function.

105
00:09:19,000 --> 00:09:28,000
The factorial function, f factorial, the definition for it is 3 factorial is 3 times 2 times 1 factorial.

106
00:09:28,000 --> 00:09:33,000
And 4 factorial is 4 times 3 times 2 times 1.

107
00:09:33,000 --> 00:09:41,000
And since we can see that 4 factorial is just 4 times what 3 factorial is, we can generalize that.

108
00:09:41,000 --> 00:09:52,000
So that for any n, like 3 or 4 or 12 or whatever, n factorial is n times n minus 1 factorial.

109
00:09:52,000 --> 00:09:55,000
So let's try that with n equals 2.

110
00:09:55,000 --> 00:10:01,000
So 2 factorial is 2 times 2 minus 1 factorial.

111
00:10:01,000 --> 00:10:10,000
And 2 minus 1 factorial is 1 times 1 minus 1 factorial or 0 factorial.

112
00:10:10,000 --> 00:10:17,000
And 0 factorial is and so forth and so on.

113
00:10:17,000 --> 00:10:24,000
You can see that if we just use this definition, n equals n times n minus 1 factorial, we have a problem.

114
00:10:24,000 --> 00:10:26,000
We have a circular definition.

115
00:10:26,000 --> 00:10:34,000
And so what we always have to do with a recursive mathematical function is we have to find the qualification.

116
00:10:34,000 --> 00:10:40,000
The qualification for this is that 0 factorial is 1.

117
00:10:40,000 --> 00:10:41,000
0 factorial is 1.

118
00:10:41,000 --> 00:10:52,000
Because otherwise when we got this 1 times 1 factorial, 1 times 1 times 1 factorial, and that would be 0 factorial.

119
00:10:52,000 --> 00:10:57,000
Now if we didn't know what 0 factorial is, we would have to put it through this formula again.

120
00:10:57,000 --> 00:11:04,000
And we would get minus 1, minus 2, minus 3, which just wouldn't work.

121
00:11:04,000 --> 00:11:11,000
So in programming, however, a recursive function is a function that calls itself.

122
00:11:11,000 --> 00:11:16,000
So when a function calls itself, it's a recursive function.

123
00:11:16,000 --> 00:11:22,000
So let's look at a recursive function, elevator.cpp, and examine it.

124
00:11:22,000 --> 00:11:27,000
So again, make sure that you have stopped my code space.

125
00:11:27,000 --> 00:11:31,000
I'm going to start my code space again.

126
00:11:31,000 --> 00:11:33,000
Restart my code space.

127
00:11:33,000 --> 00:11:56,000
And so again, make sure that you have opened up the Week 10 in your IDE.

128
00:11:56,000 --> 00:12:06,000
So that is in IC, IC10, a elevator.

129
00:12:06,000 --> 00:12:20,000
So here's our elevator problem right here.

130
00:12:20,000 --> 00:12:26,000
Let me pause that while I clear this up.

131
00:12:26,000 --> 00:12:29,000
Okay, I'm back, and I'm probably not going to edit that out.

132
00:12:29,000 --> 00:12:31,000
So here's the elevator.cpp.

133
00:12:31,000 --> 00:12:36,000
And so notice we've prototyped the function called elevator that takes a floor.

134
00:12:36,000 --> 00:12:41,000
In the main function, we're calling elevator sub 0.

135
00:12:41,000 --> 00:12:49,000
Now the elevator function gets one argument, its floor, and then it prints out the floor that you're on.

136
00:12:49,000 --> 00:12:51,000
And it says going up.

137
00:12:51,000 --> 00:12:54,000
So going up, floor, and it prints out floor 0.

138
00:12:54,000 --> 00:13:00,000
Then it calls itself again, elevator floor plus 1.

139
00:13:00,000 --> 00:13:04,000
And so now it's going to say going up floor 1.

140
00:13:04,000 --> 00:13:09,000
And then of course it's going to call itself again, and it's going to say going up floor 2.

141
00:13:09,000 --> 00:13:11,000
So let's go ahead and run that.

142
00:13:11,000 --> 00:13:15,000
Right click and open a terminal there.

143
00:13:15,000 --> 00:13:20,000
And then let's do make run.

144
00:13:20,000 --> 00:13:26,000
And you can see it does in fact look like an endless loop.

145
00:13:26,000 --> 00:13:32,000
An endless loop effect, except something is different here.

146
00:13:32,000 --> 00:13:44,000
And so what happens is that we get an endless loop effect, but unlike an endless loop effect, the program eventually crashes.

147
00:13:44,000 --> 00:13:55,000
That's because each time elevator is called, a new variable is created, a new copy of the floor variable with a new value.

148
00:13:55,000 --> 00:14:00,000
And it's placed in an area of memory here called the stack.

149
00:14:00,000 --> 00:14:12,000
Now as more and more floor variables are created, eventually that fills up and we run out of memory and the stack collides with the heap.

150
00:14:12,000 --> 00:14:17,000
And this specific kind of error is called a stack overflow.

151
00:14:17,000 --> 00:14:21,000
And that's very, very frequent in recursive programs actually.

152
00:14:21,000 --> 00:14:25,000
It's probably the only way you can create a stack overflow.

153
00:14:25,000 --> 00:14:30,000
You notice unlike Java, we didn't get a nice error message, stack overflow.

154
00:14:30,000 --> 00:14:35,000
Java inspects this with its Java virtual machine.

155
00:14:35,000 --> 00:14:48,000
C++ does not. It relies on the operating system to notice when your program has started overflowing the memory that was allocated for it and starts using the memory that it's not supposed to use.

156
00:14:48,000 --> 00:14:58,000
And so a segmentation fault is simply an error message from the operating system, not from C++ itself.

157
00:14:58,000 --> 00:15:09,000
So basically that says your program crashed because you did something the operating system wouldn't let you do.

158
00:15:09,000 --> 00:15:12,000
So how do we fix that?

159
00:15:12,000 --> 00:15:15,000
Well how do we fix an endless loop?

160
00:15:15,000 --> 00:15:20,000
We fix an endless loop by providing a loop bounds.

161
00:15:20,000 --> 00:15:23,000
Recursive functions need the same thing. They need a way to stop.

162
00:15:23,000 --> 00:15:27,000
In a recursive function this is called the base case.

163
00:15:27,000 --> 00:15:30,000
Now it's very similar to a loop bounds.

164
00:15:30,000 --> 00:15:33,000
What you do is you add an if statement.

165
00:15:33,000 --> 00:15:38,000
Every recursive function will have an if statement.

166
00:15:38,000 --> 00:15:42,000
And the if statement determines when a function is called again.

167
00:15:42,000 --> 00:15:46,000
If the if statement is false, we don't call it again.

168
00:15:46,000 --> 00:15:52,000
So this creates the loop-like effect that you saw, but remember it is not a loop.

169
00:15:52,000 --> 00:15:57,000
You're not inside the same function. You're in a copy of the function.

170
00:15:57,000 --> 00:16:00,000
And we'll see how that works shortly.

171
00:16:00,000 --> 00:16:10,000
So let's do that. Let's put in a base case to stop at the penthouse floor 25.

172
00:16:10,000 --> 00:16:14,000
So here's our code.

173
00:16:14,000 --> 00:16:18,000
Let me just minimize that here. Here's our code.

174
00:16:18,000 --> 00:16:29,000
We'll create a constant here. So constant penthouse k penthouse equals 25.

175
00:16:29,000 --> 00:16:34,000
And so before we call the function, we're going to check to see if it's okay.

176
00:16:34,000 --> 00:16:44,000
And so we're going to say if floor is less than the penthouse,

177
00:16:44,000 --> 00:16:53,000
then we're going to go ahead and go up to the next floor.

178
00:16:53,000 --> 00:16:58,000
If it's not, we're not. If it's not, we're not.

179
00:16:58,000 --> 00:17:08,000
So this is the idea of the base case, the terminator for a recursive function.

180
00:17:08,000 --> 00:17:14,000
So let's try it again.

181
00:17:14,000 --> 00:17:18,000
And let's do make run again.

182
00:17:18,000 --> 00:17:22,000
And notice we go up floor 1, 2, 3, 4, just like we had a loop.

183
00:17:22,000 --> 00:17:26,000
When we get to floor 25, though, we end.

184
00:17:26,000 --> 00:17:30,000
Now look at the format of the code.

185
00:17:30,000 --> 00:17:43,000
Look at that our call to the function is inside this guarded if statement.

186
00:17:43,000 --> 00:17:47,000
So this is a guarded action.

187
00:17:47,000 --> 00:17:52,000
What happens if we put code that's outside of that if statement?

188
00:17:52,000 --> 00:18:02,000
Well, if it appears after the guarded action, for instance, if we take this statement

189
00:18:02,000 --> 00:18:14,000
and we print it again, change it to going down,

190
00:18:14,000 --> 00:18:22,000
this code will execute after we have executed all of the copies of going up.

191
00:18:22,000 --> 00:18:28,000
Only when we're going up, when we're at floor 25, will we start going down.

192
00:18:28,000 --> 00:18:36,000
And even though it looks like we would only have going down floor 25 and then the function would end,

193
00:18:36,000 --> 00:18:40,000
only one copy of the function ends.

194
00:18:40,000 --> 00:18:46,000
And so when we do this and we run it again, notice we go up to floor 25

195
00:18:46,000 --> 00:18:54,000
and then we go down to floor 24, floor 23, floor 22, floor 21, and so forth.

196
00:18:54,000 --> 00:19:03,000
And so this is called unwinding the stack.

197
00:19:03,000 --> 00:19:08,000
So as we go up, we put the variables on the stack.

198
00:19:08,000 --> 00:19:14,000
When we leave, we remove them off the stack and we can use those variables again.

199
00:19:14,000 --> 00:19:18,000
So that's kind of confusing the first time you see it.

200
00:19:18,000 --> 00:19:25,000
So let me show you an example so you'll see exactly what happens.

201
00:19:25,000 --> 00:19:30,000
So in this case, here's the factorial function we're going to look at.

202
00:19:30,000 --> 00:19:35,000
So remember the n factorial is n times n minus 1 factorial with the convention.

203
00:19:35,000 --> 00:19:44,000
That's the recursive case. With the base case, the 0 factorial or 1 factorial is 1.

204
00:19:44,000 --> 00:19:46,000
So let's do a simulation of that.

205
00:19:46,000 --> 00:19:54,000
Here's a little animation with a little terminal like a Macintosh terminal.

206
00:19:54,000 --> 00:19:56,000
We're going to print out enter n.

207
00:19:56,000 --> 00:20:01,000
The user is going to type in a value like 5.

208
00:20:01,000 --> 00:20:06,000
We're going to save that in a local variable n inside the main function.

209
00:20:06,000 --> 00:20:11,000
And then we're going to print out n factorial equals the factorial of n.

210
00:20:11,000 --> 00:20:14,000
In this case, the factorial of 5.

211
00:20:14,000 --> 00:20:18,000
Well, to do that, we first have to figure out what the factorial of 5 is.

212
00:20:18,000 --> 00:20:21,000
And to do that, we call the function.

213
00:20:21,000 --> 00:20:25,000
And when we call the function, it creates what's called a stack frame.

214
00:20:25,000 --> 00:20:29,000
And this stack frame will have its own variables.

215
00:20:29,000 --> 00:20:37,000
So when we called the factorial of 5, we passed 5 to this local variable, a copy of the n here.

216
00:20:37,000 --> 00:20:43,000
And we put it in a local variable inside the function, specifically the parameter variable.

217
00:20:43,000 --> 00:20:46,000
And now we start running this function.

218
00:20:46,000 --> 00:20:49,000
If n equals 0, we're going to return 1.

219
00:20:49,000 --> 00:20:56,000
It's not 0, so we're going to return n or 5 times the factorial of n minus 1.

220
00:20:56,000 --> 00:20:58,000
What's the problem?

221
00:20:58,000 --> 00:21:01,000
We don't know what the factorial of n minus 1 is.

222
00:21:01,000 --> 00:21:03,000
How do we solve that problem?

223
00:21:03,000 --> 00:21:06,000
We call the factorial function again.

224
00:21:06,000 --> 00:21:08,000
We create another stack frame.

225
00:21:08,000 --> 00:21:12,000
This time, the local variable is 4, because that's what we passed to it.

226
00:21:12,000 --> 00:21:15,000
Notice we passed factorial of n minus 1.

227
00:21:15,000 --> 00:21:19,000
So the local variable in this frame is 4.

228
00:21:19,000 --> 00:21:32,000
And we just keep doing that until we hit the base case.

229
00:21:32,000 --> 00:21:37,000
So in this case, n is 0, and so we're going to return 1.

230
00:21:37,000 --> 00:21:39,000
Where do we turn the 1 to?

231
00:21:39,000 --> 00:21:43,000
We return the 1 to the function that called it.

232
00:21:43,000 --> 00:21:47,000
And so now we know what the expression, the compiler, can calculate.

233
00:21:47,000 --> 00:21:52,000
1 times 1, and it can return that to the previous stack frame.

234
00:21:52,000 --> 00:21:56,000
And now it can calculate 1 times 2, return that to the previous stack frame.

235
00:21:56,000 --> 00:21:59,000
2 times 3, return that.

236
00:21:59,000 --> 00:22:02,000
6 times 4, return that.

237
00:22:02,000 --> 00:22:07,000
And finally, we've got rid of all the calls to factorial n,

238
00:22:07,000 --> 00:22:10,000
and we're returning 5 times 24.

239
00:22:10,000 --> 00:22:14,000
And we can complete or execute that statement.

240
00:22:14,000 --> 00:22:19,000
So 5 factorial is 120.

241
00:22:19,000 --> 00:22:25,000
So it helps to keep this in mind, keep this little animation in mind,

242
00:22:25,000 --> 00:22:32,000
when you're thinking about how recursive functions work.

243
00:22:32,000 --> 00:22:39,000
So we can write problems, we can write functions, that solve recursive problems

244
00:22:39,000 --> 00:22:42,000
by following this simple pattern.

245
00:22:42,000 --> 00:22:47,000
If we know what the answer is, if n equals 0,

246
00:22:47,000 --> 00:22:50,000
we simply directly return the solution.

247
00:22:50,000 --> 00:22:55,000
So every recursive function will have this if else inside there.

248
00:22:55,000 --> 00:22:59,000
Now it's very common in recursive functions just to skip the else,

249
00:22:59,000 --> 00:23:04,000
because we'll just return the answer, and that way anything after the if

250
00:23:04,000 --> 00:23:07,000
basically is the else part.

251
00:23:07,000 --> 00:23:09,000
Then we'll call the function again.

252
00:23:09,000 --> 00:23:15,000
We'll split it up into simpler, smaller problems of the same structure.

253
00:23:15,000 --> 00:23:20,000
So we'll call it with a simpler value and get that out.

254
00:23:20,000 --> 00:23:23,000
We'll keep doing that until we get to the base case.

255
00:23:23,000 --> 00:23:28,000
Then we'll combine all those results by walking back up the stack,

256
00:23:28,000 --> 00:23:34,000
unwinding the stack, and combine the results to get the overall solution.

257
00:23:34,000 --> 00:23:36,000
Now that sounds much more complex than it is,

258
00:23:36,000 --> 00:23:39,000
so let me give you an example.

259
00:23:39,000 --> 00:23:43,000
You'll see that it is relatively simple.

260
00:23:43,000 --> 00:23:49,000
So we're going to look at this situation where you have children's blocks,

261
00:23:49,000 --> 00:23:52,000
and you want to build pyramids with those blocks.

262
00:23:52,000 --> 00:23:58,000
I want to know how many blocks do I need to build a pyramid of height or base,

263
00:23:58,000 --> 00:24:01,000
height and base are the same in all these things,

264
00:24:01,000 --> 00:24:05,000
height or base of 10.

265
00:24:05,000 --> 00:24:09,000
So a height or base of 1 obviously needs 1 block.

266
00:24:09,000 --> 00:24:14,000
A height or base of 2 needs 3 blocks.

267
00:24:14,000 --> 00:24:18,000
A height or base of 3 needs 6 blocks.

268
00:24:18,000 --> 00:24:22,000
And a height or base of 4 needs 10 blocks.

269
00:24:22,000 --> 00:24:24,000
So these are called triangle numbers.

270
00:24:24,000 --> 00:24:31,000
How do we write a function that figures out how many I need for a height of 10?

271
00:24:31,000 --> 00:24:33,000
Do I need 20? Do I need 50?

272
00:24:33,000 --> 00:24:35,000
How many do I need?

273
00:24:35,000 --> 00:24:40,000
And so to solve this, we'll figure out what the recursive definition is.

274
00:24:40,000 --> 00:24:43,000
Now the total blocks in the base, or the height,

275
00:24:43,000 --> 00:24:49,000
is the base plus the blocks in the next smaller triangle.

276
00:24:49,000 --> 00:24:57,000
So here's a base 4, and that's equal to 4 plus all the blocks in triangle 3.

277
00:24:57,000 --> 00:25:02,000
So that intrinsically gives me a recursive definition.

278
00:25:02,000 --> 00:25:09,000
A triangle of n is n plus the triangle of n minus 1.

279
00:25:09,000 --> 00:25:12,000
And the first triangle, base 1, we solve as 1.

280
00:25:12,000 --> 00:25:14,000
What if there are no blocks?

281
00:25:14,000 --> 00:25:18,000
Well, that's an area of 0. No blocks.

282
00:25:18,000 --> 00:25:22,000
So width of 0 has an area of 0.

283
00:25:22,000 --> 00:25:26,000
So this is our base case, or terminator.

284
00:25:26,000 --> 00:25:30,000
So let's go ahead and try that in our IDE now.

285
00:25:30,000 --> 00:25:33,000
We're going to complete the triangle function.

286
00:25:33,000 --> 00:25:35,000
It is B, I believe.

287
00:25:35,000 --> 00:25:44,000
So let's go ahead and close that one down, open up the thing over here.

288
00:25:44,000 --> 00:25:48,000
Close A, open B, and open up triangle.cpp.

289
00:25:48,000 --> 00:25:50,000
Let me close the elevator.

290
00:25:50,000 --> 00:25:53,000
Let me also open a terminal on it.

291
00:25:53,000 --> 00:25:56,000
Let's open an integrated terminal.

292
00:25:56,000 --> 00:25:58,000
So we're writing the recursive function triangle.

293
00:25:58,000 --> 00:26:00,000
You have a pair of no blocks.

294
00:26:00,000 --> 00:26:02,000
The topmost row has one block.

295
00:26:02,000 --> 00:26:03,000
Row belief has two.

296
00:26:03,000 --> 00:26:05,000
The next has three, and so forth.

297
00:26:05,000 --> 00:26:08,000
We're going to compute recursively, no loops or multiplication,

298
00:26:08,000 --> 00:26:12,000
the total number of blocks in such a triangle with the number of rows.

299
00:26:12,000 --> 00:26:14,000
Notice there are no blocks.

300
00:26:14,000 --> 00:26:16,000
Your function should return 0.

301
00:26:16,000 --> 00:26:22,000
So let's put our name on this.

302
00:26:22,000 --> 00:26:30,000
So the function is going to return an int.

303
00:26:30,000 --> 00:26:32,000
It's going to take an int.

304
00:26:32,000 --> 00:26:37,000
I'm going to call it base, or height would be fine there.

305
00:26:37,000 --> 00:26:39,000
So what's the one I know?

306
00:26:39,000 --> 00:26:40,000
No blocks.

307
00:26:40,000 --> 00:26:42,000
The simplest one.

308
00:26:42,000 --> 00:26:54,000
If base is 0, then return 0.

309
00:26:54,000 --> 00:27:02,000
Now, if base is not 0, I need to figure out n base.

310
00:27:02,000 --> 00:27:14,000
So I'm going to return base times triangle base minus 1,

311
00:27:14,000 --> 00:27:16,000
the next smallest one.

312
00:27:16,000 --> 00:27:20,000
And it's actually not times, it's plus.

313
00:27:20,000 --> 00:27:22,000
Base plus.

314
00:27:22,000 --> 00:27:28,000
Let's go back and look at our definition.

315
00:27:28,000 --> 00:27:35,000
So base plus triangle base minus 1.

316
00:27:35,000 --> 00:27:38,000
So we started with the base case.

317
00:27:38,000 --> 00:27:41,000
We wrote an if statement that returned that.

318
00:27:41,000 --> 00:27:44,000
Now we're going to figure out what the recursive case is.

319
00:27:44,000 --> 00:27:49,000
It's base plus the base of the next case.

320
00:27:49,000 --> 00:27:52,000
And then you call the triangle function with an argument

321
00:27:52,000 --> 00:27:56,000
that moves you closer to the base case.

322
00:27:56,000 --> 00:27:58,000
So let's try it.

323
00:27:58,000 --> 00:28:02,000
Let's go ahead and do that.

324
00:28:02,000 --> 00:28:05,000
Let's do make test.

325
00:28:05,000 --> 00:28:09,000
And you can see that it first makes sure that you're running

326
00:28:09,000 --> 00:28:10,000
this recursively.

327
00:28:10,000 --> 00:28:13,000
That's what this find the base case is.

328
00:28:13,000 --> 00:28:16,000
If you tried to do this with loops,

329
00:28:16,000 --> 00:28:20,000
it would say it doesn't appear to be recursive,

330
00:28:20,000 --> 00:28:22,000
if you didn't do it recursively.

331
00:28:22,000 --> 00:28:25,000
So you have to think about that paradigm.

332
00:28:25,000 --> 00:28:28,000
You have to think, solve the smallest thing,

333
00:28:28,000 --> 00:28:35,000
then call the function again to solve the remainder portion of it.

334
00:28:35,000 --> 00:28:39,000
OK, so that looks pretty good for triangles.

335
00:28:39,000 --> 00:28:42,000
Let's try another one.

336
00:28:42,000 --> 00:28:47,000
How about raising a number by the power?

337
00:28:47,000 --> 00:28:52,000
So 2 to the second power is 2 times 2.

338
00:28:52,000 --> 00:28:56,000
2 to the third power is 2 times 2 times 2.

339
00:28:56,000 --> 00:29:00,000
2 to the fourth power is 2 times 2 times 2 times 2.

340
00:29:00,000 --> 00:29:08,000
But we can recursively define that as any number to any exponent

341
00:29:08,000 --> 00:29:13,000
is the number times the number raised to the power

342
00:29:13,000 --> 00:29:16,000
of the smaller exponent.

343
00:29:16,000 --> 00:29:22,000
So 2 times 4 is 2 times 2 to the third.

344
00:29:22,000 --> 00:29:30,000
2 to the fourth is 2 times 2 to the third.

345
00:29:30,000 --> 00:29:36,000
And 2 to the 100th is 2 times 2 to the 99th power.

346
00:29:36,000 --> 00:29:41,000
So that's the recursive idea with the power function.

347
00:29:41,000 --> 00:29:45,000
So let's open up that one.

348
00:29:45,000 --> 00:29:47,000
Let me close the triangle.

349
00:29:47,000 --> 00:29:52,000
Let me close these different BASH shells I have here.

350
00:29:52,000 --> 00:29:57,000
Let's go down to C.

351
00:29:57,000 --> 00:30:05,000
Let's put our name on it.

352
00:30:05,000 --> 00:30:10,000
And so again, we want the power of a function

353
00:30:10,000 --> 00:30:19,000
that takes a number and an exponent.

354
00:30:19,000 --> 00:30:25,000
We know that the power of anything to the first power is that number.

355
00:30:25,000 --> 00:30:30,000
We also know that any number to the zeroth power is 1.

356
00:30:30,000 --> 00:30:32,000
So that's a simpler one.

357
00:30:32,000 --> 00:30:36,000
So we're going to use that for our base case.

358
00:30:36,000 --> 00:30:48,000
So if exponent is 0, we're going to return 1.

359
00:30:48,000 --> 00:30:55,000
If the exponent is not 0, we're going to return the number

360
00:30:55,000 --> 00:31:08,000
times the power of that number to the less smaller exponent.

361
00:31:08,000 --> 00:31:16,000
So this is 2 times the power of 2 to...

362
00:31:16,000 --> 00:31:22,000
So if I want 2 to the fourth, it would be 2 times the power of 2 to the third.

363
00:31:22,000 --> 00:31:26,000
And this just calls itself over and over again.

364
00:31:26,000 --> 00:31:30,000
So let's open a shell on that. Right click.

365
00:31:30,000 --> 00:31:33,000
Open an integrated terminal.

366
00:31:33,000 --> 00:31:38,000
Let's do make test.

367
00:31:38,000 --> 00:31:41,000
And again, I'm checking to make sure this is recursive.

368
00:31:41,000 --> 00:31:45,000
If you write this without recursion, by writing a loop,

369
00:31:45,000 --> 00:31:50,000
or simply writing a whole bunch of if statements, it won't give you the correct answer.

370
00:31:50,000 --> 00:31:54,000
It will tell you that it's not recursive.

371
00:31:54,000 --> 00:31:57,000
Let's do one fourth one here, or one third one here,

372
00:31:57,000 --> 00:32:02,000
just to get an idea of how you write these simple recursive functions.

373
00:32:02,000 --> 00:32:05,000
We're going to write a function changeX to Y

374
00:32:05,000 --> 00:32:09,000
that will take in a string and produce a new string.

375
00:32:09,000 --> 00:32:13,000
But for every lowercase x in the first string,

376
00:32:13,000 --> 00:32:17,000
we're going to replace it with a lowercase y.

377
00:32:17,000 --> 00:32:23,000
So let's close the power.

378
00:32:23,000 --> 00:32:26,000
Let's go down here to D.

379
00:32:26,000 --> 00:32:29,000
ChangeX to Y.

380
00:32:29,000 --> 00:32:35,000
Put our name on it.

381
00:32:35,000 --> 00:32:39,000
OK, so this is going to return a new string.

382
00:32:39,000 --> 00:32:43,000
The function is named changeX to Y.

383
00:32:43,000 --> 00:32:48,000
It's going to take a string that is not modified,

384
00:32:48,000 --> 00:32:55,000
so const string reference str.

385
00:32:55,000 --> 00:33:02,000
Now, if the string has one character, do we need to change it?

386
00:33:02,000 --> 00:33:06,000
Only if it's x, right?

387
00:33:06,000 --> 00:33:09,000
Then we need to change it to y.

388
00:33:09,000 --> 00:33:13,000
If it has no characters, do we need to change it?

389
00:33:13,000 --> 00:33:16,000
No, if it has no characters, we don't have to do any other thinking about it.

390
00:33:16,000 --> 00:33:19,000
We know that that's the answer.

391
00:33:19,000 --> 00:33:29,000
So if string size is less than one,

392
00:33:29,000 --> 00:33:33,000
then return the empty string.

393
00:33:33,000 --> 00:33:37,000
Or return quote, quote would be fine.

394
00:33:37,000 --> 00:33:40,000
Now we know I have at least one character.

395
00:33:40,000 --> 00:33:46,000
So if that one character is an x, I need to change it to a y.

396
00:33:46,000 --> 00:33:54,000
So let's save that in a variable.

397
00:33:54,000 --> 00:33:59,000
I'll use string here.

398
00:33:59,000 --> 00:34:05,000
Equals str. substring 0 and 1.

399
00:34:05,000 --> 00:34:20,000
So if front, I want to change it to y.

400
00:34:20,000 --> 00:34:24,000
And then I want to recursively call it, so I've handled one character.

401
00:34:24,000 --> 00:34:26,000
But I haven't handled the rest of the characters.

402
00:34:26,000 --> 00:34:29,000
How am I going to handle the rest of the characters?

403
00:34:29,000 --> 00:34:31,000
I'm going to call changeX to y.

404
00:34:31,000 --> 00:34:36,000
So this is going to return front, which has now been changed.

405
00:34:36,000 --> 00:34:45,000
Plus changeX to y.

406
00:34:45,000 --> 00:34:49,000
And I'm going to call it with the string.

407
00:34:49,000 --> 00:34:53,000
substring 1.

408
00:34:53,000 --> 00:34:57,000
I've already handled the first characters,

409
00:34:57,000 --> 00:35:01,000
and now I'm passing the second character, the third character, the fourth character,

410
00:35:01,000 --> 00:35:05,000
and so forth.

411
00:35:05,000 --> 00:35:08,000
So let's get one more terminal here.

412
00:35:08,000 --> 00:35:13,000
Right click, open an integrated terminal.

413
00:35:13,000 --> 00:35:18,000
And then let's do make test.

414
00:35:18,000 --> 00:35:34,000
And there that changes X to Y with those four lines of code.

415
00:35:34,000 --> 00:35:44,000
All right. Now let's talk a little bit about efficiency.

416
00:35:44,000 --> 00:35:52,000
So here is a function from your textbook to check to see if a string is a palindrome.

417
00:35:52,000 --> 00:35:57,000
So if a string has one character, it is a palindrome.

418
00:35:57,000 --> 00:36:05,000
So we don't need to check it at all if it is one character or less.

419
00:36:05,000 --> 00:36:09,000
However, if it is two characters or less,

420
00:36:09,000 --> 00:36:11,000
we have to make sure both the characters are the same,

421
00:36:11,000 --> 00:36:14,000
the one at the beginning and the one at the end.

422
00:36:14,000 --> 00:36:17,000
And so if the length is greater than one,

423
00:36:17,000 --> 00:36:22,000
we check to see if string 0 equals string length 1,

424
00:36:22,000 --> 00:36:24,000
in other words, the first and the last,

425
00:36:24,000 --> 00:36:29,000
we could have said str.front, called the front function, and str.back.

426
00:36:29,000 --> 00:36:33,000
That would have worked fine as well.

427
00:36:33,000 --> 00:36:39,000
And if the string is only two characters long, it's a palindrome.

428
00:36:39,000 --> 00:36:42,000
Then we check if it's not.

429
00:36:42,000 --> 00:36:45,000
If it's larger, we have to check if the rest of it,

430
00:36:45,000 --> 00:36:48,000
the part inside the first and last characters,

431
00:36:48,000 --> 00:36:52,000
if it's larger than two characters, is a palindrome.

432
00:36:52,000 --> 00:36:56,000
And so we do that by calling isPalindrome again

433
00:36:56,000 --> 00:37:00,000
with the string with the first character removed

434
00:37:00,000 --> 00:37:04,000
and the last character removed right here.

435
00:37:04,000 --> 00:37:07,000
Now this function is correct, but it's inefficient.

436
00:37:07,000 --> 00:37:12,000
It's inefficient because when I call this substring function,

437
00:37:12,000 --> 00:37:18,000
I have to create a new string object and put it on the stack.

438
00:37:18,000 --> 00:37:24,000
And so each time I call, each time I recursively call the function,

439
00:37:24,000 --> 00:37:27,000
I put a new string on the stack, which is expensive.

440
00:37:27,000 --> 00:37:31,000
It would be nicer if I could skip that.

441
00:37:31,000 --> 00:37:37,000
And so what I can do is instead of calling,

442
00:37:37,000 --> 00:37:41,000
instead of recursively going through the string with isPalindrome,

443
00:37:41,000 --> 00:37:46,000
I can call another function that is itself recursive.

444
00:37:46,000 --> 00:37:50,000
We call that other function that is self-recursive a helper,

445
00:37:50,000 --> 00:37:55,000
and then palindrome is not recursive, but it calls a recursive function,

446
00:37:55,000 --> 00:37:58,000
so we say it's a recursive wrapper.

447
00:37:58,000 --> 00:38:04,000
And what we would do in isPalindrome is we'd call helper

448
00:38:04,000 --> 00:38:10,000
with the original string, and then we would pass two additional arguments,

449
00:38:10,000 --> 00:38:14,000
the index to the beginning and the index to the end.

450
00:38:14,000 --> 00:38:18,000
If you want to see how this is implemented, you can look at

451
00:38:18,000 --> 00:38:24,000
the function on page 7 of your reading in this chapter.

452
00:38:24,000 --> 00:38:30,000
So that's one reason a function might be inefficient if it is recursive,

453
00:38:30,000 --> 00:38:38,000
if it creates using substring, like our last example did, additional copies.

454
00:38:38,000 --> 00:38:45,000
A function can also be inefficient because it calls itself too many times.

455
00:38:45,000 --> 00:38:51,000
So most of you are familiar with the Fibonacci sequence 0, 1, 1, 2, 3, 5, 8,

456
00:38:51,000 --> 00:38:54,000
13, 21, and 23.

457
00:38:54,000 --> 00:38:58,000
This sequence is created by simply for each term,

458
00:38:58,000 --> 00:39:04,000
in other words for the second term here, adding the two terms,

459
00:39:04,000 --> 00:39:07,000
the fourth, the zeroth, and the first term.

460
00:39:07,000 --> 00:39:10,000
We usually index these according to zero.

461
00:39:10,000 --> 00:39:13,000
You may have seen the Fibonacci sequence starting with 1, 1.

462
00:39:13,000 --> 00:39:17,000
That's perfectly fine. We're just starting at a different place.

463
00:39:17,000 --> 00:39:22,000
But the point is each term is a sum of the two preceding terms.

464
00:39:22,000 --> 00:39:27,000
So you can solve this recursively by using a function like this.

465
00:39:27,000 --> 00:39:29,000
Here's the Fibonacci sequence.

466
00:39:29,000 --> 00:39:37,000
If n is less than 2, in other words if it's 1 or 0, we return n, 0 or 1.

467
00:39:37,000 --> 00:39:40,000
Otherwise we return the sum of the previous two

468
00:39:40,000 --> 00:39:44,000
by calling the Fibonacci function recursively again.

469
00:39:44,000 --> 00:39:48,000
So notice each time I call this function I'm calling it twice.

470
00:39:48,000 --> 00:39:52,000
Now it turns out that that is very, very inefficient.

471
00:39:52,000 --> 00:39:57,000
So each time we increase the number from Fibonacci 6 to Fibonacci 7,

472
00:39:57,000 --> 00:40:03,000
we take this whole tree of recursive calls and double it.

473
00:40:03,000 --> 00:40:07,000
And so this is called an exponential explosion.

474
00:40:07,000 --> 00:40:13,000
And we can fix this also with a helper function

475
00:40:13,000 --> 00:40:16,000
and turning Fib into a wrapper.

476
00:40:16,000 --> 00:40:22,000
So let's look at our last exercise here.

477
00:40:22,000 --> 00:40:26,000
So this is E.

478
00:40:26,000 --> 00:40:32,000
And we're going to look at efficiency.

479
00:40:32,000 --> 00:40:39,000
And so what I've done here is I've created two versions of the Fibonacci sequence.

480
00:40:39,000 --> 00:40:42,000
Both of these are the same as the ones I had on the slide.

481
00:40:42,000 --> 00:40:45,000
So they're both identical now.

482
00:40:45,000 --> 00:40:49,000
And we're going to modify this to see if it's faster.

483
00:40:49,000 --> 00:40:56,000
What the main function does is it simply uses some of the C++11 timekeeping functions

484
00:40:56,000 --> 00:41:02,000
to see how many nanoseconds it takes to compute this Fibonacci number.

485
00:41:02,000 --> 00:41:10,000
So I'm calling Fibonacci 10, then 25, then 35, then 45.

486
00:41:10,000 --> 00:41:13,000
So let's go ahead and get a terminal on this.

487
00:41:13,000 --> 00:41:17,000
I didn't create a terminal before I did that.

488
00:41:17,000 --> 00:41:21,000
So let's open an integrated terminal on that.

489
00:41:21,000 --> 00:41:27,000
Let's maximize this and let's do make run.

490
00:41:27,000 --> 00:41:30,000
So you can see it's pretty fast for the first couple, right?

491
00:41:30,000 --> 00:41:34,000
Although 25 and 35 took a few seconds.

492
00:41:34,000 --> 00:41:41,000
So 5,200 nanoseconds for 10 to 2,000.

493
00:41:41,000 --> 00:41:45,000
So that's because the code is already in memory.

494
00:41:45,000 --> 00:41:48,000
We say it's cached when we call it again.

495
00:41:48,000 --> 00:41:51,000
So notice it was much less time.

496
00:41:51,000 --> 00:42:02,000
But when we go increase the time by 10, we go from 2,000 to 5,000 to about a million.

497
00:42:02,000 --> 00:42:04,000
And so both these are about a million.

498
00:42:04,000 --> 00:42:07,000
One's 600,000 and one's 800,000.

499
00:42:07,000 --> 00:42:09,000
And when we increase it only 10 more.

500
00:42:09,000 --> 00:42:13,000
So I increased it 15 and went up to a million nanoseconds.

501
00:42:13,000 --> 00:42:20,000
Now I've got about 195 million nanoseconds,

502
00:42:20,000 --> 00:42:25,000
195 million nanoseconds versus 1 million.

503
00:42:25,000 --> 00:42:29,000
So that's quite a change to increase by 10.

504
00:42:29,000 --> 00:42:34,000
And when I increase it 10 more, I go up to, let's see,

505
00:42:34,000 --> 00:42:44,000
there's thousands, hundreds of thousands, millions, up to about 23, 24 billion times.

506
00:42:44,000 --> 00:42:51,000
So you can see this exponential explosion of adding additional function calls.

507
00:42:51,000 --> 00:42:54,000
So let's see how we would solve that.

508
00:42:54,000 --> 00:42:58,000
Let's see how we would fix that.

509
00:42:58,000 --> 00:43:04,000
And the solution is to avoid making these additional functional calls.

510
00:43:04,000 --> 00:43:07,000
And so we'll write a function here.

511
00:43:07,000 --> 00:43:10,000
We'll call it helper.

512
00:43:10,000 --> 00:43:14,000
It's going to take the number n.

513
00:43:14,000 --> 00:43:21,000
And it's going to remember when we call the function what the previous two were.

514
00:43:21,000 --> 00:43:24,000
And so I'm going to call these int t0.

515
00:43:24,000 --> 00:43:27,000
And I'm going to call this one int t1.

516
00:43:27,000 --> 00:43:32,000
For term 0 and term 1.

517
00:43:32,000 --> 00:43:36,000
Now we have two possibilities here.

518
00:43:36,000 --> 00:43:46,000
If n equals 0, we're going to return whatever term 0 was.

519
00:43:46,000 --> 00:43:54,000
If n is 1, we're going to return whatever t1 is.

520
00:43:54,000 --> 00:44:02,000
If it's neither of those, we're simply going to return the helper.

521
00:44:02,000 --> 00:44:06,000
With n minus 1, a smaller n.

522
00:44:06,000 --> 00:44:11,000
Instead of t0, we're going to change t0 to t1.

523
00:44:11,000 --> 00:44:14,000
In other words, we're going to add those together.

524
00:44:14,000 --> 00:44:20,000
And t1 is going to become t1 plus t0.

525
00:44:20,000 --> 00:44:25,000
So notice how we're remembering what happens each time we call.

526
00:44:25,000 --> 00:44:31,000
So we don't have to go back down and find out what the previous one is.

527
00:44:31,000 --> 00:44:33,000
So this is our helper.

528
00:44:33,000 --> 00:44:36,000
This is going to be our wrapper.

529
00:44:36,000 --> 00:44:45,000
And what we're going to do with our wrapper is we're going to return helper with n.

530
00:44:45,000 --> 00:44:49,000
And we're going to put in what our t0 and t1 is.

531
00:44:49,000 --> 00:44:52,000
And our t0 here is going to be 0.

532
00:44:52,000 --> 00:44:55,000
And our t1 is going to be 1.

533
00:44:55,000 --> 00:45:02,000
The beginning of the sequence for the Fibonacci sequence.

534
00:45:02,000 --> 00:45:05,000
Okay, so let's try that again.

535
00:45:05,000 --> 00:45:13,000
Now, notice fib is going to take just as long as it did before.

536
00:45:13,000 --> 00:45:20,000
But fib2 is going to take almost no time at all.

537
00:45:20,000 --> 00:45:22,000
Almost no time at all.

538
00:45:22,000 --> 00:45:25,000
Even 35. Look at the difference between 35.

539
00:45:25,000 --> 00:45:35,000
Now, 45 for fib is still going to take our 25 billion nanoseconds.

540
00:45:35,000 --> 00:45:37,000
So roughly 25 seconds, right?

541
00:45:37,000 --> 00:45:39,000
24, 25 seconds.

542
00:45:39,000 --> 00:45:43,000
Okay, so it again took 24, 25 seconds.

543
00:45:43,000 --> 00:45:49,000
And again, when we did it with the helper, fib2, it was almost instantaneous.

544
00:45:49,000 --> 00:45:55,000
So recursive functions are not inherently inefficient.

545
00:45:55,000 --> 00:45:59,000
But you have to think about what function calls are being made

546
00:45:59,000 --> 00:46:08,000
and what data structures are being created when you do this.

547
00:46:08,000 --> 00:46:11,000
Okay, so you have enough stuff to turn in your exercises.

548
00:46:11,000 --> 00:46:19,000
And I will see you back here for lecture 11.

549
00:46:19,000 --> 00:46:21,000
[END]


