1
00:00:00,000 --> 00:00:00,000
Hello again everyone, this is Steve Gilbert.

2
00:00:00,000 --> 00:00:00,000
Welcome to Lecture 14, where we're going to talk

3
00:00:00,000 --> 00:00:00,000
about exceptions and templates.

4
00:00:00,000 --> 00:00:00,000
So in Lecture 13, we talked about assumptions.

5
00:00:00,000 --> 00:00:00,000
Assumptions are things that you believe should be true.

6
00:00:00,000 --> 00:00:00,000
So when you write a function, you assume certain things

7
00:00:00,000 --> 00:00:00,000
about the inputs.

8
00:00:00,000 --> 00:00:00,000
When you write a function, you assume certain things

9
00:00:00,000 --> 00:00:00,000
about the output.

10
00:00:00,000 --> 00:00:00,000
We call those preconditions and postconditions.

11
00:00:00,000 --> 00:00:00,000
So a precondition is something that's true about the inputs,

12
00:00:00,000 --> 00:00:00,000
and a postcondition is something that should

13
00:00:00,000 --> 00:00:00,000
be true about the outputs.

14
00:00:00,000 --> 00:00:00,000
Now, when we write these preconditions

15
00:00:00,000 --> 00:00:00,000
and postconditions, we use some doxygen tags

16
00:00:00,000 --> 00:00:00,000
to document them so that people who call your function

17
00:00:00,000 --> 00:00:00,000
know what to expect.

18
00:00:00,000 --> 00:00:00,000
So for instance, for the square root function,

19
00:00:00,000 --> 00:00:00,000
they should know that n should be greater or equal to 0.

20
00:00:00,000 --> 00:00:00,000
In other words, if you pass a negative number to square root,

21
00:00:00,000 --> 00:00:00,000
you are not going to get the expected output.

22
00:00:00,000 --> 00:00:00,000
The postcondition and the @return tags

23
00:00:00,000 --> 00:00:00,000
are going to tell you what you should expect to return.

24
00:00:00,000 --> 00:00:00,000
So you can use @return and @post kind of interchangeably

25
00:00:00,000 --> 00:00:00,000
to talk about the return value.

26
00:00:00,000 --> 00:00:00,000
You'd use things like @exception.

27
00:00:00,000 --> 00:00:00,000
Now, you can use @post to tell what

28
00:00:00,000 --> 00:00:00,000
should happen if the precondition is violated.

29
00:00:00,000 --> 00:00:00,000
So what is @post for square root?

30
00:00:00,000 --> 00:00:00,000
Well, @post for square root is it

31
00:00:00,000 --> 00:00:00,000
will return not a number in that case

32
00:00:00,000 --> 00:00:00,000
if you violate the precondition.

33
00:00:00,000 --> 00:00:00,000
So we have five things we can do with a precondition violation.

34
00:00:00,000 --> 00:00:00,000
First, we could try and fix it.

35
00:00:00,000 --> 00:00:00,000
So think again about square root.

36
00:00:00,000 --> 00:00:00,000
If you were writing the square root function,

37
00:00:00,000 --> 00:00:00,000
you might decide if you get a negative number,

38
00:00:00,000 --> 00:00:00,000
you'll just return 0 in that case.

39
00:00:00,000 --> 00:00:00,000
Now, that would fix the problem of getting not a number, which

40
00:00:00,000 --> 00:00:00,000
is what they actually do in the square root function.

41
00:00:00,000 --> 00:00:00,000
But it wouldn't really return the right answer.

42
00:00:00,000 --> 00:00:00,000
In other words, you'd be giving it the wrong answer.

43
00:00:00,000 --> 00:00:00,000
The square root of minus 1 is not 0.

44
00:00:00,000 --> 00:00:00,000
And so we generally don't want to do that.

45
00:00:00,000 --> 00:00:00,000
Although, when you're first programming,

46
00:00:00,000 --> 00:00:00,000
frequently you're taught to think about what

47
00:00:00,000 --> 00:00:00,000
will happen if this happens.

48
00:00:00,000 --> 00:00:00,000
So let's make sure that it doesn't crash and so forth.

49
00:00:00,000 --> 00:00:00,000
But we really don't want to do that.

50
00:00:00,000 --> 00:00:00,000
Secondly, we can terminate with an error message.

51
00:00:00,000 --> 00:00:00,000
So just stop the program when the error occurs

52
00:00:00,000 --> 00:00:00,000
and stop.

53
00:00:00,000 --> 00:00:00,000
Now, sometimes we want to do that,

54
00:00:00,000 --> 00:00:00,000
and sometimes we don't want to do that.

55
00:00:00,000 --> 00:00:00,000
For instance, we certainly wouldn't

56
00:00:00,000 --> 00:00:00,000
want to do that if someone types in the wrong URL

57
00:00:00,000 --> 00:00:00,000
in your web browser.

58
00:00:00,000 --> 00:00:00,000
You wouldn't want to terminate and say, sorry,

59
00:00:00,000 --> 00:00:00,000
Chrome's decided you've typed in the wrong URL.

60
00:00:00,000 --> 00:00:00,000
We're not going to send you to that page.

61
00:00:00,000 --> 00:00:00,000
But sometimes that's the right thing to do.

62
00:00:00,000 --> 00:00:00,000
If your program discovers an error that's

63
00:00:00,000 --> 00:00:00,000
going to propagate further and further and further

64
00:00:00,000 --> 00:00:00,000
inside your code-- in other words,

65
00:00:00,000 --> 00:00:00,000
if one of the preconditions is violated,

66
00:00:00,000 --> 00:00:00,000
the program continuing to run is not really a good idea.

67
00:00:00,000 --> 00:00:00,000
And so if the problem is caused by a mistake

68
00:00:00,000 --> 00:00:00,000
that you have made in your programming-- in other words,

69
00:00:00,000 --> 00:00:00,000
something that you logically believe should be true--

70
00:00:00,000 --> 00:00:00,000
you do want to terminate.

71
00:00:00,000 --> 00:00:00,000
And I'll talk about how you do that in a second.

72
00:00:00,000 --> 00:00:00,000
Thirdly, we could return an error code.

73
00:00:00,000 --> 00:00:00,000
And that's kind of what square root does.

74
00:00:00,000 --> 00:00:00,000
Square root returns a non-valid number

75
00:00:00,000 --> 00:00:00,000
if its precondition is violated.

76
00:00:00,000 --> 00:00:00,000
It returns a special number called not a number.

77
00:00:00,000 --> 00:00:00,000
You could throw an exception, which allows the programmer

78
00:00:00,000 --> 00:00:00,000
to catch it.

79
00:00:00,000 --> 00:00:00,000
Now, you can't do anything about what square root returns.

80
00:00:00,000 --> 00:00:00,000
But if a function throws an exception, like s2i,

81
00:00:00,000 --> 00:00:00,000
you could actually catch it.

82
00:00:00,000 --> 00:00:00,000
Or finally, we could ignore the problem altogether

83
00:00:00,000 --> 00:00:00,000
and just hope for the best.

84
00:00:00,000 --> 00:00:00,000
So we obviously don't want to ignore it.

85
00:00:00,000 --> 00:00:00,000
We generally don't want to fix it silently,

86
00:00:00,000 --> 00:00:00,000
unless the fix is just immaterial,

87
00:00:00,000 --> 00:00:00,000
like for something in the user interface that

88
00:00:00,000 --> 00:00:00,000
wouldn't be that big a deal.

89
00:00:00,000 --> 00:00:00,000
So that leaves us with these three--

90
00:00:00,000 --> 00:00:00,000
terminate with an error message, return an error code,

91
00:00:00,000 --> 00:00:00,000
throw an exception.

92
00:00:00,000 --> 00:00:00,000
So as I mentioned in the last lecture,

93
00:00:00,000 --> 00:00:00,000
if you have a programming error, we

94
00:00:00,000 --> 00:00:00,000
want to use a statement called assert, which terminates

95
00:00:00,000 --> 00:00:00,000
and tells you what line the error occurred on.

96
00:00:00,000 --> 00:00:00,000
So for instance, if I'm writing a function sum

97
00:00:00,000 --> 00:00:00,000
between lower and upper, any time

98
00:00:00,000 --> 00:00:00,000
that function is called with a lower that

99
00:00:00,000 --> 00:00:00,000
is greater than upper, I have an error that won't make sense.

100
00:00:00,000 --> 00:00:00,000
Now, if I returned 0 from that-- in other words,

101
00:00:00,000 --> 00:00:00,000
if I kind of fixed it silently, or I wrote my algorithm

102
00:00:00,000 --> 00:00:00,000
so the function returns 0 when lower was greater than upper--

103
00:00:00,000 --> 00:00:00,000
I really have a programming error.

104
00:00:00,000 --> 00:00:00,000
And I haven't found that error.

105
00:00:00,000 --> 00:00:00,000
In other words, I'm calling the function

106
00:00:00,000 --> 00:00:00,000
when lower is greater than upper.

107
00:00:00,000 --> 00:00:00,000
And I really kind of didn't want that to happen.

108
00:00:00,000 --> 00:00:00,000
So you might decide, this logically can never happen.

109
00:00:00,000 --> 00:00:00,000
If I call the function with lower greater than upper,

110
00:00:00,000 --> 00:00:00,000
I've made a mistake.

111
00:00:00,000 --> 00:00:00,000
And so I would like the program to automatically stop

112
00:00:00,000 --> 00:00:00,000
when that occurs and tell me, Steve,

113
00:00:00,000 --> 00:00:00,000
you've made a mistake on line 42 in foo.cpp.

114
00:00:00,000 --> 00:00:00,000
And so that's what the assert statement does.

115
00:00:00,000 --> 00:00:00,000
It allows you to put in statements

116
00:00:00,000 --> 00:00:00,000
that enforce the logic that you're

117
00:00:00,000 --> 00:00:00,000
trying to put inside your code.

118
00:00:00,000 --> 00:00:00,000
Commercial code is literally littered with assertions.

119
00:00:00,000 --> 00:00:00,000
One of the nice things about assertions

120
00:00:00,000 --> 00:00:00,000
is that when you're developing the code,

121
00:00:00,000 --> 00:00:00,000
you can put them in, check your bugs,

122
00:00:00,000 --> 00:00:00,000
when you're testing it and running it.

123
00:00:00,000 --> 00:00:00,000
And then when you ship your code, you can remove them.

124
00:00:00,000 --> 00:00:00,000
So you're not having the overhead of the if statements

125
00:00:00,000 --> 00:00:00,000
that the assert statement generates.

126
00:00:00,000 --> 00:00:00,000
All right, so let's talk about the other kinds of errors,

127
00:00:00,000 --> 00:00:00,000
though--

128
00:00:00,000 --> 00:00:00,000
errors that are not caused by you, the programmer,

129
00:00:00,000 --> 00:00:00,000
errors caused by exceptional but anticipated circumstances.

130
00:00:00,000 --> 00:00:00,000
If you live in the Arctic and you live in an igloo,

131
00:00:00,000 --> 00:00:00,000
you should expect that at some time

132
00:00:00,000 --> 00:00:00,000
you're going to see a polar bear at your front door.

133
00:00:00,000 --> 00:00:00,000
You should anticipate that.

134
00:00:00,000 --> 00:00:00,000
It's exceptional.

135
00:00:00,000 --> 00:00:00,000
That's not the normal.

136
00:00:00,000 --> 00:00:00,000
But you should anticipate it.

137
00:00:00,000 --> 00:00:00,000
What kind of things can we anticipate when programming?

138
00:00:00,000 --> 00:00:00,000
Well, is the user ever going to type in a file name

139
00:00:00,000 --> 00:00:00,000
incorrectly?

140
00:00:00,000 --> 00:00:00,000
Sure.

141
00:00:00,000 --> 00:00:00,000
Is the disk ever going to be full when

142
00:00:00,000 --> 00:00:00,000
you're saving a file?

143
00:00:00,000 --> 00:00:00,000
Sure.

144
00:00:00,000 --> 00:00:00,000
Now, those kinds of errors, we could just

145
00:00:00,000 --> 00:00:00,000
return an error code.

146
00:00:00,000 --> 00:00:00,000
But the problem with an error code

147
00:00:00,000 --> 00:00:00,000
is the user or the programmer has to check the error code.

148
00:00:00,000 --> 00:00:00,000
These are a little more serious.

149
00:00:00,000 --> 00:00:00,000
If the disk is full when saving a file,

150
00:00:00,000 --> 00:00:00,000
you simply can't go on.

151
00:00:00,000 --> 00:00:00,000
You'll lose data.

152
00:00:00,000 --> 00:00:00,000
If the user types a file name incorrectly,

153
00:00:00,000 --> 00:00:00,000
the program simply won't work.

154
00:00:00,000 --> 00:00:00,000
And so an exception is for something

155
00:00:00,000 --> 00:00:00,000
that you want to handle and you want to force yourself

156
00:00:00,000 --> 00:00:00,000
to handle, or you want to force programmers

157
00:00:00,000 --> 00:00:00,000
using your class to handle.

158
00:00:00,000 --> 00:00:00,000
This should be handled by throwing an exception.

159
00:00:00,000 --> 00:00:00,000
So you all know how functions work.

160
00:00:00,000 --> 00:00:00,000
Functions take inputs, they process the inputs,

161
00:00:00,000 --> 00:00:00,000
and they produce an output.

162
00:00:00,000 --> 00:00:00,000
They return that output.

163
00:00:00,000 --> 00:00:00,000
But actually, functions have a second way of returning.

164
00:00:00,000 --> 00:00:00,000
So you can think of the return the normal channel,

165
00:00:00,000 --> 00:00:00,000
but the exception is a back channel.

166
00:00:00,000 --> 00:00:00,000
So we can say, if the program normally works--

167
00:00:00,000 --> 00:00:00,000
and let's use the function called s2i.

168
00:00:00,000 --> 00:00:00,000
s2i takes a string and returns an integer,

169
00:00:00,000 --> 00:00:00,000
just like our parseInt function we're going to write today does.

170
00:00:00,000 --> 00:00:00,000
So we're going to write a version of s2i.

171
00:00:00,000 --> 00:00:00,000
And if I pass--

172
00:00:00,000 --> 00:00:00,000
that stands for string to integer.

173
00:00:00,000 --> 00:00:00,000
If I pass the string that contains the character 1,

174
00:00:00,000 --> 00:00:00,000
it will convert that string to an integer and return 1.

175
00:00:00,000 --> 00:00:00,000
If I pass a string that contains the word 1, the English word

176
00:00:00,000 --> 00:00:00,000
1, instead of returning the integer,

177
00:00:00,000 --> 00:00:00,000
it returns via this back channel called throwing an exception.

178
00:00:00,000 --> 00:00:00,000
And that exception is thrown to the function that handled it.

179
00:00:00,000 --> 00:00:00,000
Actually, it's thrown not necessarily

180
00:00:00,000 --> 00:00:00,000
to the function that called it, like the return statement is,

181
00:00:00,000 --> 00:00:00,000
the statement that called it.

182
00:00:00,000 --> 00:00:00,000
It's thrown to the nearest exception handler.

183
00:00:00,000 --> 00:00:00,000
So an exception handler is a special kind

184
00:00:00,000 --> 00:00:00,000
of block of code that we'll look at shortly.

185
00:00:00,000 --> 00:00:00,000
Now, in C++, the throwing an exception looks like this.

186
00:00:00,000 --> 00:00:00,000
If I detected an error condition,

187
00:00:00,000 --> 00:00:00,000
just throw some object.

188
00:00:00,000 --> 00:00:00,000
Now, again, this is similar to a return statement

189
00:00:00,000 --> 00:00:00,000
from inside a function, but it doesn't

190
00:00:00,000 --> 00:00:00,000
return to the calling function, but to an error handler.

191
00:00:00,000 --> 00:00:00,000
If there is no error handler, then it

192
00:00:00,000 --> 00:00:00,000
will keep bubbling up to the very main function

193
00:00:00,000 --> 00:00:00,000
where it'll find a default handler.

194
00:00:00,000 --> 00:00:00,000
And that default handler will terminate the program,

195
00:00:00,000 --> 00:00:00,000
and it will look almost exactly like an assertion.

196
00:00:00,000 --> 00:00:00,000
Look almost exactly like an assertion.

197
00:00:00,000 --> 00:00:00,000
OK, so you might have seen these in Java.

198
00:00:00,000 --> 00:00:00,000
You may have had to handle them in Java.

199
00:00:00,000 --> 00:00:00,000
And in Java, in C++, any kind of object

200
00:00:00,000 --> 00:00:00,000
may be thrown as an exception.

201
00:00:00,000 --> 00:00:00,000
Now, Java has a whole class hierarchy

202
00:00:00,000 --> 00:00:00,000
of exceptions that are rooted in the class called throwable.

203
00:00:00,000 --> 00:00:00,000
Throwable has two subclasses, error and exception.

204
00:00:00,000 --> 00:00:00,000
In C++, we could throw an integer

205
00:00:00,000 --> 00:00:00,000
if we wanted to catch different kinds of error codes.

206
00:00:00,000 --> 00:00:00,000
So you could catch int, and then you

207
00:00:00,000 --> 00:00:00,000
could check to see if it's 1, do this.

208
00:00:00,000 --> 00:00:00,000
If it's 2, do that.

209
00:00:00,000 --> 00:00:00,000
If it's 3, do that, and so forth.

210
00:00:00,000 --> 00:00:00,000
You could throw a C++ string.

211
00:00:00,000 --> 00:00:00,000
Notice the little s after the double quotes.

212
00:00:00,000 --> 00:00:00,000
We could throw a C string as well.

213
00:00:00,000 --> 00:00:00,000
That would be a different kinds of things.

214
00:00:00,000 --> 00:00:00,000
So we could throw a C++ string.

215
00:00:00,000 --> 00:00:00,000
We could throw one of the standard library exception

216
00:00:00,000 --> 00:00:00,000
classes.

217
00:00:00,000 --> 00:00:00,000
So this is similar to Java with its throwable, runtime

218
00:00:00,000 --> 00:00:00,000
exception, index out of bounds exception, and so forth.

219
00:00:00,000 --> 00:00:00,000
We could throw an illegal argument

220
00:00:00,000 --> 00:00:00,000
and construct an illegal argument object

221
00:00:00,000 --> 00:00:00,000
and say that the illegal argument was A.

222
00:00:00,000 --> 00:00:00,000
Now, the standard library includes, just like Java,

223
00:00:00,000 --> 00:00:00,000
a variety of exception classes.

224
00:00:00,000 --> 00:00:00,000
If you want to include those, you have to include a header.

225
00:00:00,000 --> 00:00:00,000
They're not automatically included, just

226
00:00:00,000 --> 00:00:00,000
like everything in C++.

227
00:00:00,000 --> 00:00:00,000
And the most common ones are things like domain error,

228
00:00:00,000 --> 00:00:00,000
the parameters outside the valid range, invalid argument,

229
00:00:00,000 --> 00:00:00,000
the argument was invalid for some reason, or out of range.

230
00:00:00,000 --> 00:00:00,000
The argument's not in expected range.

231
00:00:00,000 --> 00:00:00,000
So that's how we throw.

232
00:00:00,000 --> 00:00:00,000
That's how we signal from our function

233
00:00:00,000 --> 00:00:00,000
that an error has occurred.

234
00:00:00,000 --> 00:00:00,000
If we're calling the function, how do we

235
00:00:00,000 --> 00:00:00,000
intercept and handle that?

236
00:00:00,000 --> 00:00:00,000
And so to intercept and handle exceptions,

237
00:00:00,000 --> 00:00:00,000
we do almost the same thing you would do in Java and Python.

238
00:00:00,000 --> 00:00:00,000
Python has try, except, I think.

239
00:00:00,000 --> 00:00:00,000
Java has try, catch.

240
00:00:00,000 --> 00:00:00,000
So you place the code that can fail inside a try block.

241
00:00:00,000 --> 00:00:00,000
So we're going to call the function parseInt.

242
00:00:00,000 --> 00:00:00,000
We're going to pass it a string.

243
00:00:00,000 --> 00:00:00,000
That string may contain the digit 1,

244
00:00:00,000 --> 00:00:00,000
but it may also contain the word 1.

245
00:00:00,000 --> 00:00:00,000
And if it contains the word 1, rather than setting x

246
00:00:00,000 --> 00:00:00,000
to a value at all, what we'll do is we'll throw an exception.

247
00:00:00,000 --> 00:00:00,000
And any statements that follow this parseInt

248
00:00:00,000 --> 00:00:00,000
will be jumped over until we get to a catch block.

249
00:00:00,000 --> 00:00:00,000
So the catch block has to say what kind of exception

250
00:00:00,000 --> 00:00:00,000
it's going to throw.

251
00:00:00,000 --> 00:00:00,000
Now, this exception, we're going to decide what it throws.

252
00:00:00,000 --> 00:00:00,000
So you catch a specific type of exception.

253
00:00:00,000 --> 00:00:00,000
You always want to catch it by reference.

254
00:00:00,000 --> 00:00:00,000
So in this case, if we say the argument was invalid

255
00:00:00,000 --> 00:00:00,000
and we're catching that, we'd say catch invalid argument ref

256
00:00:00,000 --> 00:00:00,000
e.

257
00:00:00,000 --> 00:00:00,000
And then it would jump.

258
00:00:00,000 --> 00:00:00,000
If it failed, it would not do the next statement.

259
00:00:00,000 --> 00:00:00,000
It would jump from there to this invalid argument.

260
00:00:00,000 --> 00:00:00,000
Let me close Zoom.

261
00:00:00,000 --> 00:00:00,000
Keeps popping up, saying it wants me to log in.

262
00:00:00,000 --> 00:00:00,000
It would jump from this parseInt when it failed.

263
00:00:00,000 --> 00:00:00,000
It wouldn't assign anything to x.

264
00:00:00,000 --> 00:00:00,000
And it would jump down here to this catch,

265
00:00:00,000 --> 00:00:00,000
see if the exception that was thrown was this type.

266
00:00:00,000 --> 00:00:00,000
If it was, it would set the exception argument,

267
00:00:00,000 --> 00:00:00,000
and we would go into the exception altogether.

268
00:00:00,000 --> 00:00:00,000
So let's try a couple of those exercises,

269
00:00:00,000 --> 00:00:00,000
just so you get a feel for try-catch.

270
00:00:00,000 --> 00:00:00,000
So these are on part A of our exercises.

271
00:00:00,000 --> 00:00:00,000
There's an empty try-catch block here,

272
00:00:00,000 --> 00:00:00,000
which will do the catching.

273
00:00:00,000 --> 00:00:00,000
But it's up to us to redesign the code to make use of it.

274
00:00:00,000 --> 00:00:00,000
Now, there's an imaginary roster of students,

275
00:00:00,000 --> 00:00:00,000
which we'll pretend is dynamic, but for the purpose

276
00:00:00,000 --> 00:00:00,000
of this exercise, is hard-coded.

277
00:00:00,000 --> 00:00:00,000
You'll find the names in the source code.

278
00:00:00,000 --> 00:00:00,000
And the roster's implemented as an unordered map.

279
00:00:00,000 --> 00:00:00,000
You haven't learned how to use that,

280
00:00:00,000 --> 00:00:00,000
but you really don't need to know how to use it for that.

281
00:00:00,000 --> 00:00:00,000
When running the program, you're asked to enter a name.

282
00:00:00,000 --> 00:00:00,000
After doing so, it will use the map

283
00:00:00,000 --> 00:00:00,000
to print out the age of that student.

284
00:00:00,000 --> 00:00:00,000
Unfortunately, if the user enters

285
00:00:00,000 --> 00:00:00,000
a name that's not on the roster, it

286
00:00:00,000 --> 00:00:00,000
is not on the roster, an exception is thrown,

287
00:00:00,000 --> 00:00:00,000
which we don't handle, and the program just terminates.

288
00:00:00,000 --> 00:00:00,000
So we're going to do two modifications to this.

289
00:00:00,000 --> 00:00:00,000
We're going to catch the exception so that it can least

290
00:00:00,000 --> 00:00:00,000
exit gracefully, and write out a nice error telling the user

291
00:00:00,000 --> 00:00:00,000
that the name they entered doesn't exist.

292
00:00:00,000 --> 00:00:00,000
We're going to print the actual name they entered back at them.

293
00:00:00,000 --> 00:00:00,000
So let's do this first exercise.

294
00:00:00,000 --> 00:00:00,000
So here's our unordered map.

295
00:00:00,000 --> 00:00:00,000
So a map simply is a key, like the name here, and the age.

296
00:00:00,000 --> 00:00:00,000
So this is mapping a student's names to their ages.

297
00:00:00,000 --> 00:00:00,000
So this code is in a bit of a sorry state.

298
00:00:00,000 --> 00:00:00,000
If we enter a name inside here, and the name

299
00:00:00,000 --> 00:00:00,000
is Fred, which is not on our list, it will, when we do this,

300
00:00:00,000 --> 00:00:00,000
this line, student name at, will throw an exception.

301
00:00:00,000 --> 00:00:00,000
Will throw an exception.

302
00:00:00,000 --> 00:00:00,000
And so this is the try catch that we want to use.

303
00:00:00,000 --> 00:00:00,000
That's the necessary syntax.

304
00:00:00,000 --> 00:00:00,000
So we are going to throw an error.

305
00:00:00,000 --> 00:00:00,000
We're going to put this code.

306
00:00:00,000 --> 00:00:00,000
So that part's going to be outside.

307
00:00:00,000 --> 00:00:00,000
We're going to write try.

308
00:00:00,000 --> 00:00:00,000
And then I'm going to take this line-- actually,

309
00:00:00,000 --> 00:00:00,000
let me just copy this part out.

310
00:00:00,000 --> 00:00:00,000
So it gave us the syntax here.

311
00:00:00,000 --> 00:00:00,000
I'm just going to bring the catch here.

312
00:00:00,000 --> 00:00:00,000
And we're going to catch if it's out of range.

313
00:00:00,000 --> 00:00:00,000
And let me fix that.

314
00:00:00,000 --> 00:00:00,000
And we're going to say, C error, sorry, comma, name

315
00:00:00,000 --> 00:00:00,000
was not there.

316
00:00:00,000 --> 00:00:00,000
I don't know if that's the correct error message.

317
00:00:00,000 --> 00:00:00,000
OK, so notice the code that may fail

318
00:00:00,000 --> 00:00:00,000
is placed inside our try block.

319
00:00:00,000 --> 00:00:00,000
This code cannot fail.

320
00:00:00,000 --> 00:00:00,000
This code cannot fail.

321
00:00:00,000 --> 00:00:00,000
It's placed inside a try block.

322
00:00:00,000 --> 00:00:00,000
So let's try it.

323
00:00:00,000 --> 00:00:00,000
And I left out a set of arrows there.

324
00:00:00,000 --> 00:00:00,000
So I had a syntax error.

325
00:00:00,000 --> 00:00:00,000
Oops, and I put the arrows in the wrong place.

326
00:00:00,000 --> 00:00:00,000
Still had a syntax error.

327
00:00:00,000 --> 00:00:00,000
I left off a semicolon.

328
00:00:00,000 --> 00:00:00,000
I'm all thumbs today.

329
00:00:00,000 --> 00:00:00,000
OK, enter a name, John.

330
00:00:00,000 --> 00:00:00,000
John is 16 years old.

331
00:00:00,000 --> 00:00:00,000
OK, so yeah, so I didn't have-- so it was sorry, comma,

332
00:00:00,000 --> 00:00:00,000
Jake does not exist.

333
00:00:00,000 --> 00:00:00,000
So let's look at John.

334
00:00:00,000 --> 00:00:00,000
John is found, prints out its name,

335
00:00:00,000 --> 00:00:00,000
and then skips over the catch block.

336
00:00:00,000 --> 00:00:00,000
Catch block is never executed.

337
00:00:00,000 --> 00:00:00,000
Jake throws an exception here.

338
00:00:00,000 --> 00:00:00,000
We skip over the name is age years old.

339
00:00:00,000 --> 00:00:00,000
We jump from line 24 to line 27, and we print out,

340
00:00:00,000 --> 00:00:00,000
sorry, name does not exist.

341
00:00:00,000 --> 00:00:00,000
Same thing with Lawrence.

342
00:00:00,000 --> 00:00:00,000
Zoltan exists, so that works OK.

343
00:00:00,000 --> 00:00:00,000
So this is try, catch.

344
00:00:00,000 --> 00:00:00,000
Now let's do the second one.

345
00:00:00,000 --> 00:00:00,000
So we want to do it so that the program validates

346
00:00:00,000 --> 00:00:00,000
by using the try, catch.

347
00:00:00,000 --> 00:00:00,000
Doesn't just print out an error message,

348
00:00:00,000 --> 00:00:00,000
and it should do it continuously until they actually

349
00:00:00,000 --> 00:00:00,000
enter a valid name.

350
00:00:00,000 --> 00:00:00,000
So we don't have to do much difference here.

351
00:00:00,000 --> 00:00:00,000
What we're going to do is we're going

352
00:00:00,000 --> 00:00:00,000
to need to put all this code inside a do while block.

353
00:00:00,000 --> 00:00:00,000
A do while.

354
00:00:00,000 --> 00:00:00,000
So do, enter a name.

355
00:00:00,000 --> 00:00:00,000
Then we're going to put our try block.

356
00:00:00,000 --> 00:00:00,000
Try block.

357
00:00:00,000 --> 00:00:00,000
And we'll create a Boolean value.

358
00:00:00,000 --> 00:00:00,000
So that's going to have to be created

359
00:00:00,000 --> 00:00:00,000
before the do while loop.

360
00:00:00,000 --> 00:00:00,000
So Boole equals or done, false.

361
00:00:00,000 --> 00:00:00,000
If we succeed and don't throw an exception,

362
00:00:00,000 --> 00:00:00,000
we're going to set done equal to true.

363
00:00:00,000 --> 00:00:00,000
So now we're going to put in our catch block.

364
00:00:00,000 --> 00:00:00,000
And exactly the same code we had before.

365
00:00:00,000 --> 00:00:00,000
Here, sorry, name does not exist.

366
00:00:00,000 --> 00:00:00,000
And here's the end of our do.

367
00:00:00,000 --> 00:00:00,000
And here's the while.

368
00:00:00,000 --> 00:00:00,000
Not done.

369
00:00:00,000 --> 00:00:00,000
OK.

370
00:00:00,000 --> 00:00:00,000
So we're going to continue doing that while it's not done.

371
00:00:00,000 --> 00:00:00,000
We're going to enter in a name, print in the name.

372
00:00:00,000 --> 00:00:00,000
We're going to try it.

373
00:00:00,000 --> 00:00:00,000
If we try it and we succeed, if we get down to line 28,

374
00:00:00,000 --> 00:00:00,000
we're going to set done to true.

375
00:00:00,000 --> 00:00:00,000
This will fail and we'll be through.

376
00:00:00,000 --> 00:00:00,000
So let's try it.

377
00:00:00,000 --> 00:00:00,000
So enter name John.

378
00:00:00,000 --> 00:00:00,000
That worked fine.

379
00:00:00,000 --> 00:00:00,000
We just entered the name, set done to true.

380
00:00:00,000 --> 00:00:00,000
We hit our while loop and we're finished.

381
00:00:00,000 --> 00:00:00,000
Here we entered a name Jake.

382
00:00:00,000 --> 00:00:00,000
Nope.

383
00:00:00,000 --> 00:00:00,000
Sorry, name does not exist.

384
00:00:00,000 --> 00:00:00,000
It went up and it asked us to enter a name again.

385
00:00:00,000 --> 00:00:00,000
Now in this case, the code check doesn't

386
00:00:00,000 --> 00:00:00,000
show what it really looks like.

387
00:00:00,000 --> 00:00:00,000
So we would not enter Jake, Bill, and Paul.

388
00:00:00,000 --> 00:00:00,000
We'd enter Jake.

389
00:00:00,000 --> 00:00:00,000
It would say enter a name.

390
00:00:00,000 --> 00:00:00,000
We'd enter Bill here.

391
00:00:00,000 --> 00:00:00,000
Enter a name.

392
00:00:00,000 --> 00:00:00,000
We'd enter Paul.

393
00:00:00,000 --> 00:00:00,000
Paul's 31 years old.

394
00:00:00,000 --> 00:00:00,000
So notice this just repeats until it

395
00:00:00,000 --> 00:00:00,000
gives us the correct answer.

396
00:00:00,000 --> 00:00:00,000
It gives us the correct answer.

397
00:00:00,000 --> 00:00:00,000
OK, let's actually write some code now.

398
00:00:00,000 --> 00:00:00,000
And so go over and open.

399
00:00:00,000 --> 00:00:00,000
And open in IC14B, open int helper.h and int helper.cpp.

400
00:00:00,000 --> 00:00:00,000
I don't know why it's not letting me open both those.

401
00:00:00,000 --> 00:00:00,000
Maybe because I haven't added any code to it.

402
00:00:00,000 --> 00:00:00,000
Let me add code to that one and do the cpp.

403
00:00:00,000 --> 00:00:00,000
OK.

404
00:00:00,000 --> 00:00:00,000
OK, let's open a terminal on that.

405
00:00:00,000 --> 00:00:00,000
And then let me close that.

406
00:00:00,000 --> 00:00:00,000
OK, so these are the two functions we're going to write.

407
00:00:00,000 --> 00:00:00,000
So let's look at those.

408
00:00:00,000 --> 00:00:00,000
The first function, parseInt, is going

409
00:00:00,000 --> 00:00:00,000
to convert a string to an integer.

410
00:00:00,000 --> 00:00:00,000
So int n equals parseInt 42.

411
00:00:00,000 --> 00:00:00,000
If it can't succeed, it's going to throw an exception.

412
00:00:00,000 --> 00:00:00,000
The second function is going to read an int from the console.

413
00:00:00,000 --> 00:00:00,000
So this is int n equals readInt.

414
00:00:00,000 --> 00:00:00,000
Enter a number.

415
00:00:00,000 --> 00:00:00,000
The prompt is optional.

416
00:00:00,000 --> 00:00:00,000
And just like the last problem we did,

417
00:00:00,000 --> 00:00:00,000
it's going to keep prompting until integer values are

418
00:00:00,000 --> 00:00:00,000
entered.

419
00:00:00,000 --> 00:00:00,000
So we're going to start by documenting

420
00:00:00,000 --> 00:00:00,000
the functions in the header.

421
00:00:00,000 --> 00:00:00,000
Then we're going to have invalid input to parseInt

422
00:00:00,000 --> 00:00:00,000
by throwing an exception.

423
00:00:00,000 --> 00:00:00,000
And then we're going to validate our logic with assert.

424
00:00:00,000 --> 00:00:00,000
Now there's a little bit more information

425
00:00:00,000 --> 00:00:00,000
on this in the handout over here.

426
00:00:00,000 --> 00:00:00,000
So we're going to include the preconditions, postconditions,

427
00:00:00,000 --> 00:00:00,000
and exceptions.

428
00:00:00,000 --> 00:00:00,000
We're going to throw an invalid argument with an error message

429
00:00:00,000 --> 00:00:00,000
when parseInt fails.

430
00:00:00,000 --> 00:00:00,000
We use parseInt in an endless loop

431
00:00:00,000 --> 00:00:00,000
and try catch to implement readInt.

432
00:00:00,000 --> 00:00:00,000
And we'll use assert to check that we never

433
00:00:00,000 --> 00:00:00,000
reach the end of readInt.

434
00:00:00,000 --> 00:00:00,000
And I will just test this.

435
00:00:00,000 --> 00:00:00,000
I'll break out of my loop to make sure

436
00:00:00,000 --> 00:00:00,000
that the assertion works.

437
00:00:00,000 --> 00:00:00,000
Make sure that the assertion works.

438
00:00:00,000 --> 00:00:00,000
So let's document the function.

439
00:00:00,000 --> 00:00:00,000
And so parseInt-- we didn't put this in a namespace.

440
00:00:00,000 --> 00:00:00,000
We could have.

441
00:00:00,000 --> 00:00:00,000
So converts a string to an integer.

442
00:00:00,000 --> 00:00:00,000
At param s-- let me change that to str.

443
00:00:00,000 --> 00:00:00,000
I don't like just using single letter names.

444
00:00:00,000 --> 00:00:00,000
str is the string-- so str is the string to convert.

445
00:00:00,000 --> 00:00:00,000
Let's put in our precondition at pre.

446
00:00:00,000 --> 00:00:00,000
At pre, we'll contain valid digits, optional sign.

447
00:00:00,000 --> 00:00:00,000
Let's do minus 1, 2, 3 to give the optional sign there.

448
00:00:00,000 --> 00:00:00,000
So that tells us the precondition.

449
00:00:00,000 --> 00:00:00,000
That says what we assume is going

450
00:00:00,000 --> 00:00:00,000
to be true about parseInt at post or at return

451
00:00:00,000 --> 00:00:00,000
or at exception.

452
00:00:00,000 --> 00:00:00,000
Let's use at exception because that's a valid argument.

453
00:00:00,000 --> 00:00:00,000
If invalid argument, if str contains--

454
00:00:00,000 --> 00:00:00,000
contains invalid characters.

455
00:00:00,000 --> 00:00:00,000
And we might want to put more about what that possibly is.

456
00:00:00,000 --> 00:00:00,000
And at return, the integer result.

457
00:00:00,000 --> 00:00:00,000
So that's pretty good for the documentation.

458
00:00:00,000 --> 00:00:00,000
So readInt-- it's an integer from the console

459
00:00:00,000 --> 00:00:00,000
or standard input.

460
00:00:00,000 --> 00:00:00,000
At param prompt will be displayed

461
00:00:00,000 --> 00:00:00,000
if passed with a colon.

462
00:00:00,000 --> 00:00:00,000
OK, at return, and the post condition here

463
00:00:00,000 --> 00:00:00,000
is keeps prompting.

464
00:00:00,000 --> 00:00:00,000
So there's our documentation.

465
00:00:00,000 --> 00:00:00,000
There's our documentation.

466
00:00:00,000 --> 00:00:00,000
So let's take this.

467
00:00:00,000 --> 00:00:00,000
Let's go over to inhelper.cpp.

468
00:00:00,000 --> 00:00:00,000
Let's put your Canvas ID on it.

469
00:00:00,000 --> 00:00:00,000
Let's write the functions here.

470
00:00:00,000 --> 00:00:00,000
You can leave the docs inside here if you want.

471
00:00:00,000 --> 00:00:00,000
You don't have to.

472
00:00:00,000 --> 00:00:00,000
Let's put the body on it.

473
00:00:00,000 --> 00:00:00,000
Let's stub it.

474
00:00:00,000 --> 00:00:00,000
Let's return a value in each case.

475
00:00:00,000 --> 00:00:00,000
We're stubbing it, just making a skeleton.

476
00:00:00,000 --> 00:00:00,000
Let's go ahead and try it.

477
00:00:00,000 --> 00:00:00,000
OK, so number one, we made a syntax error.

478
00:00:00,000 --> 00:00:00,000
And that is when we have default arguments,

479
00:00:00,000 --> 00:00:00,000
you need to remove them in the implementation.

480
00:00:00,000 --> 00:00:00,000
Let's try it again.

481
00:00:00,000 --> 00:00:00,000
So parseInt is what's being tested here.

482
00:00:00,000 --> 00:00:00,000
parseInt is what's being tested here.

483
00:00:00,000 --> 00:00:00,000
So let's actually do something.

484
00:00:00,000 --> 00:00:00,000
And parseInt didn't work at all.

485
00:00:00,000 --> 00:00:00,000
So let's go over and look at how we get parseInt to work.

486
00:00:00,000 --> 00:00:00,000
So what we need to do for parseInt

487
00:00:00,000 --> 00:00:00,000
is we need a string stream.

488
00:00:00,000 --> 00:00:00,000
So we're going to take a input string stream.

489
00:00:00,000 --> 00:00:00,000
And we're going to initialize that with the parameter str.

490
00:00:00,000 --> 00:00:00,000
Then we're going to create an int n.

491
00:00:00,000 --> 00:00:00,000
And we're going to read into n.

492
00:00:00,000 --> 00:00:00,000
OK.

493
00:00:00,000 --> 00:00:00,000
Now, if n is not failed--

494
00:00:00,000 --> 00:00:00,000
and you can write that as if not n fail.

495
00:00:00,000 --> 00:00:00,000
So if not n fail, in other words, if n's still good.

496
00:00:00,000 --> 00:00:00,000
And n is at EOF, then we're simply going to return n.

497
00:00:00,000 --> 00:00:00,000
This simply means, did we consume everything

498
00:00:00,000 --> 00:00:00,000
inside that string?

499
00:00:00,000 --> 00:00:00,000
We're at end of file.

500
00:00:00,000 --> 00:00:00,000
That's true.

501
00:00:00,000 --> 00:00:00,000
This says, well, we didn't read any invalid characters.

502
00:00:00,000 --> 00:00:00,000
So if both of those are the case, that's true.

503
00:00:00,000 --> 00:00:00,000
Now, it's possible that someone could enter a string like this.

504
00:00:00,000 --> 00:00:00,000
So notice that the n will automatically

505
00:00:00,000 --> 00:00:00,000
skip this whitespace.

506
00:00:00,000 --> 00:00:00,000
But it will still stop right on this character.

507
00:00:00,000 --> 00:00:00,000
That means we're not at end of file.

508
00:00:00,000 --> 00:00:00,000
And so to fix that, we have to read the whitespace again.

509
00:00:00,000 --> 00:00:00,000
So in whitespace.

510
00:00:00,000 --> 00:00:00,000
And now we're just going to repeat this statement.

511
00:00:00,000 --> 00:00:00,000
Now, I'm sure this kind of bothers you.

512
00:00:00,000 --> 00:00:00,000
And it bothers me a lot, too.

513
00:00:00,000 --> 00:00:00,000
Because really what I'd like to do is do this.

514
00:00:00,000 --> 00:00:00,000
I'd like to read the input and the whitespace all

515
00:00:00,000 --> 00:00:00,000
in one statement.

516
00:00:00,000 --> 00:00:00,000
That works under the GCC library we're doing.

517
00:00:00,000 --> 00:00:00,000
It works on Unix.

518
00:00:00,000 --> 00:00:00,000
Again, the GCC library we're using.

519
00:00:00,000 --> 00:00:00,000
It works on Windows, the Windows libraries.

520
00:00:00,000 --> 00:00:00,000
It doesn't work on the Mac libraries.

521
00:00:00,000 --> 00:00:00,000
And actually, since we're not programming this in Mac,

522
00:00:00,000 --> 00:00:00,000
I'm just going to use it anyway.

523
00:00:00,000 --> 00:00:00,000
On the Mac libraries, unfortunately, it fails.

524
00:00:00,000 --> 00:00:00,000
So we're going to read the number.

525
00:00:00,000 --> 00:00:00,000
If there's any whitespace, we're going to read it.

526
00:00:00,000 --> 00:00:00,000
So this one's going to read OK.

527
00:00:00,000 --> 00:00:00,000
This one-- actually, let me comment that out.

528
00:00:00,000 --> 00:00:00,000
This one is going to throw an exception.

529
00:00:00,000 --> 00:00:00,000
That's what we want to happen.

530
00:00:00,000 --> 00:00:00,000
That should throw an exception.

531
00:00:00,000 --> 00:00:00,000
And so we're going to throw invalid argument.

532
00:00:00,000 --> 00:00:00,000
[TYPING]

533
00:00:00,000 --> 00:00:00,000
Or something else like that.

534
00:00:00,000 --> 00:00:00,000
Now, let's come down here to run.

535
00:00:00,000 --> 00:00:00,000
Let's comment out those first two.

536
00:00:00,000 --> 00:00:00,000
And let's just do make run.

537
00:00:00,000 --> 00:00:00,000
Make run.

538
00:00:00,000 --> 00:00:00,000
So I'm going to pull that right there.

539
00:00:00,000 --> 00:00:00,000
I'm going to clean that and do make run.

540
00:00:00,000 --> 00:00:00,000
Student testing 125.

541
00:00:00,000 --> 00:00:00,000
It works.

542
00:00:00,000 --> 00:00:00,000
Now, if we've done everything correctly,

543
00:00:00,000 --> 00:00:00,000
this one should throw an exception.

544
00:00:00,000 --> 00:00:00,000
So make run.

545
00:00:00,000 --> 00:00:00,000
Terminate after throwing an instance

546
00:00:00,000 --> 00:00:00,000
of standard invalid argument.

547
00:00:00,000 --> 00:00:00,000
5.2 is not an integer.

548
00:00:00,000 --> 00:00:00,000
15.2 is not an integer.

549
00:00:00,000 --> 00:00:00,000
So that's pretty cool, right?

550
00:00:00,000 --> 00:00:00,000
So this is the default handler when we didn't catch anything.

551
00:00:00,000 --> 00:00:00,000
In other words, we didn't put this in a try catch.

552
00:00:00,000 --> 00:00:00,000
If you don't put it in a try catch, it just terminates.

553
00:00:00,000 --> 00:00:00,000
So through an instance of standard invalid argument.

554
00:00:00,000 --> 00:00:00,000
Let's comment out that line again.

555
00:00:00,000 --> 00:00:00,000
And then let's go to our second one

556
00:00:00,000 --> 00:00:00,000
up here, which is read int.

557
00:00:00,000 --> 00:00:00,000
So for read int, we're going to prompt the display

558
00:00:00,000 --> 00:00:00,000
if it exists.

559
00:00:00,000 --> 00:00:00,000
So if not prompt empty.

560
00:00:00,000 --> 00:00:00,000
Or you can write it if prompt not equal to quote, quote.

561
00:00:00,000 --> 00:00:00,000
This is a little less efficient than-- because prompt empty.

562
00:00:00,000 --> 00:00:00,000
Prompt not equal to quote, quote has to first convert

563
00:00:00,000 --> 00:00:00,000
the quote, quote into a string.

564
00:00:00,000 --> 00:00:00,000
It has to use the relational operator

565
00:00:00,000 --> 00:00:00,000
to find if it's not equal.

566
00:00:00,000 --> 00:00:00,000
So prompt empty is just going to return true or false

567
00:00:00,000 --> 00:00:00,000
immediately.

568
00:00:00,000 --> 00:00:00,000
So that's probably a little better.

569
00:00:00,000 --> 00:00:00,000
But this probably is easier for people to understand.

570
00:00:00,000 --> 00:00:00,000
If the prompt is not empty, we're

571
00:00:00,000 --> 00:00:00,000
going to see out the prompt.

572
00:00:00,000 --> 00:00:00,000
And if prompt back is not equal to a space,

573
00:00:00,000 --> 00:00:00,000
and prompt back is not equal to a colon,

574
00:00:00,000 --> 00:00:00,000
let's just say a space.

575
00:00:00,000 --> 00:00:00,000
If that's not the case, then I'm going

576
00:00:00,000 --> 00:00:00,000
to print out a colon or space.

577
00:00:00,000 --> 00:00:00,000
In other words, I want to get the input away from the prompt.

578
00:00:00,000 --> 00:00:00,000
OK.

579
00:00:00,000 --> 00:00:00,000
Now let's convert the thing.

580
00:00:00,000 --> 00:00:00,000
So we're going to say return parsing.

581
00:00:00,000 --> 00:00:00,000
Oh, we need to read the value.

582
00:00:00,000 --> 00:00:00,000
So string value.

583
00:00:00,000 --> 00:00:00,000
Oh, we need to--

584
00:00:00,000 --> 00:00:00,000
yeah.

585
00:00:00,000 --> 00:00:00,000
Yeah, we're going to use parseInt.

586
00:00:00,000 --> 00:00:00,000
We're going to return parseInt.

587
00:00:00,000 --> 00:00:00,000
parseInt value.

588
00:00:00,000 --> 00:00:00,000
OK.

589
00:00:00,000 --> 00:00:00,000
So this is the basic structure.

590
00:00:00,000 --> 00:00:00,000
Let's come down here and uncomment these two lines.

591
00:00:00,000 --> 00:00:00,000
Let's do make run on it.

592
00:00:00,000 --> 00:00:00,000
OK.

593
00:00:00,000 --> 00:00:00,000
Enter a number.

594
00:00:00,000 --> 00:00:00,000
And notice how it added my colon.

595
00:00:00,000 --> 00:00:00,000
So notice my prompt is enter a number.

596
00:00:00,000 --> 00:00:00,000
It adds the colon in this space after it

597
00:00:00,000 --> 00:00:00,000
and puts my input there.

598
00:00:00,000 --> 00:00:00,000
I'll enter 245.

599
00:00:00,000 --> 00:00:00,000
And you enter 245.

600
00:00:00,000 --> 00:00:00,000
Now let me run it again.

601
00:00:00,000 --> 00:00:00,000
2.45.

602
00:00:00,000 --> 00:00:00,000
It threw an exception.

603
00:00:00,000 --> 00:00:00,000
So we want, if this value is bad,

604
00:00:00,000 --> 00:00:00,000
that's going to return-- that's going to throw an exception.

605
00:00:00,000 --> 00:00:00,000
So we're going to put this whole thing in an endless loop.

606
00:00:00,000 --> 00:00:00,000
File, true.

607
00:00:00,000 --> 00:00:00,000
So this will return out of the loop.

608
00:00:00,000 --> 00:00:00,000
Then we'll put this part.

609
00:00:00,000 --> 00:00:00,000
Enter inside a try.

610
00:00:00,000 --> 00:00:00,000
Catch.

611
00:00:00,000 --> 00:00:00,000
And I'm not going to print an error message.

612
00:00:00,000 --> 00:00:00,000
Oh, maybe I will.

613
00:00:00,000 --> 00:00:00,000
Maybe I'll print an error message.

614
00:00:00,000 --> 00:00:00,000
OK.

615
00:00:00,000 --> 00:00:00,000
I don't know if the testing actually wants this error

616
00:00:00,000 --> 00:00:00,000
message.

617
00:00:00,000 --> 00:00:00,000
OK.

618
00:00:00,000 --> 00:00:00,000
So this is like what we did in the code check exercise.

619
00:00:00,000 --> 00:00:00,000
So we have a do while or a while true.

620
00:00:00,000 --> 00:00:00,000
And if we can parse the value, we get out.

621
00:00:00,000 --> 00:00:00,000
If not, we print out, sorry, that's not an integer.

622
00:00:00,000 --> 00:00:00,000
And we go back and prompt for it again.

623
00:00:00,000 --> 00:00:00,000
So let's try that now with our run here.

624
00:00:00,000 --> 00:00:00,000
So make run.

625
00:00:00,000 --> 00:00:00,000
Enter a number, 1.

626
00:00:00,000 --> 00:00:00,000
Sorry, 1 is not an integer.

627
00:00:00,000 --> 00:00:00,000
Enter a number, 45.2.

628
00:00:00,000 --> 00:00:00,000
Sorry, 45.2 is not an integer.

629
00:00:00,000 --> 00:00:00,000
75.

630
00:00:00,000 --> 00:00:00,000
OK, and we entered 75.

631
00:00:00,000 --> 00:00:00,000
Now once we've done that, we can check the parse

632
00:00:00,000 --> 00:00:00,000
in here with the testing.

633
00:00:00,000 --> 00:00:00,000
So make test.

634
00:00:00,000 --> 00:00:00,000
So it works perfectly fine.

635
00:00:00,000 --> 00:00:00,000
So up here, you're going to--

636
00:00:00,000 --> 00:00:00,000
oh, we want to do one more thing.

637
00:00:00,000 --> 00:00:00,000
We want to break out of the loop to see

638
00:00:00,000 --> 00:00:00,000
that our assertion works.

639
00:00:00,000 --> 00:00:00,000
And we haven't put in an assertion.

640
00:00:00,000 --> 00:00:00,000
So an assertion is something that is impossible.

641
00:00:00,000 --> 00:00:00,000
So what's impossible?

642
00:00:00,000 --> 00:00:00,000
This loop is while true.

643
00:00:00,000 --> 00:00:00,000
It's impossible for me to get here.

644
00:00:00,000 --> 00:00:00,000
So I'm just going to say assert false.

645
00:00:00,000 --> 00:00:00,000
This is saying this is unreachable.

646
00:00:00,000 --> 00:00:00,000
That is unreachable.

647
00:00:00,000 --> 00:00:00,000
Now what I'm going to do is I'm going

648
00:00:00,000 --> 00:00:00,000
to make a mistake in my code.

649
00:00:00,000 --> 00:00:00,000
Remember, assertions are determined

650
00:00:00,000 --> 00:00:00,000
to catch mistakes in your code.

651
00:00:00,000 --> 00:00:00,000
I can say that my intention, my assumption,

652
00:00:00,000 --> 00:00:00,000
is that I should never, ever be able to get

653
00:00:00,000 --> 00:00:00,000
to this line of code.

654
00:00:00,000 --> 00:00:00,000
It's unreachable.

655
00:00:00,000 --> 00:00:00,000
It's unreachable.

656
00:00:00,000 --> 00:00:00,000
But what if I inadvertently say break?

657
00:00:00,000 --> 00:00:00,000
Like that.

658
00:00:00,000 --> 00:00:00,000
So this is a piece of error in my code now.

659
00:00:00,000 --> 00:00:00,000
And when I do-- let's do make run again.

660
00:00:00,000 --> 00:00:00,000
And when I do 1, if I do 42, it works fine.

661
00:00:00,000 --> 00:00:00,000
But if I do 1, it throws the exception.

662
00:00:00,000 --> 00:00:00,000
But also, I actually had an assertion.

663
00:00:00,000 --> 00:00:00,000
So I'd go look at line 55.

664
00:00:00,000 --> 00:00:00,000
When I looked at line 55, it would say,

665
00:00:00,000 --> 00:00:00,000
oh, this should be unreachable, or this is unreachable.

666
00:00:00,000 --> 00:00:00,000
And then I'd look back and try and find my error.

667
00:00:00,000 --> 00:00:00,000
I'd see, how did I possibly get to that code?

668
00:00:00,000 --> 00:00:00,000
And maybe I'd put it in the debugger or so forth.

669
00:00:00,000 --> 00:00:00,000
So I'm going to comment that out.

670
00:00:00,000 --> 00:00:00,000
So this is the kind of thing you want to put in your statement.

671
00:00:00,000 --> 00:00:00,000
Now, false normally would put some kind of condition.

672
00:00:00,000 --> 00:00:00,000
False just means, if you ever get to this line of code,

673
00:00:00,000 --> 00:00:00,000
throw the exception, or throw the assertion,

674
00:00:00,000 --> 00:00:00,000
trigger the assertion at that point.

675
00:00:00,000 --> 00:00:00,000
All right.

676
00:00:00,000 --> 00:00:00,000
So those were two good exercises to get you

677
00:00:00,000 --> 00:00:00,000
into throwing exceptions.

678
00:00:00,000 --> 00:00:00,000
The last topic we're going to talk about today

679
00:00:00,000 --> 00:00:00,000
is function templates.

680
00:00:00,000 --> 00:00:00,000
So look at this function.

681
00:00:00,000 --> 00:00:00,000
So I have a function smaller, takes two integers, a and b,

682
00:00:00,000 --> 00:00:00,000
and uses the conditional operator,

683
00:00:00,000 --> 00:00:00,000
return the smaller of a or b.

684
00:00:00,000 --> 00:00:00,000
So if a is less than b, it returns a.

685
00:00:00,000 --> 00:00:00,000
Otherwise, it returns b.

686
00:00:00,000 --> 00:00:00,000
Notice this, actually, the algorithm that she uses

687
00:00:00,000 --> 00:00:00,000
will return b if they're identical, not a.

688
00:00:00,000 --> 00:00:00,000
So perhaps it would have been better

689
00:00:00,000 --> 00:00:00,000
if you wanted to return a if it was the smaller.

690
00:00:00,000 --> 00:00:00,000
In other words, first or smaller would say a less than

691
00:00:00,000 --> 00:00:00,000
or equal to b, return a.

692
00:00:00,000 --> 00:00:00,000
What if we want this function, though,

693
00:00:00,000 --> 00:00:00,000
to work for something other than an integer?

694
00:00:00,000 --> 00:00:00,000
Will it work for a double?

695
00:00:00,000 --> 00:00:00,000
In other words, if we called smaller 1.5, 1.75, well,

696
00:00:00,000 --> 00:00:00,000
first it would truncate them, right?

697
00:00:00,000 --> 00:00:00,000
It wouldn't really work for other types.

698
00:00:00,000 --> 00:00:00,000
So if I wanted smaller of 3.5 and 7.5,

699
00:00:00,000 --> 00:00:00,000
I'd always get back an int here.

700
00:00:00,000 --> 00:00:00,000
If I wanted smaller of zebra and ant, it wouldn't work at all.

701
00:00:00,000 --> 00:00:00,000
So how would we fix that?

702
00:00:00,000 --> 00:00:00,000
How would we fix it?

703
00:00:00,000 --> 00:00:00,000
Well, option one is just write an overloaded function

704
00:00:00,000 --> 00:00:00,000
for each type.

705
00:00:00,000 --> 00:00:00,000
So here's a smaller for a for double,

706
00:00:00,000 --> 00:00:00,000
and here's a smaller for string.

707
00:00:00,000 --> 00:00:00,000
And then our main function on the previous page works.

708
00:00:00,000 --> 00:00:00,000
The downside, the disadvantage, is

709
00:00:00,000 --> 00:00:00,000
that you have to write a new version for each type you want.

710
00:00:00,000 --> 00:00:00,000
When the code in the body is exactly the same,

711
00:00:00,000 --> 00:00:00,000
both of them say return a less than b, a, b.

712
00:00:00,000 --> 00:00:00,000
So it's kind of redundant.

713
00:00:00,000 --> 00:00:00,000
That's where function templates come in.

714
00:00:00,000 --> 00:00:00,000
So a function template is a set of instructions

715
00:00:00,000 --> 00:00:00,000
that tell the compiler how to generate a function when

716
00:00:00,000 --> 00:00:00,000
it is called.

717
00:00:00,000 --> 00:00:00,000
The functions are only generated if they are called.

718
00:00:00,000 --> 00:00:00,000
If we write the template for smaller,

719
00:00:00,000 --> 00:00:00,000
and we pass in-- we don't call it with a string,

720
00:00:00,000 --> 00:00:00,000
it will never be generated from a string.

721
00:00:00,000 --> 00:00:00,000
So here's the template function.

722
00:00:00,000 --> 00:00:00,000
Notice first that every template function always

723
00:00:00,000 --> 00:00:00,000
starts with template, type name, and then

724
00:00:00,000 --> 00:00:00,000
some symbol you're going to use as a placeholder for your type.

725
00:00:00,000 --> 00:00:00,000
T is really common.

726
00:00:00,000 --> 00:00:00,000
U is really common.

727
00:00:00,000 --> 00:00:00,000
But you can use larger names or ones that are more descriptive

728
00:00:00,000 --> 00:00:00,000
if you want.

729
00:00:00,000 --> 00:00:00,000
So this says the function smaller

730
00:00:00,000 --> 00:00:00,000
is going to return a type of whatever type T is.

731
00:00:00,000 --> 00:00:00,000
And it's going to take two arguments, a const T ref for a

732
00:00:00,000 --> 00:00:00,000
and a const T ref for b.

733
00:00:00,000 --> 00:00:00,000
And notice the code in here is exactly the same.

734
00:00:00,000 --> 00:00:00,000
Now, templates have to be seen when your code compiles.

735
00:00:00,000 --> 00:00:00,000
For that reason, they're generally

736
00:00:00,000 --> 00:00:00,000
placed in a header file.

737
00:00:00,000 --> 00:00:00,000
They are not pre-compiled like a regular function.

738
00:00:00,000 --> 00:00:00,000
Now, there are two ways to call a template function.

739
00:00:00,000 --> 00:00:00,000
Or specifically, there are two ways

740
00:00:00,000 --> 00:00:00,000
to generate the function from the template.

741
00:00:00,000 --> 00:00:00,000
When you call it, you can explicitly specify

742
00:00:00,000 --> 00:00:00,000
the type to be used for T. So I could

743
00:00:00,000 --> 00:00:00,000
call that function with smaller.

744
00:00:00,000 --> 00:00:00,000
And then in angle brackets after the name, I could say string.

745
00:00:00,000 --> 00:00:00,000
So generate a smaller function that uses string for T,

746
00:00:00,000 --> 00:00:00,000
and then pass in frog and flea.

747
00:00:00,000 --> 00:00:00,000
Now, that will write-- when you call the function,

748
00:00:00,000 --> 00:00:00,000
it will write a version of smaller

749
00:00:00,000 --> 00:00:00,000
that has the T replaced with string here.

750
00:00:00,000 --> 00:00:00,000
So it will say string smaller.

751
00:00:00,000 --> 00:00:00,000
Const string ref a, const string ref b, return a less than b.

752
00:00:00,000 --> 00:00:00,000
It will write that function for you.

753
00:00:00,000 --> 00:00:00,000
So that is called a template function.

754
00:00:00,000 --> 00:00:00,000
This is a function template.

755
00:00:00,000 --> 00:00:00,000
The function that's generated is called a template function.

756
00:00:00,000 --> 00:00:00,000
Now, can you simply call it implicitly?

757
00:00:00,000 --> 00:00:00,000
Yes, you can.

758
00:00:00,000 --> 00:00:00,000
So if I call the function auto n equals smaller 3.46 and 3.45,

759
00:00:00,000 --> 00:00:00,000
it will, in fact, give me back 3.45.

760
00:00:00,000 --> 00:00:00,000
And that generates this function.

761
00:00:00,000 --> 00:00:00,000
Double, remember, replaces the T with double,

762
00:00:00,000 --> 00:00:00,000
replaces the a with double, the b with double.

763
00:00:00,000 --> 00:00:00,000
And actually, it will replace it with const double ref,

764
00:00:00,000 --> 00:00:00,000
const double ref b.

765
00:00:00,000 --> 00:00:00,000
The reason we do the const in the template

766
00:00:00,000 --> 00:00:00,000
is because we don't know what type T is going to be here.

767
00:00:00,000 --> 00:00:00,000
And so we use the const T ref in case it's a library type.

768
00:00:00,000 --> 00:00:00,000
It doesn't hurt it if it's a primitive type,

769
00:00:00,000 --> 00:00:00,000
although it's not as efficient as it could be.

770
00:00:00,000 --> 00:00:00,000
Now, a couple of problems with that.

771
00:00:00,000 --> 00:00:00,000
First, the compiler cannot read your mind.

772
00:00:00,000 --> 00:00:00,000
What if we said auto s equals smaller frog and flea?

773
00:00:00,000 --> 00:00:00,000
If we do this, the compiler is going

774
00:00:00,000 --> 00:00:00,000
to deduce type T as a character array instead of string.

775
00:00:00,000 --> 00:00:00,000
And the code actually will not work.

776
00:00:00,000 --> 00:00:00,000
So notice earlier-- so notice here

777
00:00:00,000 --> 00:00:00,000
I'm finding the smaller frog and flea, and it doesn't work.

778
00:00:00,000 --> 00:00:00,000
But here, I explicitly said, oh, I

779
00:00:00,000 --> 00:00:00,000
want to use string for that type.

780
00:00:00,000 --> 00:00:00,000
And it did work.

781
00:00:00,000 --> 00:00:00,000
So the compiler can't read your mind.

782
00:00:00,000 --> 00:00:00,000
The solution is to either explicitly instantiate it,

783
00:00:00,000 --> 00:00:00,000
or you can add an overload of the function.

784
00:00:00,000 --> 00:00:00,000
If you write an overloaded non-template function that

785
00:00:00,000 --> 00:00:00,000
exactly matches the arguments here,

786
00:00:00,000 --> 00:00:00,000
then this version will be used before the other version.

787
00:00:00,000 --> 00:00:00,000
OK.

788
00:00:00,000 --> 00:00:00,000
A couple more problems with deduction.

789
00:00:00,000 --> 00:00:00,000
What happens when we do this?

790
00:00:00,000 --> 00:00:00,000
Auto n equals smaller 3.46 and 4.

791
00:00:00,000 --> 00:00:00,000
Well, that doesn't even compile.

792
00:00:00,000 --> 00:00:00,000
T is supposed to be a double, like argument 1,

793
00:00:00,000 --> 00:00:00,000
or an n, like argument 2.

794
00:00:00,000 --> 00:00:00,000
And remember, let's look back at the template.

795
00:00:00,000 --> 00:00:00,000
We have only one type name here, but two arguments

796
00:00:00,000 --> 00:00:00,000
that are type T. So it's going to look at this one and say,

797
00:00:00,000 --> 00:00:00,000
oh, no, it's a double.

798
00:00:00,000 --> 00:00:00,000
Oh, no, it's an int.

799
00:00:00,000 --> 00:00:00,000
It doesn't compile.

800
00:00:00,000 --> 00:00:00,000
It doesn't compile.

801
00:00:00,000 --> 00:00:00,000
OK.

802
00:00:00,000 --> 00:00:00,000
So how do we fix that?

803
00:00:00,000 --> 00:00:00,000
Well, you don't have to make every argument the same type

804
00:00:00,000 --> 00:00:00,000
parameter.

805
00:00:00,000 --> 00:00:00,000
So let's say we have a double.

806
00:00:00,000 --> 00:00:00,000
We don't have to make every argument the same type

807
00:00:00,000 --> 00:00:00,000
parameter.

808
00:00:00,000 --> 00:00:00,000
So I could say template.

809
00:00:00,000 --> 00:00:00,000
I could create a type name named T, another type name named

810
00:00:00,000 --> 00:00:00,000
U. And in this case, when I called it here,

811
00:00:00,000 --> 00:00:00,000
A would be double, or T would be double, and U would be int.

812
00:00:00,000 --> 00:00:00,000
Now, which one will it return?

813
00:00:00,000 --> 00:00:00,000
Will it return an int or a double?

814
00:00:00,000 --> 00:00:00,000
This actually is a little bit problematic.

815
00:00:00,000 --> 00:00:00,000
The return type could be either T or U.

816
00:00:00,000 --> 00:00:00,000
Starting in C++ 17, we can put auto as the return type here,

817
00:00:00,000 --> 00:00:00,000
and it will allow compiler deduction.

818
00:00:00,000 --> 00:00:00,000
If you look in your reader, you'll

819
00:00:00,000 --> 00:00:00,000
see a version that will work with C++ 11 and 14.

820
00:00:00,000 --> 00:00:00,000
This is called a trailing return type.

821
00:00:00,000 --> 00:00:00,000
However, this function probably has

822
00:00:00,000 --> 00:00:00,000
to decide either return an int or a double in this case.

823
00:00:00,000 --> 00:00:00,000
Because in fact, what's going to happen

824
00:00:00,000 --> 00:00:00,000
is to see if A is less than B. And if A is an int

825
00:00:00,000 --> 00:00:00,000
and B is a double, your computer cannot actually compute this

826
00:00:00,000 --> 00:00:00,000
without knowing which of those is a larger.

827
00:00:00,000 --> 00:00:00,000
So the larger type will always be the type

828
00:00:00,000 --> 00:00:00,000
that's returned in that case.

829
00:00:00,000 --> 00:00:00,000
OK, let's do a couple of exercises

830
00:00:00,000 --> 00:00:00,000
before we end up this lecture and our hour together.

831
00:00:00,000 --> 00:00:00,000
So let me go back to our lecture exercise.

832
00:00:00,000 --> 00:00:00,000
And these are some function templates

833
00:00:00,000 --> 00:00:00,000
from Purdue University.

834
00:00:00,000 --> 00:00:00,000
So we're going to write one function, exchange AB, which

835
00:00:00,000 --> 00:00:00,000
has two parameters of the same type.

836
00:00:00,000 --> 00:00:00,000
So we only need one template parameter.

837
00:00:00,000 --> 00:00:00,000
A function which is instantiated from exchange

838
00:00:00,000 --> 00:00:00,000
will exchange or swap these two parameters.

839
00:00:00,000 --> 00:00:00,000
And then multiples, sum, x, and n.

840
00:00:00,000 --> 00:00:00,000
The first type of parameters will

841
00:00:00,000 --> 00:00:00,000
have the type represented by the function template type

842
00:00:00,000 --> 00:00:00,000
parameter kind, or T. n will always be int.

843
00:00:00,000 --> 00:00:00,000
The return type's void.

844
00:00:00,000 --> 00:00:00,000
All parameters are passed by value,

845
00:00:00,000 --> 00:00:00,000
except for sum, which is passed by reference.

846
00:00:00,000 --> 00:00:00,000
A function instantiated from multiples

847
00:00:00,000 --> 00:00:00,000
will compute 1 plus x plus 2x plus 3x and so forth to nx.

848
00:00:00,000 --> 00:00:00,000
So let's go ahead and do that, although I don't remember

849
00:00:00,000 --> 00:00:00,000
exactly how to solve that.

850
00:00:00,000 --> 00:00:00,000
OK, so here's the first one.

851
00:00:00,000 --> 00:00:00,000
We're going to exchange A and B. So for the templates,

852
00:00:00,000 --> 00:00:00,000
we're going to write template type name T.

853
00:00:00,000 --> 00:00:00,000
Looks like exchange doesn't return anything.

854
00:00:00,000 --> 00:00:00,000
And so that's going to be T reference A and T reference B.

855
00:00:00,000 --> 00:00:00,000
We'll create a temporary T object.

856
00:00:00,000 --> 00:00:00,000
So T temp.

857
00:00:00,000 --> 00:00:00,000
We'll initialize it with A. We'll say A equals B.

858
00:00:00,000 --> 00:00:00,000
We'll say B equals temp.

859
00:00:00,000 --> 00:00:00,000
And now we've exchanged the two values.

860
00:00:00,000 --> 00:00:00,000
OK, so notice we can do it with ints.

861
00:00:00,000 --> 00:00:00,000
We can do it with doubles.

862
00:00:00,000 --> 00:00:00,000
We can do it with strings.

863
00:00:00,000 --> 00:00:00,000
OK, so sum-- OK, so that is going to take template type

864
00:00:00,000 --> 00:00:00,000
name.

865
00:00:00,000 --> 00:00:00,000
They want kind for the type here,

866
00:00:00,000 --> 00:00:00,000
I think, just to show you that you can use--

867
00:00:00,000 --> 00:00:00,000
you don't need to use T. Void and kind reference sum.

868
00:00:00,000 --> 00:00:00,000
And kind-- what was the second argument in that?

869
00:00:00,000 --> 00:00:00,000
x, kind reference x, or kind x, test by value, and int n.

870
00:00:00,000 --> 00:00:00,000
OK, so sum, let's set it to whatever value represents 0,

871
00:00:00,000 --> 00:00:00,000
or the empty value.

872
00:00:00,000 --> 00:00:00,000
For instance, if we wanted to sum strings,

873
00:00:00,000 --> 00:00:00,000
do they do strings here?

874
00:00:00,000 --> 00:00:00,000
No, they only do it with numbers,

875
00:00:00,000 --> 00:00:00,000
because the expression is going to be 1 over.

876
00:00:00,000 --> 00:00:00,000
So we're going to say sum equals 0.

877
00:00:00,000 --> 00:00:00,000
Or is it?

878
00:00:00,000 --> 00:00:00,000
Let's look at the expression.

879
00:00:00,000 --> 00:00:00,000
So sum equals 1 plus x.

880
00:00:00,000 --> 00:00:00,000
And it'll be converted to whatever type it is.

881
00:00:00,000 --> 00:00:00,000
And then it's going to be x plus 2x plus 3x.

882
00:00:00,000 --> 00:00:00,000
So write a loop for int i equals 1, so 1x, i less than

883
00:00:00,000 --> 00:00:00,000
or equal to n, because we want nx, i plus plus,

884
00:00:00,000 --> 00:00:00,000
sum equals sum plus i times x.

885
00:00:00,000 --> 00:00:00,000
And I think that's all we'll have to do.

886
00:00:00,000 --> 00:00:00,000
Down here it works, you can see, with doubles.

887
00:00:00,000 --> 00:00:00,000
And it works with ints.

888
00:00:00,000 --> 00:00:00,000
OK, let's try it.

889
00:00:00,000 --> 00:00:00,000
OK, so that worked.

890
00:00:00,000 --> 00:00:00,000
Here's swapping two ints, here's swapping two doubles,

891
00:00:00,000 --> 00:00:00,000
here's swapping two strings.

892
00:00:00,000 --> 00:00:00,000
Here is doing multiples with doubles,

893
00:00:00,000 --> 00:00:00,000
here's doing multiples with integers.

894
00:00:00,000 --> 00:00:00,000
All righty then, I believe that's all for today.

895
00:00:00,000 --> 00:00:00,000
And so we will see you in the next lecture in lecture 15.

