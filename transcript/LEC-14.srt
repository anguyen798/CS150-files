
1
00:00:00,000 --> 00:00:04,300
Hello again everyone, this is Steve Gilbert.

2
00:00:04,300 --> 00:00:06,600
Welcome to Lecture 14, where we're going to talk

3
00:00:06,600 --> 00:00:10,300
about exceptions and templates.

4
00:00:10,300 --> 00:00:13,540
So in Lecture 13, we talked about assumptions.

5
00:00:13,540 --> 00:00:18,860
Assumptions are things that you believe should be true.

6
00:00:18,860 --> 00:00:23,200
So when you write a function, you assume certain things

7
00:00:23,200 --> 00:00:25,140
about the inputs.

8
00:00:25,140 --> 00:00:28,500
When you write a function, you assume certain things

9
00:00:28,500 --> 00:00:30,000
about the output.

10
00:00:30,000 --> 00:00:32,940
We call those preconditions and postconditions.

11
00:00:32,940 --> 00:00:37,000
So a precondition is something that's true about the inputs,

12
00:00:37,000 --> 00:00:39,740
and a postcondition is something that should

13
00:00:39,740 --> 00:00:43,080
be true about the outputs.

14
00:00:43,080 --> 00:00:45,500
Now, when we write these preconditions

15
00:00:45,500 --> 00:00:48,780
and postconditions, we use some doxygen tags

16
00:00:48,780 --> 00:00:52,400
to document them so that people who call your function

17
00:00:52,400 --> 00:00:54,720
know what to expect.

18
00:00:54,720 --> 00:00:57,700
So for instance, for the square root function,

19
00:00:57,700 --> 00:01:04,220
they should know that n should be greater or equal to 0.

20
00:01:04,220 --> 00:01:07,580
In other words, if you pass a negative number to square root,

21
00:01:07,580 --> 00:01:11,220
you are not going to get the expected output.

22
00:01:11,220 --> 00:01:14,580
The postcondition and the @return tags

23
00:01:14,580 --> 00:01:17,980
are going to tell you what you should expect to return.

24
00:01:17,980 --> 00:01:24,260
So you can use @return and @post kind of interchangeably

25
00:01:24,260 --> 00:01:26,540
to talk about the return value.

26
00:01:26,540 --> 00:01:28,420
You'd use things like @exception.

27
00:01:28,420 --> 00:01:30,100
Now, you can use @post to tell what

28
00:01:30,100 --> 00:01:33,780
should happen if the precondition is violated.

29
00:01:33,780 --> 00:01:36,580
So what is @post for square root?

30
00:01:36,580 --> 00:01:40,700
Well, @post for square root is it

31
00:01:40,700 --> 00:01:44,780
will return not a number in that case

32
00:01:44,780 --> 00:01:49,940
if you violate the precondition.

33
00:01:49,940 --> 00:01:53,940
So we have five things we can do with a precondition violation.

34
00:01:53,940 --> 00:01:56,460
First, we could try and fix it.

35
00:01:56,460 --> 00:01:58,660
So think again about square root.

36
00:01:58,660 --> 00:02:01,500
If you were writing the square root function,

37
00:02:01,500 --> 00:02:04,660
you might decide if you get a negative number,

38
00:02:04,660 --> 00:02:07,940
you'll just return 0 in that case.

39
00:02:07,940 --> 00:02:14,380
Now, that would fix the problem of getting not a number, which

40
00:02:14,380 --> 00:02:17,740
is what they actually do in the square root function.

41
00:02:17,740 --> 00:02:21,380
But it wouldn't really return the right answer.

42
00:02:21,380 --> 00:02:23,620
In other words, you'd be giving it the wrong answer.

43
00:02:23,620 --> 00:02:26,700
The square root of minus 1 is not 0.

44
00:02:26,700 --> 00:02:30,260
And so we generally don't want to do that.

45
00:02:30,260 --> 00:02:31,940
Although, when you're first programming,

46
00:02:31,940 --> 00:02:36,260
frequently you're taught to think about what

47
00:02:36,260 --> 00:02:37,940
will happen if this happens.

48
00:02:37,940 --> 00:02:41,700
So let's make sure that it doesn't crash and so forth.

49
00:02:41,700 --> 00:02:44,940
But we really don't want to do that.

50
00:02:44,940 --> 00:02:48,900
Secondly, we can terminate with an error message.

51
00:02:48,900 --> 00:02:52,940
So just stop the program when the error occurs

52
00:02:52,940 --> 00:02:54,780
and stop.

53
00:02:54,780 --> 00:02:56,420
Now, sometimes we want to do that,

54
00:02:56,420 --> 00:02:58,580
and sometimes we don't want to do that.

55
00:02:58,580 --> 00:03:00,580
For instance, we certainly wouldn't

56
00:03:00,580 --> 00:03:03,780
want to do that if someone types in the wrong URL

57
00:03:03,780 --> 00:03:05,420
in your web browser.

58
00:03:05,420 --> 00:03:08,060
You wouldn't want to terminate and say, sorry,

59
00:03:08,060 --> 00:03:10,380
Chrome's decided you've typed in the wrong URL.

60
00:03:10,380 --> 00:03:14,620
We're not going to send you to that page.

61
00:03:14,620 --> 00:03:17,580
But sometimes that's the right thing to do.

62
00:03:17,580 --> 00:03:21,100
If your program discovers an error that's

63
00:03:21,100 --> 00:03:24,060
going to propagate further and further and further

64
00:03:24,060 --> 00:03:26,220
inside your code-- in other words,

65
00:03:26,220 --> 00:03:29,900
if one of the preconditions is violated,

66
00:03:29,900 --> 00:03:34,740
the program continuing to run is not really a good idea.

67
00:03:34,740 --> 00:03:37,820
And so if the problem is caused by a mistake

68
00:03:37,820 --> 00:03:41,620
that you have made in your programming-- in other words,

69
00:03:41,620 --> 00:03:45,740
something that you logically believe should be true--

70
00:03:45,740 --> 00:03:47,100
you do want to terminate.

71
00:03:47,100 --> 00:03:50,860
And I'll talk about how you do that in a second.

72
00:03:50,860 --> 00:03:53,180
Thirdly, we could return an error code.

73
00:03:53,180 --> 00:03:55,020
And that's kind of what square root does.

74
00:03:55,020 --> 00:03:58,940
Square root returns a non-valid number

75
00:03:58,940 --> 00:04:01,860
if its precondition is violated.

76
00:04:01,860 --> 00:04:06,580
It returns a special number called not a number.

77
00:04:06,580 --> 00:04:10,980
You could throw an exception, which allows the programmer

78
00:04:10,980 --> 00:04:11,740
to catch it.

79
00:04:11,740 --> 00:04:15,020
Now, you can't do anything about what square root returns.

80
00:04:15,020 --> 00:04:19,700
But if a function throws an exception, like s2i,

81
00:04:19,700 --> 00:04:21,980
you could actually catch it.

82
00:04:21,980 --> 00:04:26,420
Or finally, we could ignore the problem altogether

83
00:04:26,420 --> 00:04:28,740
and just hope for the best.

84
00:04:28,740 --> 00:04:31,300
So we obviously don't want to ignore it.

85
00:04:31,300 --> 00:04:34,740
We generally don't want to fix it silently,

86
00:04:34,740 --> 00:04:37,940
unless the fix is just immaterial,

87
00:04:37,940 --> 00:04:40,780
like for something in the user interface that

88
00:04:40,780 --> 00:04:42,260
wouldn't be that big a deal.

89
00:04:42,260 --> 00:04:47,780
So that leaves us with these three--

90
00:04:47,780 --> 00:04:50,180
terminate with an error message, return an error code,

91
00:04:50,180 --> 00:04:51,940
throw an exception.

92
00:04:51,940 --> 00:04:54,220
So as I mentioned in the last lecture,

93
00:04:54,220 --> 00:04:59,060
if you have a programming error, we

94
00:04:59,060 --> 00:05:03,380
want to use a statement called assert, which terminates

95
00:05:03,380 --> 00:05:07,460
and tells you what line the error occurred on.

96
00:05:07,460 --> 00:05:11,340
So for instance, if I'm writing a function sum

97
00:05:11,340 --> 00:05:14,860
between lower and upper, any time

98
00:05:14,860 --> 00:05:19,500
that function is called with a lower that

99
00:05:19,500 --> 00:05:24,500
is greater than upper, I have an error that won't make sense.

100
00:05:24,500 --> 00:05:31,140
Now, if I returned 0 from that-- in other words,

101
00:05:31,140 --> 00:05:34,420
if I kind of fixed it silently, or I wrote my algorithm

102
00:05:34,420 --> 00:05:40,660
so the function returns 0 when lower was greater than upper--

103
00:05:40,660 --> 00:05:42,580
I really have a programming error.

104
00:05:42,580 --> 00:05:43,940
And I haven't found that error.

105
00:05:43,940 --> 00:05:46,540
In other words, I'm calling the function

106
00:05:46,540 --> 00:05:50,620
when lower is greater than upper.

107
00:05:50,620 --> 00:05:53,300
And I really kind of didn't want that to happen.

108
00:05:53,300 --> 00:05:58,700
So you might decide, this logically can never happen.

109
00:05:58,700 --> 00:06:01,580
If I call the function with lower greater than upper,

110
00:06:01,580 --> 00:06:03,140
I've made a mistake.

111
00:06:03,140 --> 00:06:07,900
And so I would like the program to automatically stop

112
00:06:07,900 --> 00:06:10,340
when that occurs and tell me, Steve,

113
00:06:10,340 --> 00:06:16,660
you've made a mistake on line 42 in foo.cpp.

114
00:06:16,660 --> 00:06:19,820
And so that's what the assert statement does.

115
00:06:19,820 --> 00:06:22,060
It allows you to put in statements

116
00:06:22,060 --> 00:06:24,940
that enforce the logic that you're

117
00:06:24,940 --> 00:06:28,460
trying to put inside your code.

118
00:06:28,460 --> 00:06:33,060
Commercial code is literally littered with assertions.

119
00:06:33,060 --> 00:06:35,360
One of the nice things about assertions

120
00:06:35,360 --> 00:06:37,340
is that when you're developing the code,

121
00:06:37,340 --> 00:06:39,780
you can put them in, check your bugs,

122
00:06:39,780 --> 00:06:41,820
when you're testing it and running it.

123
00:06:41,820 --> 00:06:46,220
And then when you ship your code, you can remove them.

124
00:06:46,220 --> 00:06:50,260
So you're not having the overhead of the if statements

125
00:06:50,260 --> 00:06:52,300
that the assert statement generates.

126
00:06:52,300 --> 00:06:59,260
All right, so let's talk about the other kinds of errors,

127
00:06:59,260 --> 00:06:59,940
though--

128
00:06:59,940 --> 00:07:03,580
errors that are not caused by you, the programmer,

129
00:07:03,580 --> 00:07:10,180
errors caused by exceptional but anticipated circumstances.

130
00:07:10,180 --> 00:07:13,980
If you live in the Arctic and you live in an igloo,

131
00:07:13,980 --> 00:07:17,700
you should expect that at some time

132
00:07:17,700 --> 00:07:20,180
you're going to see a polar bear at your front door.

133
00:07:20,180 --> 00:07:22,220
You should anticipate that.

134
00:07:22,220 --> 00:07:23,540
It's exceptional.

135
00:07:23,540 --> 00:07:25,100
That's not the normal.

136
00:07:25,100 --> 00:07:27,540
But you should anticipate it.

137
00:07:27,540 --> 00:07:30,580
What kind of things can we anticipate when programming?

138
00:07:30,580 --> 00:07:34,140
Well, is the user ever going to type in a file name

139
00:07:34,140 --> 00:07:35,260
incorrectly?

140
00:07:35,260 --> 00:07:36,780
Sure.

141
00:07:36,780 --> 00:07:39,020
Is the disk ever going to be full when

142
00:07:39,020 --> 00:07:40,340
you're saving a file?

143
00:07:40,340 --> 00:07:41,980
Sure.

144
00:07:41,980 --> 00:07:46,060
Now, those kinds of errors, we could just

145
00:07:46,060 --> 00:07:47,820
return an error code.

146
00:07:47,820 --> 00:07:49,740
But the problem with an error code

147
00:07:49,740 --> 00:07:55,020
is the user or the programmer has to check the error code.

148
00:07:55,020 --> 00:07:57,140
These are a little more serious.

149
00:07:57,140 --> 00:07:59,700
If the disk is full when saving a file,

150
00:07:59,700 --> 00:08:01,140
you simply can't go on.

151
00:08:01,140 --> 00:08:02,780
You'll lose data.

152
00:08:02,780 --> 00:08:05,180
If the user types a file name incorrectly,

153
00:08:05,180 --> 00:08:07,620
the program simply won't work.

154
00:08:07,620 --> 00:08:11,140
And so an exception is for something

155
00:08:11,140 --> 00:08:15,420
that you want to handle and you want to force yourself

156
00:08:15,420 --> 00:08:18,020
to handle, or you want to force programmers

157
00:08:18,020 --> 00:08:22,020
using your class to handle.

158
00:08:22,020 --> 00:08:26,980
This should be handled by throwing an exception.

159
00:08:26,980 --> 00:08:29,500
So you all know how functions work.

160
00:08:29,500 --> 00:08:33,220
Functions take inputs, they process the inputs,

161
00:08:33,220 --> 00:08:34,940
and they produce an output.

162
00:08:34,940 --> 00:08:37,900
They return that output.

163
00:08:37,900 --> 00:08:43,620
But actually, functions have a second way of returning.

164
00:08:43,620 --> 00:08:47,980
So you can think of the return the normal channel,

165
00:08:47,980 --> 00:08:51,740
but the exception is a back channel.

166
00:08:51,740 --> 00:08:57,820
So we can say, if the program normally works--

167
00:08:57,820 --> 00:09:01,420
and let's use the function called s2i.

168
00:09:01,420 --> 00:09:07,020
s2i takes a string and returns an integer,

169
00:09:07,020 --> 00:09:11,100
just like our parseInt function we're going to write today does.

170
00:09:11,100 --> 00:09:15,700
So we're going to write a version of s2i.

171
00:09:15,700 --> 00:09:18,580
And if I pass--

172
00:09:18,580 --> 00:09:21,540
that stands for string to integer.

173
00:09:21,540 --> 00:09:27,260
If I pass the string that contains the character 1,

174
00:09:27,260 --> 00:09:31,300
it will convert that string to an integer and return 1.

175
00:09:31,300 --> 00:09:35,900
If I pass a string that contains the word 1, the English word

176
00:09:35,900 --> 00:09:39,780
1, instead of returning the integer,

177
00:09:39,780 --> 00:09:45,420
it returns via this back channel called throwing an exception.

178
00:09:45,420 --> 00:09:51,500
And that exception is thrown to the function that handled it.

179
00:09:51,500 --> 00:09:53,380
Actually, it's thrown not necessarily

180
00:09:53,380 --> 00:09:56,660
to the function that called it, like the return statement is,

181
00:09:56,660 --> 00:09:58,420
the statement that called it.

182
00:09:58,420 --> 00:10:03,460
It's thrown to the nearest exception handler.

183
00:10:03,460 --> 00:10:06,300
So an exception handler is a special kind

184
00:10:06,300 --> 00:10:11,060
of block of code that we'll look at shortly.

185
00:10:11,060 --> 00:10:18,060
Now, in C++, the throwing an exception looks like this.

186
00:10:18,060 --> 00:10:21,660
If I detected an error condition,

187
00:10:21,660 --> 00:10:24,900
just throw some object.

188
00:10:24,900 --> 00:10:28,020
Now, again, this is similar to a return statement

189
00:10:28,020 --> 00:10:30,620
from inside a function, but it doesn't

190
00:10:30,620 --> 00:10:34,940
return to the calling function, but to an error handler.

191
00:10:34,940 --> 00:10:38,020
If there is no error handler, then it

192
00:10:38,020 --> 00:10:41,740
will keep bubbling up to the very main function

193
00:10:41,740 --> 00:10:43,700
where it'll find a default handler.

194
00:10:43,700 --> 00:10:46,860
And that default handler will terminate the program,

195
00:10:46,860 --> 00:10:52,260
and it will look almost exactly like an assertion.

196
00:10:52,260 --> 00:10:57,180
Look almost exactly like an assertion.

197
00:10:57,180 --> 00:11:01,380
OK, so you might have seen these in Java.

198
00:11:01,380 --> 00:11:04,380
You may have had to handle them in Java.

199
00:11:04,380 --> 00:11:09,140
And in Java, in C++, any kind of object

200
00:11:09,140 --> 00:11:11,500
may be thrown as an exception.

201
00:11:11,500 --> 00:11:15,260
Now, Java has a whole class hierarchy

202
00:11:15,260 --> 00:11:20,260
of exceptions that are rooted in the class called throwable.

203
00:11:20,260 --> 00:11:24,660
Throwable has two subclasses, error and exception.

204
00:11:24,660 --> 00:11:28,980
In C++, we could throw an integer

205
00:11:28,980 --> 00:11:32,900
if we wanted to catch different kinds of error codes.

206
00:11:32,900 --> 00:11:36,700
So you could catch int, and then you

207
00:11:36,700 --> 00:11:39,140
could check to see if it's 1, do this.

208
00:11:39,140 --> 00:11:40,660
If it's 2, do that.

209
00:11:40,660 --> 00:11:43,580
If it's 3, do that, and so forth.

210
00:11:43,580 --> 00:11:46,500
You could throw a C++ string.

211
00:11:46,500 --> 00:11:49,660
Notice the little s after the double quotes.

212
00:11:49,660 --> 00:11:53,580
We could throw a C string as well.

213
00:11:53,580 --> 00:11:55,380
That would be a different kinds of things.

214
00:11:55,380 --> 00:11:58,100
So we could throw a C++ string.

215
00:11:58,100 --> 00:12:01,940
We could throw one of the standard library exception

216
00:12:01,940 --> 00:12:03,260
classes.

217
00:12:03,260 --> 00:12:07,300
So this is similar to Java with its throwable, runtime

218
00:12:07,300 --> 00:12:11,380
exception, index out of bounds exception, and so forth.

219
00:12:11,380 --> 00:12:13,500
We could throw an illegal argument

220
00:12:13,500 --> 00:12:16,340
and construct an illegal argument object

221
00:12:16,340 --> 00:12:21,220
and say that the illegal argument was A.

222
00:12:21,220 --> 00:12:25,580
Now, the standard library includes, just like Java,

223
00:12:25,580 --> 00:12:28,380
a variety of exception classes.

224
00:12:28,380 --> 00:12:31,340
If you want to include those, you have to include a header.

225
00:12:31,340 --> 00:12:33,220
They're not automatically included, just

226
00:12:33,220 --> 00:12:35,820
like everything in C++.

227
00:12:35,820 --> 00:12:40,740
And the most common ones are things like domain error,

228
00:12:40,740 --> 00:12:44,680
the parameters outside the valid range, invalid argument,

229
00:12:44,680 --> 00:12:48,980
the argument was invalid for some reason, or out of range.

230
00:12:48,980 --> 00:12:51,580
The argument's not in expected range.

231
00:12:51,580 --> 00:12:58,020
So that's how we throw.

232
00:12:58,020 --> 00:13:01,820
That's how we signal from our function

233
00:13:01,820 --> 00:13:04,180
that an error has occurred.

234
00:13:04,180 --> 00:13:06,940
If we're calling the function, how do we

235
00:13:06,940 --> 00:13:09,180
intercept and handle that?

236
00:13:09,180 --> 00:13:11,320
And so to intercept and handle exceptions,

237
00:13:11,320 --> 00:13:16,860
we do almost the same thing you would do in Java and Python.

238
00:13:16,860 --> 00:13:22,940
Python has try, except, I think.

239
00:13:22,940 --> 00:13:25,500
Java has try, catch.

240
00:13:25,500 --> 00:13:30,140
So you place the code that can fail inside a try block.

241
00:13:30,140 --> 00:13:35,900
So we're going to call the function parseInt.

242
00:13:35,900 --> 00:13:38,020
We're going to pass it a string.

243
00:13:38,020 --> 00:13:41,260
That string may contain the digit 1,

244
00:13:41,260 --> 00:13:43,820
but it may also contain the word 1.

245
00:13:43,820 --> 00:13:48,540
And if it contains the word 1, rather than setting x

246
00:13:48,540 --> 00:13:55,020
to a value at all, what we'll do is we'll throw an exception.

247
00:13:55,020 --> 00:13:59,060
And any statements that follow this parseInt

248
00:13:59,060 --> 00:14:04,580
will be jumped over until we get to a catch block.

249
00:14:04,580 --> 00:14:10,980
So the catch block has to say what kind of exception

250
00:14:10,980 --> 00:14:12,820
it's going to throw.

251
00:14:12,820 --> 00:14:17,740
Now, this exception, we're going to decide what it throws.

252
00:14:17,740 --> 00:14:21,980
So you catch a specific type of exception.

253
00:14:21,980 --> 00:14:24,860
You always want to catch it by reference.

254
00:14:24,860 --> 00:14:28,260
So in this case, if we say the argument was invalid

255
00:14:28,260 --> 00:14:33,380
and we're catching that, we'd say catch invalid argument ref

256
00:14:33,380 --> 00:14:34,900
e.

257
00:14:34,900 --> 00:14:36,820
And then it would jump.

258
00:14:36,820 --> 00:14:39,900
If it failed, it would not do the next statement.

259
00:14:39,900 --> 00:14:43,660
It would jump from there to this invalid argument.

260
00:14:43,660 --> 00:14:44,940
Let me close Zoom.

261
00:14:44,940 --> 00:14:50,620
Keeps popping up, saying it wants me to log in.

262
00:14:50,620 --> 00:14:53,300
It would jump from this parseInt when it failed.

263
00:14:53,300 --> 00:14:55,540
It wouldn't assign anything to x.

264
00:14:55,540 --> 00:14:57,980
And it would jump down here to this catch,

265
00:14:57,980 --> 00:15:02,220
see if the exception that was thrown was this type.

266
00:15:02,220 --> 00:15:05,340
If it was, it would set the exception argument,

267
00:15:05,340 --> 00:15:09,060
and we would go into the exception altogether.

268
00:15:09,060 --> 00:15:11,740
So let's try a couple of those exercises,

269
00:15:11,740 --> 00:15:16,940
just so you get a feel for try-catch.

270
00:15:16,940 --> 00:15:24,660
So these are on part A of our exercises.

271
00:15:24,660 --> 00:15:27,180
There's an empty try-catch block here,

272
00:15:27,180 --> 00:15:28,780
which will do the catching.

273
00:15:28,780 --> 00:15:33,460
But it's up to us to redesign the code to make use of it.

274
00:15:33,460 --> 00:15:36,340
Now, there's an imaginary roster of students,

275
00:15:36,340 --> 00:15:39,100
which we'll pretend is dynamic, but for the purpose

276
00:15:39,100 --> 00:15:42,260
of this exercise, is hard-coded.

277
00:15:42,260 --> 00:15:44,020
You'll find the names in the source code.

278
00:15:44,020 --> 00:15:47,020
And the roster's implemented as an unordered map.

279
00:15:47,020 --> 00:15:48,580
You haven't learned how to use that,

280
00:15:48,580 --> 00:15:52,380
but you really don't need to know how to use it for that.

281
00:15:52,380 --> 00:15:55,420
When running the program, you're asked to enter a name.

282
00:15:55,420 --> 00:15:57,580
After doing so, it will use the map

283
00:15:57,580 --> 00:16:00,180
to print out the age of that student.

284
00:16:00,180 --> 00:16:02,420
Unfortunately, if the user enters

285
00:16:02,420 --> 00:16:05,340
a name that's not on the roster, it

286
00:16:05,340 --> 00:16:08,540
is not on the roster, an exception is thrown,

287
00:16:08,540 --> 00:16:12,060
which we don't handle, and the program just terminates.

288
00:16:12,060 --> 00:16:16,300
So we're going to do two modifications to this.

289
00:16:16,300 --> 00:16:19,380
We're going to catch the exception so that it can least

290
00:16:19,380 --> 00:16:24,660
exit gracefully, and write out a nice error telling the user

291
00:16:24,660 --> 00:16:28,100
that the name they entered doesn't exist.

292
00:16:28,100 --> 00:16:32,460
We're going to print the actual name they entered back at them.

293
00:16:32,460 --> 00:16:36,860
So let's do this first exercise.

294
00:16:36,860 --> 00:16:38,860
So here's our unordered map.

295
00:16:38,860 --> 00:16:46,340
So a map simply is a key, like the name here, and the age.

296
00:16:46,340 --> 00:16:51,060
So this is mapping a student's names to their ages.

297
00:16:51,060 --> 00:16:56,180
So this code is in a bit of a sorry state.

298
00:16:56,180 --> 00:17:00,340
If we enter a name inside here, and the name

299
00:17:00,340 --> 00:17:06,860
is Fred, which is not on our list, it will, when we do this,

300
00:17:06,860 --> 00:17:11,820
this line, student name at, will throw an exception.

301
00:17:11,820 --> 00:17:14,020
Will throw an exception.

302
00:17:14,020 --> 00:17:18,340
And so this is the try catch that we want to use.

303
00:17:18,340 --> 00:17:21,860
That's the necessary syntax.

304
00:17:21,860 --> 00:17:25,020
So we are going to throw an error.

305
00:17:25,020 --> 00:17:27,620
We're going to put this code.

306
00:17:27,620 --> 00:17:31,460
So that part's going to be outside.

307
00:17:31,460 --> 00:17:33,540
We're going to write try.

308
00:17:33,540 --> 00:17:49,020
And then I'm going to take this line-- actually,

309
00:17:49,020 --> 00:17:53,420
let me just copy this part out.

310
00:17:53,420 --> 00:17:56,460
So it gave us the syntax here.

311
00:17:56,460 --> 00:17:58,100
I'm just going to bring the catch here.

312
00:17:58,100 --> 00:18:03,340
And we're going to catch if it's out of range.

313
00:18:03,340 --> 00:18:16,020
And let me fix that.

314
00:18:16,020 --> 00:18:34,100
And we're going to say, C error, sorry, comma, name

315
00:18:34,100 --> 00:18:35,380
was not there.

316
00:18:35,380 --> 00:18:38,900
I don't know if that's the correct error message.

317
00:18:42,980 --> 00:18:46,500
OK, so notice the code that may fail

318
00:18:46,500 --> 00:18:49,140
is placed inside our try block.

319
00:18:49,140 --> 00:18:50,700
This code cannot fail.

320
00:18:50,700 --> 00:18:51,980
This code cannot fail.

321
00:18:51,980 --> 00:18:54,140
It's placed inside a try block.

322
00:18:54,140 --> 00:18:55,020
So let's try it.

323
00:18:55,020 --> 00:19:03,700
And I left out a set of arrows there.

324
00:19:03,700 --> 00:19:04,940
So I had a syntax error.

325
00:19:12,300 --> 00:19:16,220
Oops, and I put the arrows in the wrong place.

326
00:19:16,220 --> 00:19:17,620
Still had a syntax error.

327
00:19:17,620 --> 00:19:29,620
I left off a semicolon.

328
00:19:29,620 --> 00:19:31,820
I'm all thumbs today.

329
00:19:31,820 --> 00:19:39,420
OK, enter a name, John.

330
00:19:39,420 --> 00:19:41,900
John is 16 years old.

331
00:19:41,900 --> 00:19:46,180
OK, so yeah, so I didn't have-- so it was sorry, comma,

332
00:19:46,180 --> 00:19:47,460
Jake does not exist.

333
00:19:47,460 --> 00:20:06,100
So let's look at John.

334
00:20:06,100 --> 00:20:09,620
John is found, prints out its name,

335
00:20:09,620 --> 00:20:11,380
and then skips over the catch block.

336
00:20:11,380 --> 00:20:13,940
Catch block is never executed.

337
00:20:13,940 --> 00:20:17,900
Jake throws an exception here.

338
00:20:17,900 --> 00:20:20,980
We skip over the name is age years old.

339
00:20:20,980 --> 00:20:27,220
We jump from line 24 to line 27, and we print out,

340
00:20:27,220 --> 00:20:30,100
sorry, name does not exist.

341
00:20:30,100 --> 00:20:31,740
Same thing with Lawrence.

342
00:20:31,740 --> 00:20:34,540
Zoltan exists, so that works OK.

343
00:20:34,540 --> 00:20:37,500
So this is try, catch.

344
00:20:37,500 --> 00:20:39,500
Now let's do the second one.

345
00:20:39,500 --> 00:20:43,700
So we want to do it so that the program validates

346
00:20:43,700 --> 00:20:46,020
by using the try, catch.

347
00:20:46,020 --> 00:20:47,860
Doesn't just print out an error message,

348
00:20:47,860 --> 00:20:51,460
and it should do it continuously until they actually

349
00:20:51,460 --> 00:20:55,060
enter a valid name.

350
00:20:55,060 --> 00:20:58,380
So we don't have to do much difference here.

351
00:20:58,380 --> 00:21:00,020
What we're going to do is we're going

352
00:21:00,020 --> 00:21:05,220
to need to put all this code inside a do while block.

353
00:21:05,220 --> 00:21:06,940
A do while.

354
00:21:06,940 --> 00:21:15,300
So do, enter a name.

355
00:21:29,060 --> 00:21:34,700
Then we're going to put our try block.

356
00:21:34,700 --> 00:21:35,200
Try block.

357
00:21:35,200 --> 00:21:46,780
And we'll create a Boolean value.

358
00:21:46,780 --> 00:21:49,060
So that's going to have to be created

359
00:21:49,060 --> 00:21:51,780
before the do while loop.

360
00:21:51,780 --> 00:22:04,380
So Boole equals or done, false.

361
00:22:04,380 --> 00:22:07,420
If we succeed and don't throw an exception,

362
00:22:07,420 --> 00:22:09,380
we're going to set done equal to true.

363
00:22:09,380 --> 00:22:19,020
So now we're going to put in our catch block.

364
00:22:19,020 --> 00:22:37,620
And exactly the same code we had before.

365
00:22:40,620 --> 00:22:53,460
Here, sorry, name does not exist.

366
00:22:53,460 --> 00:23:02,420
And here's the end of our do.

367
00:23:02,420 --> 00:23:05,660
And here's the while.

368
00:23:05,660 --> 00:23:06,160
Not done.

369
00:23:08,160 --> 00:23:08,660
OK.

370
00:23:08,660 --> 00:23:13,720
So we're going to continue doing that while it's not done.

371
00:23:13,720 --> 00:23:17,000
We're going to enter in a name, print in the name.

372
00:23:17,000 --> 00:23:18,480
We're going to try it.

373
00:23:18,480 --> 00:23:23,200
If we try it and we succeed, if we get down to line 28,

374
00:23:23,200 --> 00:23:26,240
we're going to set done to true.

375
00:23:26,240 --> 00:23:28,880
This will fail and we'll be through.

376
00:23:28,880 --> 00:23:29,760
So let's try it.

377
00:23:34,720 --> 00:23:37,040
So enter name John.

378
00:23:37,040 --> 00:23:38,360
That worked fine.

379
00:23:38,360 --> 00:23:41,680
We just entered the name, set done to true.

380
00:23:41,680 --> 00:23:44,120
We hit our while loop and we're finished.

381
00:23:44,120 --> 00:23:46,240
Here we entered a name Jake.

382
00:23:46,240 --> 00:23:46,800
Nope.

383
00:23:46,800 --> 00:23:48,960
Sorry, name does not exist.

384
00:23:48,960 --> 00:23:52,000
It went up and it asked us to enter a name again.

385
00:23:52,000 --> 00:23:54,760
Now in this case, the code check doesn't

386
00:23:54,760 --> 00:23:58,280
show what it really looks like.

387
00:23:58,280 --> 00:24:00,520
So we would not enter Jake, Bill, and Paul.

388
00:24:00,520 --> 00:24:01,920
We'd enter Jake.

389
00:24:01,920 --> 00:24:03,160
It would say enter a name.

390
00:24:03,160 --> 00:24:04,600
We'd enter Bill here.

391
00:24:04,600 --> 00:24:05,200
Enter a name.

392
00:24:05,200 --> 00:24:06,160
We'd enter Paul.

393
00:24:06,160 --> 00:24:07,920
Paul's 31 years old.

394
00:24:07,920 --> 00:24:10,680
So notice this just repeats until it

395
00:24:10,680 --> 00:24:13,640
gives us the correct answer.

396
00:24:13,640 --> 00:24:17,560
It gives us the correct answer.

397
00:24:17,560 --> 00:24:22,440
OK, let's actually write some code now.

398
00:24:22,440 --> 00:24:24,800
And so go over and open.

399
00:24:28,320 --> 00:24:34,960
And open in IC14B, open int helper.h and int helper.cpp.

400
00:24:34,960 --> 00:24:42,920
I don't know why it's not letting me open both those.

401
00:24:42,920 --> 00:24:46,200
Maybe because I haven't added any code to it.

402
00:24:46,200 --> 00:24:49,400
Let me add code to that one and do the cpp.

403
00:24:49,400 --> 00:24:49,900
OK.

404
00:24:49,900 --> 00:25:00,320
OK, let's open a terminal on that.

405
00:25:00,320 --> 00:25:07,120
And then let me close that.

406
00:25:07,120 --> 00:25:13,760
OK, so these are the two functions we're going to write.

407
00:25:13,760 --> 00:25:15,360
So let's look at those.

408
00:25:17,280 --> 00:25:24,480
The first function, parseInt, is going

409
00:25:24,480 --> 00:25:27,360
to convert a string to an integer.

410
00:25:27,360 --> 00:25:30,760
So int n equals parseInt 42.

411
00:25:30,760 --> 00:25:35,760
If it can't succeed, it's going to throw an exception.

412
00:25:35,760 --> 00:25:40,640
The second function is going to read an int from the console.

413
00:25:40,640 --> 00:25:44,040
So this is int n equals readInt.

414
00:25:44,040 --> 00:25:45,400
Enter a number.

415
00:25:45,400 --> 00:25:47,400
The prompt is optional.

416
00:25:47,400 --> 00:25:49,920
And just like the last problem we did,

417
00:25:49,920 --> 00:25:54,360
it's going to keep prompting until integer values are

418
00:25:54,360 --> 00:25:55,920
entered.

419
00:25:55,920 --> 00:25:58,480
So we're going to start by documenting

420
00:25:58,480 --> 00:26:01,120
the functions in the header.

421
00:26:01,120 --> 00:26:04,280
Then we're going to have invalid input to parseInt

422
00:26:04,280 --> 00:26:06,320
by throwing an exception.

423
00:26:06,320 --> 00:26:10,440
And then we're going to validate our logic with assert.

424
00:26:10,440 --> 00:26:12,920
Now there's a little bit more information

425
00:26:12,920 --> 00:26:15,680
on this in the handout over here.

426
00:26:15,680 --> 00:26:23,000
So we're going to include the preconditions, postconditions,

427
00:26:23,000 --> 00:26:24,360
and exceptions.

428
00:26:24,360 --> 00:26:27,200
We're going to throw an invalid argument with an error message

429
00:26:27,200 --> 00:26:28,920
when parseInt fails.

430
00:26:28,920 --> 00:26:30,900
We use parseInt in an endless loop

431
00:26:30,900 --> 00:26:34,320
and try catch to implement readInt.

432
00:26:34,320 --> 00:26:37,040
And we'll use assert to check that we never

433
00:26:37,040 --> 00:26:40,640
reach the end of readInt.

434
00:26:40,640 --> 00:26:43,800
And I will just test this.

435
00:26:43,800 --> 00:26:45,440
I'll break out of my loop to make sure

436
00:26:45,440 --> 00:26:47,480
that the assertion works.

437
00:26:47,480 --> 00:26:50,280
Make sure that the assertion works.

438
00:26:50,280 --> 00:26:51,880
So let's document the function.

439
00:26:51,880 --> 00:27:02,440
And so parseInt-- we didn't put this in a namespace.

440
00:27:02,440 --> 00:27:04,440
We could have.

441
00:27:04,440 --> 00:27:12,200
So converts a string to an integer.

442
00:27:12,200 --> 00:27:22,040
At param s-- let me change that to str.

443
00:27:22,040 --> 00:27:24,160
I don't like just using single letter names.

444
00:27:24,160 --> 00:27:40,680
str is the string-- so str is the string to convert.

445
00:27:40,680 --> 00:27:46,720
Let's put in our precondition at pre.

446
00:27:46,720 --> 00:28:09,400
At pre, we'll contain valid digits, optional sign.

447
00:28:09,400 --> 00:28:21,320
Let's do minus 1, 2, 3 to give the optional sign there.

448
00:28:21,320 --> 00:28:28,200
So that tells us the precondition.

449
00:28:28,200 --> 00:28:30,600
That says what we assume is going

450
00:28:30,600 --> 00:28:40,800
to be true about parseInt at post or at return

451
00:28:40,800 --> 00:28:41,760
or at exception.

452
00:28:41,760 --> 00:28:56,120
Let's use at exception because that's a valid argument.

453
00:28:56,120 --> 00:29:18,040
If invalid argument, if str contains--

454
00:29:18,040 --> 00:29:28,440
contains invalid characters.

455
00:29:28,440 --> 00:29:38,680
And we might want to put more about what that possibly is.

456
00:29:38,680 --> 00:29:52,200
And at return, the integer result.

457
00:29:52,200 --> 00:29:54,200
So that's pretty good for the documentation.

458
00:29:54,200 --> 00:30:07,800
So readInt-- it's an integer from the console

459
00:30:07,800 --> 00:30:10,120
or standard input.

460
00:30:10,120 --> 00:30:25,480
At param prompt will be displayed

461
00:30:25,480 --> 00:30:29,320
if passed with a colon.

462
00:30:35,680 --> 00:30:47,520
OK, at return, and the post condition here

463
00:30:47,520 --> 00:30:53,960
is keeps prompting.

464
00:31:04,680 --> 00:31:06,760
So there's our documentation.

465
00:31:06,760 --> 00:31:09,200
There's our documentation.

466
00:31:09,200 --> 00:31:10,440
So let's take this.

467
00:31:10,440 --> 00:31:18,440
Let's go over to inhelper.cpp.

468
00:31:18,440 --> 00:31:20,800
Let's put your Canvas ID on it.

469
00:31:20,800 --> 00:31:22,160
Let's write the functions here.

470
00:31:22,160 --> 00:31:29,120
You can leave the docs inside here if you want.

471
00:31:29,120 --> 00:31:32,400
You don't have to.

472
00:31:32,400 --> 00:31:33,720
Let's put the body on it.

473
00:31:33,720 --> 00:31:37,280
Let's stub it.

474
00:31:37,280 --> 00:31:43,720
Let's return a value in each case.

475
00:31:43,720 --> 00:31:49,000
We're stubbing it, just making a skeleton.

476
00:31:49,000 --> 00:31:56,120
Let's go ahead and try it.

477
00:31:56,120 --> 00:32:07,120
OK, so number one, we made a syntax error.

478
00:32:07,120 --> 00:32:11,440
And that is when we have default arguments,

479
00:32:11,440 --> 00:32:16,280
you need to remove them in the implementation.

480
00:32:16,280 --> 00:32:17,440
Let's try it again.

481
00:32:25,440 --> 00:32:29,440
So parseInt is what's being tested here.

482
00:32:29,440 --> 00:32:32,960
parseInt is what's being tested here.

483
00:32:32,960 --> 00:32:35,280
So let's actually do something.

484
00:32:35,280 --> 00:32:39,280
And parseInt didn't work at all.

485
00:32:39,280 --> 00:32:43,200
So let's go over and look at how we get parseInt to work.

486
00:32:43,200 --> 00:32:48,920
So what we need to do for parseInt

487
00:32:48,920 --> 00:32:53,360
is we need a string stream.

488
00:32:53,360 --> 00:32:57,360
So we're going to take a input string stream.

489
00:32:57,360 --> 00:33:14,760
And we're going to initialize that with the parameter str.

490
00:33:14,760 --> 00:33:18,720
Then we're going to create an int n.

491
00:33:18,720 --> 00:33:21,560
And we're going to read into n.

492
00:33:22,560 --> 00:33:24,840
OK.

493
00:33:24,840 --> 00:33:34,240
Now, if n is not failed--

494
00:33:34,240 --> 00:33:38,320
and you can write that as if not n fail.

495
00:33:38,320 --> 00:33:46,680
So if not n fail, in other words, if n's still good.

496
00:33:46,680 --> 00:34:01,680
And n is at EOF, then we're simply going to return n.

497
00:34:01,680 --> 00:34:05,000
This simply means, did we consume everything

498
00:34:05,000 --> 00:34:07,760
inside that string?

499
00:34:07,760 --> 00:34:09,160
We're at end of file.

500
00:34:09,160 --> 00:34:10,720
That's true.

501
00:34:10,720 --> 00:34:15,600
This says, well, we didn't read any invalid characters.

502
00:34:15,600 --> 00:34:18,960
So if both of those are the case, that's true.

503
00:34:18,960 --> 00:34:23,520
Now, it's possible that someone could enter a string like this.

504
00:34:23,520 --> 00:34:34,440
So notice that the n will automatically

505
00:34:34,440 --> 00:34:36,440
skip this whitespace.

506
00:34:36,440 --> 00:34:39,480
But it will still stop right on this character.

507
00:34:39,480 --> 00:34:41,800
That means we're not at end of file.

508
00:34:41,800 --> 00:34:48,600
And so to fix that, we have to read the whitespace again.

509
00:34:48,600 --> 00:34:52,760
So in whitespace.

510
00:34:52,760 --> 00:34:55,840
And now we're just going to repeat this statement.

511
00:34:55,840 --> 00:34:58,760
Now, I'm sure this kind of bothers you.

512
00:34:58,760 --> 00:35:01,200
And it bothers me a lot, too.

513
00:35:01,200 --> 00:35:07,880
Because really what I'd like to do is do this.

514
00:35:07,880 --> 00:35:10,760
I'd like to read the input and the whitespace all

515
00:35:10,760 --> 00:35:12,680
in one statement.

516
00:35:12,680 --> 00:35:17,040
That works under the GCC library we're doing.

517
00:35:17,040 --> 00:35:26,920
It works on Unix.

518
00:35:26,920 --> 00:35:29,920
Again, the GCC library we're using.

519
00:35:29,920 --> 00:35:36,080
It works on Windows, the Windows libraries.

520
00:35:36,080 --> 00:35:38,900
It doesn't work on the Mac libraries.

521
00:35:38,900 --> 00:35:42,920
And actually, since we're not programming this in Mac,

522
00:35:42,920 --> 00:35:45,920
I'm just going to use it anyway.

523
00:35:45,920 --> 00:35:48,040
On the Mac libraries, unfortunately, it fails.

524
00:35:48,040 --> 00:35:55,000
So we're going to read the number.

525
00:35:55,000 --> 00:35:58,160
If there's any whitespace, we're going to read it.

526
00:35:58,160 --> 00:36:01,440
So this one's going to read OK.

527
00:36:01,440 --> 00:36:05,960
This one-- actually, let me comment that out.

528
00:36:05,960 --> 00:36:13,760
This one is going to throw an exception.

529
00:36:13,760 --> 00:36:16,040
That's what we want to happen.

530
00:36:16,040 --> 00:36:18,520
That should throw an exception.

531
00:36:18,520 --> 00:36:25,200
And so we're going to throw invalid argument.

532
00:36:25,200 --> 00:36:44,640
[TYPING]

533
00:36:44,640 --> 00:36:45,960
Or something else like that.

534
00:36:45,960 --> 00:36:54,800
Now, let's come down here to run.

535
00:36:54,800 --> 00:36:58,720
Let's comment out those first two.

536
00:36:58,720 --> 00:37:06,280
And let's just do make run.

537
00:37:06,280 --> 00:37:06,920
Make run.

538
00:37:06,920 --> 00:37:12,040
So I'm going to pull that right there.

539
00:37:12,040 --> 00:37:17,320
I'm going to clean that and do make run.

540
00:37:17,320 --> 00:37:19,240
Student testing 125.

541
00:37:19,240 --> 00:37:20,720
It works.

542
00:37:20,720 --> 00:37:26,480
Now, if we've done everything correctly,

543
00:37:26,480 --> 00:37:29,640
this one should throw an exception.

544
00:37:29,640 --> 00:37:30,600
So make run.

545
00:37:30,600 --> 00:37:35,920
Terminate after throwing an instance

546
00:37:35,920 --> 00:37:38,600
of standard invalid argument.

547
00:37:38,600 --> 00:37:42,040
5.2 is not an integer.

548
00:37:42,040 --> 00:37:45,400
15.2 is not an integer.

549
00:37:45,400 --> 00:37:46,800
So that's pretty cool, right?

550
00:37:46,800 --> 00:37:53,640
So this is the default handler when we didn't catch anything.

551
00:37:53,640 --> 00:37:56,240
In other words, we didn't put this in a try catch.

552
00:37:56,240 --> 00:37:59,800
If you don't put it in a try catch, it just terminates.

553
00:37:59,800 --> 00:38:05,440
So through an instance of standard invalid argument.

554
00:38:05,440 --> 00:38:07,680
Let's comment out that line again.

555
00:38:07,680 --> 00:38:09,880
And then let's go to our second one

556
00:38:09,880 --> 00:38:16,760
up here, which is read int.

557
00:38:16,760 --> 00:38:20,560
So for read int, we're going to prompt the display

558
00:38:20,560 --> 00:38:23,160
if it exists.

559
00:38:23,160 --> 00:38:41,920
So if not prompt empty.

560
00:38:41,920 --> 00:38:52,160
Or you can write it if prompt not equal to quote, quote.

561
00:38:52,160 --> 00:39:03,160
This is a little less efficient than-- because prompt empty.

562
00:39:03,160 --> 00:39:06,360
Prompt not equal to quote, quote has to first convert

563
00:39:06,360 --> 00:39:08,320
the quote, quote into a string.

564
00:39:08,320 --> 00:39:10,000
It has to use the relational operator

565
00:39:10,000 --> 00:39:11,840
to find if it's not equal.

566
00:39:11,840 --> 00:39:15,040
So prompt empty is just going to return true or false

567
00:39:15,040 --> 00:39:16,400
immediately.

568
00:39:16,400 --> 00:39:18,080
So that's probably a little better.

569
00:39:18,080 --> 00:39:25,680
But this probably is easier for people to understand.

570
00:39:25,680 --> 00:39:28,440
If the prompt is not empty, we're

571
00:39:28,440 --> 00:39:32,000
going to see out the prompt.

572
00:39:36,000 --> 00:39:57,520
And if prompt back is not equal to a space,

573
00:39:57,520 --> 00:40:10,240
and prompt back is not equal to a colon,

574
00:40:10,240 --> 00:40:11,240
let's just say a space.

575
00:40:11,240 --> 00:40:16,120
If that's not the case, then I'm going

576
00:40:16,120 --> 00:40:18,720
to print out a colon or space.

577
00:40:18,720 --> 00:40:26,840
In other words, I want to get the input away from the prompt.

578
00:40:28,840 --> 00:40:31,200
OK.

579
00:40:31,200 --> 00:40:36,040
Now let's convert the thing.

580
00:40:36,040 --> 00:40:42,080
So we're going to say return parsing.

581
00:40:42,080 --> 00:40:51,400
Oh, we need to read the value.

582
00:40:51,400 --> 00:40:53,080
So string value.

583
00:40:53,080 --> 00:40:58,560
Oh, we need to--

584
00:40:58,560 --> 00:41:01,320
yeah.

585
00:41:01,320 --> 00:41:03,120
Yeah, we're going to use parseInt.

586
00:41:03,120 --> 00:41:11,200
We're going to return parseInt.

587
00:41:11,200 --> 00:41:18,880
parseInt value.

588
00:41:20,880 --> 00:41:23,880
OK.

589
00:41:23,880 --> 00:41:25,760
So this is the basic structure.

590
00:41:25,760 --> 00:41:32,880
Let's come down here and uncomment these two lines.

591
00:41:32,880 --> 00:41:39,640
Let's do make run on it.

592
00:41:40,000 --> 00:41:40,500
OK.

593
00:41:40,500 --> 00:41:52,440
Enter a number.

594
00:41:52,440 --> 00:41:55,560
And notice how it added my colon.

595
00:41:55,560 --> 00:41:58,280
So notice my prompt is enter a number.

596
00:41:58,280 --> 00:42:00,240
It adds the colon in this space after it

597
00:42:00,240 --> 00:42:02,240
and puts my input there.

598
00:42:02,240 --> 00:42:05,560
I'll enter 245.

599
00:42:05,560 --> 00:42:07,920
And you enter 245.

600
00:42:07,920 --> 00:42:11,360
Now let me run it again.

601
00:42:11,360 --> 00:42:14,000
2.45.

602
00:42:14,000 --> 00:42:16,480
It threw an exception.

603
00:42:16,480 --> 00:42:22,640
So we want, if this value is bad,

604
00:42:22,640 --> 00:42:27,840
that's going to return-- that's going to throw an exception.

605
00:42:27,840 --> 00:42:30,480
So we're going to put this whole thing in an endless loop.

606
00:42:33,360 --> 00:42:36,360
File, true.

607
00:42:36,360 --> 00:42:57,200
So this will return out of the loop.

608
00:42:57,200 --> 00:42:58,680
Then we'll put this part.

609
00:42:58,680 --> 00:43:06,480
Enter inside a try.

610
00:43:06,480 --> 00:43:17,020
Catch.

611
00:43:26,320 --> 00:43:29,560
And I'm not going to print an error message.

612
00:43:29,560 --> 00:43:30,440
Oh, maybe I will.

613
00:43:30,440 --> 00:43:31,880
Maybe I'll print an error message.

614
00:43:31,880 --> 00:43:32,380
OK.

615
00:43:32,380 --> 00:43:51,880
I don't know if the testing actually wants this error

616
00:43:51,880 --> 00:43:53,680
message.

617
00:43:53,680 --> 00:43:54,160
OK.

618
00:43:54,160 --> 00:43:58,480
So this is like what we did in the code check exercise.

619
00:43:58,480 --> 00:44:02,800
So we have a do while or a while true.

620
00:44:02,800 --> 00:44:07,040
And if we can parse the value, we get out.

621
00:44:07,040 --> 00:44:10,320
If not, we print out, sorry, that's not an integer.

622
00:44:10,320 --> 00:44:14,080
And we go back and prompt for it again.

623
00:44:14,080 --> 00:44:20,920
So let's try that now with our run here.

624
00:44:20,920 --> 00:44:23,960
So make run.

625
00:44:23,960 --> 00:44:25,440
Enter a number, 1.

626
00:44:25,440 --> 00:44:26,960
Sorry, 1 is not an integer.

627
00:44:26,960 --> 00:44:31,520
Enter a number, 45.2.

628
00:44:31,520 --> 00:44:33,720
Sorry, 45.2 is not an integer.

629
00:44:33,720 --> 00:44:35,320
75.

630
00:44:35,320 --> 00:44:37,000
OK, and we entered 75.

631
00:44:37,000 --> 00:44:41,800
Now once we've done that, we can check the parse

632
00:44:41,800 --> 00:44:44,400
in here with the testing.

633
00:44:44,400 --> 00:44:45,120
So make test.

634
00:44:50,840 --> 00:44:55,200
So it works perfectly fine.

635
00:44:55,200 --> 00:44:57,800
So up here, you're going to--

636
00:44:57,800 --> 00:44:59,240
oh, we want to do one more thing.

637
00:44:59,240 --> 00:45:00,880
We want to break out of the loop to see

638
00:45:00,880 --> 00:45:02,640
that our assertion works.

639
00:45:02,640 --> 00:45:04,840
And we haven't put in an assertion.

640
00:45:04,840 --> 00:45:08,680
So an assertion is something that is impossible.

641
00:45:08,680 --> 00:45:10,400
So what's impossible?

642
00:45:10,400 --> 00:45:12,920
This loop is while true.

643
00:45:12,920 --> 00:45:17,520
It's impossible for me to get here.

644
00:45:17,520 --> 00:45:19,520
So I'm just going to say assert false.

645
00:45:19,520 --> 00:45:26,680
This is saying this is unreachable.

646
00:45:26,680 --> 00:45:32,880
That is unreachable.

647
00:45:32,880 --> 00:45:35,960
Now what I'm going to do is I'm going

648
00:45:35,960 --> 00:45:37,960
to make a mistake in my code.

649
00:45:37,960 --> 00:45:39,880
Remember, assertions are determined

650
00:45:39,880 --> 00:45:42,680
to catch mistakes in your code.

651
00:45:42,680 --> 00:45:46,240
I can say that my intention, my assumption,

652
00:45:46,240 --> 00:45:50,440
is that I should never, ever be able to get

653
00:45:50,440 --> 00:45:51,600
to this line of code.

654
00:45:51,600 --> 00:45:53,880
It's unreachable.

655
00:45:53,880 --> 00:45:55,320
It's unreachable.

656
00:45:55,320 --> 00:46:00,920
But what if I inadvertently say break?

657
00:46:00,920 --> 00:46:02,320
Like that.

658
00:46:02,320 --> 00:46:07,560
So this is a piece of error in my code now.

659
00:46:07,560 --> 00:46:17,800
And when I do-- let's do make run again.

660
00:46:17,800 --> 00:46:34,800
And when I do 1, if I do 42, it works fine.

661
00:46:34,800 --> 00:46:39,480
But if I do 1, it throws the exception.

662
00:46:39,480 --> 00:46:46,600
But also, I actually had an assertion.

663
00:46:46,600 --> 00:46:50,160
So I'd go look at line 55.

664
00:46:50,160 --> 00:46:54,600
When I looked at line 55, it would say,

665
00:46:54,600 --> 00:46:58,760
oh, this should be unreachable, or this is unreachable.

666
00:46:58,760 --> 00:47:01,840
And then I'd look back and try and find my error.

667
00:47:01,840 --> 00:47:05,680
I'd see, how did I possibly get to that code?

668
00:47:05,680 --> 00:47:08,200
And maybe I'd put it in the debugger or so forth.

669
00:47:08,200 --> 00:47:12,000
So I'm going to comment that out.

670
00:47:12,000 --> 00:47:15,000
So this is the kind of thing you want to put in your statement.

671
00:47:15,000 --> 00:47:18,680
Now, false normally would put some kind of condition.

672
00:47:18,680 --> 00:47:23,040
False just means, if you ever get to this line of code,

673
00:47:23,040 --> 00:47:25,960
throw the exception, or throw the assertion,

674
00:47:25,960 --> 00:47:28,520
trigger the assertion at that point.

675
00:47:30,360 --> 00:47:34,000
All right.

676
00:47:34,000 --> 00:47:37,560
So those were two good exercises to get you

677
00:47:37,560 --> 00:47:40,920
into throwing exceptions.

678
00:47:40,920 --> 00:47:43,080
The last topic we're going to talk about today

679
00:47:43,080 --> 00:47:45,080
is function templates.

680
00:47:45,080 --> 00:47:46,480
So look at this function.

681
00:47:46,480 --> 00:47:51,080
So I have a function smaller, takes two integers, a and b,

682
00:47:51,080 --> 00:47:52,680
and uses the conditional operator,

683
00:47:52,680 --> 00:47:55,760
return the smaller of a or b.

684
00:47:55,760 --> 00:47:58,400
So if a is less than b, it returns a.

685
00:47:58,400 --> 00:48:00,520
Otherwise, it returns b.

686
00:48:00,520 --> 00:48:03,760
Notice this, actually, the algorithm that she uses

687
00:48:03,760 --> 00:48:09,480
will return b if they're identical, not a.

688
00:48:09,480 --> 00:48:11,200
So perhaps it would have been better

689
00:48:11,200 --> 00:48:13,920
if you wanted to return a if it was the smaller.

690
00:48:13,920 --> 00:48:17,680
In other words, first or smaller would say a less than

691
00:48:17,680 --> 00:48:21,800
or equal to b, return a.

692
00:48:21,800 --> 00:48:23,380
What if we want this function, though,

693
00:48:23,380 --> 00:48:26,200
to work for something other than an integer?

694
00:48:26,200 --> 00:48:28,080
Will it work for a double?

695
00:48:28,080 --> 00:48:38,440
In other words, if we called smaller 1.5, 1.75, well,

696
00:48:38,440 --> 00:48:40,160
first it would truncate them, right?

697
00:48:40,160 --> 00:48:43,080
It wouldn't really work for other types.

698
00:48:43,080 --> 00:48:48,000
So if I wanted smaller of 3.5 and 7.5,

699
00:48:48,000 --> 00:48:50,600
I'd always get back an int here.

700
00:48:50,600 --> 00:48:55,360
If I wanted smaller of zebra and ant, it wouldn't work at all.

701
00:48:55,360 --> 00:48:57,000
So how would we fix that?

702
00:48:57,000 --> 00:48:58,480
How would we fix it?

703
00:48:58,480 --> 00:49:01,280
Well, option one is just write an overloaded function

704
00:49:01,280 --> 00:49:02,760
for each type.

705
00:49:02,760 --> 00:49:06,760
So here's a smaller for a for double,

706
00:49:06,760 --> 00:49:08,640
and here's a smaller for string.

707
00:49:08,640 --> 00:49:13,440
And then our main function on the previous page works.

708
00:49:13,440 --> 00:49:16,320
The downside, the disadvantage, is

709
00:49:16,320 --> 00:49:20,040
that you have to write a new version for each type you want.

710
00:49:20,040 --> 00:49:24,360
When the code in the body is exactly the same,

711
00:49:24,360 --> 00:49:29,080
both of them say return a less than b, a, b.

712
00:49:29,080 --> 00:49:31,440
So it's kind of redundant.

713
00:49:31,440 --> 00:49:34,320
That's where function templates come in.

714
00:49:34,320 --> 00:49:38,360
So a function template is a set of instructions

715
00:49:38,360 --> 00:49:43,040
that tell the compiler how to generate a function when

716
00:49:43,040 --> 00:49:45,080
it is called.

717
00:49:45,080 --> 00:49:49,000
The functions are only generated if they are called.

718
00:49:49,000 --> 00:49:52,560
If we write the template for smaller,

719
00:49:52,560 --> 00:49:57,560
and we pass in-- we don't call it with a string,

720
00:49:57,560 --> 00:50:00,280
it will never be generated from a string.

721
00:50:00,280 --> 00:50:02,720
So here's the template function.

722
00:50:02,720 --> 00:50:05,600
Notice first that every template function always

723
00:50:05,600 --> 00:50:09,880
starts with template, type name, and then

724
00:50:09,880 --> 00:50:13,960
some symbol you're going to use as a placeholder for your type.

725
00:50:13,960 --> 00:50:15,200
T is really common.

726
00:50:15,200 --> 00:50:16,640
U is really common.

727
00:50:16,640 --> 00:50:20,880
But you can use larger names or ones that are more descriptive

728
00:50:20,880 --> 00:50:22,440
if you want.

729
00:50:22,440 --> 00:50:25,560
So this says the function smaller

730
00:50:25,560 --> 00:50:30,640
is going to return a type of whatever type T is.

731
00:50:30,640 --> 00:50:34,800
And it's going to take two arguments, a const T ref for a

732
00:50:34,800 --> 00:50:37,080
and a const T ref for b.

733
00:50:37,080 --> 00:50:40,760
And notice the code in here is exactly the same.

734
00:50:40,760 --> 00:50:46,240
Now, templates have to be seen when your code compiles.

735
00:50:46,240 --> 00:50:48,120
For that reason, they're generally

736
00:50:48,120 --> 00:50:49,880
placed in a header file.

737
00:50:49,880 --> 00:50:56,320
They are not pre-compiled like a regular function.

738
00:50:56,320 --> 00:51:00,680
Now, there are two ways to call a template function.

739
00:51:00,680 --> 00:51:02,700
Or specifically, there are two ways

740
00:51:02,700 --> 00:51:06,240
to generate the function from the template.

741
00:51:06,240 --> 00:51:09,320
When you call it, you can explicitly specify

742
00:51:09,320 --> 00:51:13,040
the type to be used for T. So I could

743
00:51:13,040 --> 00:51:16,040
call that function with smaller.

744
00:51:16,040 --> 00:51:19,920
And then in angle brackets after the name, I could say string.

745
00:51:19,920 --> 00:51:24,960
So generate a smaller function that uses string for T,

746
00:51:24,960 --> 00:51:28,120
and then pass in frog and flea.

747
00:51:28,120 --> 00:51:32,240
Now, that will write-- when you call the function,

748
00:51:32,240 --> 00:51:36,280
it will write a version of smaller

749
00:51:36,280 --> 00:51:40,600
that has the T replaced with string here.

750
00:51:40,600 --> 00:51:42,400
So it will say string smaller.

751
00:51:42,400 --> 00:51:47,600
Const string ref a, const string ref b, return a less than b.

752
00:51:47,600 --> 00:51:50,000
It will write that function for you.

753
00:51:50,000 --> 00:51:53,760
So that is called a template function.

754
00:51:53,760 --> 00:51:55,920
This is a function template.

755
00:51:55,920 --> 00:51:59,360
The function that's generated is called a template function.

756
00:51:59,360 --> 00:52:06,600
Now, can you simply call it implicitly?

757
00:52:06,600 --> 00:52:08,600
Yes, you can.

758
00:52:08,600 --> 00:52:16,320
So if I call the function auto n equals smaller 3.46 and 3.45,

759
00:52:16,320 --> 00:52:20,200
it will, in fact, give me back 3.45.

760
00:52:20,200 --> 00:52:22,960
And that generates this function.

761
00:52:22,960 --> 00:52:26,320
Double, remember, replaces the T with double,

762
00:52:26,320 --> 00:52:29,680
replaces the a with double, the b with double.

763
00:52:29,680 --> 00:52:33,720
And actually, it will replace it with const double ref,

764
00:52:33,720 --> 00:52:36,140
const double ref b.

765
00:52:36,140 --> 00:52:40,440
The reason we do the const in the template

766
00:52:40,440 --> 00:52:44,680
is because we don't know what type T is going to be here.

767
00:52:44,680 --> 00:52:51,240
And so we use the const T ref in case it's a library type.

768
00:52:51,240 --> 00:52:53,480
It doesn't hurt it if it's a primitive type,

769
00:52:53,480 --> 00:52:56,120
although it's not as efficient as it could be.

770
00:52:56,120 --> 00:53:02,120
Now, a couple of problems with that.

771
00:53:02,120 --> 00:53:04,760
First, the compiler cannot read your mind.

772
00:53:04,760 --> 00:53:10,680
What if we said auto s equals smaller frog and flea?

773
00:53:10,680 --> 00:53:13,960
If we do this, the compiler is going

774
00:53:13,960 --> 00:53:20,880
to deduce type T as a character array instead of string.

775
00:53:20,880 --> 00:53:23,920
And the code actually will not work.

776
00:53:23,920 --> 00:53:26,440
So notice earlier-- so notice here

777
00:53:26,440 --> 00:53:31,120
I'm finding the smaller frog and flea, and it doesn't work.

778
00:53:31,120 --> 00:53:34,440
But here, I explicitly said, oh, I

779
00:53:34,440 --> 00:53:36,960
want to use string for that type.

780
00:53:36,960 --> 00:53:39,200
And it did work.

781
00:53:39,200 --> 00:53:42,600
So the compiler can't read your mind.

782
00:53:42,600 --> 00:53:46,880
The solution is to either explicitly instantiate it,

783
00:53:46,880 --> 00:53:50,720
or you can add an overload of the function.

784
00:53:50,720 --> 00:53:55,140
If you write an overloaded non-template function that

785
00:53:55,140 --> 00:53:58,560
exactly matches the arguments here,

786
00:53:58,560 --> 00:54:02,840
then this version will be used before the other version.

787
00:54:04,800 --> 00:54:05,300
OK.

788
00:54:05,300 --> 00:54:08,160
A couple more problems with deduction.

789
00:54:08,160 --> 00:54:10,120
What happens when we do this?

790
00:54:10,120 --> 00:54:17,120
Auto n equals smaller 3.46 and 4.

791
00:54:17,120 --> 00:54:19,680
Well, that doesn't even compile.

792
00:54:19,680 --> 00:54:23,960
T is supposed to be a double, like argument 1,

793
00:54:23,960 --> 00:54:26,120
or an n, like argument 2.

794
00:54:26,120 --> 00:54:28,160
And remember, let's look back at the template.

795
00:54:29,080 --> 00:54:31,960
We have only one type name here, but two arguments

796
00:54:31,960 --> 00:54:35,160
that are type T. So it's going to look at this one and say,

797
00:54:35,160 --> 00:54:37,160
oh, no, it's a double.

798
00:54:37,160 --> 00:54:38,840
Oh, no, it's an int.

799
00:54:38,840 --> 00:54:40,200
It doesn't compile.

800
00:54:40,200 --> 00:54:41,000
It doesn't compile.

801
00:54:41,000 --> 00:54:45,660
OK.

802
00:54:45,660 --> 00:54:50,040
So how do we fix that?

803
00:54:50,040 --> 00:54:53,120
Well, you don't have to make every argument the same type

804
00:54:53,120 --> 00:54:54,120
parameter.

805
00:54:54,120 --> 00:54:56,160
So let's say we have a double.

806
00:54:56,160 --> 00:54:58,400
We don't have to make every argument the same type

807
00:54:58,400 --> 00:54:59,720
parameter.

808
00:54:59,720 --> 00:55:00,960
So I could say template.

809
00:55:00,960 --> 00:55:04,360
I could create a type name named T, another type name named

810
00:55:04,360 --> 00:55:09,760
U. And in this case, when I called it here,

811
00:55:09,760 --> 00:55:16,040
A would be double, or T would be double, and U would be int.

812
00:55:16,040 --> 00:55:19,080
Now, which one will it return?

813
00:55:19,080 --> 00:55:22,720
Will it return an int or a double?

814
00:55:22,720 --> 00:55:26,440
This actually is a little bit problematic.

815
00:55:26,440 --> 00:55:29,560
The return type could be either T or U.

816
00:55:29,560 --> 00:55:35,360
Starting in C++ 17, we can put auto as the return type here,

817
00:55:35,360 --> 00:55:39,120
and it will allow compiler deduction.

818
00:55:39,120 --> 00:55:40,680
If you look in your reader, you'll

819
00:55:40,680 --> 00:55:46,000
see a version that will work with C++ 11 and 14.

820
00:55:46,000 --> 00:55:49,440
This is called a trailing return type.

821
00:55:49,440 --> 00:55:51,520
However, this function probably has

822
00:55:51,520 --> 00:55:58,600
to decide either return an int or a double in this case.

823
00:55:58,600 --> 00:56:02,040
Because in fact, what's going to happen

824
00:56:02,040 --> 00:56:05,960
is to see if A is less than B. And if A is an int

825
00:56:05,960 --> 00:56:11,560
and B is a double, your computer cannot actually compute this

826
00:56:11,560 --> 00:56:14,320
without knowing which of those is a larger.

827
00:56:14,320 --> 00:56:17,200
So the larger type will always be the type

828
00:56:17,200 --> 00:56:21,240
that's returned in that case.

829
00:56:21,240 --> 00:56:23,120
OK, let's do a couple of exercises

830
00:56:23,120 --> 00:56:28,800
before we end up this lecture and our hour together.

831
00:56:28,800 --> 00:56:36,960
So let me go back to our lecture exercise.

832
00:56:36,960 --> 00:56:39,160
And these are some function templates

833
00:56:39,160 --> 00:56:41,360
from Purdue University.

834
00:56:41,360 --> 00:56:46,280
So we're going to write one function, exchange AB, which

835
00:56:46,280 --> 00:56:48,760
has two parameters of the same type.

836
00:56:48,760 --> 00:56:51,960
So we only need one template parameter.

837
00:56:51,960 --> 00:56:54,640
A function which is instantiated from exchange

838
00:56:54,640 --> 00:56:58,120
will exchange or swap these two parameters.

839
00:56:58,120 --> 00:57:01,760
And then multiples, sum, x, and n.

840
00:57:01,760 --> 00:57:03,920
The first type of parameters will

841
00:57:03,920 --> 00:57:08,080
have the type represented by the function template type

842
00:57:08,080 --> 00:57:13,880
parameter kind, or T. n will always be int.

843
00:57:13,880 --> 00:57:15,720
The return type's void.

844
00:57:15,720 --> 00:57:18,040
All parameters are passed by value,

845
00:57:18,040 --> 00:57:21,200
except for sum, which is passed by reference.

846
00:57:21,200 --> 00:57:24,200
A function instantiated from multiples

847
00:57:24,200 --> 00:57:32,800
will compute 1 plus x plus 2x plus 3x and so forth to nx.

848
00:57:32,800 --> 00:57:35,200
So let's go ahead and do that, although I don't remember

849
00:57:35,200 --> 00:57:38,680
exactly how to solve that.

850
00:57:38,680 --> 00:57:40,160
OK, so here's the first one.

851
00:57:40,160 --> 00:57:47,600
We're going to exchange A and B. So for the templates,

852
00:57:47,600 --> 00:57:59,760
we're going to write template type name T.

853
00:57:59,760 --> 00:58:03,080
Looks like exchange doesn't return anything.

854
00:58:03,080 --> 00:58:17,320
And so that's going to be T reference A and T reference B.

855
00:58:17,320 --> 00:58:21,360
We'll create a temporary T object.

856
00:58:21,360 --> 00:58:24,800
So T temp.

857
00:58:24,800 --> 00:58:37,680
We'll initialize it with A. We'll say A equals B.

858
00:58:37,680 --> 00:58:40,960
We'll say B equals temp.

859
00:58:40,960 --> 00:58:45,720
And now we've exchanged the two values.

860
00:58:47,720 --> 00:58:50,800
OK, so notice we can do it with ints.

861
00:58:50,800 --> 00:58:52,480
We can do it with doubles.

862
00:58:52,480 --> 00:58:53,520
We can do it with strings.

863
00:58:53,520 --> 00:59:08,600
OK, so sum-- OK, so that is going to take template type

864
00:59:08,600 --> 00:59:11,280
name.

865
00:59:11,280 --> 00:59:13,240
They want kind for the type here,

866
00:59:13,240 --> 00:59:15,720
I think, just to show you that you can use--

867
00:59:15,720 --> 00:59:33,760
you don't need to use T. Void and kind reference sum.

868
00:59:37,920 --> 00:59:46,920
And kind-- what was the second argument in that?

869
00:59:46,920 --> 00:59:57,920
x, kind reference x, or kind x, test by value, and int n.

870
01:00:03,320 --> 01:00:12,880
OK, so sum, let's set it to whatever value represents 0,

871
01:00:12,880 --> 01:00:14,280
or the empty value.

872
01:00:14,280 --> 01:00:16,640
For instance, if we wanted to sum strings,

873
01:00:16,640 --> 01:00:18,040
do they do strings here?

874
01:00:18,040 --> 01:00:20,160
No, they only do it with numbers,

875
01:00:20,160 --> 01:00:23,320
because the expression is going to be 1 over.

876
01:00:23,320 --> 01:00:28,160
So we're going to say sum equals 0.

877
01:00:32,640 --> 01:00:33,640
Or is it?

878
01:00:33,640 --> 01:00:37,560
Let's look at the expression.

879
01:00:37,560 --> 01:00:44,960
So sum equals 1 plus x.

880
01:00:44,960 --> 01:00:55,480
And it'll be converted to whatever type it is.

881
01:00:55,480 --> 01:01:01,200
And then it's going to be x plus 2x plus 3x.

882
01:01:01,200 --> 01:01:16,480
So write a loop for int i equals 1, so 1x, i less than

883
01:01:16,480 --> 01:01:23,400
or equal to n, because we want nx, i plus plus,

884
01:01:23,400 --> 01:01:34,240
sum equals sum plus i times x.

885
01:01:34,240 --> 01:01:41,840
And I think that's all we'll have to do.

886
01:01:41,840 --> 01:01:44,480
Down here it works, you can see, with doubles.

887
01:01:44,480 --> 01:01:47,120
And it works with ints.

888
01:01:47,120 --> 01:01:48,120
OK, let's try it.

889
01:01:53,040 --> 01:01:54,360
OK, so that worked.

890
01:01:54,360 --> 01:01:56,920
Here's swapping two ints, here's swapping two doubles,

891
01:01:56,920 --> 01:01:59,080
here's swapping two strings.

892
01:01:59,080 --> 01:02:01,160
Here is doing multiples with doubles,

893
01:02:01,160 --> 01:02:03,720
here's doing multiples with integers.

894
01:02:03,720 --> 01:02:16,400
All righty then, I believe that's all for today.

895
01:02:16,400 --> 01:02:21,920
And so we will see you in the next lecture in lecture 15.


