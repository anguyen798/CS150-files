Hello folks, welcome to our last lecture, lecture 28 on polymorphism.
So this is continuing the idea of inheritance.
In the last lecture we looked at what's called specialization inheritance.
With specialization inheritance, a derived class adds new features, it's a specialized
kind of a base class.
So it may have new member functions, it may have new data members, such as the instructor
and the student did in our last exercise.
With specification inheritance, what we want to do is not add new features, but change
behavior so that when we send the same message to different classes, they will interact according
to their nature.
So I have three animals here, and if I ask them to speak, the animal that's a dog says
woof, the animal that's a cat says meow, the animal that is a cow says moo.
So that's the basic idea behind polymorphism.
So if you go ahead and look in our, in the downloaded IC28 folder in pet01, you'll see
that I have a header file with pets, and you'll see that if you look through that, you'll
see that there are three different kinds of pets.
There is a base class pet, and then two derived classes.
Every cat and every dog, of course, is a pet, so we use public inheritance for this.
Now our cat inherits two member functions, license and getID, and it redefines speak.
It doesn't override it, it redefines it.
The dog inherits getID, and it redefines speak and license.
So this is the basic picture we have of that.
Now if you go over to the, if you go over to your IDE and you just open the client program,
you'll see that I create a pet, a cat and a dog, and I send the same message to each
of them.
And when we run this program, what you'll see is that the generic pet acts differently
than the cat and the dog.
Each one of them acts according to its nature.
And so each object responds appropriately to exactly the same request.
So how does that work?
This is called static polymorphism, and this works because the compiler looks at the declared
type of the variables P, C, and D.
P is of type pet, C is of type cat, and D is of type dog.
And it calls the correct function based on that type, and this binding together of the
function call, the function that is actually called, happens at compile time.
And so this is called static polymorphism or early binding.
Early binding.
Now what we would prefer instead of static polymorphism is polymorphic functions.
Instead of writing several overloaded functions like this, show and passing it a cat, show
passing it a dog, why can't I do this?
Why can't I simply write a function show pet or show pet pointer and ask it to speak and
then call the function like show my dog.
After all, every dog is a pet, right?
So that should work.
So let's go ahead and look and see what happens.
And this is not in A. This is in, let's close that one, this is in B, pet 2.
And if we look up the client, we see we have a speak with a pet and a speak with a pet
pointer.
I have a cat, a dog, and so we can get their IDs to make sure that we in fact have a cat
or a dog.
And in section 1, I pass a dog object to speak and a cat object to speak.
So let's go ahead and open a terminal and see if that works.
So I'm going to do make run.
Ok so the cat had an ID of 101, the dog had an ID of 102, but when I pass 101 and 102,
the cat and the dog, they forget what kind of pet they are and they forget how to do
any dog or cat stuff.
Somehow they've lost their memory of their catness and dogness.
They have amnesia, so to speak.
They have amnesia, so to speak.
Now if I change it so that I don't have a cat and dog and I use a pointer and I pass
the address of my dog and the address to my cat, again they don't remember they're a cat
and a dog.
They remember their ID number, right?
So they remember the pet part of themselves, but they don't remember the cat and dog point.
And if I call pet through a base pointer, so here notice c_ptr and d_ptr are not cat
and dog pointers, they're pet pointers, but they're storing the address of the cat and
the address of the dog.
Again that doesn't seem to work.
Finally the last section here, I wanted to look at how big each object is.
Each object is just big enough to store the size of their ID.
So the question we really have is how come this didn't work?
By the way, if we did this in Java it would work perfectly.
In C++ it doesn't seem to work and the question is why.
So for part one, when we had a function called show_pet_p and we pass a dog object by value
to the show function, what happens is the dog object passed by value is sliced into
two parts.
So imagine that a dog has a pet part and a dog part, but the variable over here only
has enough room for the pet part.
The dog part is just discarded.
So this is similar to what happens when you pass a double value to an int variable or
you assign a double value to an int variable.
The fractional part is sliced off and thrown away or truncated.
So this is called the slicing problem.
This is one reason we never write functions that take objects by value.
It also means that in C++ you cannot assign a derived object to a base variable.
It will get sliced off and thrown away.
Now notice the second part of this though.
I had pointers and derived objects.
So notice I said speak with the address of the dog and speak with the address of the
cat.
Why didn't that work?
There was no slicing.
Obviously the pointer is the same size for a cat or a dog pointer.
The pointer is the same, but it still doesn't work.
It still doesn't work.
And it doesn't work because the function calls are still linked together, what we say they
are bound, based on the declared pointer type.
And the type of the pointer in the speak member function is not a cat or a dog.
Remember it is a pet pointer.
So the fact that this is a pet pointer means that this is always going to call the pet
version of speak, not the cat or the dog.
And that information has to be known at compile time.
That information knows at compile time.
So it sounds like polymorphic functions that we have in Java are impossible.
That's not the case.
What we want is a way to tell the function that the pet pointer p parameter actually
points to a cat or dog object.
Well when will we know that?
We'll know it when we call the function.
We'll know it at run time.
We want to wait until run time, not at compile time, to decide which function to call.
And this is called late binding.
And that is what the keyword virtual in a class does.
The keyword virtual enables late binding.
Now as I mentioned, you may, but don't need to, repeat that virtual in the derive class.
If a function is virtual in the base class, it is virtual and it will use this late binding.
Now you might wonder why you didn't have this complication in Java.
That's because in C++ you can have both early and late binding.
In Java, all binding happens at run time.
The reason is because in C++ they want to allow you to use the more efficient binding.
And because the default in C++ is always to use the most efficient way, early binding
is the default.
Late binding uses indirection to call the function, which is a little bit slower.
And it also uses a little bit more memory.
Each object has a v pointer, which points to a v table.
So let's go see how that works.
And to see how that works we'll go to our pet3.
And the only difference between pets2 and pets3 is that I have added this keyword virtual
only in the header file.
The rest of the code is exactly the same.
You notice this pet pointer calling pet speaking through the base pointers and so forth.
Actually it's not exactly the same, but it works exactly the same.
So in pets3, let's do make run.
So now calling the virtual functions through the base pointer, the cat remembers that it's
a cat.
It remembers it's type cat.
And it remembers to say meow.
The size of each object, notice, has changed though.
So it went from 4 bytes to 16 bytes.
Why is that?
We have the 4 bytes for the ID, and then we have 8 bytes because this is Unix for a pointer.
There's 4 bytes that are unused in each object.
Now notice in my client program, if I call a function with an object, even though it's
a virtual function, it's not polymorphic.
So polymorphic functions cannot take objects.
In other words, this will not work.
If we made it a const pet reference, that would be perfectly fine.
It would work.
If we make it a pet by value, you cannot pass an object.
You cannot pass an object.
Can you call a polymorphic function with a pointer?
Yes.
It looks like we can see meow and arf.
Can you call a polymorphic function with a base pointer?
Yes, it works perfectly fine.
When we call speak with a base pointer, remember cpointer is a pet pointer, not a pointer.
It's a pointer to a cat that happens to be pointing to a cat.
And so it waits until runtime to determine that.
OK, so that's the basic idea behind polymorphism.
With polymorphism, you have to call it through a base pointer.
So for instance, if I have a cat and a pet pointer p, so this pointer is of type pet,
but it points to a cat.
When we call pspeak, if the function is virtual, it will call catspeak.
You call a polymorphic function only with a pointer or reference.
So this is not polymorphic.
This is polymorphic.
The polymorphic function, of course, must call a virtual function.
In other words, if speak isn't virtual, it's still not polymorphic.
When we call speak with the address of c, the compiler uses the dynamic type to decide
which function to call catspeak.
And again, the decision is made at runtime.
OK, so let's do an exercise.
This is exercise A. We have four different kinds of cards, like an ID card or what in
old-fashioned movies someone would-- a calling card, right?
We have an ID card that has an ID number on it, like your student ID card.
We have a calling card that doesn't have your name on it, but it has a card number on it,
and we have a driver's license.
So four different kinds of cards.
So let's put away this client.
Let's put away pets3.
Let's go look at A. And let's go look at cards.h.
So here's the card.
Here is the ID card.
Here is the calling card.
Here is a driver's license.
It's like a phone card, a calling card, not something you would call somebody on.
And here is our client program over here.
So we have a Billful class.
It creates a base class pointer and initializes that base class pointer cp to a new plain
card that says John Doe.
Then it adds that to this Billfold object.
Now the Billfold will accept-- it has a vector inside it that takes an array of cards.
Then we initialize this base pointer a second time with a new ID card and add it to the
Billfold, a new calling card, and a new driver's license, and then we call printCards.
And again, what is supposed to happen is it's supposed to print the regular card, the ID
card, the calling card, and the driver's license.
So the problem is it only prints-- it doesn't print the right thing-- and it leaks memory.
So we're going to do make check or make grind to see the errors.
So let me open up a-- let me do make grind-- I'll do make check.
And notice, number one, the output is wrong.
Compare that to this.
This is what the output is supposed to look like.
And secondly, look at all this memory leaks inside here.
Memory leaks inside the program.
So let's see what the problem is and let's see how we can fix it.
Now the Billfold class stores pointers to objects in a vector.
The objects themselves have been created on the heap with new, but never deleted.
And so while the vector, all the memory that the vector uses, is destroyed when the Billfold
is destroyed, because vector has its own destructor, the Billfold class, the objects that it creates,
the objects that it has created, have not been destroyed.
So any class that manages dynamic memory needs a destructor.
Each class can have only one destructor.
It's not overloaded.
And the syntax is simply the same name as the default constructor with a tilde in front
of it.
An r destructor for the Billfold class should walk through the vector and delete each pointer.
So let's see if we can fix the memory problems first.
Move that down there.
So we'll go to the Billfold H. We'll add a destructor to it.
So tilde Billfold.
We'll copy that to Billfold.cpp.
We'll qualify that name.
So there's the destructor.
And we'll do exactly the same thing that print cards does, is we'll walk through all of the
cards and we'll simply delete each pointer.
OK.
So we have added a destructor to the Billfold class to make sure that all of the dynamic
memory that that vector contains isn't destroyed, doesn't leak.
Let's do control L. Let's do make check again.
We still had a lot of memory leaks inside here.
OK.
Look at this stuff.
That's kind of weird.
So it looks like it's saying that object passed to delete has the wrong time.
The size of the allocated byte is 32 bytes.
The size of the deallocated type is 32 bytes.
Now look at cards.h.
Notice that this object only has one data member.
This object has a different one data member and this data member.
So this one's got two.
This one has three.
And so each of these objects we put on the heap is actually a different size.
So it says that somehow we're deleting the wrong kind of thing.
Notice also one other problem.
Still doesn't print the right thing, right?
So let's see if we can print the right thing and let's see if that helps us to get back
to the fact that we're still leaking some memory here because of this new delete type
mismatch.
The fact that we actually allocated 64 bytes in one case but only deleted 32 bytes.
Now even though each specific card has its own print member function, it actually isn't
being called.
So let's go look.
Notice when we look at cards.cpp, when we look at print for an ID card, it's supposed
to print the ID number.
That's not being called, obviously.
So what would cause the functions not to be called?
Because print isn't declared virtual in the base class card.
So let's make print virtual.
Let's rebuild and see if that fixes all of our problems.
So we'll go to cards.h.
We'll change print in card.
Nowhere else, we'll just make it virtual here.
We'll rebuild.
We'll do a make check.
Whoa, it won't even compile now.
It won't even compile now.
And actually it's our bill phone that won't compile now.
So why is that case?
Why do we have this new error?
So think about what happens when we delete a card pointer.
It's going to look at the heap.
It's going to find the size of a card object and delete that amount of memory from a heap.
So we kind of got an intimation in the last set of errors we got when it said, oh, you
allocated 64 bytes, but you only deleted 32.
With virtual functions, the objects on the heap may not be a card.
We have to add a virtual destructor to classes with virtual members.
Now in our case, the only reason we add a virtual destructor is to tell the destructor
to actually look on the heap and see how much memory was added.
So in the card class, we're going to add virtual tilde card.
And then we're not even going to write anything.
We're just going to do equals default.
We're not going to do anything special.
The only thing that's doing is telling the card class, when it's destroyed, to actually
look on the heap and see what kind of card is actually there.
OK, let's try it once more.
I'm not quite sure what I did.
I think I accidentally killed my code space accidentally somehow.
So we're going to wait to see if it will start it.
And word elitist.
I probably pressed the wrong-- I meant to press Control-L to just clear the screen,
but I did something else instead of that.
I'm going to close that terminal.
I'm not sure what happens.
So I'm going to do Control-A again.
I'm going to update later.
Oh, by the way, when you get that update message and you update, make sure every time you update,
you rerun the 150 config.py.
Just go to the root directory, type Python, 150config.py, and enter in your information once again.
OK, so I need to be in A. Open in an integrated terminal.
And let's do make check once again.
OK, notice we didn't get any memory leaks now, and it actually prints each of the correct
values.
All right, folks, we're going to do one more thing here.
I want to talk about class relationships.
And to do that, we're going to create a class called the stack.
Now a stack is a classic data structure, or what we call an abstract data type.
It's fundamental for many different algorithms.
And it is a sequence, like a vector, except you can only add things at the end, or the
top of the stack, we say.
And you can only remove them from the top.
So you're not allowed to look through the items inside the stack.
There are really only four operations on this type.
This is called push, add an item to the stack.
Top, remove the item that's at the top of the stack.
Top, retrieve a copy of the item that's on the top of the stack.
And empty, see if there are any things in the stack.
Now for this stack class, in exercise B over here, so let's close that, close that, close
that, go to B, and let's go to stack.h.
Let's go to RPN.
What I've done here is I've created a program that creates a reverse Polish notation calculator.
So normally, when we write an expression, we write an expression that looks like this.
1 + 2 * 3.
This is called infix notation.
Now in reverse Polish notation, what we do is write that like this.
1, 2, 3 * +.
1, 2, 3 * +.
Now the way reverse Polish notation works is that we, as we get input, we add it onto
the top of the stack.
If the input happens to be one of the operators, what we do is we pop the values off the stack.
So if it's a plus or a minus or a multiply or divide, we pop the items off the stack.
And then we add them together and put the answer back on the stack.
So let me go open a shell for this, for B. Let me do make run.
And notice that this calculator allows me to add in values.
So what this expression means is multiply 2 * 4 and then add the result of that, 8,
to 1.
And then P will print the current value or Q will quit.
So I'll say P and Q. And so that will print out the value 9 and quit the calculator.
So our goal here is not to really learn how this works, but this is an interesting algorithm
to see how a calculator works.
Our goal is to look at this class stack.
So we want to create this class which adds or removes things from the top of the stack.
Now in this example, in this version, I'm going to open stack.h.
In this version, we're using a stack from the standard library.
So there is a header called stack and I am using this alias, this type alias, to say
that a stack equals the standard stack.
And so you can see that our code works.
Our exercises today are to use different kinds of inheritance to get something so the same
thing works.
So we're going to comment out this and we're going to get it to work for the different
types.
So the starting code uses the standard library stack double.
A type alias allows us to use the simpler name stack.
So I won't need to change anything except what I put in the header file.
So we're going to start with regular inheritance.
So we're going to inherit from a vector of double.
We're going to add inline members for push, pop, and top.
We don't need empty because with public inheritance we inherit public.
We inherit empty from vector.
And then we'll call the inherited methods in the definitions of the unlined members.
So let's look at that, how we could create this class.
So we're going to comment that out.
And then we're going to say class stack is a kind of public standard vector of double.
Open brace, close brace, semicolon.
Now in the public section we're going to add double top and cost.
And we're simply going to return back.
Whoever is at the back of that vector.
Remember we are a vector.
Void pop.
And this is going to say pop back.
That's the name of the function in the vector that we're using.
And void push double n.
We're going to say push back n.
So here is our version of the stack where we've used inheritance just to reuse that.
Now if that worked, we'll be able to say make run.
And now we're no longer using the built in stack from the library.
We're using one that we built by using the vector to do this.
So we're going to say 1, 2, 4 times plus and then p.
And then I'm going to do q to quit that.
So it gives me the same thing.
It works exactly the same.
Now that works.
But there is a major logical problem.
Because the stack can use all of the vector methods, that means it can access other elements
beside the top.
And it can change the contents of the stack.
So imagine that if you were writing a gambling application and you wanted to use a stack
because you know it promises it can only access the card that's on top.
Check what happens if someone would use your stack here that you just wrote.
It would allow people to cheat.
That means that we are really violating the contract of the stack interface.
The stack interface guarantees that you can only push, pop, top, and empty.
That you can't do anything else to it.
So really in this case, using public inheritance, it says that a stack is a vector.
And a stack is not really a vector.
A stack can do some of the things that a vector can do.
It's like a vector, but it's not a vector.
The vector can do more than a stack can.
So public inheritance is really inappropriate to use in this situation.
So let's try another one.
We'll try composition or layering.
Instead of inheriting from vector, what we're going to do is add a private vector data member.
Add the inline members.
Now again, because we're not using public inheritance, there is no inherited methods.
So we'll have to add inline member functions for push, pop, top, and empty.
And then we'll forward all the requests to that embedded member.
So let's go ahead and let's copy this right here.
Put it down in stack.
Comment out the one we had up here under exercise one, so it won't interfere with what we're
doing now.
We're going to get rid of this inheritance part.
We're going to add a data member, so private standard vector double v.
And now for these functions, we're going to call that data member vback, vpopback, vpushback.
We'll have to add empty there.
Empty const return vempty.
And we may also need size here.
Let's see if we do need size.
Let's do matron.
Yeah, it needs size.
So size p size const return vsize.
Ok, so again we can do 1, 2, 4 times plus p and it gives us 9q and it quits.
So this kind of class is called an adapter class.
That's because what it does is it adapts the interface or changes the interface of one
class to another class.
And this use of composition is known as layering, where we're not really using all of the features
of the vector, we're just picking out some of those features.
And so it's slightly different than a hasa or a whole part, where we're letting the part
do all of the work.
Now with private inheritance, the derived class inherits the implementation but not
the interface.
We say that private inheritance is an implemented with relationship.
So let's go ahead and try that third one here.
We're going to grab this.
I'm going to copy it down here and we're going to comment out exercise 2.
And here we're going to say our class inherits privately from standard vector double.
So now we no longer have this data member inside here.
We no longer have this data member inside here.
And we would simply say top is returned back.
We don't need those two because they are inherited.
The problem is if we try and compile this now, if we try and compile it now, if I do
make, it'll tell me I'm sorry, those functions are inaccessible inside here.
And so what we need to do is we need to selectively import the base class interface.
In other words, unlike public inheritance, it's not entirely included.
And so all of the member functions we call, we need to add this using vector pushback.
Using vector back.
Using vector popback.
So anything that we use inside here, we have to, anything we use as part of our implementation,
we have to bring in as part of the interface.
So this is used much less because it's a little bit more complex.
So 1, 2, 4 times plus P, we get our 9, Q, we get our quit.
Because this is a little bit more complex using private inheritance than using composition
or layering, composition or layering is probably preferred.
Notice with private inheritance, this prevents, unlike unwanted members being called, unlike
ISA, when we use public inheritance, unwanted members could be called.
They can't be called now with this stat class.
You can't automatically change the function names, which would be nice.
You must use inline delegated functions, just like layering.
And since we have to do the same thing we had to do with layering, in other words, add
these delegating functions here, and we have to import the interface as well, it's generally
easier just to use layering.
I think that's easier.
So what do these features mean?
So public inheritance means ISA.
If a class D publicly inherits from B, every object of type D is also an object of type
B, but not vice versa.
So an ostrich is a bird, but not every bird is an ostrich.
Private inheritance does not mean ISA.
Public inheritance means substitutability.
I can pass a, I can assign a, the address of an ostrich to a bird pointer.
Private inheritance means implemented with.
There is no substitutability.
There is no conceptual relationship between the classes.
It simply means I want to use the implementation of the base class in my derived class.
And composition is either a has a relationship or an implemented with relationship.
You can use it as a whole part where something has a specific part that does its work, or
you can use it for layering, like we've done here, where we've just used the vector to
implement the part we needed.
I have one other topic I want to talk about.
This is back to our pet class.
My pet hierarchy has a problem.
My generic pet says, what's my motivation?
But generic pets really can't speak.
They don't have mouths, for instance, right?
My pet could be a plant.
But I can't remove the speak member function because then I'd lose the ability to call
speak polymorphically, which is what I want.
And so the solution is to create an abstract function.
In Java, you do this using the keyword abstract.
In C++ terminology, even though this is generically known as an abstract function, it's called
a pure virtual function.
The syntax looks like this.
It must be virtual.
And then it must be assigned a value zero.
This is simply kind of saying, if you think of it logically, that this function is not
going to have an implementation.
All we're keeping is the prototype.
Now once you have done this, the class that contains a pure virtual function or an abstract
function becomes an abstract base class, what we call an ABC.
If you have an abstract base class, you cannot instantiate from it.
You can only inherit from it.
And the classes that you derive from it are called concrete classes.
And they are required to implement that function.
So let's look at our last example here in our IDE in pet4.
So you notice now in pets.h, I have my virtual functions like I had before.
I have my class cat.
But the speak function is turned into an abstract function or a pure virtual function.
That means that I could not create a pet object.
And it means that any classes I created like elephant would be required to add the speak
function.
So in my client over here, notice if I try and compile this, let's kill that, let's open
up pets4.
If I try and compile this, I'm not sure why I have a syntax error here.
The x and z is called client.
I see.
Actually let me go ahead and kill this make file.
Hopefully by the time you get it, it will be fixed.
Let me delete that make file.
Let me get the make file from pet3.
Move it to pet4.
And I'm missing the .o in the pet4 one, the one I had before.
So let's do make on this.
So in pet4, I'm trying to build this program.
I'm going to do make.
And it says I cannot create this elephant.
That's because the elephant is an abstract type.
Why is it an abstract?
Because the following virtual functions are pure within elephant.
Virtual void pet speak.
So I cannot create that elephant.
I could not create the pet.
Let's do that, try that and do make again.
Cannot declare variable p to be of abstract type pet.
So if the child class, the derived class does not implement the pure virtual function, then
it will not compile.
You also cannot instantiate a pure virtual, an abstract class.
The only thing you can do with it is you can derive from it.
So let's do make run.
And notice now this works perfectly fine.
The cats and dogs can speak, but the pet can no longer speak.
And this works polymorphically.
These are polymorphic member functions.
Okay, so what's the upshot from this last thing?
A regular virtual function means the children inherit the interface plus a default implementation.
The child may change it, but it's not required to change it.
A non-virtual function means that the children inherit the interface plus a mandatory implementation.
The child or the derived class cannot override it.
It can replace it, but it really shouldn't do that.
It creates what are called schizophrenic classes.
Finally, if we have a pure virtual function, it means the parent is declaring that the
child must override it.
It's a mandatory override for the derived class.
Alright folks, that's everything for this semester.
I'll see you online, or I'll see you in class.
Bye bye.
Bye.
