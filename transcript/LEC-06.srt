1
00:00:00,000 --> 00:00:00,000
Hello everyone, this is Steve Gilbert. Welcome to lecture 6 on programming with loops.

2
00:00:00,000 --> 00:00:00,000
Before you get started make sure you've gone into Canvas and that you have

3
00:00:00,000 --> 00:00:00,000
you have clicked week 2.

4
00:00:00,000 --> 00:00:00,000
In week 2 you've gone and clicked the lecture exercise in programming with loops, the third tab over.

5
00:00:00,000 --> 00:00:00,000
On the lecture exercise click the starter form.

6
00:00:00,000 --> 00:00:00,000
When you get the starter form go ahead and rename it here so you'll be able to find it when we get started.

7
00:00:00,000 --> 00:00:00,000
Now C++, like Java, has several different kinds of loops.

8
00:00:00,000 --> 00:00:00,000
They have four of them. There's a while loop, there's a do while loop,

9
00:00:00,000 --> 00:00:00,000
there is a for loop, and then there is the simplified for loop we saw in the last lecture.

10
00:00:00,000 --> 00:00:00,000
But just knowing about these four kinds of loops really doesn't give you any guidance

11
00:00:00,000 --> 00:00:00,000
when you want to decide what loop should I use for this problem.

12
00:00:00,000 --> 00:00:00,000
For that you really need a different way of thinking about loops.

13
00:00:00,000 --> 00:00:00,000
And so rather than thinking about the four kinds of loops syntax,

14
00:00:00,000 --> 00:00:00,000
think about the five ways to control the number of repetitions.

15
00:00:00,000 --> 00:00:00,000
Last lecture we looked at range iteration.

16
00:00:00,000 --> 00:00:00,000
We visited every element in the container.

17
00:00:00,000 --> 00:00:00,000
That's what the simplified or the range based for loop is for.

18
00:00:00,000 --> 00:00:00,000
We have counter controlled iteration.

19
00:00:00,000 --> 00:00:00,000
We're going to look at that today.

20
00:00:00,000 --> 00:00:00,000
That's when we have a fixed number of times we're going to repeat.

21
00:00:00,000 --> 00:00:00,000
Do this loop ten times.

22
00:00:00,000 --> 00:00:00,000
We have a sentinel loop.

23
00:00:00,000 --> 00:00:00,000
A sentinel loop is for input, when we look at the contents of input

24
00:00:00,000 --> 00:00:00,000
and we look for a specific value that tells us to stop looping.

25
00:00:00,000 --> 00:00:00,000
We have a data loop.

26
00:00:00,000 --> 00:00:00,000
A data loop is also known as an end of file loop,

27
00:00:00,000 --> 00:00:00,000
when we simply want to process all the data that remains in input.

28
00:00:00,000 --> 00:00:00,000
So both the sentinel loop and the data loop are used for input loops.

29
00:00:00,000 --> 00:00:00,000
Finally we have a limit loop.

30
00:00:00,000 --> 00:00:00,000
A limit loop is when we want to do a calculation,

31
00:00:00,000 --> 00:00:00,000
look at the calculation and somehow determine are we close enough.

32
00:00:00,000 --> 00:00:00,000
Have we reached our limit?

33
00:00:00,000 --> 00:00:00,000
And so we're going to use this to think about loops.

34
00:00:00,000 --> 00:00:00,000
We're going to use these five ideas to think about loops when we write our loops.

35
00:00:00,000 --> 00:00:00,000
So let's look first at a little bit of review for the range loops.

36
00:00:00,000 --> 00:00:00,000
So C++11 introduced this new simplified range-based for loop,

37
00:00:00,000 --> 00:00:00,000
similar to the for loop in Python

38
00:00:00,000 --> 00:00:00,000
and the new for loop introduced in Java 5 in Java.

39
00:00:00,000 --> 00:00:00,000
And so this will allow you to visit every element inside a collection.

40
00:00:00,000 --> 00:00:00,000
It works on the string type, it works on the vector type,

41
00:00:00,000 --> 00:00:00,000
it works on the built-in array type,

42
00:00:00,000 --> 00:00:00,000
it actually works on all the collection types that are in the standard library.

43
00:00:00,000 --> 00:00:00,000
And the basic syntax looks like this.

44
00:00:00,000 --> 00:00:00,000
For, then you declare a variable.

45
00:00:00,000 --> 00:00:00,000
Now you can specifically specify the type, like char C,

46
00:00:00,000 --> 00:00:00,000
or you can use auto here, auto E.

47
00:00:00,000 --> 00:00:00,000
Then a colon, and then just the name of the collection variable that you want to loop over.

48
00:00:00,000 --> 00:00:00,000
This will go through each copy of the variable and put that variable inside E.

49
00:00:00,000 --> 00:00:00,000
Now there are three variations in C++, Java has only one variation.

50
00:00:00,000 --> 00:00:00,000
In, similar to Java, we can use value iteration,

51
00:00:00,000 --> 00:00:00,000
meaning take the first element out of the collection,

52
00:00:00,000 --> 00:00:00,000
put it in the variable E, put a copy of it in the variable E,

53
00:00:00,000 --> 00:00:00,000
then take the second one, put it in the variable E,

54
00:00:00,000 --> 00:00:00,000
then take the third one, put it in the variable E.

55
00:00:00,000 --> 00:00:00,000
Instead of making a copy of each of those elements though,

56
00:00:00,000 --> 00:00:00,000
we can actually look directly at the element.

57
00:00:00,000 --> 00:00:00,000
And so this is for auto ref, again you don't need to use auto here,

58
00:00:00,000 --> 00:00:00,000
you can use char or int or whatever the type of the elements in the collection are.

59
00:00:00,000 --> 00:00:00,000
And this actually looks at the individual elements, so you can actually change them.

60
00:00:00,000 --> 00:00:00,000
Now suppose our collection was filled with very, very large elements, say pictures.

61
00:00:00,000 --> 00:00:00,000
You were going through the camera roll on your iPhone.

62
00:00:00,000 --> 00:00:00,000
This first one would be very, very expensive to make a copy of each picture just to look at it.

63
00:00:00,000 --> 00:00:00,000
The second one would be more efficient,

64
00:00:00,000 --> 00:00:00,000
but it's possible that the function would modify the pictures in your picture roll.

65
00:00:00,000 --> 00:00:00,000
What you might want to do there is use this third one.

66
00:00:00,000 --> 00:00:00,000
For this third one, we look at the element,

67
00:00:00,000 --> 00:00:00,000
but because of the const in front of it, we're prevented from modifying it.

68
00:00:00,000 --> 00:00:00,000
Okay, so that was what we did last lecture.

69
00:00:00,000 --> 00:00:00,000
Now let's look at counter-controlled loops.

70
00:00:00,000 --> 00:00:00,000
So a counter-controlled loop creates a separate variable called a loop control variable,

71
00:00:00,000 --> 00:00:00,000
and that will control the number of repetitions, the counter.

72
00:00:00,000 --> 00:00:00,000
Now we can use this loop control variable two ways.

73
00:00:00,000 --> 00:00:00,000
Traditionally we use this to the for loop, but you can do it with a while loop as well.

74
00:00:00,000 --> 00:00:00,000
One way is when we want to loop through a string,

75
00:00:00,000 --> 00:00:00,000
and we want to access the elements of the string,

76
00:00:00,000 --> 00:00:00,000
or we want to access the elements of an array or a vector or something like that.

77
00:00:00,000 --> 00:00:00,000
To do that, because the array and the string and the vector all start their element numbering at zero,

78
00:00:00,000 --> 00:00:00,000
we want to start our index at zero.

79
00:00:00,000 --> 00:00:00,000
And so because we don't want to think about how to end that, we use an asymmetric bounds.

80
00:00:00,000 --> 00:00:00,000
Notice it includes the initial bounds, the lower bounds, index zero, but it excludes the upper bounds.

81
00:00:00,000 --> 00:00:00,000
So notice it's less than ten here.

82
00:00:00,000 --> 00:00:00,000
Now the name for these loop control variables, i and j, are very common names.

83
00:00:00,000 --> 00:00:00,000
If you have a nested loop, you'd start with i and then go to j,

84
00:00:00,000 --> 00:00:00,000
and then maybe k if you had three nested loops inside each other.

85
00:00:00,000 --> 00:00:00,000
This int i = 0 is initialized before the loop is entered.

86
00:00:00,000 --> 00:00:00,000
And the scope of the counter i, or the control variable i, is only inside the body of the for loop.

87
00:00:00,000 --> 00:00:00,000
It doesn't extend after the for loop.

88
00:00:00,000 --> 00:00:00,000
Now the test expression, the second part of this counter controlled loop, is tested before the loop is entered.

89
00:00:00,000 --> 00:00:00,000
And so we call this kind of loop a guarded loop, meaning you can't get to the actions unless you pass the test.

90
00:00:00,000 --> 00:00:00,000
This condition here is the loop guard.

91
00:00:00,000 --> 00:00:00,000
Finally, after we've gone through and executed all the statements in the body of the loop,

92
00:00:00,000 --> 00:00:00,000
we come back to this loop control variable and increment it here.

93
00:00:00,000 --> 00:00:00,000
This is called the update expression.

94
00:00:00,000 --> 00:00:00,000
This is not updated after we do the test, it's updated after we do all the things in the body.

95
00:00:00,000 --> 00:00:00,000
Now the for loop can also be used for a second purpose.

96
00:00:00,000 --> 00:00:00,000
That is, it can be used to generate a sequence of data.

97
00:00:00,000 --> 00:00:00,000
And when we do that, you use a slightly different set of conditions, a different set of bounds called symmetric bounds.

98
00:00:00,000 --> 00:00:00,000
What that means is you'll start at the lower bounds and include that, but you'll also include the upper bounds.

99
00:00:00,000 --> 00:00:00,000
So if we wanted to write a loop that would print from 1 to 10, rather than writing for 0, int i = 0, i < 10,

100
00:00:00,000 --> 00:00:00,000
and then printing i + 1, we'd print for int i = 1, i <= 10.

101
00:00:00,000 --> 00:00:00,000
So when you generate sequences of data, you want to include both the lower bounds, int i = 1,

102
00:00:00,000 --> 00:00:00,000
and the upper bounds, i <= 10.

103
00:00:00,000 --> 00:00:00,000
Notice with the asymmetric bounds we didn't include the upper bounds 10.

104
00:00:00,000 --> 00:00:00,000
We said keep going while i < 10.

105
00:00:00,000 --> 00:00:00,000
Now for strings and counter-controlled loops, there is a pattern that you can memorize.

106
00:00:00,000 --> 00:00:00,000
And first, initialize both the lower and upper bounds in the initialization section.

107
00:00:00,000 --> 00:00:00,000
Both the upper and lower bounds, in other words, i and what you're going to test i against, the size or the length.

108
00:00:00,000 --> 00:00:00,000
Use size t as the control variable, not int.

109
00:00:00,000 --> 00:00:00,000
That's because strings, the size function, the size member function, returns a size t.

110
00:00:00,000 --> 00:00:00,000
Initialize the upper bounds with str.size, and make sure that the control variable never, ever goes less than 0.

111
00:00:00,000 --> 00:00:00,000
So some of the loops that you would write in Java simply won't work in C++.

112
00:00:00,000 --> 00:00:00,000
Now we are going to use this first idiom we're going to look at. It's called the "building a string" idiom.

113
00:00:00,000 --> 00:00:00,000
So the input for building a string will be a const string ref. It won't be modified.

114
00:00:00,000 --> 00:00:00,000
The result will be an empty string. The output will be the empty string.

115
00:00:00,000 --> 00:00:00,000
Each time you go through the loop, you'll concatenate something to the result to produce the output.

116
00:00:00,000 --> 00:00:00,000
So we're going to do an exercise to show you this idiom and to get you started with some hands-on work with processing strings with counter-controlled loops.

117
00:00:00,000 --> 00:00:00,000
And so this is the exercise called "to reverse."

118
00:00:00,000 --> 00:00:00,000
And so this will be in A in your starter code in ICO6.

119
00:00:00,000 --> 00:00:00,000
And so go ahead and put your name on the top of it.

120
00:00:00,000 --> 00:00:00,000
So a "building a string" idiom produces a new string. So the output is going to be called "string."

121
00:00:00,000 --> 00:00:00,000
"To reverse" is the name of a function. It takes a single string as an argument and produces a duplicate with the characters in reverse order.

122
00:00:00,000 --> 00:00:00,000
You may use the library function "size" and "at." The argument will not be modified.

123
00:00:00,000 --> 00:00:00,000
So "string to reverse." Its argument is not going to be modified, so it's a const string ref str.

124
00:00:00,000 --> 00:00:00,000
The output is going to be a new string, so "string result."

125
00:00:00,000 --> 00:00:00,000
And we're going to return the result.

126
00:00:00,000 --> 00:00:00,000
Okay, so let's try that. Let's go ahead and, oh, I need to open a terminal on that.

127
00:00:00,000 --> 00:00:00,000
So let me open a terminal on A. Open an integrated terminal.

128
00:00:00,000 --> 00:00:00,000
So now we've opened that folder A.

129
00:00:00,000 --> 00:00:00,000
And let's go ahead and do "make test."

130
00:00:00,000 --> 00:00:00,000
And all of the code compiles correctly. Of course it doesn't produce the correct output.

131
00:00:00,000 --> 00:00:00,000
It isn't reversed string, but we have the mechanics working.

132
00:00:00,000 --> 00:00:00,000
So now we're going to go into that second pattern for counter-controlled loops.

133
00:00:00,000 --> 00:00:00,000
So we're going to write "for something something do something."

134
00:00:00,000 --> 00:00:00,000
So in this first section, we're going to create the control variable, the lower bounds, and the upper bounds, what the highest part is.

135
00:00:00,000 --> 00:00:00,000
So we're going to say "for size p, i = 0, and len = str.size."

136
00:00:00,000 --> 00:00:00,000
So notice we're doing both of these. Separate them with a comma, not with a semicolon.

137
00:00:00,000 --> 00:00:00,000
Our upper bounds is going to be "i < len."

138
00:00:00,000 --> 00:00:00,000
And then we're going to go "++i."

139
00:00:00,000 --> 00:00:00,000
Now you might wonder why I can't say "str.size t, i = 0, i < str.size++i."

140
00:00:00,000 --> 00:00:00,000
You'll see many people do that, but the size is not going to change here.

141
00:00:00,000 --> 00:00:00,000
So we don't want to keep calling this function every time we come back to this condition.

142
00:00:00,000 --> 00:00:00,000
So this is a better way to do that. Save the size. Make sure you save it in a size t.

143
00:00:00,000 --> 00:00:00,000
So now we're at step four, or we're at the last part of the building a string idiom.

144
00:00:00,000 --> 00:00:00,000
And what we're going to do is we're going to say "result = str."

145
00:00:00,000 --> 00:00:00,000
And I can use a substring or I can use charAt.

146
00:00:00,000 --> 00:00:00,000
So I can use strAt, or at, not charAt. strAt i + result.

147
00:00:00,000 --> 00:00:00,000
So you notice each time, instead of putting the character after the one before it,

148
00:00:00,000 --> 00:00:00,000
by switching the order of these two things, I'm putting the character in front of it,

149
00:00:00,000 --> 00:00:00,000
and I'm reversing the string. I'm reversing the string.

150
00:00:00,000 --> 00:00:00,000
I'm going to show you a couple more ways to do this, but let's look to make sure that this works correctly.

151
00:00:00,000 --> 00:00:00,000
We'll do Ctrl+L to clear it, and do make test.

152
00:00:00,000 --> 00:00:00,000
And in fact that reverses all of the input strings correctly.

153
00:00:00,000 --> 00:00:00,000
Now many of you, I'm going to comment this one out, because that's a very simple way to do it.

154
00:00:00,000 --> 00:00:00,000
Many of you would solve this problem like this.

155
00:00:00,000 --> 00:00:00,000
You'd say for size p, i = strSize -1, i >= 0, - - i, result = result.

156
00:00:00,000 --> 00:00:00,000
Or let's do the shorthand, result += strAt i.

157
00:00:00,000 --> 00:00:00,000
Now this would make sense in Java, but it has a problem here.

158
00:00:00,000 --> 00:00:00,000
Here, when i is 0, it'll add the first element here, at the end of it.

159
00:00:00,000 --> 00:00:00,000
Then we do i - -. Well that doesn't go to -1.

160
00:00:00,000 --> 00:00:00,000
As a matter of fact, this condition cannot ever be false.

161
00:00:00,000 --> 00:00:00,000
And so if we come down here, and we try and just make it, notice we get an error there.

162
00:00:00,000 --> 00:00:00,000
We're doing a comparison of an unsigned expression, greater or equal to 0, by definition is always true.

163
00:00:00,000 --> 00:00:00,000
By definition is always true.

164
00:00:00,000 --> 00:00:00,000
And so that's an error. This piece of code is an error.

165
00:00:00,000 --> 00:00:00,000
Also, even if it did work, what if the input string was empty?

166
00:00:00,000 --> 00:00:00,000
Again, strSize -1 would not be, strSize would be 0.

167
00:00:00,000 --> 00:00:00,000
0 - 1 is not -1. It's all unsigned numbers.

168
00:00:00,000 --> 00:00:00,000
So when I subtract 1 from 0, I get the very, very large number 18 quintillion, or something like that.

169
00:00:00,000 --> 00:00:00,000
Very, very large number.

170
00:00:00,000 --> 00:00:00,000
So this simply won't even compile.

171
00:00:00,000 --> 00:00:00,000
We could fix it like this.

172
00:00:00,000 --> 00:00:00,000
So now it'll compile, but down here, we would need to remember to go i - 1.

173
00:00:00,000 --> 00:00:00,000
Because of course, strSize would crash when we ran it.

174
00:00:00,000 --> 00:00:00,000
When i was strSize, and we tried to get the str at strSize, that is out of bounds, and it would crash at that point.

175
00:00:00,000 --> 00:00:00,000
So this version will work as well.

176
00:00:00,000 --> 00:00:00,000
Let's go ahead and clear that.

177
00:00:00,000 --> 00:00:00,000
And do make test.

178
00:00:00,000 --> 00:00:00,000
But you can see if you want to do that, you have to always be aware that you cannot go less than 0.

179
00:00:00,000 --> 00:00:00,000
It literally is impossible for you to do that.

180
00:00:00,000 --> 00:00:00,000
So either two of those are perfectly fine.

181
00:00:00,000 --> 00:00:00,000
Okay, so now let's look at processing substrings.

182
00:00:00,000 --> 00:00:00,000
Here is a substring catapult.

183
00:00:00,000 --> 00:00:00,000
Notice that it has 7 characters, or 8 characters, indexes 0 through 7.

184
00:00:00,000 --> 00:00:00,000
Suppose we want to count the number of times the cat appears in the string.

185
00:00:00,000 --> 00:00:00,000
Well, I would need to look at 3 characters at a time, not a single character like the idiom we looked at before.

186
00:00:00,000 --> 00:00:00,000
So this algorithm and technique is worth mentioning.

187
00:00:00,000 --> 00:00:00,000
Worth memorizing.

188
00:00:00,000 --> 00:00:00,000
So here we have 3 variables.

189
00:00:00,000 --> 00:00:00,000
We have our counter control variable i,

190
00:00:00,000 --> 00:00:00,000
slen, which is going to be the length of our substring, cat in this case,

191
00:00:00,000 --> 00:00:00,000
and len, which is going to be the size of the string, in this case 7.

192
00:00:00,000 --> 00:00:00,000
We set i and slen, i, not to be 0, but to be the size of the substring.

193
00:00:00,000 --> 00:00:00,000
So i is pointing right here at 3.

194
00:00:00,000 --> 00:00:00,000
Then in our loop, rather than stopping at i less than len,

195
00:00:00,000 --> 00:00:00,000
so len of course is 8 in this case because there are 8 characters,

196
00:00:00,000 --> 00:00:00,000
we're going to go i plus len, so we have a little pointer here, or an index here,

197
00:00:00,000 --> 00:00:00,000
where we're going to stop, this second little arrow right here.

198
00:00:00,000 --> 00:00:00,000
Now we're going to extract the substring we're looking at

199
00:00:00,000 --> 00:00:00,000
by taking s.substring, i minus slen, slen.

200
00:00:00,000 --> 00:00:00,000
So again, this is something you can memorize.

201
00:00:00,000 --> 00:00:00,000
It will always work.

202
00:00:00,000 --> 00:00:00,000
And then you can do conditionals to examine the substring that you extracted.

203
00:00:00,000 --> 00:00:00,000
So we're going to do this with an exercise called count.

204
00:00:00,000 --> 00:00:00,000
And we're going to count the number, just like I'd count the number of cats here,

205
00:00:00,000 --> 00:00:00,000
we're going to count the number of times the code appears in a string.

206
00:00:00,000 --> 00:00:00,000
Now there's a couple little details here that make it a little bit more complex.

207
00:00:00,000 --> 00:00:00,000
So this is going to be b.

208
00:00:00,000 --> 00:00:00,000
I'm going to put my name on top of it.

209
00:00:00,000 --> 00:00:00,000
And I'm going to go ahead and open a terminal here

210
00:00:00,000 --> 00:00:00,000
on b so I can write code on it.

211
00:00:00,000 --> 00:00:00,000
So let's look at the instructions.

212
00:00:00,000 --> 00:00:00,000
We're going to write a function called count code.

213
00:00:00,000 --> 00:00:00,000
It will take a single string as an argument.

214
00:00:00,000 --> 00:00:00,000
It will not be modified.

215
00:00:00,000 --> 00:00:00,000
It will return the number of times that a pattern like code appears in the string.

216
00:00:00,000 --> 00:00:00,000
Any character at all is acceptable in place of the d.

217
00:00:00,000 --> 00:00:00,000
You can use size, substring, at, and back.

218
00:00:00,000 --> 00:00:00,000
You may not use find.

219
00:00:00,000 --> 00:00:00,000
So this is going to return a count, so it's not going to return a string.

220
00:00:00,000 --> 00:00:00,000
It's going to return an int.

221
00:00:00,000 --> 00:00:00,000
The function is named count code.

222
00:00:00,000 --> 00:00:00,000
The argument is a string that's not modified, so that's a const string reference str.

223
00:00:00,000 --> 00:00:00,000
The result in this case is an int rather than a string.

224
00:00:00,000 --> 00:00:00,000
And if you do that, you're going to have an error, because result is a primitive type.

225
00:00:00,000 --> 00:00:00,000
It's uninitialized, so we want to initialize that to zero.

226
00:00:00,000 --> 00:00:00,000
And finally we want to return the result.

227
00:00:00,000 --> 00:00:00,000
We'll go ahead and check to make sure that I have the syntax right

228
00:00:00,000 --> 00:00:00,000
by making it and testing it.

229
00:00:00,000 --> 00:00:00,000
So I'll make test.

230
00:00:00,000 --> 00:00:00,000
And I actually got 40%.

231
00:00:00,000 --> 00:00:00,000
I didn't really do any work on it, because I'm returning zero,

232
00:00:00,000 --> 00:00:00,000
and zero is correct for several of these answers.

233
00:00:00,000 --> 00:00:00,000
Code doesn't appear.

234
00:00:00,000 --> 00:00:00,000
But the important part here is that it compiles and it links,

235
00:00:00,000 --> 00:00:00,000
and I have that part correct.

236
00:00:00,000 --> 00:00:00,000
Okay, now our variables.

237
00:00:00,000 --> 00:00:00,000
So size T, SLEN equals four.

238
00:00:00,000 --> 00:00:00,000
We're looking for four.

239
00:00:00,000 --> 00:00:00,000
And our loop for size TI equals SLEN.

240
00:00:00,000 --> 00:00:00,000
And, of course, LEN.

241
00:00:00,000 --> 00:00:00,000
LEN equals std size.

242
00:00:00,000 --> 00:00:00,000
I less than or equal to SLEN.

243
00:00:00,000 --> 00:00:00,000
To LEN, not SLEN.

244
00:00:00,000 --> 00:00:00,000
Plus plus I.

245
00:00:00,000 --> 00:00:00,000
So that will allow us to go through and get four characters at a time,

246
00:00:00,000 --> 00:00:00,000
which we'll do with substring.

247
00:00:00,000 --> 00:00:00,000
So string subs equals str substring I minus SLEN.

248
00:00:00,000 --> 00:00:00,000
SLEN.

249
00:00:00,000 --> 00:00:00,000
So we're getting four characters at a time.

250
00:00:00,000 --> 00:00:00,000
Now we can see, now I know I'm guaranteed,

251
00:00:00,000 --> 00:00:00,000
because I've memorized this idiom right here,

252
00:00:00,000 --> 00:00:00,000
I'm guaranteed that I have four characters in subs,

253
00:00:00,000 --> 00:00:00,000
because I've made sure that this only allows me to get four characters at a time.

254
00:00:00,000 --> 00:00:00,000
And that means I can say if subs substring zero two is equal to CO,

255
00:00:00,000 --> 00:00:00,000
it starts with CO, and subs back equals E,

256
00:00:00,000 --> 00:00:00,000
then it's that code pattern I'm looking for.

257
00:00:00,000 --> 00:00:00,000
And I can increment result.

258
00:00:00,000 --> 00:00:00,000
So here's the pattern for processing substrings inside a string.

259
00:00:00,000 --> 00:00:00,000
So let's try that out again.

260
00:00:00,000 --> 00:00:00,000
Let's clear the thing and do a make test.

261
00:00:00,000 --> 00:00:00,000
Now let me show you another way to do it, just like I did previously.

262
00:00:00,000 --> 00:00:00,000
So this is the way I recommend, but,

263
00:00:00,000 --> 00:00:00,000
actually I'm going to leave SLEN there.

264
00:00:00,000 --> 00:00:00,000
I'm going to comment that out.

265
00:00:00,000 --> 00:00:00,000
We could do it like this.

266
00:00:00,000 --> 00:00:00,000
I'm not quite sure what just happened there.

267
00:00:00,000 --> 00:00:00,000
I must have, oh, no.

268
00:00:00,000 --> 00:00:00,000
Let me save it.

269
00:00:00,000 --> 00:00:00,000
I'm not quite sure why I'm getting a,

270
00:00:00,000 --> 00:00:00,000
I have no idea what this is.

271
00:00:00,000 --> 00:00:00,000
Hold on, I'm going to pause this for a while while I try and figure out what,

272
00:00:00,000 --> 00:00:00,000
okay, I'm back.

273
00:00:00,000 --> 00:00:00,000
I don't know why it was doing that.

274
00:00:00,000 --> 00:00:00,000
I just kind of ended up closing the little window that opened up and did it again.

275
00:00:00,000 --> 00:00:00,000
So let's try it this way.

276
00:00:00,000 --> 00:00:00,000
Let's try it forward.

277
00:00:00,000 --> 00:00:00,000
So for size p, i equals zero.

278
00:00:00,000 --> 00:00:00,000
LEN equals third size.

279
00:00:00,000 --> 00:00:00,000
I less than LEN plus plus I.

280
00:00:00,000 --> 00:00:00,000
String subs equals third subster,

281
00:00:00,000 --> 00:00:00,000
I SLEN.

282
00:00:00,000 --> 00:00:00,000
So starting at zero, getting four characters.

283
00:00:00,000 --> 00:00:00,000
And if subs size equals four,

284
00:00:00,000 --> 00:00:00,000
and subs substring zero two equals CO,

285
00:00:00,000 --> 00:00:00,000
and subs back equals E,

286
00:00:00,000 --> 00:00:00,000
then result plus plus.

287
00:00:00,000 --> 00:00:00,000
So this will work as well, but notice I had to add this extra case here,

288
00:00:00,000 --> 00:00:00,000
because it's possible that I wouldn't get four characters here

289
00:00:00,000 --> 00:00:00,000
when the I is gone past the length.

290
00:00:00,000 --> 00:00:00,000
Now, you might try and fix that.

291
00:00:00,000 --> 00:00:00,000
In fact, in Java you would fix it by simply saying size minus three.

292
00:00:00,000 --> 00:00:00,000
Why doesn't that work here?

293
00:00:00,000 --> 00:00:00,000
That doesn't work here because these are unsigned numbers.

294
00:00:00,000 --> 00:00:00,000
If the length is less than three,

295
00:00:00,000 --> 00:00:00,000
this will give you a huge number and your program will crash.

296
00:00:00,000 --> 00:00:00,000
Program will crash.

297
00:00:00,000 --> 00:00:00,000
So I'm going to leave that there.

298
00:00:00,000 --> 00:00:00,000
I'm going to comment out this part right here.

299
00:00:00,000 --> 00:00:00,000
And I want to show you the program crashing.

300
00:00:00,000 --> 00:00:00,000
Because you'll notice on our inputs here,

301
00:00:00,000 --> 00:00:00,000
we have two strings, one string that is less than zero.

302
00:00:00,000 --> 00:00:00,000
And so this is the effect we'll get if we do that,

303
00:00:00,000 --> 00:00:00,000
which would be the standard way you'd write it in Java.

304
00:00:00,000 --> 00:00:00,000
Make test.

305
00:00:00,000 --> 00:00:00,000
And notice this substring pos, which is one, this size, which is zero.

306
00:00:00,000 --> 00:00:00,000
So notice that this aborted, it core dumped,

307
00:00:00,000 --> 00:00:00,000
which means basically that it crashed at that point.

308
00:00:00,000 --> 00:00:00,000
So this thing that would work in Java simply won't work in C++.

309
00:00:00,000 --> 00:00:00,000
So we can put it like this.

310
00:00:00,000 --> 00:00:00,000
And let's make sure it will work again.

311
00:00:00,000 --> 00:00:00,000
Let's do make test.

312
00:00:00,000 --> 00:00:00,000
Okay, so that works perfectly fine.

313
00:00:00,000 --> 00:00:00,000
But I actually think this is a little more complex.

314
00:00:00,000 --> 00:00:00,000
It goes through more times than are necessary.

315
00:00:00,000 --> 00:00:00,000
And I think learning this one is a little bit better.

316
00:00:00,000 --> 00:00:00,000
This one is a little bit easier.

317
00:00:00,000 --> 00:00:00,000
So I'm going to comment out that one.

318
00:00:00,000 --> 00:00:00,000
Even though it works, I kind of don't like because it's a little complex.

319
00:00:00,000 --> 00:00:00,000
I'm going to uncomment this one.

320
00:00:00,000 --> 00:00:00,000
And you comment and uncomment with just control and the slash character.

321
00:00:00,000 --> 00:00:00,000
Control and the slash character.

322
00:00:00,000 --> 00:00:00,000
And let me just go a third time to make sure it works.

323
00:00:00,000 --> 00:00:00,000
Control L, control L.

324
00:00:00,000 --> 00:00:00,000
And yes, we get the right answer.

325
00:00:00,000 --> 00:00:00,000
Okay, so processing characters right here.

326
00:00:00,000 --> 00:00:00,000
And look at the two reverse example we did.

327
00:00:00,000 --> 00:00:00,000
And processing substrings, this one right here.

328
00:00:00,000 --> 00:00:00,000
Now there are a couple of other loops.

329
00:00:00,000 --> 00:00:00,000
Those are the only two exercises we're going to do.

330
00:00:00,000 --> 00:00:00,000
But I want to talk about a couple of other kinds of loops,

331
00:00:00,000 --> 00:00:00,000
which are indefinite loop.

332
00:00:00,000 --> 00:00:00,000
The simplest indefinite loop syntactically uses while.

333
00:00:00,000 --> 00:00:00,000
And basically it's while the condition is true,

334
00:00:00,000 --> 00:00:00,000
do these statements over and over and over again.

335
00:00:00,000 --> 00:00:00,000
So let me show you a while loop and tell me how many times it repeats.

336
00:00:00,000 --> 00:00:00,000
So I call a function randchar.

337
00:00:00,000 --> 00:00:00,000
It gives me back a random character and I store it in the variable C.

338
00:00:00,000 --> 00:00:00,000
Now while C is not equal to the Q character, I print out C.

339
00:00:00,000 --> 00:00:00,000
And then I set C again to the next random character.

340
00:00:00,000 --> 00:00:00,000
How many times will that loop repeat?

341
00:00:00,000 --> 00:00:00,000
Well, it might repeat once.

342
00:00:00,000 --> 00:00:00,000
It might repeat not at all.

343
00:00:00,000 --> 00:00:00,000
The first character I get might be a Q.

344
00:00:00,000 --> 00:00:00,000
Or it might never come up.

345
00:00:00,000 --> 00:00:00,000
The randchar function might in fact never return me a random Q in that case.

346
00:00:00,000 --> 00:00:00,000
So you can't tell by looking at the loop.

347
00:00:00,000 --> 00:00:00,000
And that's why we call it an indefinite loop, an indefinite loop.

348
00:00:00,000 --> 00:00:00,000
Now one kind of indefinite loop is a primed sentinel loop.

349
00:00:00,000 --> 00:00:00,000
A sentinel loop reads from input.

350
00:00:00,000 --> 00:00:00,000
And when it reads a special value from input, the sentinel, it stops.

351
00:00:00,000 --> 00:00:00,000
The primed loop is one technique for writing a sentinel loop.

352
00:00:00,000 --> 00:00:00,000
It was named after this old-fashioned water pump.

353
00:00:00,000 --> 00:00:00,000
And the old-fashioned water pump back in the old west

354
00:00:00,000 --> 00:00:00,000
was simply a pipe stuck in the ground with a piston inside

355
00:00:00,000 --> 00:00:00,000
that drew water from down underground by using suction.

356
00:00:00,000 --> 00:00:00,000
But to get suction, they had to have a good seal around the piston.

357
00:00:00,000 --> 00:00:00,000
And so to get a good seal, you would first pour a bucket of water into the pump.

358
00:00:00,000 --> 00:00:00,000
That would create a seal around the piston, and so you could start pumping.

359
00:00:00,000 --> 00:00:00,000
And that pouring the bucket of water in before you started pumping

360
00:00:00,000 --> 00:00:00,000
is called priming the loop.

361
00:00:00,000 --> 00:00:00,000
And so this loop is called a primed loop.

362
00:00:00,000 --> 00:00:00,000
And here's the algorithm for that.

363
00:00:00,000 --> 00:00:00,000
You read a value into a variable.

364
00:00:00,000 --> 00:00:00,000
If the variable is not the sentinel, you process the variable,

365
00:00:00,000 --> 00:00:00,000
then read the next value.

366
00:00:00,000 --> 00:00:00,000
So while the variable is not the sentinel, process the variable,

367
00:00:00,000 --> 00:00:00,000
read the next value.

368
00:00:00,000 --> 00:00:00,000
Now, we could do the same thing and not require two read statements.

369
00:00:00,000 --> 00:00:00,000
So look back here.

370
00:00:00,000 --> 00:00:00,000
Notice I have read a value into a variable before the loop,

371
00:00:00,000 --> 00:00:00,000
and at the end of the loop I have read the next value into the variable.

372
00:00:00,000 --> 00:00:00,000
What if we only want to have the read a value into a variable part once?

373
00:00:00,000 --> 00:00:00,000
For that, we can use a flag-controlled loop.

374
00:00:00,000 --> 00:00:00,000
So instead of two read statements, you can use a Boolean flag

375
00:00:00,000 --> 00:00:00,000
to signal if you've found the sentinel.

376
00:00:00,000 --> 00:00:00,000
So here you'd create a flag.

377
00:00:00,000 --> 00:00:00,000
I've called it finished here of type bool, and I've set it to false.

378
00:00:00,000 --> 00:00:00,000
I'm not finished.

379
00:00:00,000 --> 00:00:00,000
Then my loop control is while I'm not finished.

380
00:00:00,000 --> 00:00:00,000
Now I read the value into the variable.

381
00:00:00,000 --> 00:00:00,000
Notice I'm only reading once.

382
00:00:00,000 --> 00:00:00,000
If the value is the sentinel, set finish to true.

383
00:00:00,000 --> 00:00:00,000
Otherwise, or else, process the variable.

384
00:00:00,000 --> 00:00:00,000
So this is the code for a flag-controlled sentinel loop.

385
00:00:00,000 --> 00:00:00,000
Finally, we can use what's called a loop-and-a-half idiom.

386
00:00:00,000 --> 00:00:00,000
Now, normally a loop has only one exit at the loop condition,

387
00:00:00,000 --> 00:00:00,000
at the while or the for.

388
00:00:00,000 --> 00:00:00,000
Some languages, however, allow you to exit from inside a loop.

389
00:00:00,000 --> 00:00:00,000
Ada, the language Ada, does this with its exit-when construct.

390
00:00:00,000 --> 00:00:00,000
Now in C++, you can do the same thing Ada does

391
00:00:00,000 --> 00:00:00,000
by using an if and a break.

392
00:00:00,000 --> 00:00:00,000
And so this is a loop-and-a-half.

393
00:00:00,000 --> 00:00:00,000
While there is more data to process,

394
00:00:00,000 --> 00:00:00,000
read the value.

395
00:00:00,000 --> 00:00:00,000
If the value is the sentinel, then exit or break.

396
00:00:00,000 --> 00:00:00,000
Process the variable.

397
00:00:00,000 --> 00:00:00,000
This is called the loop-and-a-half idiom, as I just mentioned.

398
00:00:00,000 --> 00:00:00,000
Now, many programmers don't like this.

399
00:00:00,000 --> 00:00:00,000
I actually am relatively fond of it.

400
00:00:00,000 --> 00:00:00,000
I think it's easy to understand.

401
00:00:00,000 --> 00:00:00,000
And there is a paper that you might want to look at.

402
00:00:00,000 --> 00:00:00,000
On the slides you can find the link to it.

403
00:00:00,000 --> 00:00:00,000
It's "Loop Exits in Structured Programming."

404
00:00:00,000 --> 00:00:00,000
Now, it's an old paper. It's from 1999.

405
00:00:00,000 --> 00:00:00,000
It's talking about the Pascal language, so it's not exactly up to date.

406
00:00:00,000 --> 00:00:00,000
But it, in fact, provides good reasons

407
00:00:00,000 --> 00:00:00,000
why this is actually a pretty good loop-control strategy.

408
00:00:00,000 --> 00:00:00,000
Why it's actually better than some of the other ones.

409
00:00:00,000 --> 00:00:00,000
Well, that's it for this lecture.

410
00:00:00,000 --> 00:00:00,000
We're going to follow up on these loop-and-a-half idioms

411
00:00:00,000 --> 00:00:00,000
and learn about exits in our next lecture

412
00:00:00,000 --> 00:00:00,000
when we're going to do more on loops.

413
00:00:00,000 --> 00:00:00,000
[no audio]

