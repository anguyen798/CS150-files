1
00:00:00,000 --> 00:00:00,000
Hello everyone, this is Steve Gilbert. Welcome to lecture 21. We're going to continue talking about arrays. In this lecture, partially filled arrays and two-dimensional arrays.

2
00:00:00,000 --> 00:00:00,000
So let's start right in with partially filled arrays. So often you'll use only a portion of an array.

3
00:00:00,000 --> 00:00:00,000
So here I have an array. You can see it has 10 elements, but I'm really only using the first four elements.

4
00:00:00,000 --> 00:00:00,000
And since the array size can't change, when you're working with arrays, you need to plan for the worst case.

5
00:00:00,000 --> 00:00:00,000
You need to make the allocated array large enough to hold the maximum data that your problem will use.

6
00:00:00,000 --> 00:00:00,000
Then you create a couple of extra variables. Capacity over here is going to represent the worst case, your allocated size.

7
00:00:00,000 --> 00:00:00,000
And size is going to be the effective size of the array.

8
00:00:00,000 --> 00:00:00,000
Now under the hood, this is how the vector class actually works. It kind of does this magic for you.

9
00:00:00,000 --> 00:00:00,000
But now that we're working with arrays, which are built into the language, we're going to see how that works.

10
00:00:00,000 --> 00:00:00,000
So go ahead and open up the first exercise here. So go ahead and go to week 6.

11
00:00:00,000 --> 00:00:00,000
Go to partially filled arrays. Click the lecture exercise. On the lecture exercise, click the link for the starter form.

12
00:00:00,000 --> 00:00:00,000
Let me click it here. Make a copy.

13
00:00:00,000 --> 00:00:00,000
And this will be the set of instructions we're going to use.

14
00:00:00,000 --> 00:00:00,000
So we're going to write three template functions which should work for any numeric type.

15
00:00:00,000 --> 00:00:00,000
ToString, the parameter is going to be the array and the number of elements.

16
00:00:00,000 --> 00:00:00,000
We're going to return a string with each element separated by a space.

17
00:00:00,000 --> 00:00:00,000
No commas this time. And the element surrounded by brackets.

18
00:00:00,000 --> 00:00:00,000
ReadArray, this is going to read from cin and it's going to read into an array and return the size as a size t.

19
00:00:00,000 --> 00:00:00,000
We'll end with a non-numeric sentinel, so people can type in a q.

20
00:00:00,000 --> 00:00:00,000
Or filling the entire array will end the input. Either one of those.

21
00:00:00,000 --> 00:00:00,000
And finally indexOf. For indexOf we're going to return the index or the position of the first occurrence of the value that we want to find.

22
00:00:00,000 --> 00:00:00,000
You find the prototypes of partial.h and we're going to test with makeTest.

23
00:00:00,000 --> 00:00:00,000
So let's go over here. Let's open up IC21A.

24
00:00:00,000 --> 00:00:00,000
And partial.h is going to have our prototypes. Notice it's created a static constant not found.

25
00:00:00,000 --> 00:00:00,000
And these are our template functions.

26
00:00:00,000 --> 00:00:00,000
Notice here in the header file I've written the templates.

27
00:00:00,000 --> 00:00:00,000
What we're going to do is we're just going to copy those templates.

28
00:00:00,000 --> 00:00:00,000
Those prototypes.

29
00:00:00,000 --> 00:00:00,000
And we're going to go into partial.cpp.

30
00:00:00,000 --> 00:00:00,000
And we're going to implement them right there.

31
00:00:00,000 --> 00:00:00,000
Now remember when you implement a template function you need to include the template class T or type name T as well.

32
00:00:00,000 --> 00:00:00,000
Put our name on the top of it.

33
00:00:00,000 --> 00:00:00,000
So let's look at the steps we need to do these exercises.

34
00:00:00,000 --> 00:00:00,000
First we're going to look at filling or reading from input.

35
00:00:00,000 --> 00:00:00,000
Now I want to read a new value from input.

36
00:00:00,000 --> 00:00:00,000
And I want to put it right here in position 4.

37
00:00:00,000 --> 00:00:00,000
Notice size is already set to 4.

38
00:00:00,000 --> 00:00:00,000
So the equivalent of pushback for a partially filled array, pushback in vector of course,

39
00:00:00,000 --> 00:00:00,000
simply puts the value into A at size.

40
00:00:00,000 --> 00:00:00,000
So we'll put the value inside here and we'll increment size.

41
00:00:00,000 --> 00:00:00,000
Of course that only works if size is less than capacity.

42
00:00:00,000 --> 00:00:00,000
So let's look at that exercise here.

43
00:00:00,000 --> 00:00:00,000
That part.

44
00:00:00,000 --> 00:00:00,000
So that's going to be the read array.

45
00:00:00,000 --> 00:00:00,000
Reads from C and stores values at the end of the array.

46
00:00:00,000 --> 00:00:00,000
Our parameter A is the array.

47
00:00:00,000 --> 00:00:00,000
It's an input/output parameter.

48
00:00:00,000 --> 00:00:00,000
And capacity is going to be the number of elements.

49
00:00:00,000 --> 00:00:00,000
It's going to return the current size.

50
00:00:00,000 --> 00:00:00,000
So this is assuming, notice we didn't pass in the current size,

51
00:00:00,000 --> 00:00:00,000
so it's assuming that size is going to start out at 0.

52
00:00:00,000 --> 00:00:00,000
So size T size equals 0.

53
00:00:00,000 --> 00:00:00,000
And we're going to then return that size.

54
00:00:00,000 --> 00:00:00,000
Okay, so now we need to read values into elements.

55
00:00:00,000 --> 00:00:00,000
What type are the elements?

56
00:00:00,000 --> 00:00:00,000
The elements are of type T.

57
00:00:00,000 --> 00:00:00,000
So we're going to need to make a T in.

58
00:00:00,000 --> 00:00:00,000
This is the value we're going to read.

59
00:00:00,000 --> 00:00:00,000
And it can be integer, it can be double, it can be any numeric type.

60
00:00:00,000 --> 00:00:00,000
And so we're going to keep reading while size is less than capacity.

61
00:00:00,000 --> 00:00:00,000
And we can successfully read a value.

62
00:00:00,000 --> 00:00:00,000
If there's a non-numeric terminator in there, like a Q, this will stop.

63
00:00:00,000 --> 00:00:00,000
So we'll say CNN.

64
00:00:00,000 --> 00:00:00,000
Okay, so there's our loop to read an array.

65
00:00:00,000 --> 00:00:00,000
And so we'll say A at size equals N, and size plus plus.

66
00:00:00,000 --> 00:00:00,000
And of course we've returned size here.

67
00:00:00,000 --> 00:00:00,000
We've returned size.

68
00:00:00,000 --> 00:00:00,000
Now let's go ahead and stub these other two out so we can --

69
00:00:00,000 --> 00:00:00,000
So I'm just going to return not found for this first one.

70
00:00:00,000 --> 00:00:00,000
So it's going to return not found or the index of it.

71
00:00:00,000 --> 00:00:00,000
And for this one, two string.

72
00:00:00,000 --> 00:00:00,000
I'm going to return not done.

73
00:00:00,000 --> 00:00:00,000
Okay, so let's open a terminal on that.

74
00:00:00,000 --> 00:00:00,000
And let's go ahead and do make to make sure it compiles.

75
00:00:00,000 --> 00:00:00,000
Okay, no syntax errors. Let's do make test.

76
00:00:00,000 --> 00:00:00,000
Okay, it says we've got 20%, so read array actually seems to work.

77
00:00:00,000 --> 00:00:00,000
Two string, we haven't done anything on yet.

78
00:00:00,000 --> 00:00:00,000
Read array int.

79
00:00:00,000 --> 00:00:00,000
When I called two string on it, of course that's not done.

80
00:00:00,000 --> 00:00:00,000
And here's read array int.

81
00:00:00,000 --> 00:00:00,000
And since we're using index -- oh no, this is index.

82
00:00:00,000 --> 00:00:00,000
Read array int right here.

83
00:00:00,000 --> 00:00:00,000
And read array double both seem to work right now.

84
00:00:00,000 --> 00:00:00,000
So both of those seem to work.

85
00:00:00,000 --> 00:00:00,000
Alright, let's put that away and let's go to our next one we want to write here.

86
00:00:00,000 --> 00:00:00,000
Which is printing or two string.

87
00:00:00,000 --> 00:00:00,000
Now we can't use operator, the output operator, because the array doesn't know its size.

88
00:00:00,000 --> 00:00:00,000
So we need to write a two string that we could use in place of that.

89
00:00:00,000 --> 00:00:00,000
So we want to write two string, but we only want to print the valid elements.

90
00:00:00,000 --> 00:00:00,000
Again, this is review, we're going to do the fence post algorithm.

91
00:00:00,000 --> 00:00:00,000
We want the elements values separated by a single space.

92
00:00:00,000 --> 00:00:00,000
So we're going to print the delimiter.

93
00:00:00,000 --> 00:00:00,000
If there are any elements, print the first one.

94
00:00:00,000 --> 00:00:00,000
Use a loop to print the remaining elements.

95
00:00:00,000 --> 00:00:00,000
Proceed each by the separator. After the if, print the closing, the limiter.

96
00:00:00,000 --> 00:00:00,000
Now there are a couple ways to do this. I don't remember which one I did for my test.

97
00:00:00,000 --> 00:00:00,000
Let's see if we got s-stream. We don't have s-stream up here.

98
00:00:00,000 --> 00:00:00,000
So let's see if we can do it with two string.

99
00:00:00,000 --> 00:00:00,000
If not, we'll need to include s-stream.

100
00:00:00,000 --> 00:00:00,000
So what we'll do is return

101
00:00:00,000 --> 00:00:00,000
so string result

102
00:00:00,000 --> 00:00:00,000
and we'll return result.

103
00:00:00,000 --> 00:00:00,000
And let's say result

104
00:00:00,000 --> 00:00:00,000
equals the opening

105
00:00:00,000 --> 00:00:00,000
bracket.

106
00:00:00,000 --> 00:00:00,000
If size is greater than zero,

107
00:00:00,000 --> 00:00:00,000
result plus equals two string

108
00:00:00,000 --> 00:00:00,000
from the string class

109
00:00:00,000 --> 00:00:00,000
a sub zero.

110
00:00:00,000 --> 00:00:00,000
And then for size t, i equals one,

111
00:00:00,000 --> 00:00:00,000
i less than size.

112
00:00:00,000 --> 00:00:00,000
And let's change this to

113
00:00:00,000 --> 00:00:00,000
size t size.

114
00:00:00,000 --> 00:00:00,000
Notice the parameter says it's supposed to be named size and my thing had it set to n right there, which is a mistake.

115
00:00:00,000 --> 00:00:00,000
i less than size plus plus i.

116
00:00:00,000 --> 00:00:00,000
Result plus equals

117
00:00:00,000 --> 00:00:00,000
a space plus two string

118
00:00:00,000 --> 00:00:00,000
a sub i.

119
00:00:00,000 --> 00:00:00,000
And

120
00:00:00,000 --> 00:00:00,000
then after the if

121
00:00:00,000 --> 00:00:00,000
plus equals closing thing

122
00:00:00,000 --> 00:00:00,000
and we'll return the result.

123
00:00:00,000 --> 00:00:00,000
Now this may or may not work. I think it'll work with the integers.

124
00:00:00,000 --> 00:00:00,000
I'm not sure it'll work with the doubles.

125
00:00:00,000 --> 00:00:00,000
In fact, it does work perfectly fine with the doubles.

126
00:00:00,000 --> 00:00:00,000
But I don't think it'll give us exactly this output. I think it'll give us output that

127
00:00:00,000 --> 00:00:00,000
has slightly more decimal places. But let's try it and see.

128
00:00:00,000 --> 00:00:00,000
So we can make tests.

129
00:00:00,000 --> 00:00:00,000
Okay, and I missed a semicolon there.

130
00:00:00,000 --> 00:00:00,000
Right there on line 20.

131
00:00:00,000 --> 00:00:00,000
You know, remember when you're looking at these errors, it'll tell you what the line is in the file right there.

132
00:00:00,000 --> 00:00:00,000
Partial cpp line 20.

133
00:00:00,000 --> 00:00:00,000
Make tests.

134
00:00:00,000 --> 00:00:00,000
Okay, so two string for integers works perfectly fine.

135
00:00:00,000 --> 00:00:00,000
Two string for doubles is giving me actually slightly more than I wanted.

136
00:00:00,000 --> 00:00:00,000
So actually the two string for double is perfectly fine, but so that it matches our test, let's do it the way we looked at before.

137
00:00:00,000 --> 00:00:00,000
And so let's include sstream in this.

138
00:00:00,000 --> 00:00:00,000
And let's comment out all this.

139
00:00:00,000 --> 00:00:00,000
So that's the method using two string to do it.

140
00:00:00,000 --> 00:00:00,000
Two string built into the string class.

141
00:00:00,000 --> 00:00:00,000
So we'll use ostring, stream out.

142
00:00:00,000 --> 00:00:00,000
Out.

143
00:00:00,000 --> 00:00:00,000
If size greater than zero.

144
00:00:00,000 --> 00:00:00,000
Out a sub zero.

145
00:00:00,000 --> 00:00:00,000
For size t, i equals one, i less than size, plus plus i.

146
00:00:00,000 --> 00:00:00,000
Out space a sub i.

147
00:00:00,000 --> 00:00:00,000
Out.

148
00:00:00,000 --> 00:00:00,000
And return out string.

149
00:00:00,000 --> 00:00:00,000
Okay, so this will fix the problem we have right here when it expects 130139, but it founds 130386.

150
00:00:00,000 --> 00:00:00,000
It finds one more decimal place when I do two string there.

151
00:00:00,000 --> 00:00:00,000
And so let's go ahead and try it once again.

152
00:00:00,000 --> 00:00:00,000
And two string for doubles works the way the test is expecting it.

153
00:00:00,000 --> 00:00:00,000
Now there's nothing wrong with doing it the other way.

154
00:00:00,000 --> 00:00:00,000
Just my test program is expecting the output in a particular way using the ostring stream.

155
00:00:00,000 --> 00:00:00,000
Okay, the last thing we're going to look at is the index of, oh no.

156
00:00:00,000 --> 00:00:00,000
I don't have a slide on index of.

157
00:00:00,000 --> 00:00:00,000
So let's just go ahead and look at the instructions for index of.

158
00:00:00,000 --> 00:00:00,000
Index of is a linear search.

159
00:00:00,000 --> 00:00:00,000
We're going to look through from the beginning of the array.

160
00:00:00,000 --> 00:00:00,000
Notice the array is not changed.

161
00:00:00,000 --> 00:00:00,000
And we're going to look through this value.

162
00:00:00,000 --> 00:00:00,000
That should be, again, for my documentation, it calls it value.

163
00:00:00,000 --> 00:00:00,000
I've called it val there.

164
00:00:00,000 --> 00:00:00,000
That's a mistake.

165
00:00:00,000 --> 00:00:00,000
And we're going to say for size p, i equals zero, i less than size, plus plus i.

166
00:00:00,000 --> 00:00:00,000
If a at i equals val, q, we're going to return i.

167
00:00:00,000 --> 00:00:00,000
And if it's not equal to value, we're going to return not found.

168
00:00:00,000 --> 00:00:00,000
Okay, let's try that.

169
00:00:00,000 --> 00:00:00,000
That's our last check.

170
00:00:00,000 --> 00:00:00,000
Let's do make test.

171
00:00:00,000 --> 00:00:00,000
And that passes 100%.

172
00:00:00,000 --> 00:00:00,000
Okay, for our second group down here, we want to look at erasing elements.

173
00:00:00,000 --> 00:00:00,000
We're going to write an erase template function which searches for an element in the partially filled array

174
00:00:00,000 --> 00:00:00,000
and removes it if found, keeping the array in order.

175
00:00:00,000 --> 00:00:00,000
We're going to use make test to test your code.

176
00:00:00,000 --> 00:00:00,000
The parameters are the array, the number of elements,

177
00:00:00,000 --> 00:00:00,000
that's an output parameter.

178
00:00:00,000 --> 00:00:00,000
Actually, it's an input and output parameter because it has a value going in

179
00:00:00,000 --> 00:00:00,000
and it will have a different value going out, the value to remove.

180
00:00:00,000 --> 00:00:00,000
We'll retrieve true if a value was removed, false if not.

181
00:00:00,000 --> 00:00:00,000
Notice you'll find several examples inside run.

182
00:00:00,000 --> 00:00:00,000
So how do we erase an element?

183
00:00:00,000 --> 00:00:00,000
Now, unlike vector, there is no erase function.

184
00:00:00,000 --> 00:00:00,000
So if I want to delete this element, the 0, 1, 2, 3, 4, if I want to delete element 4,

185
00:00:00,000 --> 00:00:00,000
what I have to do is move element 5 into its position,

186
00:00:00,000 --> 00:00:00,000
move element 6 into the position where 5 was,

187
00:00:00,000 --> 00:00:00,000
move element 7 into the position where 6 was,

188
00:00:00,000 --> 00:00:00,000
and then delete the size.

189
00:00:00,000 --> 00:00:00,000
So find the element that matches the value, decrement the size,

190
00:00:00,000 --> 00:00:00,000
shift the elements left, and then update the index.

191
00:00:00,000 --> 00:00:00,000
Finally, we're going to return, in this case, not the elements removed,

192
00:00:00,000 --> 00:00:00,000
but we're going to return true or false.

193
00:00:00,000 --> 00:00:00,000
So if we couldn't find it, we'll return false.

194
00:00:00,000 --> 00:00:00,000
So let's go over there and let's close those two terminals, let's close partial,

195
00:00:00,000 --> 00:00:00,000
let's open up B,

196
00:00:00,000 --> 00:00:00,000
let's get partial.cpp and grab our prototype,

197
00:00:00,000 --> 00:00:00,000
and put our name on here,

198
00:00:00,000 --> 00:00:00,000
and define our function template right there,

199
00:00:00,000 --> 00:00:00,000
and return false, and we'll stub that out.

200
00:00:00,000 --> 00:00:00,000
So let's open a shell.

201
00:00:00,000 --> 00:00:00,000
Let's do make test.

202
00:00:00,000 --> 00:00:00,000
Okay, and our code compiles and runs. Doesn't exactly work.

203
00:00:00,000 --> 00:00:00,000
Okay, so I'm going to start with this array, I'm going to try and erase 5, that should be true,

204
00:00:00,000 --> 00:00:00,000
and then I should have 2, 8, 11, since I'm not erasing anything yet, I have that.

205
00:00:00,000 --> 00:00:00,000
So now we'll look at how to erase it.

206
00:00:00,000 --> 00:00:00,000
So let's close our terminal here, and let's look at that algorithm.

207
00:00:00,000 --> 00:00:00,000
So A is an input out parameter, this is an input out parameter, size.

208
00:00:00,000 --> 00:00:00,000
And val, I call that value here, so I'm having a problem keeping my documentation and my name actually in sync here.

209
00:00:00,000 --> 00:00:00,000
Okay, so let's find the element val.

210
00:00:00,000 --> 00:00:00,000
So for size p, i equals 0, i less than size, plus plus i,

211
00:00:00,000 --> 00:00:00,000
if a sub i equals val, let's call it value in both cases.

212
00:00:00,000 --> 00:00:00,000
Make it the same in this one and the previous one.

213
00:00:00,000 --> 00:00:00,000
If a sub i equals the value, then I've found the one that I want to delete,

214
00:00:00,000 --> 00:00:00,000
and so I'm going to return true, I found it, and I'm going to delete it.

215
00:00:00,000 --> 00:00:00,000
So the steps, I found the element number 1, I'm going to decrement the size, so size minus minus,

216
00:00:00,000 --> 00:00:00,000
and I'm going to shift all the elements left.

217
00:00:00,000 --> 00:00:00,000
So for size p, j equals i, j less than size, j plus plus, a sub j equals a sub j plus 1.

218
00:00:00,000 --> 00:00:00,000
So the current element, where val was, I'm going to replace with the one that was right after it.

219
00:00:00,000 --> 00:00:00,000
And then I'm going to do the next thing until I get to the size.

220
00:00:00,000 --> 00:00:00,000
Of course we deleted one, so we're going to return true.

221
00:00:00,000 --> 00:00:00,000
So let's try that and see if it works.

222
00:00:00,000 --> 00:00:00,000
We'll do make test.

223
00:00:00,000 --> 00:00:00,000
And so I deleted 5 from a, and so a now has 2, 8, 11, 14.

224
00:00:00,000 --> 00:00:00,000
I delete 14, the element in the last position, it has 2, 8, 11.

225
00:00:00,000 --> 00:00:00,000
I try and delete 1, it returns false because 1 isn't found.

226
00:00:00,000 --> 00:00:00,000
I try and delete 2, the element in the beginning, and 2 is erased from a,

227
00:00:00,000 --> 00:00:00,000
and so a has 8 and 11 afterwards.

228
00:00:00,000 --> 00:00:00,000
We do the same thing with a double because it's a template function,

229
00:00:00,000 --> 00:00:00,000
and it works perfectly fine for both types of values.

230
00:00:00,000 --> 00:00:00,000
Alright, so that's erasing.

231
00:00:00,000 --> 00:00:00,000
How about inserting elements into an array?

232
00:00:00,000 --> 00:00:00,000
With inserting elements into an array, you do a shift, just like with deletions,

233
00:00:00,000 --> 00:00:00,000
but the shift has to happen not starting at the place where you want to insert,

234
00:00:00,000 --> 00:00:00,000
but it has to start at the end.

235
00:00:00,000 --> 00:00:00,000
You have to shift the last element into the first unused element,

236
00:00:00,000 --> 00:00:00,000
the next to the last element into the next unused element,

237
00:00:00,000 --> 00:00:00,000
the element in front of that, and now we have two copies of this element,

238
00:00:00,000 --> 00:00:00,000
and we can overwrite that element with the value.

239
00:00:00,000 --> 00:00:00,000
So I want to insert 3.25 into this array that has 4 elements.

240
00:00:00,000 --> 00:00:00,000
So to insert it, I first have to check to make sure size is greater or equal to capacity.

241
00:00:00,000 --> 00:00:00,000
Now in this exercise, the one we're going to do here,

242
00:00:00,000 --> 00:00:00,000
we're not going to return true or false.

243
00:00:00,000 --> 00:00:00,000
We're going to return a pointer.

244
00:00:00,000 --> 00:00:00,000
So, again, we could return the value.

245
00:00:00,000 --> 00:00:00,000
We could return an index.

246
00:00:00,000 --> 00:00:00,000
We could return true or false.

247
00:00:00,000 --> 00:00:00,000
We could return a count.

248
00:00:00,000 --> 00:00:00,000
All of those would be possible and we'd have to keep track of them.

249
00:00:00,000 --> 00:00:00,000
In this case, we're going to return the address of the element that was inserted,

250
00:00:00,000 --> 00:00:00,000
very similar to what an iterator actually does,

251
00:00:00,000 --> 00:00:00,000
and I want to insert 3.25.

252
00:00:00,000 --> 00:00:00,000
So what I start by doing is creating a variable

253
00:00:00,000 --> 00:00:00,000
and set it to the first element that is larger than value.

254
00:00:00,000 --> 00:00:00,000
So I loop through, I say, "Is .3 larger than 3.25?"

255
00:00:00,000 --> 00:00:00,000
No.

256
00:00:00,000 --> 00:00:00,000
"Is 2.3 larger than 3.25?"

257
00:00:00,000 --> 00:00:00,000
No.

258
00:00:00,000 --> 00:00:00,000
"Is 7.1 larger than 3.25?"

259
00:00:00,000 --> 00:00:00,000
Oh, yes it is.

260
00:00:00,000 --> 00:00:00,000
So this is my position.

261
00:00:00,000 --> 00:00:00,000
My position is going to be position 2.

262
00:00:00,000 --> 00:00:00,000
Then I'm going to copy elements from size, which is 4, down to pos.

263
00:00:00,000 --> 00:00:00,000
I'm going to move the 9.5 into the 4, the 7.1 into the 9.5.

264
00:00:00,000 --> 00:00:00,000
Now I'm at pos, I'm at 2.

265
00:00:00,000 --> 00:00:00,000
I'm going to add the element, the 3.5, where the 7.1 is now,

266
00:00:00,000 --> 00:00:00,000
and I'm going to increment the size so it goes from 4 to 5.

267
00:00:00,000 --> 00:00:00,000
In this case, we're going to return the address of the added element.

268
00:00:00,000 --> 00:00:00,000
OK, so let's go ahead and close this terminal, close this version of partial,

269
00:00:00,000 --> 00:00:00,000
open up the one from C.

270
00:00:00,000 --> 00:00:00,000
So I'll just copy from partial.h,

271
00:00:00,000 --> 00:00:00,000
I'll open up partial.cpp and paste it in there,

272
00:00:00,000 --> 00:00:00,000
and I'll put my name on the top of this.

273
00:00:00,000 --> 00:00:00,000
OK, so this is going to insert an int value into the array A,

274
00:00:00,000 --> 00:00:00,000
keeping the elements in order.

275
00:00:00,000 --> 00:00:00,000
So I am going to check first to make sure that the size is less than capacity.

276
00:00:00,000 --> 00:00:00,000
So if size is greater or equal to capacity,

277
00:00:00,000 --> 00:00:00,000
I have no room to add the item, so I'm going to return null pointer.

278
00:00:00,000 --> 00:00:00,000
Now I know I have room to add an item, so I'm simply going to find out where it is added.

279
00:00:00,000 --> 00:00:00,000
So I'm going to say size p pos equals 0,

280
00:00:00,000 --> 00:00:00,000
while pos is less than size,

281
00:00:00,000 --> 00:00:00,000
and A sub pos is less than value.

282
00:00:00,000 --> 00:00:00,000
And then I'm going to say pos plus plus.

283
00:00:00,000 --> 00:00:00,000
OK, so pos will be pointing to the element that is greater or equal to value.

284
00:00:00,000 --> 00:00:00,000
And so this means we're going to insert in front of any equal items.

285
00:00:00,000 --> 00:00:00,000
Equal items will be pushed to the right.

286
00:00:00,000 --> 00:00:00,000
OK, so now pos is the value.

287
00:00:00,000 --> 00:00:00,000
I need to do for size p i equals size i greater than pos minus minus pos.

288
00:00:00,000 --> 00:00:00,000
And I need to say A sub i equals A sub i minus 1.

289
00:00:00,000 --> 00:00:00,000
The one in front of it gets copied there.

290
00:00:00,000 --> 00:00:00,000
Now I need to add the element at pos.

291
00:00:00,000 --> 00:00:00,000
I need to say A sub pos equals our value.

292
00:00:00,000 --> 00:00:00,000
We've inserted it.

293
00:00:00,000 --> 00:00:00,000
I need to increment the size, size plus plus, because we've added a new element in it.

294
00:00:00,000 --> 00:00:00,000
And I need to return the address of the added element.

295
00:00:00,000 --> 00:00:00,000
So I need to return the address of A at pos.

296
00:00:00,000 --> 00:00:00,000
Now we can also write this as A plus pos.

297
00:00:00,000 --> 00:00:00,000
That would be the same.

298
00:00:00,000 --> 00:00:00,000
We could use address arithmetic instead of the address operator to do that.

299
00:00:00,000 --> 00:00:00,000
OK, let's open a shell on this.

300
00:00:00,000 --> 00:00:00,000
Right click, open an integrated terminal.

301
00:00:00,000 --> 00:00:00,000
Let's close that.

302
00:00:00,000 --> 00:00:00,000
Let's do make test.

303
00:00:00,000 --> 00:00:00,000
OK, I got an unexpected qualifier on line 21 in partial.cpp.

304
00:00:00,000 --> 00:00:00,000
Line 21, and that's because I meant to delete that,

305
00:00:00,000 --> 00:00:00,000
and I accidentally hit the key below the backspace key and added in a backslash.

306
00:00:00,000 --> 00:00:00,000
OK, make test.

307
00:00:00,000 --> 00:00:00,000
OK.

308
00:00:00,000 --> 00:00:00,000
OK, obviously my code doesn't work, so I have made a mistake.

309
00:00:00,000 --> 00:00:00,000
I have an empty array, capacity 5.

310
00:00:00,000 --> 00:00:00,000
I insert 4 into it, that's fine.

311
00:00:00,000 --> 00:00:00,000
Then I insert 1. I expect 1, 4, but I found 4, 4.

312
00:00:00,000 --> 00:00:00,000
Then I found 4, 4, 4.

313
00:00:00,000 --> 00:00:00,000
Insert 5.

314
00:00:00,000 --> 00:00:00,000
So let's look at our code here.

315
00:00:00,000 --> 00:00:00,000
Either the pos, I'm figuring out, well pos is less than size,

316
00:00:00,000 --> 00:00:00,000
and a at pos is less than value pos.

317
00:00:00,000 --> 00:00:00,000
OK, so we need to look at this second one and trace through it together.

318
00:00:00,000 --> 00:00:00,000
And this is a good thing to do to debug your code.

319
00:00:00,000 --> 00:00:00,000
So we want this one when the array is, has the value 4 in it.

320
00:00:00,000 --> 00:00:00,000
So size is, so this is false.

321
00:00:00,000 --> 00:00:00,000
Size t pos is 0, size t pos is going to be looking at that.

322
00:00:00,000 --> 00:00:00,000
We're trying to insert 1.

323
00:00:00,000 --> 00:00:00,000
So a sub 0

324
00:00:00,000 --> 00:00:00,000
is a sub 0 before

325
00:00:00,000 --> 00:00:00,000
it's not less than value, 4 less than 1 would be false, would drop out.

326
00:00:00,000 --> 00:00:00,000
So pos should be 0.

327
00:00:00,000 --> 00:00:00,000
For i equals size 1, i greater than pos,

328
00:00:00,000 --> 00:00:00,000
minus minus pos, so i is greater than pos, i is 1, pos is 0.

329
00:00:00,000 --> 00:00:00,000
So a sub 1 equals pos, so we put the 4 in that.

330
00:00:00,000 --> 00:00:00,000
That works fine.

331
00:00:00,000 --> 00:00:00,000
Then a sub 0 equals 1,

332
00:00:00,000 --> 00:00:00,000
so this plus plus return a.

333
00:00:00,000 --> 00:00:00,000
OK, I'm going to, I'm going to pos this while I figure this out kind of on my own.

334
00:00:00,000 --> 00:00:00,000
Because it looks like that code is correct and it's obviously not working.

335
00:00:00,000 --> 00:00:00,000
Alright folks, I'm back. It took me a long time to figure out what I had done wrong.

336
00:00:00,000 --> 00:00:00,000
You notice in this loop I'm setting i to size, i greater than pos.

337
00:00:00,000 --> 00:00:00,000
Then I'm decrementing pos, that would be like decrementing length, I should be decrementing i.

338
00:00:00,000 --> 00:00:00,000
And so now I believe our insertion will work correctly.

339
00:00:00,000 --> 00:00:00,000
Yes, so now we correctly insert, inserts it in the correct place.

340
00:00:00,000 --> 00:00:00,000
So sometimes you just have to look at those things for a while to find out what you did wrong.

341
00:00:00,000 --> 00:00:00,000
Alright, now let's talk about multidimensional arrays.

342
00:00:00,000 --> 00:00:00,000
So a multidimensional array we logically think of as rows and columns, right, like a spreadsheet, a matrix.

343
00:00:00,000 --> 00:00:00,000
Internally, however, it's stored linearly.

344
00:00:00,000 --> 00:00:00,000
Memory is linear and it's stored linearly as an array of an arrays.

345
00:00:00,000 --> 00:00:00,000
The second row in the array follows the last element of the first row.

346
00:00:00,000 --> 00:00:00,000
Now the syntax for 2D arrays is a little bit different than it is in Java.

347
00:00:00,000 --> 00:00:00,000
2D arrays are not used as much as they are in Java because they're much less flexible in C++.

348
00:00:00,000 --> 00:00:00,000
So first we have to have constants for both the rows and the columns.

349
00:00:00,000 --> 00:00:00,000
And so here I've created a two-dimensional array with rows and columns.

350
00:00:00,000 --> 00:00:00,000
Looks pretty similar to what you do in Java, except for the fact that these need to be constants.

351
00:00:00,000 --> 00:00:00,000
You can default initialize it starting in C++11, so it's not uninitialized.

352
00:00:00,000 --> 00:00:00,000
And you can initialize it by providing rows and columns inside.

353
00:00:00,000 --> 00:00:00,000
Now if I left off these inner braces, it would still give me, as long as columns is three here,

354
00:00:00,000 --> 00:00:00,000
notice I don't need to supply the rows in that case, and it would still give me two rows of three columns.

355
00:00:00,000 --> 00:00:00,000
Two rows of three columns, even if I left off the inner braces.

356
00:00:00,000 --> 00:00:00,000
The inner braces would not be required.

357
00:00:00,000 --> 00:00:00,000
What the inner braces do is allow you to initialize each row separately.

358
00:00:00,000 --> 00:00:00,000
So suppose I initialized row one just with one element and brace, and then row two with four, five, and six.

359
00:00:00,000 --> 00:00:00,000
Row one would have one, zero, zero, and row two would have then the four, five, and six inside it.

360
00:00:00,000 --> 00:00:00,000
So that's how you can initialize a two-dimensional array.

361
00:00:00,000 --> 00:00:00,000
Now you access the elements using row and column.

362
00:00:00,000 --> 00:00:00,000
This is called row major order.

363
00:00:00,000 --> 00:00:00,000
If you access outside the bounds, for instance, if I wrote balances zero sub six,

364
00:00:00,000 --> 00:00:00,000
you can see zero has zero, one, two, three, four, five, six, looks like it would be right here.

365
00:00:00,000 --> 00:00:00,000
We know, however, that row one is immediately following it.

366
00:00:00,000 --> 00:00:00,000
We could just line up these rows right here, and so we know that this would access one sub zero.

367
00:00:00,000 --> 00:00:00,000
That would normally work, but technically it's undefined behavior.

368
00:00:00,000 --> 00:00:00,000
So you should probably avoid doing it, although I've never seen it not work, but you should avoid doing that.

369
00:00:00,000 --> 00:00:00,000
You can calculate the number of rows.

370
00:00:00,000 --> 00:00:00,000
So you have an array, it's been declared, you want to calculate the number of rows.

371
00:00:00,000 --> 00:00:00,000
Now normally you'll store those in constant variables, right, or in constants.

372
00:00:00,000 --> 00:00:00,000
But if you have a two-dimensional array and you want to know the number of rows,

373
00:00:00,000 --> 00:00:00,000
it's exactly like finding the number of elements in a one-dimensional array.

374
00:00:00,000 --> 00:00:00,000
The size of A divided by the size of A sub zero.

375
00:00:00,000 --> 00:00:00,000
Because A sub zero is not this first element, this first row is A sub zero.

376
00:00:00,000 --> 00:00:00,000
So that's dividing the whole size, the number of bytes allocated for the two-dimensional array,

377
00:00:00,000 --> 00:00:00,000
by the number of bytes allocated for the first row.

378
00:00:00,000 --> 00:00:00,000
If you want to find the first column, you take the size of the first row,

379
00:00:00,000 --> 00:00:00,000
size of A sub zero, and divide that by the size of A sub zero sub zero.

380
00:00:00,000 --> 00:00:00,000
A sub zero sub zero.

381
00:00:00,000 --> 00:00:00,000
Now when you're passing a two-dimensional array to a function,

382
00:00:00,000 --> 00:00:00,000
you have to specify the number of columns as a constant.

383
00:00:00,000 --> 00:00:00,000
So in Java, we can write it this second way, where I have the illegal here on my slide.

384
00:00:00,000 --> 00:00:00,000
We can just say that n is a two-dimensional array of ints,

385
00:00:00,000 --> 00:00:00,000
and we can find out the rows and the columns at run time.

386
00:00:00,000 --> 00:00:00,000
We cannot in C++.

387
00:00:00,000 --> 00:00:00,000
So this function odds will only work with arrays that have this fixed number of columns.

388
00:00:00,000 --> 00:00:00,000
Now if you only want to process a particular column,

389
00:00:00,000 --> 00:00:00,000
then you could pass an additional argument for that column.

390
00:00:00,000 --> 00:00:00,000
Now you can take a single row from a two-dimensional array,

391
00:00:00,000 --> 00:00:00,000
and you can pass it to a function that takes a one-dimensional array just by subscripting it.

392
00:00:00,000 --> 00:00:00,000
So A sub zero in this element is not the first int,

393
00:00:00,000 --> 00:00:00,000
it's the first row of five ints will be passed to that.

394
00:00:00,000 --> 00:00:00,000
So we're going to look at an exercise here that tries processing two-dimensional arrays.

395
00:00:00,000 --> 00:00:00,000
Again, as I mentioned, these are not really used a lot in C++,

396
00:00:00,000 --> 00:00:00,000
but I just want you to get some practice doing it.

397
00:00:00,000 --> 00:00:00,000
So we're going to write several versions of a function called average.

398
00:00:00,000 --> 00:00:00,000
So let's go ahead and close our partial, close that,

399
00:00:00,000 --> 00:00:00,000
go and in D, open up A2DH, which we're going to make some changes to,

400
00:00:00,000 --> 00:00:00,000
so put your name on it, and summer 2022.

401
00:00:00,000 --> 00:00:00,000
And we're going to put some prototypes right here.

402
00:00:00,000 --> 00:00:00,000
Arrays must have a constant second dimension.

403
00:00:00,000 --> 00:00:00,000
Change this for different size 2D arrays.

404
00:00:00,000 --> 00:00:00,000
So here in my prototype, all my test programs are doing it for 10 columns is the constant size.

405
00:00:00,000 --> 00:00:00,000
So that's the maximum columns.

406
00:00:00,000 --> 00:00:00,000
What we're going to do is something similar to partially filled arrays for 2D arrays.

407
00:00:00,000 --> 00:00:00,000
So first we're going to write a function called average that's going to take a 2D array.

408
00:00:00,000 --> 00:00:00,000
All of these will return a double down here.

409
00:00:00,000 --> 00:00:00,000
So this is going to take a 2D array of ints, the number of rows, the number of columns,

410
00:00:00,000 --> 00:00:00,000
and we're going to default the columns to max calls.

411
00:00:00,000 --> 00:00:00,000
So we're going to say double average.

412
00:00:00,000 --> 00:00:00,000
It is going to be a constant A.

413
00:00:00,000 --> 00:00:00,000
Now we don't have to supply the rows, but we do have to supply max calls.

414
00:00:00,000 --> 00:00:00,000
And it's going to be size T rows and size T columns.

415
00:00:00,000 --> 00:00:00,000
And we'll default that to max calls.

416
00:00:00,000 --> 00:00:00,000
So if they don't pass that last argument, it will print out 10 columns, right?

417
00:00:00,000 --> 00:00:00,000
Or it will use 10 columns.

418
00:00:00,000 --> 00:00:00,000
Now we're going to write an average function that takes a one dimensional array of int in the columns.

419
00:00:00,000 --> 00:00:00,000
So double average, constant A, bracket, bracket, size T columns equals max calls.

420
00:00:00,000 --> 00:00:00,000
And finally we're going to take a 2D array of int, and it's going to average the numbers in columns.

421
00:00:00,000 --> 00:00:00,000
So it's going to take columns and column.

422
00:00:00,000 --> 00:00:00,000
So double average, constant A, max calls, size T rows, size T columns, size T column.

423
00:00:00,000 --> 00:00:00,000
And let's open up a shell on this so I can make the thing a little bit wider.

424
00:00:00,000 --> 00:00:00,000
Ok, so here are our three prototypes for the functions we're going to write.

425
00:00:00,000 --> 00:00:00,000
Now notice I have a prototype here that will print a 2D array in this form.

426
00:00:00,000 --> 00:00:00,000
Notice it will print the rows surrounded so it's kind of a fence post with the interior one, just the values like that.

427
00:00:00,000 --> 00:00:00,000
And it is going to print on this stream.

428
00:00:00,000 --> 00:00:00,000
It takes the rows and the size T is max calls.

429
00:00:00,000 --> 00:00:00,000
Now if we open up A2.cpp, put our name on it, our ID at least.

430
00:00:00,000 --> 00:00:00,000
You'll see I've already completed the A out function.

431
00:00:00,000 --> 00:00:00,000
So you notice it's using rows and columns here, rows and columns for the number of elements to print.

432
00:00:00,000 --> 00:00:00,000
And so if columns is anything other than max call, it will only print that number of elements.

433
00:00:00,000 --> 00:00:00,000
So it's like a partially filled array.

434
00:00:00,000 --> 00:00:00,000
So we have an array that looks like this.

435
00:00:00,000 --> 00:00:00,000
One, two, three, four, zero, zero, zero, zero, zero, zero, zero, and six, seven, eight, nine, zero, zero, zero, zero, zero, zero, zero, and three, five, seven, nine, zero, zero, zero, zero, zero.

436
00:00:00,000 --> 00:00:00,000
Now we only want to use these first four columns.

437
00:00:00,000 --> 00:00:00,000
We don't want to use the rest of it.

438
00:00:00,000 --> 00:00:00,000
So we're passing an array that looks like this whole thing, but we're only using this part of it inside here.

439
00:00:00,000 --> 00:00:00,000
And so that way we can make different rows and different columns.

440
00:00:00,000 --> 00:00:00,000
So that's the idea of partially filled arrays with two-dimensional arrays.

441
00:00:00,000 --> 00:00:00,000
So let's grab our code for A2.h.

442
00:00:00,000 --> 00:00:00,000
And let's bring our functions over here.

443
00:00:00,000 --> 00:00:00,000
OK, now you remember when we bring a prototype over, if it has any default arguments, we need to remove those default arguments.

444
00:00:00,000 --> 00:00:00,000
So let's put the bottom on it.

445
00:00:00,000 --> 00:00:00,000
So even though this thing is allocated max col size, we're only going to use columns.

446
00:00:00,000 --> 00:00:00,000
So we're going to say double sum is zero.

447
00:00:00,000 --> 00:00:00,000
Or size PR equals zero, R less than rows, R plus plus. Or size TC equals zero, C less than columns, C plus plus.

448
00:00:00,000 --> 00:00:00,000
Sum plus equals A at rows, R, and C at the row and column.

449
00:00:00,000 --> 00:00:00,000
So now we have the sum here, and we can return sum divided by rows times columns.

450
00:00:00,000 --> 00:00:00,000
The number of elements. So here is averaging. You need to use a nested loop when you're averaging a two-dimensional array.

451
00:00:00,000 --> 00:00:00,000
Now, we haven't handled any error checking here, so what if rows and columns is zero?

452
00:00:00,000 --> 00:00:00,000
Of course, we would have an error here. And we should check that.

453
00:00:00,000 --> 00:00:00,000
And you'll notice down here, I did that with an assert.

454
00:00:00,000 --> 00:00:00,000
Actually, I checked a different assert.

455
00:00:00,000 --> 00:00:00,000
Okay, so we're going to average a single column. So double sum is zero.

456
00:00:00,000 --> 00:00:00,000
Or size TI equals zero, I less than columns, I plus plus.

457
00:00:00,000 --> 00:00:00,000
Sum plus equals A sub I.

458
00:00:00,000 --> 00:00:00,000
Return sum divided by columns. Again, no error checking there to make sure that that's not zero.

459
00:00:00,000 --> 00:00:00,000
And this one is going to look very similar.

460
00:00:00,000 --> 00:00:00,000
So double sum. Or size TR equals zero, R less than rows, R plus plus. Sum plus equals A sub R sub column.

461
00:00:00,000 --> 00:00:00,000
Alright, so we're only adding one column there. And then return sum divided by the number of rows.

462
00:00:00,000 --> 00:00:00,000
Alright, so let's go ahead and try it out.

463
00:00:00,000 --> 00:00:00,000
Let's do make first to make sure we don't have any syntax errors. Nope.

464
00:00:00,000 --> 00:00:00,000
Let's do make test.

465
00:00:00,000 --> 00:00:00,000
Okay, so here is A out and I've supplied a size four when I do it.

466
00:00:00,000 --> 00:00:00,000
Here's A out. If I don't supply a value, I only supply the three arguments.

467
00:00:00,000 --> 00:00:00,000
And so notice it's printing those extra zeros at the end that we didn't use.

468
00:00:00,000 --> 00:00:00,000
Here's the average of all the used elements.

469
00:00:00,000 --> 00:00:00,000
And so that's average values, rows. And because there's only four.

470
00:00:00,000 --> 00:00:00,000
Here's the average of all the elements, which would not give us the right value, right?

471
00:00:00,000 --> 00:00:00,000
Because we're not really using these.

472
00:00:00,000 --> 00:00:00,000
So we'd want to call it with average, take in the values, the number of rows that we're using,

473
00:00:00,000 --> 00:00:00,000
and the number of columns that are actually in use.

474
00:00:00,000 --> 00:00:00,000
Here's the average of the second row. Here's the average of the second row, only four columns.

475
00:00:00,000 --> 00:00:00,000
Notice you call it again by passing that default argument that was the default argument.

476
00:00:00,000 --> 00:00:00,000
And here's the average of the third column in the entire array.

477
00:00:00,000 --> 00:00:00,000
Okay, so that's it for lecture 21. I'll see you next time for our next lecture.

