Hello everyone, welcome to lecture 12. I'm Steve Gilbert and today we're going to look at processing disk files.
Let's start with a little bit of review though.
So first I want to look at streams and data loops.
So the stream classes that we're going to use are IStream and OStream.
IStream is the input stream class. It's a class that knows how to read data and bring it into your program.
The OStream class is an output stream class. It knows how to read/write data and send it out of your program.
When your program starts up, it automatically creates several global standard stream objects.
CIN for input, COUT for output, and CERR for sending out error messages.
These are automatically connected to your operating system's standard streams called StandardIN, StandardOUT, and StandardERR.
By the way, Java does exactly the same thing. StandardIN is connected to a scanner object when you create it.
System.OUT is connected to the StandardOUTput just like COUT is.
And System.ERR is connected to StandardOUTput just like CERR is in Java.
Now we can use these streams with a special kind of loop called a data loop.
A data loop stops not when we reach a counter, not when we reach a limit, but when the source is out of data.
And there are three different ways to read from a stream.
We can read a character by character, which is what we did when we wrote our filter programs in the last lecture.
So while CIN, GET CH, COUT, PUT CH.
We can also use the string function called GETLINE to read an entire line of input.
So notice here I'm saying while GETLINE, I'm using any kind of input stream, IN, LINE,
and this will again, when it's out of data, it will return false, and I'm printing out the line.
When you read this line, it will strip the new line character from the end,
so I needed to add it here if I wanted my output to look the same as the input.
And finally I can read token by token.
So I can do while IN, N, COUT, N.
And this will not only read whatever kind IN is, but it will convert the characters into the type of IN.
So if I had a file full of integers, I could process it using this.
Of course, this is slightly different.
GET and GETLINE will only end when they run out of data.
When I have a formatted input like this, or token-oriented input,
it could end when there is something that is not an integer, for instance, in the stream.
So we're going to look at a function that takes a stream as input,
and we're going to use a data loop with the first exercise today called SUM EVENS.
So make sure you've gone to week 3.
On week 3, make sure you've gone to the files tab over here.
Click the lecture exercises.
Click the link for the starter code.
Go ahead and make a copy of this, change the name on it,
and we're ready to go with exercise A on data loops.
So we're going to write the function SUMEVEN that adds all the even numbers inside its ISTREAM argument.
So go ahead and open a shell over here on folder A in 12,
and open up evensummer.cpp.
So this function is going to return an int.
Let's see what it was named again.
It was named SUMEVENS.
It's going to take an ISTREAM argument, so it's going to read from a stream.
So SUMEVENS ISTREAM, we'll just call it int.
And we'll do int sum is zero and return sum.
Unfortunately when we try and compile this, when we just do make down here,
you'll see we get a whole bunch of errors.
And the problem is that we are passing the wrong kind of argument.
So when you pass a stream, it's a library type, so you cannot pass it by value.
So we're going to pass it by reference.
And so now when we do make, the code compiles.
So you cannot pass streams by value.
You cannot pass streams by value.
Now for our data loop, we want to read an integer from this stream.
So we're going to have int n. We're going to say while int n.
So while we read the integer n from int, if n remainder 2 equals zero,
it's an even number, then we're going to add it to our sum.
So sum plus equals n.
Okay, so let's try that.
Make test.
And here we've added some integers here.
One, two, three, four, one, two, five, seven.
No even numbers here.
All even numbers here.
No numbers here.
And so forth.
So notice we're not doing this with a string.
We're doing it with a stream.
Remember all stream input is character input.
Character input.
So we talked about filter programs in the last lecture, in lecture 11.
So filter programs read from standard input, and they write to standard output.
State filters, like the one we did, look for changes in input.
So CECO changed the state of its printed flag.
So the printing Boolean flag was used to monitor the stream state
when we did that with Alice in Wonderland.
Process filters modify their stream's contents.
So here, for instance, is the toUpper filter that I showed you in the last lecture.
Well, CN getCH, C output, toUpperCH.
So we're processing the data as we go through.
So we're going to do that with an exercise just to get a little bit more used to stream input and output.
We're going to write a 150 encryption library.
So let's look at the details over there in our handout.
So an encryption program scrambles the bytes in a file
so that the file is unreadable except to those who know the decryption method and the secret keyword.
Now, we're going to ignore 2,000 years of progress in the field of encryption,
and we're going to use a method that was familiar to Julius Caesar.
He simply replaced his A's with a D, B's with an E, and so forth.
And this is called the Caesar cipher.
And so the idea with a Caesar cipher, or any cipher, is you get input, which is plain text,
and then you get output, which is called cipher text.
Now, notice a couple things about it.
We are only ciphering the things that are characters.
We are not ciphering the spaces, and we're not ciphering any punctuation.
We're only ciphering the characters.
Now, with encryption, if we pass in encryption text, we should get back the plain text.
So let's go ahead and look at our lib function in the starter code over here in B.
Let's close Even Summer, close these shells we've opened already,
go down to B, and you can see I have a folder called enclib.
So let's open a shell on that, on enclib.
And we're going to look at encrypt the header file.
And you can see I've already put inside here the two functions we're going to write in the namespace inc.
I've already documented them.
And we are simply going to implement those two functions over here.
So go ahead and put your name on the top there.
And then let's grab from inc.h, let's grab the namespace,
and the prototype, and pop it over here.
I'm going to leave the documentation over here because it makes it a little bit easier.
Ok, so we have one function that will take plain text and turn it to cipher text,
and one function that will take cipher text and turn it to plain text.
Notice each of these are going to read from input and write to output.
So both of them are going to use a data loop.
So char ch while in.get, notice we're not using cn here, ch, out.
We're not using cout either.
Put ch.
Let's put the other one for the plain text one.
So now we've got our stubs here, our things that read from input, write to output.
We're not using the key here at all.
And so let's do make test.
So you can see on this, all of these failed of course because we haven't done any encryption.
So I am getting, so notice I'm putting out exactly what I got in.
So when I get in attack at dawn, I expect to get this as output.
When I get in how now brown cow, I expect to get this as output.
When I decrypt attack this, I expect to get attack at dawn and how now brown cow and I love cs150.
So let's go and look at each of those characters.
What we're going to do is we're going to add this number, shifting the characters rightward.
So if it's an A and the key was one, it's going to become B.
So we could simply try that by saying key.
And to decrypt it, we're going to do the same thing.
Okay, let's see how that works. That's pretty simplified.
But let's see if it in fact works.
It didn't look like it worked anywhere because look at, we are almost got that one right.
But we're encrypting the spaces.
So notice that that means that when we print the data out, we need to say,
if, and we're going to use from the CC type up here, we're going to use the header, we're going to use the function if is alpha.
And we could do it manually, right?
We could say if ch, I mean I could do it like this.
If ch is greater or equal to A and ch is less than or equal to Z.
Or ch is greater or equal to A and ch is less than or equal to Z.
That would be the same as saying if is alpha ch.
Which is probably a little bit easier to read.
So if it's alpha, we're going to print the thing with the key.
Else, we're going to output ch.
We're going to do the same thing up here.
I'll just put it right there.
If is alpha ch.
I'll put that.
Else, I'll put ch plus key.
OK, let's try it this third time.
The second time we didn't get any passing. Let's see if we get any passing this time.
Ah, I got one passing.
I got how now brown cow.
How now brown cow.
That one is still not working. Let me try that again.
The first one is still not working at all and I thought we kind of fixed that.
So let's look. Oh, notice the mistake I made there.
So if it's not an alpha character, we just want to put it out.
OK, not with the key.
OK, let's try it again.
Now we got two passing.
So how now brown cow works in both cases.
This is the encrypted version of it.
This is the decrypted version of the ciphertext here.
This doesn't quite work.
So this is a tackadon.
So attack seems to work. At seems to work.
So instead of B here, I have that.
So our key here is five.
So if I take W, I should change it to an X for one, Y for two, Z for three.
Oh, four is going to move me beyond the characters.
Right. So if I'm at the end of the character, if I'm at the end of the set of characters and I'm moving to the right,
then I have to add myself around. Right. I have to move it around.
So that means we're kind of doing a remainder operator, but I need to use a.
I need to use an actual modulus operator.
So this looked pretty simple, but it's not actually that simple.
So we can do it two ways. I'll show you one way where I do three things.
So is upper. Ch. Else if is lower. Ch.
OK, for this one, what we're going to do if it's upper, what I'm going to need to do is,
you know, that's not going to work. Let me pause it for a second. Let me figure out how to get it to work.
OK, so this is relatively complex. So what I'm going to have to do,
so I'm going to have to take the ASCII code. If it's uppercase, I'm going to have to subtract it from the A.
Then I'm going to add the key to it. I'm going to take that remainder 26.
And then I'm going to add A to it. And we'd have to do exactly the same thing with the lowercase one.
Except we change it to the lowercase character.
So let's try that and see if the encryption works.
So the encryption all works right here. Let me show you why that works.
So basically with characters, here's what we have in memory.
We have a whole bunch of ASCII characters and then A, B, C, D, through Z.
Then some more characters and then A, B, C, D, through lowercase C and then some more characters.
And so A is ASCII 65 and lowercase A is ASCII 97.
So that's how they're organized. So what we need to do is we need to find the position.
So if we get an A here, we want the number zero. If we get this A, we also want the number zero.
So let's use that scheme. So I'm going to call that position.
So int pos equals, so is upper CH? Then pos is going to be A minus CH.
If it's not, if it's lower, then pos, now that's actually, we're going to say, int pos equals zero.
If is upper CH, pos equals A minus CH. Else if is lower CH, pos equals A minus CH.
So that gives me my position zero, one, two, three, four. I'm going to add the key to pos.
And I'm going to take it remainder 26. So if we have W and we go beyond 26, it will wrap around to be the character B, which is what we want.
So I'm going to say pos equals pos plus key remainder 26.
Now, what do I need to do? If CH is upper, I need to output A plus pos.
That will give me the character of that position. And in this case, I would need to output A plus pos.
So we have to know for the difference if it's upper or lower case.
OK, let's try that one and then we'll put it into the decryption thing.
The decryption is slightly more complex. OK.
OK, so all these I got completely wrong.
And that didn't work at all.
I'm going to pause again and spend a few seconds thinking about this.
OK, I saw what I did last time. The mistake was I did the subtraction the wrong way.
So let's say if is alpha CH.
So it's got to be an upper case or lower case character.
Let's find its position inside its respective character set.
So if pos equals is upper CH.
So its position is CH minus A.
Before I wrote that as A minus CH.
If it's lower case, its position is CH minus lower case A.
So again, if that's an upper or lower case A, position will be zero.
Now we want to update the position.
So pos equals pos plus key.
Remainder 26 to get us the wraparound effect.
Now we want to update the characters.
So CH equals is upper CH.
If it's upper CH, then CH is uppercase A plus the position.
And if it's lower case, it's lower case A plus the position.
Now this is what we do if it's an alphabetical character.
We encrypt it, all of the characters we print out right here.
So let's try that.
Let's do make test.
And our encryption for the plain text works ok.
And actually that is a little bit clearer as to what's happening there.
Let's go ahead and just take this code here.
And let's think about the decryption.
Now the decryption, we're subtracting something from the key.
And so again, we get the position the same.
We subtract the key the same.
But now we have a problem in this little piece of code right here.
Because if this is a negative number, which it will be if we had an A and we shift it left,
if that is a negative number, the mod 26 doesn't work.
So what we have to do is add pos plus 26 minus key.
In other words, we have to shift one whole alphabetical set at the same time.
And that should do the decryption part ok.
To turn it into plain text.
So let's try it.
Let's do make test.
And that correctly decrypts our text.
Attack at dawn is turned into this.
This is turned into attack at dawn.
Ok, so that was a little more complex than I expected.
But a little bit of good review for process filters.
Ok, so now let's go to our next topic.
Our next topic is going to be how do I program using disk files.
So C++ has some classes that explicitly allow you to specify the source to read from a file
or a sink to write to a file in code.
So these are in a new header.
They are not in Iostream.
It is in the header fstream.
You probably also need to include Iostream if you want to use cin and cout
because those are created in the Iostream header.
So these classes are called ifstream.
Not istream, ifstream.
So the f signifying that it is a file.
That will connect to a file and read data.
An ofstream, again the f signifying a file, connect to a file and write data.
Again, if you want to use cin and cout, those are created in Iostream, so include that as well.
Now, using explicit files involves three steps.
First, with cin and cout we didn't have to create any objects.
With the ifstream and ofstream, we need to explicitly create an instance of the stream class we are going to use.
So again, we didn't need to do these with the standard streams, cin and cout.
We do need to use it with these explicit file streams.
Secondly, we need to open the file or create the file.
We simply associate the stream with a source or sync.
There are a couple of different methods.
And then we just read and write from it exactly as if it was cin and cout.
Finally, in Java you have to be very, very careful to close your stream after you have opened it
if you create a dist file stream.
In C++ we don't need to worry about that.
It will automatically be closed by a destructor, so you don't need to worry about that.
You may occasionally need to use the close member function, but most of the time you will not.
So, to create and associate the object, you can do this.
Here I have created an instance of the stream, just like I create an int or any other variable.
And then I have called the member function open and told it what text file I want to open.
Now this is a path.
This would be in the current working directory.
If you wanted to open it in a different path, you would pass the entire path inside here
as a C style string or as a string object.
You can do the whole thing in one statement though,
by just passing the path that you want to open to the constructor.
So here I am using the default constructor and then calling open on it.
Here I am just using the constructor that opens it.
You would use exactly the same pattern for OFStream, which would create an output file.
Now, how do we know if the file was opened correctly or it was created correctly?
What you have to do, if you can't open it, is you have to check the stream itself.
If the stream is false, or if its member function fail is true,
then it didn't open correctly.
It didn't open correctly.
And so, what do you do when you can't open it?
Well, you could use a loop and you could reprompt for the correct file name.
If you are asking the user to enter a file name.
Or you could print an error message.
Now, since this is an error message, we want to use not cout, but we want to use cerror.
And we could return from the function, return an error code, exit from the program altogether.
So, let's look at an example that does that.
And for this, we are going to use the second kind of data loop, a line oriented data loop.
So, a line oriented data loop reads one line of text at a time.
It throws away the new line from that line of text.
Notice that it does not, git line does not return the string.
Instead, the string is a string passed by reference, which is filled in, in the function.
What it does return is it returns the stream object itself.
And we'll use that as the boolean condition.
While the stream is still good, git align.
You also, with git line, it's sometimes hard to remember that it's not included in I/O's stream.
It instead is a function inside the string type.
So, you have to remember to include string.
So, our third exercise today is the flip lines problems.
What we are going to do is open a file or print an error message.
So, we are going to go over the stuff we did in the last slide.
And then we are going to reverse the first pair of lines, the second pair, and so forth.
So, let's go over here.
Let's look at the exercise.
So, here we are going to read this file.
We are going to read the first two lines.
And then in the output we are going to take the second line and print it first, and the first line and print it second.
We are going to do that through the whole file.
Now, notice that a line can be blank, as on the third pair.
And so we switch to "Beware the Jabberwock" with a blank line.
And we may have an odd number of lines.
In that case, only the last line is printed in its original position.
It's not flipped with an invisible line that would be after it.
Now, we are going to do two things here.
We are going to do that, processing the line by line.
But we are also going to look at the process for opening and checking a file.
So, we are going to write the function named "flip lines" that accepts the name of the file as its parameter.
It's not a stream, like the first exercise we did today.
And it's going to open and write to the console the same file's contents with the lines switched, like I just said.
If the file cannot be opened, then "cannot open filename.txt" is printed to "Sierra" with "filename.txt" replaced with the actual name.
So, let's do that.
OK, this is in C.
So, we are going to do "flip lines".
So, put our name on it.
And the function is named "flip lines".
It's not going to return anything, so it's going to be a void function.
And it's going to take a string for the filename.
So, there's our stub.
Let's go ahead and open a terminal on C.
And simply do "make" to make sure the stub works.
Yes, it works. So, it complies.
So, step one. We need to create an input stream on filename.
So, "if stream in" and we'll pass in "fname".
Let me do it. So, this is the original name.
So, "in open fname".
So, that's perfectly OK.
It's kind of a lot of extra work, though.
So, let's do this.
"if stream in fname".
So, that's "create" and "open" at the same time.
And I'll comment out these first two lines.
Now, we need to make sure if it opened.
So, "if in failed" to open.
"if in fail".
What we're going to do is say "sr".
"cannot open fname".
And since this is a void function, I'm just going to return.
Or, so I can do "return".
Notice it's a void function.
Or, I could skip this return.
I could skip that return.
And I could put the remaining part of the code in the "else" down here.
So, I'll do that.
I know specifically in 250 they don't like you putting this return inside there.
So, I'll do that.
I generally would do it.
But, I'm trying to make it easier for you when you go on to the next class.
So, we can't open the file name.
If we didn't fail, what are we going to do?
We're going to read the file and print it to output.
So, I need two lines.
I need to read two lines at a time.
So, I'm going to have "string line1" and "line2".
I'm going to say "while getline in line1".
So, that's going to read one line.
And now I'm going to say "if getline in line2".
Now I've read two lines.
If that fails, of course, I've only read one line.
And then I'm going to do "cout".
I'm going to print "line2", a new line, "line1", and a new line.
If that failed, else, then of course I'm going to do "cout line1" and "line2" because we didn't read two lines.
So, here's getting a file name in.
Opening the file.
If we can't open it, printing out an error message. Otherwise, reading and printing the output.
So, let's try this. Let's open up a shell there.
Let's do "make test".
Oops.
Sorry, I didn't want that. I guess because I had multiple ones there.
I was trying to get rid of this extra one over here.
Kind of too much work.
"make test"
Ok, so, here's an easy file that had a second line and a first line. It just replaced it.
Here's trying to check the error message. Kind of an open, no loadout text.
And here's the original test in here.
Checking the file that was on the handout here.
This file right here.
Ok, so there's the whole function right there.
Now, I, as I mentioned, I would probably do it like this.
There's no reason to go on. I would remove that "else" part there.
Because if I got here.
I like that because it's a little bit shorter, personally.
Alright, let's go on now.
And look at token oriented dataloops.
So this is what we started with today, while in VAR.
We're reading one token at a time.
Now this fails at end to file, like the other two loops do. The character oriented and the light oriented.
And it fails when it can't convert the token.
So if we failed because we couldn't convert a token, and we weren't at end to file,
we'd need to clear the error flags with in.clear
before we could read anything else.
And then we'd still need to remove the offending input.
So, here I've created a string just to hold the offending input.
If in fail, in clear, in error data.
So this clears the flags, this removes the token, and then we can keep going on
to the remaining data.
So we're going to look at a final exercise today.
Expenses.
We're going to process a file with characters and tokens.
So we're going to learn a couple of tricks to doing that.
So let's close flip lines.
Let's open up d, expenses.cpp.
Let's open expenses.txt too. So this is the file we're processing.
What we want to do is we want to read each line.
We want to sum up this person's expenses,
print their name, and print their
print their data out.
Print the sum of their expenses.
So let's add a comment on there. Notice we have an in file and an out file.
We're going to open the input file.
So if string in, in file.
If we can't find it, if in fail.
We're going to print an error message.
Sierra cannot open in file.
And I'm going to just return from that.
Then we're going to create the output file.
It says expenses summary, but we're going to use the name out file,
which is created up here.
So we're going to say OF string out,
and I'm going to create it with out file.
And we have to check to make sure that worked as well.
So if out fail,
Sierra cannot create out file,
and I'll return there.
Okay, so this is the setup before we do anything.
Now we've opened both the input and output file,
and we can loop through each character in the file.
So let's write a loop that does that.
I'm going to leave that up there
and write it down here rather than writing inside it.
So char ch while in get ch.
Okay, so that's our main loop.
Loop through each character in the file.
Now if the character is a non-digit, then print it out.
So if not is digit ch,
out put ch.
Otherwise, so else, we'll have some code inside here, the else.
Okay, so we've read our first digit in the line.
So again, let's look at expenses.txt.
I read and printed that, that, that, that, that, that, that, that, that space,
and now I've just read the two.
So here I need to create and initialize a sum for the line.
So double sum zero.
I need to repeat until input fails or ch equals the null, right?
So I need to say while in or while not in fail
and ch is not equal to the null line.
Now notice the instruction says until.
We have to put it in the reverse sense and say keep going while this is true.
Okay.
So if ch is a digit,
what we're going to do is put it back in the stream.
So in put back ch
or alternatively in unget would work as well.
Now we need to read the entire number from the stream.
So look at expenses.txt.
We read the digit two, took it out of the stream,
but we want to actually read this whole number.
So we have to take the two and put it back in the stream
so we're reading right from that point.
Now to read that whole number and convert it, of course,
what I need to use is formatted input.
So I need to say double in, in, in.
So we read the number from the stream.
Of course we need to add the number to the sum.
So sum plus equals in.
Now if it's not a digit or even if it was a digit,
after that loop we need to read the next digit.
So in, get, ch.
Now at the end of this while loop, after the loop is over,
after we've done all of this stuff,
we need to print the sum with two decimals and a new line.
So that's right here.
We need to say out, not cout, fixed, set precision,
to, sum, end.
Now we could actually put the out fixed precision up here
even before the loop started, so we just have to do the sum.
So this would be perfectly fine.
And here we could just say out, sum, end out,
and it kind of doesn't clutter up the flow of the control with the output.
So here's our outer loop, well we can read a character.
Here is our inner loop where we're summing up the numbers in one line
and printing out the output.
Okay, let's go ahead and try that and see how we did.
Let's get a shell on that.
So we're going to say make, and make test.
Okay, so I tried to open a file that did not exist.
I tried to open a file that you were not allowed to write to.
And I tried to create a file with the correct input.
That worked okay.
Then I read the file, so that makes sure that I read the next correct number of lines.
And then I correctly went through and read the, summed the data.
Now you might wonder, you might wonder why I had to go to all this extra work inside here
to read the, why I couldn't just do well in, arrow, arrow, end,
and get it to work like that.
Well notice, some of the people have put in notes inside here,
and we have to make sure we skip over those.
And so those would fail inside, inside that line.
And so this last exercise we did, process a file with characters
and with token oriented input, and opening files.
Okay, that's it for today.
And I will see you on the next lecture, on lecture 13.
