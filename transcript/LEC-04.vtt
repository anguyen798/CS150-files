WEBVTT

00:00:00.000 --> 00:00:00.000
 Hello everyone, this is Steve Gilbert. Welcome to lecture 4 on functions and decisions.

00:00:00.000 --> 00:00:00.000
 This week we're going to start moving away from writing input processing output programs

00:00:00.000 --> 00:00:00.000
 and start moving towards writing functions.

00:00:00.000 --> 00:00:00.000
 Now a function, you remember, is a named piece of code, like square root.

00:00:00.000 --> 00:00:00.000
 You can think of these, though, like mini IPO programs.

00:00:00.000 --> 00:00:00.000
 In other words, they still have input processing and output,

00:00:00.000 --> 00:00:00.000
 but the input processing and output is somewhat different.

00:00:00.000 --> 00:00:00.000
 So here are the major differences.

00:00:00.000 --> 00:00:00.000
 Instead of prompting the user, "Please tell me the number of boxes that you want,"

00:00:00.000 --> 00:00:00.000
 the input is going to come through the parameter list.

00:00:00.000 --> 00:00:00.000
 There's going to be no prompt and then waiting for the user to type input.

00:00:00.000 --> 00:00:00.000
 And then, instead of printing the output on the screen,

00:00:00.000 --> 00:00:00.000
 the output is going to be returned from the function.

00:00:00.000 --> 00:00:00.000
 Now, of course, you can still use functions to create IPO programs.

00:00:00.000 --> 00:00:00.000
 In fact, you're going to do this in one of the homework assignments.

00:00:00.000 --> 00:00:00.000
 You can have regular input and output,

00:00:00.000 --> 00:00:00.000
 but normally, unless we're writing an input and output function,

00:00:00.000 --> 00:00:00.000
 we won't do IO inside the function itself.

00:00:00.000 --> 00:00:00.000
 So let's look at arguments and parameters.

00:00:00.000 --> 00:00:00.000
 Now, most functions require extra information to do their work.

00:00:00.000 --> 00:00:00.000
 In other words, you couldn't just dial up Domino's or Pizza Hut and say,

00:00:00.000 --> 00:00:00.000
 "Send me a pizza," and not give them any extra information.

00:00:00.000 --> 00:00:00.000
 You'd have to tell them who you are, where to send the pizza to,

00:00:00.000 --> 00:00:00.000
 what size pizza you want, what, you know, toppings you want on the pizza, and so forth.

00:00:00.000 --> 00:00:00.000
 And so think of a function like square root.

00:00:00.000 --> 00:00:00.000
 Square root, when you call the square root function,

00:00:00.000 --> 00:00:00.000
 it doesn't stop and say, "Hello, what number would you like the square root on?"

00:00:00.000 --> 00:00:00.000
 It doesn't prompt you for input.

00:00:00.000 --> 00:00:00.000
 It also doesn't print its output on the screen.

00:00:00.000 --> 00:00:00.000
 Instead, square root gets its input through arguments and parameters.

00:00:00.000 --> 00:00:00.000
 Now, we're going to use these two terms in a very specific way.

00:00:00.000 --> 00:00:00.000
 Sometimes they're confused with each other,

00:00:00.000 --> 00:00:00.000
 and many times they're used in different ways.

00:00:00.000 --> 00:00:00.000
 But we're going to refer to arguments as the values that are supplied when a function is called,

00:00:00.000 --> 00:00:00.000
 not the variables that are created when the function is defined.

00:00:00.000 --> 00:00:00.000
 Those we're going to call parameters.

00:00:00.000 --> 00:00:00.000
 So when a function's defined, we're going to declare variables

00:00:00.000 --> 00:00:00.000
 that will be used inside the function to store the value.

00:00:00.000 --> 00:00:00.000
 Now, we have two kinds of functions.

00:00:00.000 --> 00:00:00.000
 We have fruitful functions or void functions.

00:00:00.000 --> 00:00:00.000
 A fruitful function is a function that produces a value.

00:00:00.000 --> 00:00:00.000
 That means we can call a fruitful function as part of an expression, as part of a calculation.

00:00:00.000 --> 00:00:00.000
 A void function, which is also known as a procedure, needs a side effect.

00:00:00.000 --> 00:00:00.000
 A void function would be something that says, you know, print this value.

00:00:00.000 --> 00:00:00.000
 It doesn't return anything.

00:00:00.000 --> 00:00:00.000
 It just does something.

00:00:00.000 --> 00:00:00.000
 So the does something part we call a side effect.

00:00:00.000 --> 00:00:00.000
 Now, we're going to do our first example here, our first exercise.

00:00:00.000 --> 00:00:00.000
 So make sure that you have gone into, got the lecture exercise document,

00:00:00.000 --> 00:00:00.000
 gone to Fridays, got the lecture exercise document,

00:00:00.000 --> 00:00:00.000
 clicked the link for the starter code,

00:00:00.000 --> 00:00:00.000
 and we'll look at this first problem we're going to do here.

00:00:00.000 --> 00:00:00.000
 So here, what we want to do is write a function called last digit.

00:00:00.000 --> 00:00:00.000
 Now, again, unlike the IPO programs we've written before in class,

00:00:00.000 --> 00:00:00.000
 we're not going to prompt the user, what digit do you want to process?

00:00:00.000 --> 00:00:00.000
 We're just going to pass the digit to the function last digit.

00:00:00.000 --> 00:00:00.000
 So if we give last digit a number like 3,572, the last digit in that number is 2,

00:00:00.000 --> 00:00:00.000
 and so that's the value it should return.

00:00:00.000 --> 00:00:00.000
 We also want it to work for negative numbers.

00:00:00.000 --> 00:00:00.000
 For instance, giving last digit -947 should return 7, not -7.

00:00:00.000 --> 00:00:00.000
 You can use one other function here.

00:00:00.000 --> 00:00:00.000
 You can use the abs function in C standard lib.

00:00:00.000 --> 00:00:00.000
 That's the version of abs that works for integers,

00:00:00.000 --> 00:00:00.000
 but no other library functions, and you can't use string.

00:00:00.000 --> 00:00:00.000
 So we couldn't take the substring at the size -1,

00:00:00.000 --> 00:00:00.000
 or the back function to get the integer.

00:00:00.000 --> 00:00:00.000
 So let's look at how we do this.

00:00:00.000 --> 00:00:00.000
 Let's open up in IC4, let's open up A, and let's open up last digit.cpp,

00:00:00.000 --> 00:00:00.000
 and we're going to write our function here.

00:00:00.000 --> 00:00:00.000
 Notice I've included only this one header we can have.

00:00:00.000 --> 00:00:00.000
 So how do we write a function?

00:00:00.000 --> 00:00:00.000
 Well, you always start with - so this is the function we're writing.

00:00:00.000 --> 00:00:00.000
 You always start with first draft skeleton.

00:00:00.000 --> 00:00:00.000
 The name for the skeleton is called a stub.

00:00:00.000 --> 00:00:00.000
 A stub doesn't actually do all of the work.

00:00:00.000 --> 00:00:00.000
 All it does is get the mechanical parts out of the way.

00:00:00.000 --> 00:00:00.000
 The reason you start with this first draft skeleton

00:00:00.000 --> 00:00:00.000
 is because you want to get the, again, the mechanical parts,

00:00:00.000 --> 00:00:00.000
 the part that you can memorize, you want that to be second nature,

00:00:00.000 --> 00:00:00.000
 just like driving a stick shift.

00:00:00.000 --> 00:00:00.000
 You want the shifting and using the clutch and so forth to be second nature.

00:00:00.000 --> 00:00:00.000
 And so that's what a stub is.

00:00:00.000 --> 00:00:00.000
 So here are the six questions we need to ask.

00:00:00.000 --> 00:00:00.000
 We need to ask first what kind of thing the function returns,

00:00:00.000 --> 00:00:00.000
 and write that down first.

00:00:00.000 --> 00:00:00.000
 In this case, last digit is going to return an int.

00:00:00.000 --> 00:00:00.000
 Secondly, we need to put in the name of the function.

00:00:00.000 --> 00:00:00.000
 Now, if we spell last digit with a lowercase d here,

00:00:00.000 --> 00:00:00.000
 it's not going to work, because our testing, or our client program,

00:00:00.000 --> 00:00:00.000
 is going to be calling the last digit function spelled exactly the way that is.

00:00:00.000 --> 00:00:00.000
 Third, we're going to put the input variable declaration,

00:00:00.000 --> 00:00:00.000
 the parameter declaration, inside parentheses following that.

00:00:00.000 --> 00:00:00.000
 And so these three parts, one, two, and three,

00:00:00.000 --> 00:00:00.000
 is going to create the interface for the function,

00:00:00.000 --> 00:00:00.000
 the part that describes it to the compiler.

00:00:00.000 --> 00:00:00.000
 The next part is going to create the body,

00:00:00.000 --> 00:00:00.000
 or the implementation of the function.

00:00:00.000 --> 00:00:00.000
 So you add braces to surround the function body.

00:00:00.000 --> 00:00:00.000
 Then, don't think at all about what the program is going to do.

00:00:00.000 --> 00:00:00.000
 Don't think at all about what the function is supposed to do.

00:00:00.000 --> 00:00:00.000
 Think about what kind of thing it is going to produce.

00:00:00.000 --> 00:00:00.000
 And so create a variable for the output, the result,

00:00:00.000 --> 00:00:00.000
 and initialize it, just a nothing, to an empty value, to zero.

00:00:00.000 --> 00:00:00.000
 Finally, return the result.

00:00:00.000 --> 00:00:00.000
 Then, once you make sure that compiles it and links,

00:00:00.000 --> 00:00:00.000
 you can test the program, and we can go in and complete it.

00:00:00.000 --> 00:00:00.000
 So let's walk through these steps so you can see them together.

00:00:00.000 --> 00:00:00.000
 So here's our function, lastDigit.

00:00:00.000 --> 00:00:00.000
 The first question is, what kind of thing that returns?

00:00:00.000 --> 00:00:00.000
 Well, it returns an int, so you just write that down.

00:00:00.000 --> 00:00:00.000
 Then we put in the name, lastDigit.

00:00:00.000 --> 00:00:00.000
 Then we put in the parameter.

00:00:00.000 --> 00:00:00.000
 Now this is going to take a digit.

00:00:00.000 --> 00:00:00.000
 It's going to be an int, so it's going to take a number.

00:00:00.000 --> 00:00:00.000
 So I'm going to say int number.

00:00:00.000 --> 00:00:00.000
 Notice this is what a parameter declaration looks like.

00:00:00.000 --> 00:00:00.000
 Just like a regular variable declaration,

00:00:00.000 --> 00:00:00.000
 except we don't put a semicolon there.

00:00:00.000 --> 00:00:00.000
 So int number.

00:00:00.000 --> 00:00:00.000
 So we did step one, two, and three.

00:00:00.000 --> 00:00:00.000
 The return type, what comes out, the name of the function,

00:00:00.000 --> 00:00:00.000
 and what goes into the function, the parameter declarations.

00:00:00.000 --> 00:00:00.000
 Step four is to create the implementation, the body.

00:00:00.000 --> 00:00:00.000
 Step five is to create the output.

00:00:00.000 --> 00:00:00.000
 So this is going to be an int.

00:00:00.000 --> 00:00:00.000
 So we're going to create the result.

00:00:00.000 --> 00:00:00.000
 We're going to initialize it to zero.

00:00:00.000 --> 00:00:00.000
 You can do it like that.

00:00:00.000 --> 00:00:00.000
 You can do it like that.

00:00:00.000 --> 00:00:00.000
 Either one of those is fine.

00:00:00.000 --> 00:00:00.000
 What you can't do is that.

00:00:00.000 --> 00:00:00.000
 If you do that, you have a random result.

00:00:00.000 --> 00:00:00.000
 You don't want to do that.

00:00:00.000 --> 00:00:00.000
 So we'll say int result, set it to zero.

00:00:00.000 --> 00:00:00.000
 And then step six, we're going to return the result.

00:00:00.000 --> 00:00:00.000
 Okay, so now we have our skeleton.

00:00:00.000 --> 00:00:00.000
 Let's test the skeleton to make sure it worked.

00:00:00.000 --> 00:00:00.000
 We're going to go over here.

00:00:00.000 --> 00:00:00.000
 We're going to open an integrated folder on A.

00:00:00.000 --> 00:00:00.000
 So now you notice that is switched to A.

00:00:00.000 --> 00:00:00.000
 I'm going to go here and I'm going to do make test.

00:00:00.000 --> 00:00:00.000
 Now you might be unhappy that you've got no points.

00:00:00.000 --> 00:00:00.000
 You should not be.

00:00:00.000 --> 00:00:00.000
 You should not be unhappy because what you've done is you've done all of the mechanical parts.

00:00:00.000 --> 00:00:00.000
 If it didn't compile at this point,

00:00:00.000 --> 00:00:00.000
 you'd know that you'd made some mistake in your stub, in your skeleton.

00:00:00.000 --> 00:00:00.000
 And you could concentrate on getting that right without worrying about what makes the program work.

00:00:00.000 --> 00:00:00.000
 So that's the whole beauty of this.

00:00:00.000 --> 00:00:00.000
 Create the mechanical part first and then do the stub.

00:00:00.000 --> 00:00:00.000
 So at one point you're concentrating on the syntax, getting that right.

00:00:00.000 --> 00:00:00.000
 The second point you're concentrating on figuring out how to get the program to work.

00:00:00.000 --> 00:00:00.000
 So let's think about how we get this program to work.

00:00:00.000 --> 00:00:00.000
 If we have a number, 35, 7, 67, I want the last digit here.

00:00:00.000 --> 00:00:00.000
 How do I get that 7 right there?

00:00:00.000 --> 00:00:00.000
 Well I get the 7 by taking, dividing the number by 10 and getting the remainder.

00:00:00.000 --> 00:00:00.000
 If I divide the number by 10, I get 356.

00:00:00.000 --> 00:00:00.000
 If I get the remainder, I get the 7 that's left over.

00:00:00.000 --> 00:00:00.000
 So I'm just going to set result equals number, remainder, 10.

00:00:00.000 --> 00:00:00.000
 And I'm going to try that again.

00:00:00.000 --> 00:00:00.000
 OK, let's clear the terminal with control L.

00:00:00.000 --> 00:00:00.000
 Let's do make test.

00:00:00.000 --> 00:00:00.000
 Oh, much better, I got 90.

00:00:00.000 --> 00:00:00.000
 But I have one of these tests that is failing here.

00:00:00.000 --> 00:00:00.000
 It's obvious why it's failing.

00:00:00.000 --> 00:00:00.000
 It's failing because I'm getting -7 here.

00:00:00.000 --> 00:00:00.000
 And so remember I told you that we could use this absolute value function for integers from there.

00:00:00.000 --> 00:00:00.000
 And so we're just going to put the absolute value of number, remainder, 10 into the argument there.

00:00:00.000 --> 00:00:00.000
 And we're going to make test once again.

00:00:00.000 --> 00:00:00.000
 And we have 100%.

00:00:00.000 --> 00:00:00.000
 When you're doing this, try to do it step by step as I've just showed you.

00:00:00.000 --> 00:00:00.000
 Don't start at the top and simply try and type out the answer from the beginning and end.

00:00:00.000 --> 00:00:00.000
 Do it in chunks like this.

00:00:00.000 --> 00:00:00.000
 Build the stub.

00:00:00.000 --> 00:00:00.000
 Make sure the mechanics work.

00:00:00.000 --> 00:00:00.000
 Do the simplest thing that will possibly work.

00:00:00.000 --> 00:00:00.000
 Result equals number, remainder, 10.

00:00:00.000 --> 00:00:00.000
 Then fix up the parts that don't work.

00:00:00.000 --> 00:00:00.000
 Do it incrementally.

00:00:00.000 --> 00:00:00.000
 That will really help you.

00:00:00.000 --> 00:00:00.000
 Now let's start talking about decisions.

00:00:00.000 --> 00:00:00.000
 So if you were writing a programming language, what parts do you need?

00:00:00.000 --> 00:00:00.000
 What features are required?

00:00:00.000 --> 00:00:00.000
 So you can write any programming language using three control structures.

00:00:00.000 --> 00:00:00.000
 This is from a paper that was written back in 1966 by Bohm and Jacopini.

00:00:00.000 --> 00:00:00.000
 So we have been writing programs so far using only one control structure - sequence.

00:00:00.000 --> 00:00:00.000
 That means we did our prompt, then our input, then our processing, then our output.

00:00:00.000 --> 00:00:00.000
 The statements were in order - the first, the second, the third, and so forth.

00:00:00.000 --> 00:00:00.000
 So that's what we've been doing with IPO programs.

00:00:00.000 --> 00:00:00.000
 The second kind of sequence, or the second kind of control structure that we're going to work on now, is called selection.

00:00:00.000 --> 00:00:00.000
 That's conditional execution with an if statement.

00:00:00.000 --> 00:00:00.000
 This is also sometimes called branching.

00:00:00.000 --> 00:00:00.000
 And then we're going to move on and look at iteration.

00:00:00.000 --> 00:00:00.000
 That's while looping.

00:00:00.000 --> 00:00:00.000
 So today we're going to start with selection.

00:00:00.000 --> 00:00:00.000
 Now to make a decision, we first have to think about conditions.

00:00:00.000 --> 00:00:00.000
 So decision making in C++ is based on these three foundations.

00:00:00.000 --> 00:00:00.000
 First, the built-in bool type returns true and false.

00:00:00.000 --> 00:00:00.000
 In Java this is called the boolean type.

00:00:00.000 --> 00:00:00.000
 I think in Python it's called bool as well.

00:00:00.000 --> 00:00:00.000
 Second, but in Python the true and false values are capital true and capital false.

00:00:00.000 --> 00:00:00.000
 In Java they're true and false, lowercase, like this.

00:00:00.000 --> 00:00:00.000
 Secondly, we have a group of operators called relational operators.

00:00:00.000 --> 00:00:00.000
 The relational operators compare values of any type, and they produce a boolean result.

00:00:00.000 --> 00:00:00.000
 Or a true/false result.

00:00:00.000 --> 00:00:00.000
 Finally, we have the logical operators.

00:00:00.000 --> 00:00:00.000
 The logical operators operate not on any kind of value, but only on boolean expressions, or true/false expressions.

00:00:00.000 --> 00:00:00.000
 And they combine them or negate them.

00:00:00.000 --> 00:00:00.000
 So the relational operators are operators like less than, greater than, greater than or equal, less than or equal, and equal.

00:00:00.000 --> 00:00:00.000
 And the logical operators are the operators and, and, or, and, not.

00:00:00.000 --> 00:00:00.000
 Now unfortunately, in C++ truthiness is a little bit more flexible than you might expect if you come from Python or if you come from Java.

00:00:00.000 --> 00:00:00.000
 So here's the problem, and I'm going to walk you through several different pitfalls.

00:00:00.000 --> 00:00:00.000
 Now, as with numbers, C++ has implicit bool conversions.

00:00:00.000 --> 00:00:00.000
 Now, Java has implicit numeric conversions.

00:00:00.000 --> 00:00:00.000
 In other words, it will automatically convert an int to a double, and you don't have to write a cast or anything like that.

00:00:00.000 --> 00:00:00.000
 But C++ will convert a number to a true/false value.

00:00:00.000 --> 00:00:00.000
 Something that Java won't do, and Python won't do.

00:00:00.000 --> 00:00:00.000
 So, if you have a number, and if the expression is false, if the number is anything other than zero, it is true.

00:00:00.000 --> 00:00:00.000
 If the number is zero, it's considered false.

00:00:00.000 --> 00:00:00.000
 So numbers and boolean values are implicitly converted.

00:00:00.000 --> 00:00:00.000
 Suppose I have a number, three, or a variable, a, that is a number.

00:00:00.000 --> 00:00:00.000
 And I want to assign that to a bool.

00:00:00.000 --> 00:00:00.000
 Well, if the number was zero, the bool variable will take on the value false.

00:00:00.000 --> 00:00:00.000
 If it's anything other than zero, a negative number or a positive number, it will be true.

00:00:00.000 --> 00:00:00.000
 Now, suppose I then take that bool variable, and I assign it to a number variable.

00:00:00.000 --> 00:00:00.000
 No matter what the number variable originally was, now if the bool was false, the number will be zero.

00:00:00.000 --> 00:00:00.000
 If the bool was true, the number will be one.

00:00:00.000 --> 00:00:00.000
 Now, in Java, if you print out a boolean variable, you'll get true and false.

00:00:00.000 --> 00:00:00.000
 The same thing is not true in C++.

00:00:00.000 --> 00:00:00.000
 In C++, the default is to print out zero and one.

00:00:00.000 --> 00:00:00.000
 Zero for false, one for true.

00:00:00.000 --> 00:00:00.000
 So if I print out a boolean variable, it will print out zero or one.

00:00:00.000 --> 00:00:00.000
 You can change that by using a manipulator.

00:00:00.000 --> 00:00:00.000
 You remember the manipulators we used for fix and set precision?

00:00:00.000 --> 00:00:00.000
 There's a bool alpha manipulator.

00:00:00.000 --> 00:00:00.000
 If you do that, it will use true and false, just like Java does.

00:00:00.000 --> 00:00:00.000
 So what are the pitfalls of this fact that numbers and boolean values are implicitly convertible?

00:00:00.000 --> 00:00:00.000
 Here's the first pitfall, an embedded assignment.

00:00:00.000 --> 00:00:00.000
 In Java, if we wrote this statement, if area equals zero,

00:00:00.000 --> 00:00:00.000
 now notice that I have the assignment operator there, not the equality operator.

00:00:00.000 --> 00:00:00.000
 In Java, Java would say, "Eh, that's not a boolean value.

00:00:00.000 --> 00:00:00.000
 You've made a mistake in your if statement."

00:00:00.000 --> 00:00:00.000
 In C++, it will actually assign zero to area,

00:00:00.000 --> 00:00:00.000
 and then when the if statement tries to go and evaluate, it'll say,

00:00:00.000 --> 00:00:00.000
 "Oh, I don't have a boolean here, but I have a number,

00:00:00.000 --> 00:00:00.000
 and I can convert that number to a boolean, and so this would be false."

00:00:00.000 --> 00:00:00.000
 If you assign a non-zero, then the condition is considered true.

00:00:00.000 --> 00:00:00.000
 Again, you're not told about this problem.

00:00:00.000 --> 00:00:00.000
 There is no warning.

00:00:00.000 --> 00:00:00.000
 Java, of course, will protect you from this, and C# will protect you from this.

00:00:00.000 --> 00:00:00.000
 They'll protect you from this as long as you're not comparing a boolean value to--

00:00:00.000 --> 00:00:00.000
 or a boolean variable to true and false, in which case you'll have the same problem.

00:00:00.000 --> 00:00:00.000
 So here's a question.

00:00:00.000 --> 00:00:00.000
 Let me ask you this.

00:00:00.000 --> 00:00:00.000
 I'll give you a few seconds.

00:00:00.000 --> 00:00:00.000
 Pause the screen and see if you can answer it, and then I'll talk about it.

00:00:00.000 --> 00:00:00.000
 Okay, so if a equals 3, if a equals 4, a is 4, which is weird,

00:00:00.000 --> 00:00:00.000
 because I just set it to 3, else a is not 4.

00:00:00.000 --> 00:00:00.000
 What prints?

00:00:00.000 --> 00:00:00.000
 a.

00:00:00.000 --> 00:00:00.000
 a is 4, weird.

00:00:00.000 --> 00:00:00.000
 b. a is not 4.

00:00:00.000 --> 00:00:00.000
 That's a syntax error.

00:00:00.000 --> 00:00:00.000
 It won't compile.

00:00:00.000 --> 00:00:00.000
 And d. neither one.

00:00:00.000 --> 00:00:00.000
 So pause for a few seconds and then come back, and we'll answer it.

00:00:00.000 --> 00:00:00.000
 Okay, welcome back.

00:00:00.000 --> 00:00:00.000
 So here I have an embedded assignment instead of a comparison.

00:00:00.000 --> 00:00:00.000
 When you read it, it says if a equals 4, of course it's not 4, it's 3,

00:00:00.000 --> 00:00:00.000
 so I'll go into the else and print a is not 4.

00:00:00.000 --> 00:00:00.000
 In fact, this assigns 4 to a, and then because that is nonzero,

00:00:00.000 --> 00:00:00.000
 the if statement considers it true.

00:00:00.000 --> 00:00:00.000
 And so we go into the truth part, and a prints out.

00:00:00.000 --> 00:00:00.000
 a is 4, weird.

00:00:00.000 --> 00:00:00.000
 So one of the pitfalls of convertibility between bools and numbers in C++.

00:00:00.000 --> 00:00:00.000
 Let me show you a couple other conditional pitfalls.

00:00:00.000 --> 00:00:00.000
 When you use the logical operators and and or,

00:00:00.000 --> 00:00:00.000
 it's possible to have both an impossible and an unavoidable condition.

00:00:00.000 --> 00:00:00.000
 The impossible condition is when you use and.

00:00:00.000 --> 00:00:00.000
 And if you use and, in this case,

00:00:00.000 --> 00:00:00.000
 I'm checking to see if a person is between 13 and 65,

00:00:00.000 --> 00:00:00.000
 but in fact that's not what I've written.

00:00:00.000 --> 00:00:00.000
 This is an impossible condition,

00:00:00.000 --> 00:00:00.000
 because the variable age cannot both be less than 13 and greater than 65.

00:00:00.000 --> 00:00:00.000
 It cannot be both of those.

00:00:00.000 --> 00:00:00.000
 Now we use the term and.

00:00:00.000 --> 00:00:00.000
 Make sure that person is under 13 and greater than 65.

00:00:00.000 --> 00:00:00.000
 We wouldn't say that.

00:00:00.000 --> 00:00:00.000
 However, we do use the term and and or kind of interchangeably in our informal speech.

00:00:00.000 --> 00:00:00.000
 And so you need to make sure every time you use and and or

00:00:00.000 --> 00:00:00.000
 that you double check to make sure you have a condition with and

00:00:00.000 --> 00:00:00.000
 that it's possible for all conditions to be true simultaneously.

00:00:00.000 --> 00:00:00.000
 This condition will always be false.

00:00:00.000 --> 00:00:00.000
 It's impossible.

00:00:00.000 --> 00:00:00.000
 Similarly, if you use or,

00:00:00.000 --> 00:00:00.000
 make sure it's possible for all conditions to be false simultaneously.

00:00:00.000 --> 00:00:00.000
 This condition here,

00:00:00.000 --> 00:00:00.000
 when you read it to yourself,

00:00:00.000 --> 00:00:00.000
 if age is greater than 13 or age is less than 65,

00:00:00.000 --> 00:00:00.000
 do something.

00:00:00.000 --> 00:00:00.000
 We read that kind of informally and it makes sense to us.

00:00:00.000 --> 00:00:00.000
 But we don't realize that every age must be either greater than 13 or less than 65.

00:00:00.000 --> 00:00:00.000
 There is no age that doesn't meet that condition.

00:00:00.000 --> 00:00:00.000
 So it's unavoidable.

00:00:00.000 --> 00:00:00.000
 Finally, because of this implicit conversion to Boolean,

00:00:00.000 --> 00:00:00.000
 it's very, very important to remember to always use complete relational expressions in conditions.

00:00:00.000 --> 00:00:00.000
 This is not a syntax error,

00:00:00.000 --> 00:00:00.000
 and it especially bites people who are Python programmers.

00:00:00.000 --> 00:00:00.000
 So we would read this if age is equal to 12 or 13 or 14,

00:00:00.000 --> 00:00:00.000
 and that would make sense to us when we read it.

00:00:00.000 --> 00:00:00.000
 But the compiler reads it if age equals 12,

00:00:00.000 --> 00:00:00.000
 now that's false,

00:00:00.000 --> 00:00:00.000
 or 13.

00:00:00.000 --> 00:00:00.000
 Well, we're not saying age equals equals 13.

00:00:00.000 --> 00:00:00.000
 We're just saying 13.

00:00:00.000 --> 00:00:00.000
 And remember the Boolean operators and and or operate on Boolean expressions.

00:00:00.000 --> 00:00:00.000
 So 13, even though it's a number here,

00:00:00.000 --> 00:00:00.000
 is treated as a Boolean expression.

00:00:00.000 --> 00:00:00.000
 It's not 0, therefore it's true.

00:00:00.000 --> 00:00:00.000
 So this is if false or true, and it's always true.

00:00:00.000 --> 00:00:00.000
 No matter what you do, no matter what value age it has,

00:00:00.000 --> 00:00:00.000
 this expression will always be true.

00:00:00.000 --> 00:00:00.000
 Let me give you another little quick check here.

00:00:00.000 --> 00:00:00.000
 We have a string grade set to C.

00:00:00.000 --> 00:00:00.000
 If grade equals equals A or A plus or A minus,

00:00:00.000 --> 00:00:00.000
 C out got an A.

00:00:00.000 --> 00:00:00.000
 Else if grade equals B or B plus or B minus,

00:00:00.000 --> 00:00:00.000
 C out got a B.

00:00:00.000 --> 00:00:00.000
 Else if grade equals C or C plus or C minus,

00:00:00.000 --> 00:00:00.000
 C out got a C.

00:00:00.000 --> 00:00:00.000
 What prints, assuming we have all the string includes and everything,

00:00:00.000 --> 00:00:00.000
 does it print got an A, got a B, got a C, or a syntax error?

00:00:00.000 --> 00:00:00.000
 So pause the video here, think about it, write down your answer,

00:00:00.000 --> 00:00:00.000
 and when you come back I'll answer it.

00:00:00.000 --> 00:00:00.000
 OK, welcome back.

00:00:00.000 --> 00:00:00.000
 So this is the same problem we just talked about on the last slide.

00:00:00.000 --> 00:00:00.000
 This is a Boolean expression, a relational expression.

00:00:00.000 --> 00:00:00.000
 So grade equals equals A is false.

00:00:00.000 --> 00:00:00.000
 Now the grade is not equal to A plus,

00:00:00.000 --> 00:00:00.000
 but this is not saying if grade equals equals A plus.

00:00:00.000 --> 00:00:00.000
 That is saying true.

00:00:00.000 --> 00:00:00.000
 It's not zero, it's true.

00:00:00.000 --> 00:00:00.000
 And so this is false or true, that whole expression is true,

00:00:00.000 --> 00:00:00.000
 so this will always print out got an A.

00:00:00.000 --> 00:00:00.000
 Let's look at another pitfall with comparison operators.

00:00:00.000 --> 00:00:00.000
 So here I've called the square root function

00:00:00.000 --> 00:00:00.000
 and stored the result in the variable root.

00:00:00.000 --> 00:00:00.000
 Now I'm taking the square root of 2,

00:00:00.000 --> 00:00:00.000
 and so if I multiply root times root,

00:00:00.000 --> 00:00:00.000
 I should get the square of 2,

00:00:00.000 --> 00:00:00.000
 or the square of the square root of 2,

00:00:00.000 --> 00:00:00.000
 or I should get 2.

00:00:00.000 --> 00:00:00.000
 And so this should print out OK.

00:00:00.000 --> 00:00:00.000
 Now this is syntactically comparable,

00:00:00.000 --> 00:00:00.000
 so I can compare this real number to this real number,

00:00:00.000 --> 00:00:00.000
 but if you simply write it down the way you learned it in mathematics,

00:00:00.000 --> 00:00:00.000
 you will get the wrong answer.

00:00:00.000 --> 00:00:00.000
 This will in fact print out back to Math 30,

00:00:00.000 --> 00:00:00.000
 because these answers will not exactly be 2.

00:00:00.000 --> 00:00:00.000
 And so there is no perfect solution.

00:00:00.000 --> 00:00:00.000
 In general, there's no perfect solution,

00:00:00.000 --> 00:00:00.000
 because real numbers are designed to work with very, very small numbers,

00:00:00.000 --> 00:00:00.000
 like a coronavirus,

00:00:00.000 --> 00:00:00.000
 and very, very large numbers, like the distance to far galaxies.

00:00:00.000 --> 00:00:00.000
 And so we cannot just have some simple value

00:00:00.000 --> 00:00:00.000
 and say if it's this close, it's OK.

00:00:00.000 --> 00:00:00.000
 So in general, you have to decide, based on the problem,

00:00:00.000 --> 00:00:00.000
 what's close enough.

00:00:00.000 --> 00:00:00.000
 We call that the epsilon value.

00:00:00.000 --> 00:00:00.000
 So here's a very common one,

00:00:00.000 --> 00:00:00.000
 1e^-14 is about the biggest difference that can be decided between two doubles.

00:00:00.000 --> 00:00:00.000
 Then you take the two numbers, if you want to see if they're equal,

00:00:00.000 --> 00:00:00.000
 root times root,

00:00:00.000 --> 00:00:00.000
 subtract it from 2.0,

00:00:00.000 --> 00:00:00.000
 and take the absolute value of that.

00:00:00.000 --> 00:00:00.000
 And if the absolute value is less than this epsilon value,

00:00:00.000 --> 00:00:00.000
 then the numbers are equivalently equal.

00:00:00.000 --> 00:00:00.000
 Now this might seem like a lot of work,

00:00:00.000 --> 00:00:00.000
 but it's in fact what you have to do.

00:00:00.000 --> 00:00:00.000
 It's not only what you have to do in C++,

00:00:00.000 --> 00:00:00.000
 it's what you have to do in Java and Python as well.

00:00:00.000 --> 00:00:00.000
 You simply cannot compare real numbers using the relational operators

00:00:00.000 --> 00:00:00.000
 and expect to get back a meaningful answer in every single case.

00:00:00.000 --> 00:00:00.000
 So if you care about correctness,

00:00:00.000 --> 00:00:00.000
 you'll make sure that you do this.

00:00:00.000 --> 00:00:00.000
 OK, so that's the Boolean type and some pitfalls with the Boolean type.

00:00:00.000 --> 00:00:00.000
 Let's go ahead and look at selection, so if statements.

00:00:00.000 --> 00:00:00.000
 Why do we want to use if statements in our code?

00:00:00.000 --> 00:00:00.000
 We use selection to control the flow of data.

00:00:00.000 --> 00:00:00.000
 We want to select a particular value or kind of value from a data flow.

00:00:00.000 --> 00:00:00.000
 For instance, we're getting all the transactions from a gas pump.

00:00:00.000 --> 00:00:00.000
 We want to select the debits or the credits.

00:00:00.000 --> 00:00:00.000
 How much do they owe us? How much did they pay us?

00:00:00.000 --> 00:00:00.000
 We do that with an if statement.

00:00:00.000 --> 00:00:00.000
 Now while this data is going by,

00:00:00.000 --> 00:00:00.000
 we may want to selectively update a counter or an accumulator.

00:00:00.000 --> 00:00:00.000
 We're looking at a string, and we want to count the vowels and the consonants.

00:00:00.000 --> 00:00:00.000
 We need to use an if statement to determine which counter to update.

00:00:00.000 --> 00:00:00.000
 We want to reduce root data to correct part of a program

00:00:00.000 --> 00:00:00.000
 in response to user commands or to input.

00:00:00.000 --> 00:00:00.000
 Oh, I got a credit in.

00:00:00.000 --> 00:00:00.000
 I want to send it to the part of the programs that processes a credit.

00:00:00.000 --> 00:00:00.000
 Oh, they checked three on the menu.

00:00:00.000 --> 00:00:00.000
 I want to go to the action that corresponds to three on the menu.

00:00:00.000 --> 00:00:00.000
 And finally, we use selection to error check data.

00:00:00.000 --> 00:00:00.000
 If the data that comes in is not within the bounds,

00:00:00.000 --> 00:00:00.000
 we would process it to a--we would send it to a place that would correct it.

00:00:00.000 --> 00:00:00.000
 So we'll use error checking.

00:00:00.000 --> 00:00:00.000
 We use selection to control error checking.

00:00:00.000 --> 00:00:00.000
 The important thing to realize about this is that selection produces information.

00:00:00.000 --> 00:00:00.000
 Selection is back to our old friend input, processing, and output.

00:00:00.000 --> 00:00:00.000
 When you come to a selection statement,

00:00:00.000 --> 00:00:00.000
 you have raw information before the selection statement--

00:00:00.000 --> 00:00:00.000
 raw data before the selection statement.

00:00:00.000 --> 00:00:00.000
 After the selection statement, things have changed.

00:00:00.000 --> 00:00:00.000
 You know some more information.

00:00:00.000 --> 00:00:00.000
 You know that I've found one more vowel

00:00:00.000 --> 00:00:00.000
 or that I've added something to the amount that the user has paid.

00:00:00.000 --> 00:00:00.000
 So selection produces information just like an IPO program.

00:00:00.000 --> 00:00:00.000
 Input, processing, and output is the basic function that all computing is based on.

00:00:00.000 --> 00:00:00.000
 Okay, so let's look at the six selection structures we have in C++.

00:00:00.000 --> 00:00:00.000
 We have one-way independent if statements.

00:00:00.000 --> 00:00:00.000
 So if this is true, do that or then do that.

00:00:00.000 --> 00:00:00.000
 We have two-way or either/or actions.

00:00:00.000 --> 00:00:00.000
 So this is--if this is true, do that; otherwise or else, do that.

00:00:00.000 --> 00:00:00.000
 We have sequential dependent if statements.

00:00:00.000 --> 00:00:00.000
 So if this is true, do that; else, if this is true, do that;

00:00:00.000 --> 00:00:00.000
 else, if neither of those are true, do the third thing.

00:00:00.000 --> 00:00:00.000
 We have nested or leveled decisions.

00:00:00.000 --> 00:00:00.000
 If A is true and if B is true, do something;

00:00:00.000 --> 00:00:00.000
 else, if A is true and B is false, do something else;

00:00:00.000 --> 00:00:00.000
 else, if A is false and B is true, do something;

00:00:00.000 --> 00:00:00.000
 else, if A is false and B is false, do something else.

00:00:00.000 --> 00:00:00.000
 Nested or leveled decision making.

00:00:00.000 --> 00:00:00.000
 We have labeled integral tests.

00:00:00.000 --> 00:00:00.000
 This is called the switch structure.

00:00:00.000 --> 00:00:00.000
 And finally, we have a selection expression.

00:00:00.000 --> 00:00:00.000
 This is called the conditional operator.

00:00:00.000 --> 00:00:00.000
 So we do a test.

00:00:00.000 --> 00:00:00.000
 If the test is true, this value is assigned to val.

00:00:00.000 --> 00:00:00.000
 If the test is false, this value is assigned to val.

00:00:00.000 --> 00:00:00.000
 Now, in looking at these six kinds of selection structures,

00:00:00.000 --> 00:00:00.000
 you have to understand that they're not all designed

00:00:00.000 --> 00:00:00.000
 to do exactly the same thing.

00:00:00.000 --> 00:00:00.000
 We have a rubric to decide which one is the right one to use.

00:00:00.000 --> 00:00:00.000
 The first rubric is we want to make sure that

00:00:00.000 --> 00:00:00.000
 whichever selection structure we use,

00:00:00.000 --> 00:00:00.000
 it produces the correct output.

00:00:00.000 --> 00:00:00.000
 That's kind of the non...we can't argue with that.

00:00:00.000 --> 00:00:00.000
 It has to produce the correct output.

00:00:00.000 --> 00:00:00.000
 The second thing we want to do is we want to make sure

00:00:00.000 --> 00:00:00.000
 that whichever selection structure we use,

00:00:00.000 --> 00:00:00.000
 that the code we produce is understandable

00:00:00.000 --> 00:00:00.000
 and it's maintainable, meaning when you come back to it,

00:00:00.000 --> 00:00:00.000
 you can change it and the code still works correctly.

00:00:00.000 --> 00:00:00.000
 You can understand it and maintain it.

00:00:00.000 --> 00:00:00.000
 Thirdly, we want to make sure we use the correct semantics.

00:00:00.000 --> 00:00:00.000
 Each of these statements says something

00:00:00.000 --> 00:00:00.000
 to a programmer who understands programming.

00:00:00.000 --> 00:00:00.000
 And so it's like learning an idiom in a new language.

00:00:00.000 --> 00:00:00.000
 If you're speaking French, there are idioms

00:00:00.000 --> 00:00:00.000
 that are French idioms.

00:00:00.000 --> 00:00:00.000
 You want to learn the idioms so when you say them,

00:00:00.000 --> 00:00:00.000
 the French speakers will understand you.

00:00:00.000 --> 00:00:00.000
 The same way with programming.

00:00:00.000 --> 00:00:00.000
 If you use a one-way independent if statement,

00:00:00.000 --> 00:00:00.000
 you may get all of your code correct.

00:00:00.000 --> 00:00:00.000
 It may be understandable and maintainable,

00:00:00.000 --> 00:00:00.000
 but it's not saying what you think it's saying,

00:00:00.000 --> 00:00:00.000
 even if it produces the correct output.

00:00:00.000 --> 00:00:00.000
 So using the correct semantics means using

00:00:00.000 --> 00:00:00.000
 the correct kind of selection structure

00:00:00.000 --> 00:00:00.000
 for the situation you're in.

00:00:00.000 --> 00:00:00.000
 And only then, after we've done those three,

00:00:00.000 --> 00:00:00.000
 do we want to fall back and think about,

00:00:00.000 --> 00:00:00.000
 "Oh, I want to make sure that this code is efficient

00:00:00.000 --> 00:00:00.000
 as it possibly could be."

00:00:00.000 --> 00:00:00.000
 Okay, so let's look at which one is the correct one

00:00:00.000 --> 00:00:00.000
 to use in each situation.

00:00:00.000 --> 00:00:00.000
 Imagine that you're writing the code that is going to process

00:00:00.000 --> 00:00:00.000
 this dialog box over here.

00:00:00.000 --> 00:00:00.000
 Notice it has these check boxes.

00:00:00.000 --> 00:00:00.000
 These check boxes mean that I could select one

00:00:00.000 --> 00:00:00.000
 or all of them or none of them.

00:00:00.000 --> 00:00:00.000
 So the decisions and what happens

00:00:00.000 --> 00:00:00.000
 based on that decision is truly independent.

00:00:00.000 --> 00:00:00.000
 When this happens, the only way to write these,

00:00:00.000 --> 00:00:00.000
 you can't use if/else, you can't use if/else/if,

00:00:00.000 --> 00:00:00.000
 you must use independent ifs.

00:00:00.000 --> 00:00:00.000
 So if the startup task pane is checked,

00:00:00.000 --> 00:00:00.000
 we're going to do whatever action is required for that.

00:00:00.000 --> 00:00:00.000
 That has nothing to do with whether

00:00:00.000 --> 00:00:00.000
 the layout was checked

00:00:00.000 --> 00:00:00.000
 or any of the other ones were checked.

00:00:00.000 --> 00:00:00.000
 And so independent ifs are the correct way to do this.

00:00:00.000 --> 00:00:00.000
 This is called the "guarded action" idiom.

00:00:00.000 --> 00:00:00.000
 In other words, we're only doing the action

00:00:00.000 --> 00:00:00.000
 if we pass the test at the start of the action.

00:00:00.000 --> 00:00:00.000
 The test condition is guarding

00:00:00.000 --> 00:00:00.000
 the action that we're doing.

00:00:00.000 --> 00:00:00.000
 This is the only case

00:00:00.000 --> 00:00:00.000
 that you should ever use independent ifs.

00:00:00.000 --> 00:00:00.000
 If this situation is not true,

00:00:00.000 --> 00:00:00.000
 using independent ifs is the wrong

00:00:00.000 --> 00:00:00.000
 semantics for that case.

00:00:00.000 --> 00:00:00.000
 So let's look at another one.

00:00:00.000 --> 00:00:00.000
 And beginning programmers, they learn the if statement

00:00:00.000 --> 00:00:00.000
 and they try and use the if statement,

00:00:00.000 --> 00:00:00.000
 the independent if statement, for everything.

00:00:00.000 --> 00:00:00.000
 What happens if you have an either/or decision

00:00:00.000 --> 00:00:00.000
 or a two-way branch?

00:00:00.000 --> 00:00:00.000
 For this, we want to use the

00:00:00.000 --> 00:00:00.000
 else statement. The reason we want to use

00:00:00.000 --> 00:00:00.000
 the else statement is because it covers all

00:00:00.000 --> 00:00:00.000
 possibilities. In other words, for

00:00:00.000 --> 00:00:00.000
 every possible input, you want to put it

00:00:00.000 --> 00:00:00.000
 in bucket A or bucket B.

00:00:00.000 --> 00:00:00.000
 If you try doing this with

00:00:00.000 --> 00:00:00.000
 independent if statements, you will

00:00:00.000 --> 00:00:00.000
 make a mistake when you write the second if statement

00:00:00.000 --> 00:00:00.000
 eventually. And that mistake will

00:00:00.000 --> 00:00:00.000
 either allow you to skip some inputs

00:00:00.000 --> 00:00:00.000
 or it will allow you to put an input

00:00:00.000 --> 00:00:00.000
 in both buckets, which you don't want

00:00:00.000 --> 00:00:00.000
 to do. So think of the situation of

00:00:00.000 --> 00:00:00.000
 paying someone overtime

00:00:00.000 --> 00:00:00.000
 when they get... or paying time

00:00:00.000 --> 00:00:00.000
 and a half when someone gets overtime, more than

00:00:00.000 --> 00:00:00.000
 40 hours a week. If you do it with

00:00:00.000 --> 00:00:00.000
 independent if statements, you're likely to write

00:00:00.000 --> 00:00:00.000
 if hours is less than 40,

00:00:00.000 --> 00:00:00.000
 pay them normal time.

00:00:00.000 --> 00:00:00.000
 Else... or if hours is greater than 40,

00:00:00.000 --> 00:00:00.000
 pay them overtime.

00:00:00.000 --> 00:00:00.000
 Well, you've just skipped the people whose hours were exactly

00:00:00.000 --> 00:00:00.000
 40. If you go back and you realize

00:00:00.000 --> 00:00:00.000
 you've skipped some people,

00:00:00.000 --> 00:00:00.000
 if hours less than or equal

00:00:00.000 --> 00:00:00.000
 to 40, pay them normally. If hours

00:00:00.000 --> 00:00:00.000
 greater or equal to 40, pay them overtime.

00:00:00.000 --> 00:00:00.000
 You've just paid the overtime people twice.

00:00:00.000 --> 00:00:00.000
 So again, if you use if/else,

00:00:00.000 --> 00:00:00.000
 someone will either be in the normal bucket

00:00:00.000 --> 00:00:00.000
 or the overtime bucket, and they will never be

00:00:00.000 --> 00:00:00.000
 in both buckets. And so it will

00:00:00.000 --> 00:00:00.000
 skip you, it will avoid

00:00:00.000 --> 00:00:00.000
 you doing situations where that problem occurs.

00:00:00.000 --> 00:00:00.000
 So let's do an exercise. This is called

00:00:00.000 --> 00:00:00.000
 the double sum exercise.

00:00:00.000 --> 00:00:00.000
 Let's go back to our code space. I need to restart

00:00:00.000 --> 00:00:00.000
 my code space because it stopped while I was

00:00:00.000 --> 00:00:00.000
 talking to you guys.

00:00:00.000 --> 00:00:00.000
 Let's see how long this

00:00:00.000 --> 00:00:00.000
 takes to do it.

00:00:00.000 --> 00:00:00.000
 [silence]

00:00:00.000 --> 00:00:00.000
 Okay, we were in last digit,

00:00:00.000 --> 00:00:00.000
 so I'm going to close last digit. We're going to

00:00:00.000 --> 00:00:00.000
 go into B, and we're going to do

00:00:00.000 --> 00:00:00.000
 the double sum problem.

00:00:00.000 --> 00:00:00.000
 So let's look

00:00:00.000 --> 00:00:00.000
 at the problem here.

00:00:00.000 --> 00:00:00.000
 We're going to write a function, which

00:00:00.000 --> 00:00:00.000
 given two int arguments, returns a sum

00:00:00.000 --> 00:00:00.000
 unless the two values are the same, we're going to return

00:00:00.000 --> 00:00:00.000
 double the sum.

00:00:00.000 --> 00:00:00.000
 Okay, so let's put our

00:00:00.000 --> 00:00:00.000
 name on this one.

00:00:00.000 --> 00:00:00.000
 So this

00:00:00.000 --> 00:00:00.000
 is going to take two int arguments,

00:00:00.000 --> 00:00:00.000
 so it's going to return an int.

00:00:00.000 --> 00:00:00.000
 Its name is double sum.

00:00:00.000 --> 00:00:00.000
 It's going to take two parameters,

00:00:00.000 --> 00:00:00.000
 so int a and

00:00:00.000 --> 00:00:00.000
 int b.

00:00:00.000 --> 00:00:00.000
 We're going to put the body on it.

00:00:00.000 --> 00:00:00.000
 We're going to create the result.

00:00:00.000 --> 00:00:00.000
 [typing]

00:00:00.000 --> 00:00:00.000
 And we're going to return the result.

00:00:00.000 --> 00:00:00.000
 [typing]

00:00:00.000 --> 00:00:00.000
 And we're going to try it out to make sure we got it

00:00:00.000 --> 00:00:00.000
 correctly mechanically working.

00:00:00.000 --> 00:00:00.000
 So, right click, open a new integrated terminal.

00:00:00.000 --> 00:00:00.000
 Do make

00:00:00.000 --> 00:00:00.000
 test.

00:00:00.000 --> 00:00:00.000
 And it compiles

00:00:00.000 --> 00:00:00.000
 and runs correctly.

00:00:00.000 --> 00:00:00.000
 So we know we've got the mechanical parts.

00:00:00.000 --> 00:00:00.000
 Okay, so we want to say

00:00:00.000 --> 00:00:00.000
 two things here.

00:00:00.000 --> 00:00:00.000
 So if

00:00:00.000 --> 00:00:00.000
 a

00:00:00.000 --> 00:00:00.000
 is equal to b

00:00:00.000 --> 00:00:00.000
 I'm going to

00:00:00.000 --> 00:00:00.000
 set the result equal to

00:00:00.000 --> 00:00:00.000
 two times a plus b.

00:00:00.000 --> 00:00:00.000
 Else

00:00:00.000 --> 00:00:00.000
 I'm going to set the result

00:00:00.000 --> 00:00:00.000
 equal to a plus b.

00:00:00.000 --> 00:00:00.000
 Okay, so

00:00:00.000 --> 00:00:00.000
 this is relatively

00:00:00.000 --> 00:00:00.000
 straightforward.

00:00:00.000 --> 00:00:00.000
 It uses the correct semantics, if and else.

00:00:00.000 --> 00:00:00.000
 In other words, something a

00:00:00.000 --> 00:00:00.000
 either is equal to b or it's not equal to b.

00:00:00.000 --> 00:00:00.000
 And it's going to

00:00:00.000 --> 00:00:00.000
 go into one of these or the other.

00:00:00.000 --> 00:00:00.000
 So if we look back to our

00:00:00.000 --> 00:00:00.000
 four

00:00:00.000 --> 00:00:00.000
 rubric that we were looking at

00:00:00.000 --> 00:00:00.000
 to see if we've done it correctly.

00:00:00.000 --> 00:00:00.000
 We've seen that it produces the correct result.

00:00:00.000 --> 00:00:00.000
 And of course I'm going to check here to make sure it does produce the correct result.

00:00:00.000 --> 00:00:00.000
 So I'm going to do make test.

00:00:00.000 --> 00:00:00.000
 And yay,

00:00:00.000 --> 00:00:00.000
 we have 100%.

00:00:00.000 --> 00:00:00.000
 So it's pretty

00:00:00.000 --> 00:00:00.000
 understandable with if else.

00:00:00.000 --> 00:00:00.000
 I can see what's happening.

00:00:00.000 --> 00:00:00.000
 It's semantically correct. It's an either or decision.

00:00:00.000 --> 00:00:00.000
 It's not quite as efficient as I wanted.

00:00:00.000 --> 00:00:00.000
 So we could come back here, even though we have it done

00:00:00.000 --> 00:00:00.000
 correct and we're happy with it.

00:00:00.000 --> 00:00:00.000
 We might come back and say, you know, I don't like the fact that I'm calculating

00:00:00.000 --> 00:00:00.000
 a plus b twice.

00:00:00.000 --> 00:00:00.000
 I'm calculating a plus b twice.

00:00:00.000 --> 00:00:00.000
 And we could change that by

00:00:00.000 --> 00:00:00.000
 simply taking our initial result

00:00:00.000 --> 00:00:00.000
 and putting in a plus b.

00:00:00.000 --> 00:00:00.000
 Now we can

00:00:00.000 --> 00:00:00.000
 get rid of this else part all together.

00:00:00.000 --> 00:00:00.000
 Now I still

00:00:00.000 --> 00:00:00.000
 have an either or condition.

00:00:00.000 --> 00:00:00.000
 This is my else condition

00:00:00.000 --> 00:00:00.000
 and this is my if condition.

00:00:00.000 --> 00:00:00.000
 And so I don't have to say a plus b again.

00:00:00.000 --> 00:00:00.000
 I can say two times result like that.

00:00:00.000 --> 00:00:00.000
 So this is the initial value.

00:00:00.000 --> 00:00:00.000
 This is still an alternative action

00:00:00.000 --> 00:00:00.000
 even though I'm not using the else statement.

00:00:00.000 --> 00:00:00.000
 And it's somewhat more efficient.

00:00:00.000 --> 00:00:00.000
 Right? Somewhat more efficient.

00:00:00.000 --> 00:00:00.000
 It still has a slightly

00:00:00.000 --> 00:00:00.000
 it still has a slight chance

00:00:00.000 --> 00:00:00.000
 of error though. Remember our second

00:00:00.000 --> 00:00:00.000
 thing was to make sure it's maintainable.

00:00:00.000 --> 00:00:00.000
 What would that second chance of error be?

00:00:00.000 --> 00:00:00.000
 Well, because I'm using equals equals here, I'm

00:00:00.000 --> 00:00:00.000
 susceptible to doing that.

00:00:00.000 --> 00:00:00.000
 And if I do that, of course,

00:00:00.000 --> 00:00:00.000
 I break the first rule. Oh, actually I have the

00:00:00.000 --> 00:00:00.000
 warning set up so that

00:00:00.000 --> 00:00:00.000
 this will actually catch that.

00:00:00.000 --> 00:00:00.000
 As in C++ normally

00:00:00.000 --> 00:00:00.000
 it wouldn't catch that. So I have an extra warning set up

00:00:00.000 --> 00:00:00.000
 w error parenthesis

00:00:00.000 --> 00:00:00.000
 to catch that.

00:00:00.000 --> 00:00:00.000
 However, it's possible we couldn't catch that.

00:00:00.000 --> 00:00:00.000
 Right? It's possible we couldn't catch that.

00:00:00.000 --> 00:00:00.000
 And so

00:00:00.000 --> 00:00:00.000
 we might want to do something else.

00:00:00.000 --> 00:00:00.000
 We might want to write this if a not equal to b

00:00:00.000 --> 00:00:00.000
 result equals

00:00:00.000 --> 00:00:00.000
 a plus b

00:00:00.000 --> 00:00:00.000
 and then do the else part.

00:00:00.000 --> 00:00:00.000
 So I'm going to put that back the way I had it.

00:00:00.000 --> 00:00:00.000
 And I'm just going to rely

00:00:00.000 --> 00:00:00.000
 on the fact that my compiler here is catching that

00:00:00.000 --> 00:00:00.000
 so I don't have to worry about it.

00:00:00.000 --> 00:00:00.000
 OK,

00:00:00.000 --> 00:00:00.000
 let's go on to our next

00:00:00.000 --> 00:00:00.000
 kind of decision statement.

00:00:00.000 --> 00:00:00.000
 Our next kind of selection statement.

00:00:00.000 --> 00:00:00.000
 Multiway interdependent tests.

00:00:00.000 --> 00:00:00.000
 Now remember I said you should not

00:00:00.000 --> 00:00:00.000
 use if for

00:00:00.000 --> 00:00:00.000
 anything other than independent tests.

00:00:00.000 --> 00:00:00.000
 And in this case we have an

00:00:00.000 --> 00:00:00.000
 interdependent test. So if

00:00:00.000 --> 00:00:00.000
 percent greater than one

00:00:00.000 --> 00:00:00.000
 we get out of range. If percent is less than one we set

00:00:00.000 --> 00:00:00.000
 the result to a. If percent is less than ninety

00:00:00.000 --> 00:00:00.000
 we set the result to b. Set the result to c.

00:00:00.000 --> 00:00:00.000
 We set our result to 65. We're going to

00:00:00.000 --> 00:00:00.000
 set the result to d because this is true.

00:00:00.000 --> 00:00:00.000
 This one is false so we won't change it to f.

00:00:00.000 --> 00:00:00.000
 This one is also false so we won't change it

00:00:00.000 --> 00:00:00.000
 out of range. So we'll set the result to 65.

00:00:00.000 --> 00:00:00.000
 However, the test order

00:00:00.000 --> 00:00:00.000
 is significant. So notice I've just

00:00:00.000 --> 00:00:00.000
 changed the order of these two tests.

00:00:00.000 --> 00:00:00.000
 I've done 90 then 70 then 80.

00:00:00.000 --> 00:00:00.000
 And so this time

00:00:00.000 --> 00:00:00.000
 65 is less than 90 so I get a b.

00:00:00.000 --> 00:00:00.000
 65 is less than 70 so I get a d.

00:00:00.000 --> 00:00:00.000
 65 is less than 80

00:00:00.000 --> 00:00:00.000
 so I overwrite that d with a c

00:00:00.000 --> 00:00:00.000
 and I end up with a c out of this. Now you might be

00:00:00.000 --> 00:00:00.000
 happy about the fact that I've done this

00:00:00.000 --> 00:00:00.000
 but we've broken our first most important

00:00:00.000 --> 00:00:00.000
 rubric rule. The output

00:00:00.000 --> 00:00:00.000
 is not correct.

00:00:00.000 --> 00:00:00.000
 So this is not the correct way

00:00:00.000 --> 00:00:00.000
 to write interdependent tests.

00:00:00.000 --> 00:00:00.000
 If one test depends on the result

00:00:00.000 --> 00:00:00.000
 of both of the tests that came before it or after it

00:00:00.000 --> 00:00:00.000
 you have, are not supposed to use

00:00:00.000 --> 00:00:00.000
 independent if statements.

00:00:00.000 --> 00:00:00.000
 Instead, when only

00:00:00.000 --> 00:00:00.000
 one condition can be true, then you should

00:00:00.000 --> 00:00:00.000
 use if, else if,

00:00:00.000 --> 00:00:00.000
 else if, else if. These are

00:00:00.000 --> 00:00:00.000
 called ladder style if, else if

00:00:00.000 --> 00:00:00.000
 statements. They're ladder style because you can read

00:00:00.000 --> 00:00:00.000
 on them like the rungs of a ladder and you can

00:00:00.000 --> 00:00:00.000
 look at each condition and pick out the

00:00:00.000 --> 00:00:00.000
 one condition that could possibly

00:00:00.000 --> 00:00:00.000
 be true. And so this is

00:00:00.000 --> 00:00:00.000
 a program that is checking and turning

00:00:00.000 --> 00:00:00.000
 a number, "and" into

00:00:00.000 --> 00:00:00.000
 a word. One, two, three,

00:00:00.000 --> 00:00:00.000
 four billion, two hundred and so forth.

00:00:00.000 --> 00:00:00.000
 So this is obviously correct.

00:00:00.000 --> 00:00:00.000
 The order matters, so you have to be

00:00:00.000 --> 00:00:00.000
 more careful. In other words, because

00:00:00.000 --> 00:00:00.000
 only one of them can be correct, you have to

00:00:00.000 --> 00:00:00.000
 make sure that you select kind of

00:00:00.000 --> 00:00:00.000
 from the left as the problems come in.

00:00:00.000 --> 00:00:00.000
 It's semantically correct. It says there will only

00:00:00.000 --> 00:00:00.000
 be one output, whereas the previous one

00:00:00.000 --> 00:00:00.000
 was not semantically correct. It's efficient

00:00:00.000 --> 00:00:00.000
 once the answer is found, there

00:00:00.000 --> 00:00:00.000
 is no more checking.

00:00:00.000 --> 00:00:00.000
 There is no more checking.

00:00:00.000 --> 00:00:00.000
 So let's go ahead and do that. This will be our

00:00:00.000 --> 00:00:00.000
 last exercise here. And we're going to use these

00:00:00.000 --> 00:00:00.000
 sequential if statements to check

00:00:00.000 --> 00:00:00.000
 on some dates for the

00:00:00.000 --> 00:00:00.000
 four seasons problem. So this is part

00:00:00.000 --> 00:00:00.000
 C.

00:00:00.000 --> 00:00:00.000
 So let me open four seasons. Let me

00:00:00.000 --> 00:00:00.000
 close that dash shell there.

00:00:00.000 --> 00:00:00.000
 Close that dash shell. And let's put our name

00:00:00.000 --> 00:00:00.000
 on the top of it.

00:00:00.000 --> 00:00:00.000
 And let's look at the problem for four seasons.

00:00:00.000 --> 00:00:00.000
 We're going to write a function named

00:00:00.000 --> 00:00:00.000
 season. We're given two integer arguments

00:00:00.000 --> 00:00:00.000
 representing a month and a day.

00:00:00.000 --> 00:00:00.000
 And we're going to

00:00:00.000 --> 00:00:00.000
 return the season for that month and day.

00:00:00.000 --> 00:00:00.000
 Assume that months are specified as an

00:00:00.000 --> 00:00:00.000
 integer between 1 and 12, 1 for January,

00:00:00.000 --> 00:00:00.000
 2 for February. And the day is specified between

00:00:00.000 --> 00:00:00.000
 1 and 31.

00:00:00.000 --> 00:00:00.000
 So we can write the skeleton.

00:00:00.000 --> 00:00:00.000
 So string

00:00:00.000 --> 00:00:00.000
 season

00:00:00.000 --> 00:00:00.000
 int month

00:00:00.000 --> 00:00:00.000
 int day

00:00:00.000 --> 00:00:00.000
 string result

00:00:00.000 --> 00:00:00.000
 Now,

00:00:00.000 --> 00:00:00.000
 when we wrote

00:00:00.000 --> 00:00:00.000
 the, when we had a result

00:00:00.000 --> 00:00:00.000
 that was an integer, we had to give it

00:00:00.000 --> 00:00:00.000
 a starting value. With the string

00:00:00.000 --> 00:00:00.000
 type, because it's a class type, we do not.

00:00:00.000 --> 00:00:00.000
 This will be the empty string.

00:00:00.000 --> 00:00:00.000
 So you don't need to write string result

00:00:00.000 --> 00:00:00.000
 equals quote quote. As a matter of fact,

00:00:00.000 --> 00:00:00.000
 you shouldn't do that.

00:00:00.000 --> 00:00:00.000
 That actually does, requires the compiler

00:00:00.000 --> 00:00:00.000
 or the run time to do some extra work.

00:00:00.000 --> 00:00:00.000
 And we're going to return our result.

00:00:00.000 --> 00:00:00.000
 I'm going to open a shell here.

00:00:00.000 --> 00:00:00.000
 And I'm going to make sure that this

00:00:00.000 --> 00:00:00.000
 compiles and runs.

00:00:00.000 --> 00:00:00.000
 So I'm going to do make test.

00:00:00.000 --> 00:00:00.000
 OK, so you can see that again I got

00:00:00.000 --> 00:00:00.000
 zero, but I don't care about that. All I care about

00:00:00.000 --> 00:00:00.000
 is the fact that this runs.

00:00:00.000 --> 00:00:00.000
 So here, now let's go look at

00:00:00.000 --> 00:00:00.000
 the conditions we want.

00:00:00.000 --> 00:00:00.000
 So we have, are going to return

00:00:00.000 --> 00:00:00.000
 winter, spring, summer, fall

00:00:00.000 --> 00:00:00.000
 or invalid. So we have

00:00:00.000 --> 00:00:00.000
 five possible outputs.

00:00:00.000 --> 00:00:00.000
 So we can go ahead and write the skeleton for that.

00:00:00.000 --> 00:00:00.000
 If something

00:00:00.000 --> 00:00:00.000
 we're going to set

00:00:00.000 --> 00:00:00.000
 the result to that.

00:00:00.000 --> 00:00:00.000
 Else if something else.

00:00:00.000 --> 00:00:00.000
 We're going to set the result to something else.

00:00:00.000 --> 00:00:00.000
 Else if something else.

00:00:00.000 --> 00:00:00.000
 So one, two, three.

00:00:00.000 --> 00:00:00.000
 Else if something else.

00:00:00.000 --> 00:00:00.000
 Four. And

00:00:00.000 --> 00:00:00.000
 if it's none of those, it must be this one

00:00:00.000 --> 00:00:00.000
 down here.

00:00:00.000 --> 00:00:00.000
 OK, so this is the basic structure for

00:00:00.000 --> 00:00:00.000
 an if, else, if.

00:00:00.000 --> 00:00:00.000
 You notice how it looks just like a ladder here

00:00:00.000 --> 00:00:00.000
 that we could climb down. So which of these

00:00:00.000 --> 00:00:00.000
 cases should we handle first?

00:00:00.000 --> 00:00:00.000
 Which of these cases should we handle first?

00:00:00.000 --> 00:00:00.000
 Generally, if there is a

00:00:00.000 --> 00:00:00.000
 error case, you want to handle that first.

00:00:00.000 --> 00:00:00.000
 That means in all the other

00:00:00.000 --> 00:00:00.000
 if statements, you don't have to worry about

00:00:00.000 --> 00:00:00.000
 if the date is valid. So we're going to set

00:00:00.000 --> 00:00:00.000
 the result to invalid here.

00:00:00.000 --> 00:00:00.000
 And for all the rest of these,

00:00:00.000 --> 00:00:00.000
 we're just going to set them to the

00:00:00.000 --> 00:00:00.000
 so this is going to be winter.

00:00:00.000 --> 00:00:00.000
 Spring.

00:00:00.000 --> 00:00:00.000
 Summer.

00:00:00.000 --> 00:00:00.000
 Winter.

00:00:00.000 --> 00:00:00.000
 Spring.

00:00:00.000 --> 00:00:00.000
 Summer.

00:00:00.000 --> 00:00:00.000
 Winter.

00:00:00.000 --> 00:00:00.000
 Summer.

00:00:00.000 --> 00:00:00.000
 And fall.

00:00:00.000 --> 00:00:00.000
 Summer.

00:00:00.000 --> 00:00:00.000
 Sorry.

00:00:00.000 --> 00:00:00.000
 And fall.

00:00:00.000 --> 00:00:00.000
 The nice thing is fall is done.

00:00:00.000 --> 00:00:00.000
 OK, so let's start way back up at

00:00:00.000 --> 00:00:00.000
 the

00:00:00.000 --> 00:00:00.000
 the next one.

00:00:00.000 --> 00:00:00.000
 So let's start our way back up at

00:00:00.000 --> 00:00:00.000
 start our way back up at

00:00:00.000 --> 00:00:00.000
 invalid.

00:00:00.000 --> 00:00:00.000
 So what does it take for a day to be invalid?

00:00:00.000 --> 00:00:00.000
 So we don't have to validate

00:00:00.000 --> 00:00:00.000
 each day to check each year's.

00:00:00.000 --> 00:00:00.000
 But a month of 13 or -1 or a day

00:00:00.000 --> 00:00:00.000
 less than

00:00:00.000 --> 00:00:00.000
 1 or 31

00:00:00.000 --> 00:00:00.000
 would not pass. So basically we have four conditions

00:00:00.000 --> 00:00:00.000
 here. So if

00:00:00.000 --> 00:00:00.000
 month less than 1 or

00:00:00.000 --> 00:00:00.000
 month greater than 12

00:00:00.000 --> 00:00:00.000
 or day less than 1

00:00:00.000 --> 00:00:00.000
 or day

00:00:00.000 --> 00:00:00.000
 greater than 31

00:00:00.000 --> 00:00:00.000
 we know that the day is invalid.

00:00:00.000 --> 00:00:00.000
 We know the day is invalid.

00:00:00.000 --> 00:00:00.000
 So now in all the rest of these I know that the

00:00:00.000 --> 00:00:00.000
 month is valid. So let's look at winter.

00:00:00.000 --> 00:00:00.000
 So if the date

00:00:00.000 --> 00:00:00.000
 falls between 12/16

00:00:00.000 --> 00:00:00.000
 and 13/15

00:00:00.000 --> 00:00:00.000
 so 12/16 is going to

00:00:00.000 --> 00:00:00.000
 be the first day of winter, December 16th

00:00:00.000 --> 00:00:00.000
 and 3/15 is going to be

00:00:00.000 --> 00:00:00.000
 the last day of winter.

00:00:00.000 --> 00:00:00.000
 So we're going to say if

00:00:00.000 --> 00:00:00.000
 month

00:00:00.000 --> 00:00:00.000
 equals 12

00:00:00.000 --> 00:00:00.000
 and

00:00:00.000 --> 00:00:00.000
 the day is greater than 15

00:00:00.000 --> 00:00:00.000
 or

00:00:00.000 --> 00:00:00.000
 if the month is January

00:00:00.000 --> 00:00:00.000
 it's winter, if it's February it's winter,

00:00:00.000 --> 00:00:00.000
 if it's before March 10th. So month

00:00:00.000 --> 00:00:00.000
 less than 3

00:00:00.000 --> 00:00:00.000
 or

00:00:00.000 --> 00:00:00.000
 the month equals

00:00:00.000 --> 00:00:00.000
 3 and day less

00:00:00.000 --> 00:00:00.000
 than or equal to 15 we're in

00:00:00.000 --> 00:00:00.000
 winter. Now when I get down

00:00:00.000 --> 00:00:00.000
 to this next one I have removed

00:00:00.000 --> 00:00:00.000
 all of the invalid dates. I've removed

00:00:00.000 --> 00:00:00.000
 all the winter dates and so I don't have to do

00:00:00.000 --> 00:00:00.000
 any of this checking anymore.

00:00:00.000 --> 00:00:00.000
 All I have to say is

00:00:00.000 --> 00:00:00.000
 if the month

00:00:00.000 --> 00:00:00.000
 is less than 6

00:00:00.000 --> 00:00:00.000
 or

00:00:00.000 --> 00:00:00.000
 the month is 6

00:00:00.000 --> 00:00:00.000
 and the day is less

00:00:00.000 --> 00:00:00.000
 than or equal to 15.

00:00:00.000 --> 00:00:00.000
 Why don't I have to check to see if the

00:00:00.000 --> 00:00:00.000
 month is less than 3? Why don't I have to

00:00:00.000 --> 00:00:00.000
 check for January, February and the early days of

00:00:00.000 --> 00:00:00.000
 March because I already handled them here.

00:00:00.000 --> 00:00:00.000
 They could not get down to this if statement. I've already

00:00:00.000 --> 00:00:00.000
 taken them out for spring.

00:00:00.000 --> 00:00:00.000
 Similarly for summer

00:00:00.000 --> 00:00:00.000
 if

00:00:00.000 --> 00:00:00.000
 the month is

00:00:00.000 --> 00:00:00.000
 less than 9, it's before

00:00:00.000 --> 00:00:00.000
 September or

00:00:00.000 --> 00:00:00.000
 the month equals 9 and the day is

00:00:00.000 --> 00:00:00.000
 less than or equal to 15.

00:00:00.000 --> 00:00:00.000
 Again I'm in summer. For the else one I don't even

00:00:00.000 --> 00:00:00.000
 have to worry about anything. Anything that's left

00:00:00.000 --> 00:00:00.000
 must be fall.

00:00:00.000 --> 00:00:00.000
 So this is how we do

00:00:00.000 --> 00:00:00.000
 sequential if statements.

00:00:00.000 --> 00:00:00.000
 Let's try it out and see if we got it right.

00:00:00.000 --> 00:00:00.000
 I may have made a mistake.

00:00:00.000 --> 00:00:00.000
 So we'll do make test.

00:00:00.000 --> 00:00:00.000
 I didn't make a mistake. We got 100% on that.

00:00:00.000 --> 00:00:00.000
 So you have everything here you need

00:00:00.000 --> 00:00:00.000
 to take your screenshots

00:00:00.000 --> 00:00:00.000
 and I will see you

00:00:00.000 --> 00:00:00.000
 for lecture 5.

00:00:00.000 --> 00:00:00.000
 .

