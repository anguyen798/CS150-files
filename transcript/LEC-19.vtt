WEBVTT

00:00:00.000 --> 00:00:00.000
 Hi everyone, this is Steve Gilbert.

00:00:00.000 --> 00:00:00.000
 Welcome to Lecture 19, where we're going to talk

00:00:00.000 --> 00:00:00.000
 about arrays and pointers.

00:00:00.000 --> 00:00:00.000
 Now, an array is like a vector, except it's built in.

00:00:00.000 --> 00:00:00.000
 So it's a built in derived type.

00:00:00.000 --> 00:00:00.000
 What do we mean by a derived type?

00:00:00.000 --> 00:00:00.000
 A derived type is one that is built from another type.

00:00:00.000 --> 00:00:00.000
 So a pointer is a derived type.

00:00:00.000 --> 00:00:00.000
 You just can't have a raw pointer that is not of any type.

00:00:00.000 --> 00:00:00.000
 It has to be a pointer to an integer or a pointer

00:00:00.000 --> 00:00:00.000
 to a double, and so forth.

00:00:00.000 --> 00:00:00.000
 And an array is the same way.

00:00:00.000 --> 00:00:00.000
 We can't just have an array that collects anything.

00:00:00.000 --> 00:00:00.000
 We have to have an array of int or an array of double.

00:00:00.000 --> 00:00:00.000
 So it's a built in derived type for collecting elements.

00:00:00.000 --> 00:00:00.000
 Now, we use the term array in Java as well,

00:00:00.000 --> 00:00:00.000
 but arrays are quite, quite different in C++.

00:00:00.000 --> 00:00:00.000
 They are much closer to the actual machine type,

00:00:00.000 --> 00:00:00.000
 the way that your CPU works and memory works under the hood.

00:00:00.000 --> 00:00:00.000
 So like the vector, they're a homogeneous collection.

00:00:00.000 --> 00:00:00.000
 All of them has to be the same type.

00:00:00.000 --> 00:00:00.000
 And like a vector, we have continuous storage,

00:00:00.000 --> 00:00:00.000
 contiguous storage, meaning one element right next

00:00:00.000 --> 00:00:00.000
 to each other, and random access,

00:00:00.000 --> 00:00:00.000
 direct access to any element.

00:00:00.000 --> 00:00:00.000
 So let's see how we define an array.

00:00:00.000 --> 00:00:00.000
 So to define an array, we give the base type double,

00:00:00.000 --> 00:00:00.000
 the name of the array, and then in brackets afterwards,

00:00:00.000 --> 00:00:00.000
 the number of elements inside the array.

00:00:00.000 --> 00:00:00.000
 So unlike Java, where you could create an array variable,

00:00:00.000 --> 00:00:00.000
 double nums bracket bracket or double bracket bracket nums,

00:00:00.000 --> 00:00:00.000
 you cannot create an array variable

00:00:00.000 --> 00:00:00.000
 without specifying how many elements you want.

00:00:00.000 --> 00:00:00.000
 And that capacity must be a constant,

00:00:00.000 --> 00:00:00.000
 and it must be known at compile time.

00:00:00.000 --> 00:00:00.000
 Again, this is different than Java.

00:00:00.000 --> 00:00:00.000
 In Java, you could ask the user how big an array,

00:00:00.000 --> 00:00:00.000
 and then you could create a new array with that size.

00:00:00.000 --> 00:00:00.000
 You can't create a regular, what we call a static array,

00:00:00.000 --> 00:00:00.000
 that way in C++.

00:00:00.000 --> 00:00:00.000
 Now, this array definition will allocate an entire block.

00:00:00.000 --> 00:00:00.000
 So int a5, if we put that line inside a function,

00:00:00.000 --> 00:00:00.000
 will allocate a block of five integers on the heap.

00:00:00.000 --> 00:00:00.000
 There is no separate variable that points to this.

00:00:00.000 --> 00:00:00.000
 The address is simply, the name a is simply the address

00:00:00.000 --> 00:00:00.000
 of the first element.

00:00:00.000 --> 00:00:00.000
 There's no additional, what we would call,

00:00:00.000 --> 00:00:00.000
 metadata associated with it.

00:00:00.000 --> 00:00:00.000
 Now, the access is sequential.

00:00:00.000 --> 00:00:00.000
 One right on top of another on the stack, and contiguous.

00:00:00.000 --> 00:00:00.000
 So we can simply go from one to another,

00:00:00.000 --> 00:00:00.000
 simply by using addresses.

00:00:00.000 --> 00:00:00.000
 So if we want the element at 795,

00:00:00.000 --> 00:00:00.000
 we just take the address a,

00:00:00.000 --> 00:00:00.000
 and add 795 times the size of whatever the element is.

00:00:00.000 --> 00:00:00.000
 So the size of int, in this case.

00:00:00.000 --> 00:00:00.000
 And that gives us the address.

00:00:00.000 --> 00:00:00.000
 So it's simple, simple arithmetic.

00:00:00.000 --> 00:00:00.000
 It's very, very fast.

00:00:00.000 --> 00:00:00.000
 And as a matter of fact, it's even faster than it looks like,

00:00:00.000 --> 00:00:00.000
 because your CPU has dedicated address circuits that know how

00:00:00.000 --> 00:00:00.000
 to do these calculations without having to go

00:00:00.000 --> 00:00:00.000
 through the regular addition

00:00:00.000 --> 00:00:00.000
 and multiplication part of the CPU.

00:00:00.000 --> 00:00:00.000
 So there is really no faster way to store data in memory

00:00:00.000 --> 00:00:00.000
 at all than built-in arrays.

00:00:00.000 --> 00:00:00.000
 Now, arrays can be initialized in all versions of C++.

00:00:00.000 --> 00:00:00.000
 And so I can allocate space for four elements,

00:00:00.000 --> 00:00:00.000
 and I can supply values for all four of them.

00:00:00.000 --> 00:00:00.000
 Now, notice this is slightly different than what we did

00:00:00.000 --> 00:00:00.000
 with vectors, because with vectors,

00:00:00.000 --> 00:00:00.000
 we didn't use the equal sign here.

00:00:00.000 --> 00:00:00.000
 The equal sign's required as part of the syntax.

00:00:00.000 --> 00:00:00.000
 So I've allocated and initialized four elements.

00:00:00.000 --> 00:00:00.000
 I can allocate more and only initialize one,

00:00:00.000 --> 00:00:00.000
 in which case the remaining elements will be initialized

00:00:00.000 --> 00:00:00.000
 to zero as well.

00:00:00.000 --> 00:00:00.000
 Now, not because I put zero inside here.

00:00:00.000 --> 00:00:00.000
 If I had to put four, the first element would be initialized

00:00:00.000 --> 00:00:00.000
 to four, and the remaining elements would be initialized

00:00:00.000 --> 00:00:00.000
 to zero.

00:00:00.000 --> 00:00:00.000
 What happens if I do this?

00:00:00.000 --> 00:00:00.000
 Allocate room for three and provide four initializers.

00:00:00.000 --> 00:00:00.000
 Well, C++ won't let you do that,

00:00:00.000 --> 00:00:00.000
 and it simply doesn't compile.

00:00:00.000 --> 00:00:00.000
 How about if I don't allocate any space?

00:00:00.000 --> 00:00:00.000
 I just leave that blank.

00:00:00.000 --> 00:00:00.000
 That's fine as well.

00:00:00.000 --> 00:00:00.000
 C++ will come along, and it will count the number of elements,

00:00:00.000 --> 00:00:00.000
 and it will implicitly fill this three in for you.

00:00:00.000 --> 00:00:00.000
 Now, there's one new thing in C++11.

00:00:00.000 --> 00:00:00.000
 So all versions of C++ work like this.

00:00:00.000 --> 00:00:00.000
 In C++11, you can simply default initialize it just

00:00:00.000 --> 00:00:00.000
 by putting braces after it.

00:00:00.000 --> 00:00:00.000
 If you do not initialize it, the elements are just random.

00:00:00.000 --> 00:00:00.000
 Now, the individual elements are indexed or subscripted,

00:00:00.000 --> 00:00:00.000
 just like they would in a vector,

00:00:00.000 --> 00:00:00.000
 and you access them using the subscript operator.

00:00:00.000 --> 00:00:00.000
 So A and then the subscript.

00:00:00.000 --> 00:00:00.000
 That subscript can go from zero to whatever the capacity

00:00:00.000 --> 00:00:00.000
 of the array is minus one.

00:00:00.000 --> 00:00:00.000
 So if A has four elements, the elements would be zero, one,

00:00:00.000 --> 00:00:00.000
 two, three, capacity is five.

00:00:00.000 --> 00:00:00.000
 What happens with an array if we go out of bounds?

00:00:00.000 --> 00:00:00.000
 We saw with the vector that it was undefined

00:00:00.000 --> 00:00:00.000
 if we use the subscript operator,

00:00:00.000 --> 00:00:00.000
 but we could use V.at three,

00:00:00.000 --> 00:00:00.000
 and we could throw an exception if that happens.

00:00:00.000 --> 00:00:00.000
 There's no thing like that for arrays.

00:00:00.000 --> 00:00:00.000
 If you go out of bounds, you simply get undefined behavior.

00:00:00.000 --> 00:00:00.000
 The program may crash.

00:00:00.000 --> 00:00:00.000
 It may access parts of memory it should not.

00:00:00.000 --> 00:00:00.000
 It may overwrite other variables inside your program.

00:00:00.000 --> 00:00:00.000
 So you don't know what it's going to do.

00:00:00.000 --> 00:00:00.000
 What you do know is that it is never an exception.

00:00:00.000 --> 00:00:00.000
 It is never an exception.

00:00:00.000 --> 00:00:00.000
 C++ does not throw exceptions for out of bounds.

00:00:00.000 --> 00:00:00.000
 You may get a segmentation fault, as I said,

00:00:00.000 --> 00:00:00.000
 if the area you're reading and writing to is outside the

00:00:00.000 --> 00:00:00.000
 segment that the operating system allows you to write to,

00:00:00.000 --> 00:00:00.000
 or you may simply overwrite other variables

00:00:00.000 --> 00:00:00.000
 in your own program.

00:00:00.000 --> 00:00:00.000
 Now, there's no array variable like there is in Java.

00:00:00.000 --> 00:00:00.000
 So this is what an array would look like in Java.

00:00:00.000 --> 00:00:00.000
 We create an array variable, and then we'd create

00:00:00.000 --> 00:00:00.000
 or allocate room for 10 arrays, or 10 ints.

00:00:00.000 --> 00:00:00.000
 The 10 ints would be on the heap.

00:00:00.000 --> 00:00:00.000
 That would be the array,

00:00:00.000 --> 00:00:00.000
 and the variable would be separate from the array.

00:00:00.000 --> 00:00:00.000
 That doesn't happen in Java.

00:00:00.000 --> 00:00:00.000
 There's not these two parts with a variable and an array.

00:00:00.000 --> 00:00:00.000
 Instead, or that doesn't happen in C++.

00:00:00.000 --> 00:00:00.000
 Excuse me.

00:00:00.000 --> 00:00:00.000
 Instead, in C++, the array name acts

00:00:00.000 --> 00:00:00.000
 like a constant pointer or literal.

00:00:00.000 --> 00:00:00.000
 Because of that, because there is no array variable,

00:00:00.000 --> 00:00:00.000
 you can't assign or compare using array names.

00:00:00.000 --> 00:00:00.000
 So here I have two arrays.

00:00:00.000 --> 00:00:00.000
 A1 has three elements.

00:00:00.000 --> 00:00:00.000
 It's initialized, 2, 3, 4.

00:00:00.000 --> 00:00:00.000
 A2 also has three elements of the same type,

00:00:00.000 --> 00:00:00.000
 but they're uninitialized.

00:00:00.000 --> 00:00:00.000
 Could I initialize A2 by simply assigning A1?

00:00:00.000 --> 00:00:00.000
 No, you cannot.

00:00:00.000 --> 00:00:00.000
 A2 and A1 are addresses.

00:00:00.000 --> 00:00:00.000
 Imagine it's address 1,000 and 2,000.

00:00:00.000 --> 00:00:00.000
 That's like writing 2,000 equals 1,000.

00:00:00.000 --> 00:00:00.000
 Again, in your code, you can see why that wouldn't compile.

00:00:00.000 --> 00:00:00.000
 It is okay, of course, to assign

00:00:00.000 --> 00:00:00.000
 to different arrays using the elements

00:00:00.000 --> 00:00:00.000
 or the subscripted name.

00:00:00.000 --> 00:00:00.000
 So we could say A2 sub 0 equals A1 sub 0.

00:00:00.000 --> 00:00:00.000
 And you could write a loop that would go through

00:00:00.000 --> 00:00:00.000
 and assign each of those.

00:00:00.000 --> 00:00:00.000
 You might think, well, you notice on the first line there,

00:00:00.000 --> 00:00:00.000
 I could assign to A1 using these braces,

00:00:00.000 --> 00:00:00.000
 what we call an initializer list.

00:00:00.000 --> 00:00:00.000
 Can I do that to assign to A2?

00:00:00.000 --> 00:00:00.000
 No. You can only do that when you're initializing the thing.

00:00:00.000 --> 00:00:00.000
 You cannot use it for assignment later.

00:00:00.000 --> 00:00:00.000
 That simply doesn't work.

00:00:00.000 --> 00:00:00.000
 Finally, you can do this.

00:00:00.000 --> 00:00:00.000
 If A2 equals equals A3, okay, well,

00:00:00.000 --> 00:00:00.000
 actually I don't have an A3 here.

00:00:00.000 --> 00:00:00.000
 It probably should say if A1 equals equals A2.

00:00:00.000 --> 00:00:00.000
 But both of those would be perfectly legal.

00:00:00.000 --> 00:00:00.000
 They will compile, but they are really not very smart.

00:00:00.000 --> 00:00:00.000
 That's because, again, A1 and A2 are different arrays.

00:00:00.000 --> 00:00:00.000
 That means all A1 and A2 are are addresses.

00:00:00.000 --> 00:00:00.000
 So we're not comparing what's at those addresses to see

00:00:00.000 --> 00:00:00.000
 if they're the same.

00:00:00.000 --> 00:00:00.000
 We're comparing the addresses themselves.

00:00:00.000 --> 00:00:00.000
 So address 1000 is never, never,

00:00:00.000 --> 00:00:00.000
 ever going to be equal to address 2000.

00:00:00.000 --> 00:00:00.000
 By definition, that's false.

00:00:00.000 --> 00:00:00.000
 So the compiler can't check things

00:00:00.000 --> 00:00:00.000
 that simply don't make sense that way.

00:00:00.000 --> 00:00:00.000
 It can only check things that are illegal.

00:00:00.000 --> 00:00:00.000
 Now, the array does not carry around its size like a vector.

00:00:00.000 --> 00:00:00.000
 As I mentioned, there is no metadata associated

00:00:00.000 --> 00:00:00.000
 with an array like there is with a vector.

00:00:00.000 --> 00:00:00.000
 There is no A dot length data member or field

00:00:00.000 --> 00:00:00.000
 as there is with Java arrays.

00:00:00.000 --> 00:00:00.000
 Now, the compiler knows the size of an array

00:00:00.000 --> 00:00:00.000
 when it's declared, however.

00:00:00.000 --> 00:00:00.000
 And so if you're in scope of that declaration,

00:00:00.000 --> 00:00:00.000
 the compiler knows that information.

00:00:00.000 --> 00:00:00.000
 So I can find out in scope, here I've created an array A,

00:00:00.000 --> 00:00:00.000
 I can find the size of this declaration in bytes if I'm

00:00:00.000 --> 00:00:00.000
 in the scope of this declaration.

00:00:00.000 --> 00:00:00.000
 And if I want to find the number of elements,

00:00:00.000 --> 00:00:00.000
 all I do is divide the size of the whole array by the size

00:00:00.000 --> 00:00:00.000
 of the first element.

00:00:00.000 --> 00:00:00.000
 And since they're all the same size by definition,

00:00:00.000 --> 00:00:00.000
 this will give me the number of elements in the array.

00:00:00.000 --> 00:00:00.000
 But again, only in scope.

00:00:00.000 --> 00:00:00.000
 C++11 added a new way to do that.

00:00:00.000 --> 00:00:00.000
 We can take the array and pass it to end and subtract begin

00:00:00.000 --> 00:00:00.000
 from it, and that will give us the number of elements.

00:00:00.000 --> 00:00:00.000
 And finally, in C++14,

00:00:00.000 --> 00:00:00.000
 they had a new function simply called size

00:00:00.000 --> 00:00:00.000
 that will also work on arrays.

00:00:00.000 --> 00:00:00.000
 So you could pass A to standard size,

00:00:00.000 --> 00:00:00.000
 and you could get back the number of elements in the array.

00:00:00.000 --> 00:00:00.000
 Again, I want to stress this, this only works

00:00:00.000 --> 00:00:00.000
 when the array is in scope,

00:00:00.000 --> 00:00:00.000
 not when you've passed the array to a function.

00:00:00.000 --> 00:00:00.000
 All right.

00:00:00.000 --> 00:00:00.000
 So how -- if we have an array, it doesn't have any metadata,

00:00:00.000 --> 00:00:00.000
 it doesn't know how long the function is,

00:00:00.000 --> 00:00:00.000
 it doesn't have a size member function,

00:00:00.000 --> 00:00:00.000
 it doesn't have a length data member, how does the loop know

00:00:00.000 --> 00:00:00.000
 how to stop in your function if when you pass the array

00:00:00.000 --> 00:00:00.000
 to a function, the only thing the function gets is the address

00:00:00.000 --> 00:00:00.000
 of the first element?

00:00:00.000 --> 00:00:00.000
 Well, number first method, we could pass the allocated

00:00:00.000 --> 00:00:00.000
 or maximum size along with the address.

00:00:00.000 --> 00:00:00.000
 Method two, we could use a sentinel

00:00:00.000 --> 00:00:00.000
 to mark the end of the array.

00:00:00.000 --> 00:00:00.000
 Number three, we could calculate a pointer to the end,

00:00:00.000 --> 00:00:00.000
 and we could pass that pointer to the end as well

00:00:00.000 --> 00:00:00.000
 and write an iterator loop.

00:00:00.000 --> 00:00:00.000
 We could pass -- use the begin and end iterators

00:00:00.000 --> 00:00:00.000
 and pass those instead of the address of the first element.

00:00:00.000 --> 00:00:00.000
 Or finally, inside the scope of the array

00:00:00.000 --> 00:00:00.000
 where it's declared, we can use a for each loop.

00:00:00.000 --> 00:00:00.000
 So we're going to do that in our only exercise today.

00:00:00.000 --> 00:00:00.000
 We're going to create some arrays, and we're going

00:00:00.000 --> 00:00:00.000
 to loop through them.

00:00:00.000 --> 00:00:00.000
 So go ahead and open arrays.cpp in your workspace,

00:00:00.000 --> 00:00:00.000
 and then let's create five arrays.

00:00:00.000 --> 00:00:00.000
 A three-element int, a four-element char,

00:00:00.000 --> 00:00:00.000
 a five-element long, a six-element float,

00:00:00.000 --> 00:00:00.000
 and a seven-element double.

00:00:00.000 --> 00:00:00.000
 Okay. So I've got arrays.cpp open over here,

00:00:00.000 --> 00:00:00.000
 and I want to create my arrays.

00:00:00.000 --> 00:00:00.000
 So I can -- first for my three-element int,

00:00:00.000 --> 00:00:00.000
 I could do const int iSize -- I'll do it like this --

00:00:00.000 --> 00:00:00.000
 k iSize equals three.

00:00:00.000 --> 00:00:00.000
 And then I could do int integer array IA equals kSize.

00:00:00.000 --> 00:00:00.000
 Now, what would happen -- what would happen if I were

00:00:00.000 --> 00:00:00.000
 to take off this const in front of this, if I were to take off

00:00:00.000 --> 00:00:00.000
 that const in front of it?

00:00:00.000 --> 00:00:00.000
 First, let's do make on this.

00:00:00.000 --> 00:00:00.000
 Let me make my shell so I'm over in that folder, of course.

00:00:00.000 --> 00:00:00.000
 Okay. So I'm in A, and that's k iSize.

00:00:00.000 --> 00:00:00.000
 So that was giving me an error because I had spelled that wrong.

00:00:00.000 --> 00:00:00.000
 So make, and I don't have any problems with that at all.

00:00:00.000 --> 00:00:00.000
 Okay. Now I'm going to remove the int from this,

00:00:00.000 --> 00:00:00.000
 const from that, and try it again.

00:00:00.000 --> 00:00:00.000
 And you will probably find that it will compile.

00:00:00.000 --> 00:00:00.000
 Okay. That's because most --

00:00:00.000 --> 00:00:00.000
 and if we were doing this in Visual Studio,

00:00:00.000 --> 00:00:00.000
 it would not compile.

00:00:00.000 --> 00:00:00.000
 Visual Studio would be correct in that case.

00:00:00.000 --> 00:00:00.000
 What I can do over here is open up my make file

00:00:00.000 --> 00:00:00.000
 and add an extra flag on the flags, and say I want

00:00:00.000 --> 00:00:00.000
 to make this pedantic, and that will ensure

00:00:00.000 --> 00:00:00.000
 that it only uses the C++ standard.

00:00:00.000 --> 00:00:00.000
 Now when I do make, notice it says ISO C++ forbids an area --

00:00:00.000 --> 00:00:00.000
 a variable length array IA.

00:00:00.000 --> 00:00:00.000
 So this needs to be const to be correct,

00:00:00.000 --> 00:00:00.000
 even if in some compilers you can get away with it.

00:00:00.000 --> 00:00:00.000
 In some compilers you can get away with it.

00:00:00.000 --> 00:00:00.000
 But since it's not really correct according

00:00:00.000 --> 00:00:00.000
 to the language, you shouldn't do it.

00:00:00.000 --> 00:00:00.000
 So we could create an array like this.

00:00:00.000 --> 00:00:00.000
 This is uninitialized.

00:00:00.000 --> 00:00:00.000
 So let's create an array with four chars.

00:00:00.000 --> 00:00:00.000
 So char CA, and put the brackets there

00:00:00.000 --> 00:00:00.000
 and initialize it like this.

00:00:00.000 --> 00:00:00.000
 Brace brace semicolon.

00:00:00.000 --> 00:00:00.000
 C -- hold on, I'm having a hard time getting my fingers

00:00:00.000 --> 00:00:00.000
 on the right keys here.

00:00:00.000 --> 00:00:00.000
 A P -- and I'm going to put a terminator in here, a sentinel,

00:00:00.000 --> 00:00:00.000
 that we're going to look for when we process

00:00:00.000 --> 00:00:00.000
 that array, okay?

00:00:00.000 --> 00:00:00.000
 A sentinel, okay?

00:00:00.000 --> 00:00:00.000
 And notice this time I didn't initialize it.

00:00:00.000 --> 00:00:00.000
 We're going to create a five element long.

00:00:00.000 --> 00:00:00.000
 So char LA.

00:00:00.000 --> 00:00:00.000
 You can put in a literal like that.

00:00:00.000 --> 00:00:00.000
 And for our LA we'll do it 10, 20, 30.

00:00:00.000 --> 00:00:00.000
 And we'll find out that there won't be a 40 or 50,

00:00:00.000 --> 00:00:00.000
 it'll just be zeros and zeros for that last one.

00:00:00.000 --> 00:00:00.000
 A six element float.

00:00:00.000 --> 00:00:00.000
 [ Typing ]

00:00:00.000 --> 00:00:00.000
 Okay, now you might notice

00:00:00.000 --> 00:00:00.000
 that these are not floats inside of here, these are doubles.

00:00:00.000 --> 00:00:00.000
 But because this is initialization,

00:00:00.000 --> 00:00:00.000
 this will require a conversion to convert it

00:00:00.000 --> 00:00:00.000
 down to the floats.

00:00:00.000 --> 00:00:00.000
 If you didn't want that conversion,

00:00:00.000 --> 00:00:00.000
 we could make each one a float.

00:00:00.000 --> 00:00:00.000
 [ Typing ]

00:00:00.000 --> 00:00:00.000
 Like that.

00:00:00.000 --> 00:00:00.000
 That's always a better thing, you know,

00:00:00.000 --> 00:00:00.000
 to say in your code exactly what you're trying to do.

00:00:00.000 --> 00:00:00.000
 Okay, and finally we had our double, double DA.

00:00:00.000 --> 00:00:00.000
 And I'm going to use C++11.

00:00:00.000 --> 00:00:00.000
 And just default initialize everything to zero, okay?

00:00:00.000 --> 00:00:00.000
 Everything to zero.

00:00:00.000 --> 00:00:00.000
 All right, let's do make here again on this.

00:00:00.000 --> 00:00:00.000
 And now it compiles without errors.

00:00:00.000 --> 00:00:00.000
 So that's initializing and creating five arrays.

00:00:00.000 --> 00:00:00.000
 Now we're going to print each array using the array name

00:00:00.000 --> 00:00:00.000
 and see what happens.

00:00:00.000 --> 00:00:00.000
 So this is one print using the array name.

00:00:00.000 --> 00:00:00.000
 So I'm going to C out.

00:00:00.000 --> 00:00:00.000
 I'm going to print the array name as well.

00:00:00.000 --> 00:00:00.000
 So I'm going to print IA equals IA.

00:00:00.000 --> 00:00:00.000
 CA equals CA.

00:00:00.000 --> 00:00:00.000
 C out. LA. Oops.

00:00:00.000 --> 00:00:00.000
 LA equals LA.

00:00:00.000 --> 00:00:00.000
 C out. FA equals FA.

00:00:00.000 --> 00:00:00.000
 And C out.

00:00:00.000 --> 00:00:00.000
 DA.

00:00:00.000 --> 00:00:00.000
 DA didn't turn blue.

00:00:00.000 --> 00:00:00.000
 Oh, there it turned blue.

00:00:00.000 --> 00:00:00.000
 Okay. So let's go ahead and do make run.

00:00:00.000 --> 00:00:00.000
 Nothing ran.

00:00:00.000 --> 00:00:00.000
 Oh, I didn't.

00:00:00.000 --> 00:00:00.000
 No. Let me save it and do make once again.

00:00:00.000 --> 00:00:00.000
 Okay. I'm going to pause this while I figure

00:00:00.000 --> 00:00:00.000
 out what's going on right now.

00:00:00.000 --> 00:00:00.000
 Because that doesn't make any sense at all.

00:00:00.000 --> 00:00:00.000
 Oh, no. I don't need to pause it.

00:00:00.000 --> 00:00:00.000
 I just need to look and that my return zero is

00:00:00.000 --> 00:00:00.000
 up there before my print.

00:00:00.000 --> 00:00:00.000
 Which is a bad thing.

00:00:00.000 --> 00:00:00.000
 Okay. So let's do make run.

00:00:00.000 --> 00:00:00.000
 Okay. So IA prints out.

00:00:00.000 --> 00:00:00.000
 IA is simply the address for where I starts.

00:00:00.000 --> 00:00:00.000
 CA doesn't print out the address where the C starts.

00:00:00.000 --> 00:00:00.000
 It prints out cat.

00:00:00.000 --> 00:00:00.000
 LA. So I apparently made a mistake here.

00:00:00.000 --> 00:00:00.000
 LA prints that.

00:00:00.000 --> 00:00:00.000
 FA doesn't appear to be -- oh, no.

00:00:00.000 --> 00:00:00.000
 There's FA.

00:00:00.000 --> 00:00:00.000
 LA prints there and then seems to print a new line at the end.

00:00:00.000 --> 00:00:00.000
 I'm not quite sure why.

00:00:00.000 --> 00:00:00.000
 What did we do with LA?

00:00:00.000 --> 00:00:00.000
 LA we initialized to three elements, right?

00:00:00.000 --> 00:00:00.000
 And it's five long.

00:00:00.000 --> 00:00:00.000
 So I'm not sure why LA is not printing -- oh, you know.

00:00:00.000 --> 00:00:00.000
 I made LA a char.

00:00:00.000 --> 00:00:00.000
 I'm supposed to make it a long.

00:00:00.000 --> 00:00:00.000
 So again, user error here.

00:00:00.000 --> 00:00:00.000
 User error here.

00:00:00.000 --> 00:00:00.000
 Okay. Make run.

00:00:00.000 --> 00:00:00.000
 Okay. So IA, LA, FA, DA, all of those print the address

00:00:00.000 --> 00:00:00.000
 of the first element of the array.

00:00:00.000 --> 00:00:00.000
 CA does not.

00:00:00.000 --> 00:00:00.000
 So to explain why CA does not, look at this piece of code.

00:00:00.000 --> 00:00:00.000
 Okay? What is this quote?

00:00:00.000 --> 00:00:00.000
 Is that a string object?

00:00:00.000 --> 00:00:00.000
 No, it is not a string object.

00:00:00.000 --> 00:00:00.000
 It is an array of characters terminated with a null,

00:00:00.000 --> 00:00:00.000
 what we call a C string.

00:00:00.000 --> 00:00:00.000
 And so C out has an overloaded operator that looks like this

00:00:00.000 --> 00:00:00.000
 or string has an overloaded operator that looks like this.

00:00:00.000 --> 00:00:00.000
 O stream ref operator.

00:00:00.000 --> 00:00:00.000
 O stream ref out const char star S or CS for C string.

00:00:00.000 --> 00:00:00.000
 Okay? So when we pass CA here,

00:00:00.000 --> 00:00:00.000
 what we're doing is we're passing a pointer

00:00:00.000 --> 00:00:00.000
 to a constant character or a pointer to a char.

00:00:00.000 --> 00:00:00.000
 And so it's treating it exactly the same way it treats this.

00:00:00.000 --> 00:00:00.000
 So for all arrays, we will get the address IA, LA, FA, and DA.

00:00:00.000 --> 00:00:00.000
 But for character arrays, we will actually get the sequence

00:00:00.000 --> 00:00:00.000
 of characters that's inside it.

00:00:00.000 --> 00:00:00.000
 What do I do if I want to find out where the address

00:00:00.000 --> 00:00:00.000
 where CA is?

00:00:00.000 --> 00:00:00.000
 What I can do is I can cast this, so static cast void pointer.

00:00:00.000 --> 00:00:00.000
 In other words, a raw pointer to nothing, CA.

00:00:00.000 --> 00:00:00.000
 And now if I run that, make run, notice we'll get the addresses

00:00:00.000 --> 00:00:00.000
 where each of these items are stored in memory.

00:00:00.000 --> 00:00:00.000
 These are all stored in the stack because they're

00:00:00.000 --> 00:00:00.000
 in the local storage.

00:00:00.000 --> 00:00:00.000
 If I had created all of these outside of this function,

00:00:00.000 --> 00:00:00.000
 this global variables, they would be

00:00:00.000 --> 00:00:00.000
 in the static storage area.

00:00:00.000 --> 00:00:00.000
 All right.

00:00:00.000 --> 00:00:00.000
 So we've created them.

00:00:00.000 --> 00:00:00.000
 We've seen that the name of the array is just an address.

00:00:00.000 --> 00:00:00.000
 Now let's print the contents of each array.

00:00:00.000 --> 00:00:00.000
 And I'm going to use five different loops,

00:00:00.000 --> 00:00:00.000
 the five different loops we had on the previous slide.

00:00:00.000 --> 00:00:00.000
 Okay? So let's start.

00:00:00.000 --> 00:00:00.000
 Print the arrays, array contents.

00:00:00.000 --> 00:00:00.000
 And let's start is a traditional loop with size.

00:00:00.000 --> 00:00:00.000
 So I'm going to print IA.

00:00:00.000 --> 00:00:00.000
 We have a constant for IA.

00:00:00.000 --> 00:00:00.000
 So I'm going to say for I equals zero, IIA less than KI size,

00:00:00.000 --> 00:00:00.000
 plus plus I.

00:00:00.000 --> 00:00:00.000
 C out IA. Let me go there.

00:00:00.000 --> 00:00:00.000
 IA at I. And let me just do space.

00:00:00.000 --> 00:00:00.000
 And let me print.

00:00:00.000 --> 00:00:00.000
 [ Typing ]

00:00:00.000 --> 00:00:00.000
 Okay. So let's print.

00:00:00.000 --> 00:00:00.000
 Let's do that first one, make run.

00:00:00.000 --> 00:00:00.000
 And here's our first array.

00:00:00.000 --> 00:00:00.000
 You can see I have three elements.

00:00:00.000 --> 00:00:00.000
 They're uninitialized.

00:00:00.000 --> 00:00:00.000
 So they're just random values.

00:00:00.000 --> 00:00:00.000
 Now notice I didn't use the fence post algorithm here.

00:00:00.000 --> 00:00:00.000
 I used an algorithm where we have a space before

00:00:00.000 --> 00:00:00.000
 and after each element here.

00:00:00.000 --> 00:00:00.000
 And so I didn't need to print the first one separately.

00:00:00.000 --> 00:00:00.000
 I used this fence post for the next ones.

00:00:00.000 --> 00:00:00.000
 So now we're going to do 2B, use a sentinel.

00:00:00.000 --> 00:00:00.000
 Of course, you saw we could just print out the string.

00:00:00.000 --> 00:00:00.000
 But I want to show you how a sentinel works.

00:00:00.000 --> 00:00:00.000
 So here I'll use a sentinel.

00:00:00.000 --> 00:00:00.000
 So I'll say C out CA equals.

00:00:00.000 --> 00:00:00.000
 I use square brackets.

00:00:00.000 --> 00:00:00.000
 [ Typing ]

00:00:00.000 --> 00:00:00.000
 I'll say for.

00:00:00.000 --> 00:00:00.000
 [ Typing ]

00:00:00.000 --> 00:00:00.000
 And here we're going to say CA at I not equal

00:00:00.000 --> 00:00:00.000
 to the null character.

00:00:00.000 --> 00:00:00.000
 So you notice I'm not using size for my bounds at all.

00:00:00.000 --> 00:00:00.000
 I'm using the sentinel in there.

00:00:00.000 --> 00:00:00.000
 [ Typing ]

00:00:00.000 --> 00:00:00.000
 I want actually a space between each one.

00:00:00.000 --> 00:00:00.000
 And we'll print that.

00:00:00.000 --> 00:00:00.000
 [ Typing ]

00:00:00.000 --> 00:00:00.000
 And C out.

00:00:00.000 --> 00:00:00.000
 [ Typing ]

00:00:00.000 --> 00:00:00.000
 Okay. So here's CA using a sentinel loop.

00:00:00.000 --> 00:00:00.000
 Let me clear that.

00:00:00.000 --> 00:00:00.000
 Demake run.

00:00:00.000 --> 00:00:00.000
 So here's CAT.

00:00:00.000 --> 00:00:00.000
 Notice we didn't take the length

00:00:00.000 --> 00:00:00.000
 into consideration at all with CA.

00:00:00.000 --> 00:00:00.000
 We just took into consideration the fact

00:00:00.000 --> 00:00:00.000
 that it contained a terminating character.

00:00:00.000 --> 00:00:00.000
 A sentinel character.

00:00:00.000 --> 00:00:00.000
 Okay. All right.

00:00:00.000 --> 00:00:00.000
 Our third kind of loop.

00:00:00.000 --> 00:00:00.000
 Third kind of loop is calculate a pointer to the end.

00:00:00.000 --> 00:00:00.000
 Okay. And then we're going to use that.

00:00:00.000 --> 00:00:00.000
 [ Typing ]

00:00:00.000 --> 00:00:00.000
 To see.

00:00:00.000 --> 00:00:00.000
 [ Typing ]

00:00:00.000 --> 00:00:00.000
 And we're going to calculate a pointer to the end

00:00:00.000 --> 00:00:00.000
 with the size of it.

00:00:00.000 --> 00:00:00.000
 So this is going to be -- our third one is going

00:00:00.000 --> 00:00:00.000
 to be LA and it's five long.

00:00:00.000 --> 00:00:00.000
 [ Typing ]

00:00:00.000 --> 00:00:00.000
 And so we're going to --

00:00:00.000 --> 00:00:00.000
 [ Typing ]

00:00:00.000 --> 00:00:00.000
 LA equals the opening bracket.

00:00:00.000 --> 00:00:00.000
 And let's actually on this one since I know --

00:00:00.000 --> 00:00:00.000
 [ Typing ]

00:00:00.000 --> 00:00:00.000
 We print the first one up there.

00:00:00.000 --> 00:00:00.000
 [ Typing ]

00:00:00.000 --> 00:00:00.000
 Okay. Now we don't want to go to the size.

00:00:00.000 --> 00:00:00.000
 What we want to do is say for I equals zero, LA plus I.

00:00:00.000 --> 00:00:00.000
 So actually let's create the pointer to it

00:00:00.000 --> 00:00:00.000
 because when we're calling a function we would pass this

00:00:00.000 --> 00:00:00.000
 pointer to it.

00:00:00.000 --> 00:00:00.000
 So I'll say auto end P equals LA plus the size

00:00:00.000 --> 00:00:00.000
 of LA divided by the size of LA sub zero.

00:00:00.000 --> 00:00:00.000
 Okay. So I've calculated a pointer to the end.

00:00:00.000 --> 00:00:00.000
 Okay. I'm going to use a pointer to the beginning.

00:00:00.000 --> 00:00:00.000
 [ Typing ]

00:00:00.000 --> 00:00:00.000
 For a long pointer P equals LA, P less than end P, P plus plus.

00:00:00.000 --> 00:00:00.000
 [ Typing ]

00:00:00.000 --> 00:00:00.000
 LA plus one.

00:00:00.000 --> 00:00:00.000
 [ Typing ]

00:00:00.000 --> 00:00:00.000
 Oh, not an end.

00:00:00.000 --> 00:00:00.000
 Okay. Not an end.

00:00:00.000 --> 00:00:00.000
 Okay. So here we're just using pointers, right,

00:00:00.000 --> 00:00:00.000
 a pointer to the beginning and a pointer to the end.

00:00:00.000 --> 00:00:00.000
 And we calculate that pointer to the end

00:00:00.000 --> 00:00:00.000
 by taking the size of LA, its allocated size,

00:00:00.000 --> 00:00:00.000
 divided by the size of the first element

00:00:00.000 --> 00:00:00.000
 which gives us the number of elements.

00:00:00.000 --> 00:00:00.000
 This will give us a pointer right past the end.

00:00:00.000 --> 00:00:00.000
 And we'll see how square bracket ends up.

00:00:00.000 --> 00:00:00.000
 Okay. Let's try that third one.

00:00:00.000 --> 00:00:00.000
 I have end there instead of P end or end P.

00:00:00.000 --> 00:00:00.000
 [ Typing ]

00:00:00.000 --> 00:00:00.000
 Okay. And then we got our 10, 20, 30.

00:00:00.000 --> 00:00:00.000
 And as I mentioned, we only initialized the first three

00:00:00.000 --> 00:00:00.000
 so the last two are initialized to zero.

00:00:00.000 --> 00:00:00.000
 Unlike this one up here where everything is uninitialized.

00:00:00.000 --> 00:00:00.000
 Everything is uninitialized.

00:00:00.000 --> 00:00:00.000
 Okay. Okay.

00:00:00.000 --> 00:00:00.000
 So that was 2C for 2D.

00:00:00.000 --> 00:00:00.000
 [ Typing ]

00:00:00.000 --> 00:00:00.000
 We can just use iterators.

00:00:00.000 --> 00:00:00.000
 [ Typing ]

00:00:00.000 --> 00:00:00.000
 Let's see how FA.

00:00:00.000 --> 00:00:00.000
 [ Typing ]

00:00:00.000 --> 00:00:00.000
 And we'll do star, begin, FA.

00:00:00.000 --> 00:00:00.000
 Print out the first element.

00:00:00.000 --> 00:00:00.000
 [ Typing ]

00:00:00.000 --> 00:00:00.000
 For auto iter equals begin FA plus 1.

00:00:00.000 --> 00:00:00.000
 Iter not equal to end FA plus plus iter.

00:00:00.000 --> 00:00:00.000
 [ Typing ]

00:00:00.000 --> 00:00:00.000
 And for 2E.

00:00:00.000 --> 00:00:00.000
 [ Typing ]

00:00:00.000 --> 00:00:00.000
 Now all of these will work inside a function

00:00:00.000 --> 00:00:00.000
 if you pass the arguments.

00:00:00.000 --> 00:00:00.000
 If you pass up here the size as an argument.

00:00:00.000 --> 00:00:00.000
 This you don't need to pass anything.

00:00:00.000 --> 00:00:00.000
 If it's got a terminator in it, you're fine.

00:00:00.000 --> 00:00:00.000
 A sentinel in it.

00:00:00.000 --> 00:00:00.000
 This you would have to pass this second argument, the end pointer.

00:00:00.000 --> 00:00:00.000
 This you'd have to pass both begin and end to the function

00:00:00.000 --> 00:00:00.000
 to do your calculation.

00:00:00.000 --> 00:00:00.000
 And for this one, only works inside a loop.

00:00:00.000 --> 00:00:00.000
 This one would not work inside a function.

00:00:00.000 --> 00:00:00.000
 So this is the range for loop.

00:00:00.000 --> 00:00:00.000
 Okay.

00:00:00.000 --> 00:00:00.000
 [ Typing ]

00:00:00.000 --> 00:00:00.000
 So this is a little harder.

00:00:00.000 --> 00:00:00.000
 If we want to do -- this is going to be DA equals square bracket.

00:00:00.000 --> 00:00:00.000
 And we're going to do DA sub zero.

00:00:00.000 --> 00:00:00.000
 We're going -- so this one with a range for loop,

00:00:00.000 --> 00:00:00.000
 it's kind of hard to do the fence post algorithm.

00:00:00.000 --> 00:00:00.000
 And so we're going to have to create a Boolean.

00:00:00.000 --> 00:00:00.000
 [ Typing ]

00:00:00.000 --> 00:00:00.000
 We're going to have to go for auto E and DA.

00:00:00.000 --> 00:00:00.000
 If printing C out comma E. And then that will skip the first one.

00:00:00.000 --> 00:00:00.000
 We'll turn on the printing for the second one.

00:00:00.000 --> 00:00:00.000
 Okay. So a little hard to do fence post with the range base loop

00:00:00.000 --> 00:00:00.000
 because it goes through every element in the array.

00:00:00.000 --> 00:00:00.000
 Okay. So that's it.

00:00:00.000 --> 00:00:00.000
 Let's go ahead and try these out.

00:00:00.000 --> 00:00:00.000
 Do make run.

00:00:00.000 --> 00:00:00.000
 And here's our last one.

00:00:00.000 --> 00:00:00.000
 This one, remember, we initialized all to zeros like that.

00:00:00.000 --> 00:00:00.000
 All to zeros like that.

00:00:00.000 --> 00:00:00.000
 Okay. We're going to do one more thing here.

00:00:00.000 --> 00:00:00.000
 [ Typing ]

00:00:00.000 --> 00:00:00.000
 And that is I'm going to try and read and write outside

00:00:00.000 --> 00:00:00.000
 of the array bounds before printing.

00:00:00.000 --> 00:00:00.000
 And we want to see what happens to the other arrays.

00:00:00.000 --> 00:00:00.000
 So this, like I said, it's undefined.

00:00:00.000 --> 00:00:00.000
 You're not sure exactly what's going to happen.

00:00:00.000 --> 00:00:00.000
 But I want to show you

00:00:00.000 --> 00:00:00.000
 that the compiler won't stop us from doing this.

00:00:00.000 --> 00:00:00.000
 So let's come up here.

00:00:00.000 --> 00:00:00.000
 After we've printed out those names.

00:00:00.000 --> 00:00:00.000
 It's going to be part three.

00:00:00.000 --> 00:00:00.000
 [ Typing ]

00:00:00.000 --> 00:00:00.000
 So let's say FA sub minus 2 equals 3.

00:00:00.000 --> 00:00:00.000
 And let's say LA.

00:00:00.000 --> 00:00:00.000
 How big was LA?

00:00:00.000 --> 00:00:00.000
 LA was 5.

00:00:00.000 --> 00:00:00.000
 LA sub 7 equals 15.

00:00:00.000 --> 00:00:00.000
 Okay. So 3 and 15.

00:00:00.000 --> 00:00:00.000
 Now let's run it again.

00:00:00.000 --> 00:00:00.000
 I want you to see what it looked like before.

00:00:00.000 --> 00:00:00.000
 So here's what it looked like before.

00:00:00.000 --> 00:00:00.000
 We'll do make run.

00:00:00.000 --> 00:00:00.000
 [ Typing ]

00:00:00.000 --> 00:00:00.000
 And now look down here at DA.

00:00:00.000 --> 00:00:00.000
 At DA. And notice that we have this value put inside here.

00:00:00.000 --> 00:00:00.000
 So by changing FA, we actually changed DA.

00:00:00.000 --> 00:00:00.000
 Now it doesn't look like the one we did

00:00:00.000 --> 00:00:00.000
 in LA actually overwrote any other variables.

00:00:00.000 --> 00:00:00.000
 But it could have.

00:00:00.000 --> 00:00:00.000
 We could have kept going and changed.

00:00:00.000 --> 00:00:00.000
 We were writing at LA 7.

00:00:00.000 --> 00:00:00.000
 Let's write it LA 9.

00:00:00.000 --> 00:00:00.000
 Let's try it again and see if the LA changes anything.

00:00:00.000 --> 00:00:00.000
 So we'll do make run again.

00:00:00.000 --> 00:00:00.000
 And okay.

00:00:00.000 --> 00:00:00.000
 So this looking at LA, that looks like that's the LA is the

00:00:00.000 --> 00:00:00.000
 one I'm changing.

00:00:00.000 --> 00:00:00.000
 Looks like the FA, I didn't actually affect any

00:00:00.000 --> 00:00:00.000
 of the other variables.

00:00:00.000 --> 00:00:00.000
 So we'd have to look at these addresses.

00:00:00.000 --> 00:00:00.000
 We'd have to draw ourselves a little memory map.

00:00:00.000 --> 00:00:00.000
 And we'd be able to tell what happens

00:00:00.000 --> 00:00:00.000
 when we write outside of that.

00:00:00.000 --> 00:00:00.000
 But you notice it didn't give me a syntax error.

00:00:00.000 --> 00:00:00.000
 It didn't give me a compiler error.

00:00:00.000 --> 00:00:00.000
 It simply overwrote parts of my other program.

00:00:00.000 --> 00:00:00.000
 Those are very, very hard bugs to find.

00:00:00.000 --> 00:00:00.000
 Okay. So that's it for Lecture 19.

00:00:00.000 --> 00:00:00.000
 When you come on back for Lecture 20,

00:00:00.000 --> 00:00:00.000
 we'll look at some algorithms for arrays.

