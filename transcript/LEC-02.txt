Hello folks, this is Steve Gilbert. Welcome to lecture 2 on C++ syntax and variables.
So before you get started, make sure that you've gone over to lecture 2 and you've started the, uh, downloaded the, uh, starter file, the in-class exercises file here.
This is going to be the problem that we're going to work on today.
So let's talk about what computers actually do.
What do computers actually do?
Well, computers take input, which is raw data, they convert that input or process it, and they output it as information.
This is the fundamental process that every piece of computing goes through.
It's kind of like a Cuisinart. With my Cuisinart I can take onions, I can take peppers, I can take tomatoes, and I can put them in the Cuisinart, and the Cuisinart will chop them and process them, and I will get salsa as my output.
So we're going to look at this input processing and output, uh, technique while writing a C++ IPO program.
So let's go ahead and look at the instructions for that program.
So here's our problem description.
Workers at a particular company have won a 7.6% pay increase, retroactive for six months.
We're going to write a program that takes an employee's previous annual salary as input, and outputs the amount of retroactive pay to the employee, the new annual salary, and the new monthly salary.
Use a variable declaration with the modifier const to express the pay increase.
Then the instructions give us some, uh, a picture showing us what the output looks like.
This should be called a mockup or a sample run.
So you notice we're going to ask the user to enter the current annual salary.
They're going to type in a number, 10,000 here.
And then it's going to print out the new annual, the new monthly, and retroactive salary.
And it has those three numbers inside a set of brackets.
Those brackets are simply to make it easy for us to test the code to make sure that we have the output.
So, how do we solve this problem?
Well, how do we solve any computer problem?
We solve any computer problem by designing the inputs, the outputs, and the calculations.
So let's talk about that, and let's look at that.
Now I'm going to go over to our IDE.
I have opened up the problem over here.
And so notice this is in our IC folder that we downloaded when you first started.
And in the IC folder, in IC02, for lecture two, notice we have a lib salary calc A.
This is a binary library that's going to contain the testing code and so forth.
We have a make file, which is going to control the building of the program.
And we have the file that we're going to work on, salary calc.
So click that, open it up.
You can drag the terminal down here near the bottom so it's not taking up so much space.
And we're going to go ahead and put our names on this in two places, just like you saw with the homework.
So, Steven Gilbert.
And for the date, I'm just going to put the semester.
Actually, I'm going to put CS150 so I could perhaps use this video for another semester.
Secondly, we're always going to make sure you put in your user name, your Canvas login name here.
It needs to be all in lower case.
Mine's S. Gilbert.
Yours will be whatever you use to log into the CS150 Homework Console.
And we're going to put one line that describes what the program does.
And it's going to calculate wages after salary increase.
Now, to figure out the inputs, outputs, and processing, the easiest way to do that is simply to take the problem over here.
I'm going to copy it from the problem description.
Come over to our IDE.
And paste it in here where it says "Add your implementation comments" here.
So I'm just going to paste that there.
And then I'm going to go ahead and I'm just going to break that into multiple lines.
I'm just using my mouse and the Enter key.
And I'm going to make it into a nice comment so that I can read it when I'm working on my code, rather than having to keep going back to the instructions.
Now, I'm going to select all this code, just with my mouse like that.
Then I'm going to hold down my Control key and the forward slash key.
It's the one with the question mark on it.
And notice that that is going to comment that code out so that I can look at this and find out what the inputs, outputs, and processing are.
So, what are the inputs that we can see from this problem statement?
Well, it says it's going to take an employee's previous annual salary.
So I'm going to write here as a comment, "Input, annual salary."
Now, what is the output?
It's going to output the amount of retroactive pay.
So, outputs is retroactive pay.
It is new annual and monthly salaries.
Okay, so I know that I have the input.
The output, is anything given about this problem?
Or do we assume anything?
So, given or the assumption is that pay increase is 7.6% for 6 months.
So, the pay increase is 7.6%. The retroactive pay is for 6 months.
Okay, so let's figure out, so we've figured out what the inputs, the output, and the salary is.
So now we need to figure out how to calculate the salary.
We need to put in the algorithms here.
So again, we do this before we write a single line of code.
We figure out what we're going to do.
So, the processing step for new annual is going to be take the annual salary and multiply it times 1 plus the pay increase.
Okay, now that we have the new annual salary for the new monthly, I'm going to take the new annual salary and divide it by 12.
12 for the month per year.
And finally, we have one last piece of processing.
I need the retro pay.
And that I'm going to get by taking the new annual, the old annual, new annual, which will be larger.
Subtracting the old annual and then dividing that whole thing, that difference, by 2.
Because remember, they're only getting paid for 6 months and 6 months is half of a year.
Okay, so once I've done that, I can get rid of my problem statement that I've put up here.
And I have a plan or a goal or a way to start.
So this is what we did.
We designed the inputs, the outputs, and the calculations.
And then we added our IDs and our comments to the file.
Now step 2 for these kinds of programs is always just to mock up the input and the output.
And use literals for each piece.
So let's look at what the output looks like.
So this is what the output should look like. I'm just going to copy it here.
I'm going to come over to my IDE.
And I'm going to paste it here where it says write your code here.
Now, one neat thing you can do with your editor is I can hold down my Alt key.
And I can move it through two lines like that.
Oh no, I can't.
No, I take that back. We can do it in the old editor. We can't do it in the next editor.
So I'm just going to select those lines I'm going to tab over.
And then I'm going to put quotes around the parts that I want to stay as is.
Quote.
And quote.
Quote.
So the part that's going to stay plain text, I'm putting inside quotes to turn it into a string.
And now I'm just going to use the cout object on that to print that out.
I'm going to say cout. I'm going to print out that first string part.
Then I'm going to print out the dollars.
And then that's the end of that line, so I'm going to print an end line.
I'm going to do the same thing for the second line.
Cout.
I'm going to print that text.
Now here I don't really like a long line, so I'm going to bring this one down like that.
Tab it over so it's indented.
And put the operator there, the output operator.
I'm going to put the output operator between those two pieces.
The output operator between those two pieces.
Those two pieces.
And finally a new line at the end of it.
Okay, so now I have figured out what I want to do. I've planned.
I have mocked up the output. Let's see if it works.
We're going to do that by first making sure we're in this folder.
The way we're going to do that is I'm going to right click on the A, that is the name of that folder, ICO2A.
And I'm going to say Open in Integrated Terminal.
And notice my terminal then is going to have the full path to where I'm building my program.
If it doesn't have the full path, if it just says $, that means you're in the wrong folder.
So let's run this. Let's do Make Run.
So that compiles it, that runs it, that prints the output.
And if I look at this output, enter the current salary, there's a space here like there should be.
There's a space here and there's spaces and commas between each of these as there should be.
And I compare that to this output. It looks almost the same.
Now we have one slight problem here is that we don't have the correct number of decimal places for two of these numbers.
I believe one of them is okay, the 6-7, yeah the 6-7 looks okay.
These two aren't showing the decimal places. We'll see how to figure that out later.
So again, this is the part that you can simply memorize and learn how to do.
This is a technique for building these kinds of programs that you can do very quickly
so you can get the format for the output correct.
So now, let's go ahead and talk about variables and values to actually solve this program.
And so, okay, so we ran it and we compared it to the hand output, handout.
And now we're going to talk about variables and values.
So what's a variable? A variable is simply a box that is made out of memory.
So your computer has a CPU, it has memory, it has external storage like a hard disk or something like that.
It has input and output devices. But memory and CPU are the main parts of it.
And memory is where we are going to store data.
So if I take three or four blocks of memory, what we call bytes, that could be a box.
Programs store their data that they get for input and they process in things called variables.
So a variable is like a box and it has a label on it.
The label is going to describe the kind of thing that's in the box.
The box is memory, the label is its name.
Now with this box, we can put something into it.
That means we can initialize a variable with a value.
We can take something out of it. That means we can read it or print it or output it.
Finally, we can change what's in the box.
We can assign to the variable and put a new value into the box.
So this is just an analogy, of course.
It's a way of thinking about what's going on with variables.
Now the size of the box restricts what you can put in it.
If you have a little box, you might put jewelry in it.
If you have a bigger box, you might put a hat or something like that in it.
So the size of the box restricts what you can store.
Again, this is an analogy. If you have one byte, you can store a certain amount of things.
If you have ten bytes, you can store something larger and a different kind of thing.
So this concept, the fact that variables hold data
and that data can be different types is called a values type.
So inside a variable, we call that information, the things that are in that byte, its value.
A variable can have different values as the program runs.
It might start out with one value, and later on as the program runs, we'll change it to a different value.
There are also different kinds of values we can put in variables.
We have different kinds of containers for each of those values.
So if you go down to 7-Eleven and you buy coffee, they give you one kind of container to hold the coffee.
If you buy a Big Gulp or a Slurpee, they give you a different kind of container.
Popcorn goes in a different kind of container as well.
In addition, you can have different sizes of containers for the same kind of things.
So you could buy a Big Gulp, which is 32 ounces, or a Super Big Gulp, which is 64 ounces.
We do something similar with variables and values.
So a value is a quantity of data.
So 1 is a value. 3.1459 is a value.
Steve is a value, in double quotes.
D is a value, in single quotes.
True is a value.
And each of those values represent different kinds of things.
1 represents an integer.
3.1459 represents a floating point or real number.
Steve, in double quotes, represents what we call a string.
D represents a character.
And true represents a Boolean value.
You've already seen the objects Cout.
Cout represents a stream object.
So values are quantities of data.
Now, the kind of value is called the variables type.
And our formal definition for a value is simply a set of bits.
So if you have one byte, you have eight bits.
If you have two bytes, you have 16 bits.
If we take those bits by themselves, they don't have any meaning.
If we interpret them according to their type, they have a meaning.
So if we say that this byte in memory is a character,
it may represent the letter capital A.
If we take the same set of bits, exactly the same set of bits,
and we say, no, we're going to interpret that as an integer,
it would have the value 65.
So a value is a set of bits that we interpret according to its type.
So if that's a value, what is a variable?
So a variable, I've already given you an analogy.
It's a box of memory.
But mainly, but formally, it's a named storage location
that holds a value.
Now in C++, we can use pretty much the same names
that you would use in Java or Python.
Generally, the name has to start with a upper or lowercase letter,
and it can contain numbers or underscores.
It cannot contain spaces.
It cannot contain hyphens.
There are some other requirements about where the underscores can appear.
It cannot contain dollar signs like some names in Java can.
And the names all have to be ASCII characters.
They cannot be Unicode characters.
So in Java, for instance, although I'm sure most of you never did this,
you could use the symbol pi, which is, of course, a Greek letter,
as the name of a variable.
You can't do that in C++.
So a variable is a named storage location that holds a value.
It's not the same as a value.
We say that a variable is something that we can point to it in memory
if we visualize memory and say,
"This variable lives at that location."
We say that it's addressable.
And the name we use for things that are addressable like that
are objects.
So variables and objects, kind of in the lower case,
not the object-oriented sense of objects,
are things in memory that hold a value
and that they're addressable.
Now, each variable holds values of one type.
What that means is, unlike, say, Python,
those of you who came from Python,
you cannot create a variable A
and put an integer in it at one time
and then put a string in it at another time.
Each variable holds a value of one type.
So we say that these variables are strongly typed in C++.
Now, to create, that is, to declare and to define a variable,
we do two things.
We give it a name, and we specify the kind of thing it holds,
or its type.
So the syntax is just type, space, name, semicolon.
Now, of course, you might wonder, if we do that,
what value is going to be in it?
Well, no value or a random value.
Now, in Java and in Python, if you did this,
if you just said type name, well, Python doesn't have types,
but in Java, if we said int a,
we can use that variable a.
In C++, we can, but it's really a mistake
because we haven't given the variable an initial value.
So we can give the variable an initial value when we create it.
This is called initialization.
And there are several syntaxes for this.
You might wonder why.
That's because C++ has been around since the early '90s,
and as time's gone on, they've changed the syntax.
The syntax has been updated.
So this is called legacy or traditional initialization.
It looks kind of like assignment,
but it's not really the same thing.
It's just creating the variable
and giving it an initial value when you create it.
We can do it this way.
So type name, and we put the value in parentheses after the name.
This was in the original version of C++.
And in the newest version of C++, C++11,
we can actually use braces, curly braces around the value.
And this has some advantages.
So as you go forward, you generally should prefer this third reason,
although most of us, or many of us,
probably still use the first one just for, you know, from habit.
Now the equals sign here when we say name equals value,
of course, doesn't mean equality as it is in algebra.
What it means is copy the stuff from the right
into the variable on the left,
or initialize name with this value.
Okay, so let's create a variable.
Let's go back to our problem.
Let's create a variable to hold the current salary.
Now the question is, what kind of thing should it be?
C++ has two families of numbers.
They have integers, and they have real or floating point numbers.
Integers are whole, discrete numbers.
And floating point numbers, or real numbers,
may have a fractional part.
And so our salary could have a fractional part.
In other words, someone could make, you know, $1,000.52.
And so we would want to use a real or floating point number.
Like Java, the most common real or floating point number we use
is called double.
So let's create a double variable.
So I'm going to create, and I'm going to do it,
I'm actually going to divide my code here.
I'm going to put three more comments.
I'm going to say this is the input section.
I'm going to say this is the processing section.
And then I'm going to say this is the output section.
And I always do that when I write an IPO program.
So I keep track of the sequence of instructions as I type them.
So we're going to create a variable.
Its type is going to be double.
And its name is going to be annual salary.
Now, this is called snake case.
And you're free to use that style.
Or we could write it as --
this is called camel case.
And this is popular in Java, of course.
It's the current style.
So you can use either one of those.
I have no preference on those,
although I'm going to use the annual salary,
the one that is camel case.
Actually, I do have a preference on them,
but I don't have a preference for this class.
You're free to use either one.
I just find the camel case a little easier to type.
Don't do this.
Don't start it with an uppercase character.
So this is fine, all lowercase, separated by underscore.
This is fine.
Start with a lowercase and use capital letters as the interior.
So it's camel case.
This is called proper case.
We'll use proper case for classes and structures.
So there's annual salary.
Now the question is, what should I initialize that with?
In other words, annual salary has no value.
What should I initialize it with?
The answer is, we shouldn't initialize this with anything.
We want to get the input from the user.
We want to get the input.
We want to get the value from input.
We don't want to give it an initial starting value.
And so to get the value from input,
we use an object that is similar to cout.
This object is called cin, the character input object,
which will allow us to type from the keyboard.
Think of cin as similar to the scanner in Java,
if you're familiar with the Java programming language.
And to do that, we'll simply say cin.
This is called the extraction operator,
and we'll extract from cin the characters,
convert those characters to the value,
and store the value inside the variable.
So let's look at our problem here and see how we do that.
So here's my annual salary.
And so I'm going to say cin annual salary.
Now we have to make one more change.
Don't forget to make this change.
Notice this 1,000 is really not supposed
to be part of the output.
This 1,000 is supposed to be what the user types in.
So we need to come up here from our mockup,
from our dummy data, and remove that 1,000.
This endl, this new line, again,
that new line is not supposed to be part of the output.
We want the user to type their input directly after this,
which is called the prompt.
So we want to prompt them, we want to get the input,
and so this endl goes away as well.
Make sure you leave the semicolon.
So when the user hits enter after typing in the annual salary,
that will work.
So let's just try that briefly.
Let's just go up and let's just do make run again.
You can just up arrow to get make run.
And notice it stops now, and it waits for me
to type something in.
So I'm going to type in $10,000,
and notice I get the same output.
Of course, since our output isn't tied to our input at all,
we'd get the same output no matter what we did in this case.
So here is creating a variable
and getting input into a variable.
Now, processing.
So we've done the input phase.
The input phase is done.
Now the processing phase.
We want to turn our input into our desired output.
And our desired output is annual and monthly salary
or new annual and new monthly salary
and the retroactive pay.
And so we're going to create variables for each output value.
So again, you can use, I'm going to be consistent here
and use camel case, but again, feel free to use snake case
if you prefer that.
So these are going to be all doubles
since our original was a double.
So annual, I'll call that new annual.
And double new monthly.
And double retro pay.
Now, we could now, that we have the variables,
we could process them.
And in C, that was very, very common.
Many other languages that's common.
But that's really not a good habit to get in.
So instead of doing that, instead of doing int var
and then on another line, putting in your calculation,
you should initialize it on the line that calculates it.
So let's just review our three algorithms.
So the first one was we're going to let our new annual
be the original times one plus the raised percent.
We're going to let our monthly be the annual
divided by the months per year.
And we're going to let our retroactive pay
be annual minus original divided by two.
Now, we have to be careful when we do this.
We have to be careful we put the parentheses
in each correct place.
So using that algorithm, I'm going to say
my new annual is going to be my annual salary.
Now, instead of that, we use star,
just like in Java and Pascal and in Python.
And this is going to be one plus the raised percent,
which is 7.6%.
But again, like other programming languages,
we can't write it out like that.
We have to write it out as this mathematical equivalent,
which is 0.76 with a dot in front of it.
And just like in algebra, we have to be aware
of where the parentheses go in an expression.
So in this expression, notice that this does
multiplication before addition.
And so this says annual times one plus 0.76.
So that would give me a raise of 7 cents,
not what I want for the year.
So to get the addition to happen first,
what I'm going to need to do is put parentheses around that.
So that gives me the new annual salary.
Our algorithm for the monthly was new annual
divided by 12, or months per year.
And the retro pay was the new annual, the larger one,
minus the annual.
That would give me the retroactive pay for one year,
but we only get the retroactive pay for six months.
So I'm going to divide it by two.
And again here, if we didn't have the parentheses on,
that would give me the new annual salary
minus the annual salary divided by two,
which again would be much more than I actually deserved
in the output.
So this is the calculation or the processing part.
This is the calculation or the processing part.
Okay, so now let's look at that pay increase, 7.6 amount.
And you can see that here in this expression here, 7.6%.
Now if someone reads that,
they're going to wonder what that 7.6% means.
We call that 7.6% a magic number.
And we should avoid doing that.
We should use named constants, not literal values in your code.
As a matter of fact, there's a software engineering rule
called the magic number rule that says that any literal
other than zero, one, or minus one is suspect in your code.
And you should think about replacing it.
So to create a constant,
we use something that's similar to Java with final,
but instead we use a qualifier called const.
And so const double, and here I'm using the Google style,
which is to create constants starting with the lower case k
and then proper case.
Here's the Java style for this.
I'm going to try and use the Google style from now on
because in C++ all caps usually mean something called a macro.
So let's go ahead and add that.
And I'm going to actually add two constants
to our example program here.
So in my processing, I'm going to create a const,
const double k raised percent equals 0.0776.
See if I can type it right, 076.
And then in my code I'm going to replace that with k raised percent.
I'm not quite sure why I didn't pick up the name here.
Let's see if I spelled it right.
Yeah, it'll probably pick it up in a couple seconds.
We're going to create a second one here for this months per year.
So I'm going to say const, just to give you some practice,
constant k months per year is 12.
I think we all know that, but k months per year.
Okay, that looks pretty good.
Let's go ahead and try running it again.
So to clear the terminal like this,
you can hold down the control key and press L.
So that will clear the terminal.
So I'm going to say make run again.
Okay, I got an error.
That's because I put a period here instead of a semicolon.
There I got a semicolon.
So let's clear the terminal and run it again.
Okay, so it wants my current salary $10,000.
Okay, well my output actually, we actually kind of skipped one step.
And that is I've done the input, I've done the processing,
but my output I'm still using constants here, literals.
And so I want to take new annual,
and I want to replace this number that I put in there.
And I want to replace new monthly,
and I want to replace that number that I put in there.
And I want to take retro pay,
and I want to take replace that number that I put in there.
So once we've done that,
now let's go ahead and make run.
This time when I put in the $10,000,
it's actually doing my processing and calculation.
If I put in different numbers, I'd get different values out.
And, ooh, it actually even looks worse than it did before.
I still don't have the periods here.
I have three decimal places there,
and I have no decimal places there.
So let's tackle that next.
How do we format real numbers?
And we format real numbers with something called
input/output manipulators.
These are in a different header file.
They are not in I/O Stream.
They are in the header file called I/O Manip.
And these are objects.
These provide objects and functions
that we can set inside and print out to the stream
to modify the way the stream works.
Now, we're only going to memorize one of these now.
So we're going to put in the I/O Manip.
And I've probably already put it at the top.
Yeah, I've already put it here at the top for this problem.
And we're going to say, before we do any output,
we're going to say, I want all of my real numbers
to appear in fixed format, meaning not scientific notation.
And when those real numbers appear,
I want their decimal places or their precision
to be two decimal places.
Now again, this only needs to appear once.
It only needs to appear once.
So let's try our running it again.
Make run $10,000.
And notice now, we get-- oh, actually, I got--
these numbers are wrong, aren't they?
Oh, I did 1,000, not 10,000.
Let me do 10,000.
OK, so this time I got my two decimals there.
I got my 0.67.
I got my two decimals there.
Now, once we've run this,
I'm going to maximize that panel size,
and I can minimize it there rather than bringing it up and down.
Once I've done this, I can test to make sure if it's correct.
So I'm going to say, make test.
And notice it will check for all of these different kinds of inputs
for the original salary.
Notice it will say here my name and the instructor tests.
And this is what you're going to take a picture of for your screen.
At the top, it wants a picture of your source code.
And then you're going to paste in a picture of your test results there.
So those are the two things we're going to turn in for this.
We don't--I'm going to minimize that again.
We don't, when we're doing in-class exercises,
you won't do make submit.
If you tried to do make submit, it would tell you,
I'm sorry, there's nothing like that here, so make submit.
It'll say, no, there's no rule to make the target submit.
And so that simply means we don't do that for in-class exercises.
Okay, so that's it for the in-class exercise.
Let me talk to you a little bit more about variables.
In this class, unlike your first programming class,
we're actually going to talk about things at a more technical level.
And so we're going to use vocabulary more literally or specifically.
So we have five terms that we use with a variable.
We also use these with functions and classes.
So a declaration associates a name with a type.
And so a declaration of a variable has this keyword extern in front of it.
So when I say extern int x, I'm telling the compiler that x is of type int.
This does not specifically create the variable at this point.
The variable can be created somewhere else in your program.
And the variables in your program must be declared
for the rest of your program to compile.
They do not need to be defined. For instance,
in your homework you have a variable assignment.
Let's go look at one of your homeworks.
So I'm going to go up to homework.
I'm going to go homework 1.
I'm going to look at homework1.cpp.
And I'm going to bring this down.
And notice there's this string assignment.
Notice it's not just string assignment.
It's extern string assignment.
That means that this variable, the compiler knows that assignment is a string,
but it doesn't see the definition of that.
It's defined somewhere else.
In this case, it's defined in this file, libh01.a.
It's defined in some compile code.
So a declaration allows us to use a variable that is defined elsewhere.
A definition is something that actually creates an object or code.
So when I write int y, the compiler reserves enough space for an int
and remembers that that particular space it reserved is only for an int.
So this is called a definition or, in this case, a defining declaration.
It both associates the name y with int,
and it creates the variable or allocates the space for the variable y at that time.
Now I'm going to kind of go ahead a little bit
and talk about something we're going to talk about later.
So if in this variable I say int y,
I have created a variable y inside that function.
It's only visible inside that function,
and it has automatically managed the memory for it.
If I come up here and I say int x, I've created a variable x,
but that variable is not automatically managed.
It's put in what we call the static storage area.
This is what we call a global variable,
and y down here is a local variable.
So both of those are allocated in different regions of memory,
and we'll talk about that much later in the course.
Now, in Java and in the C# programming language,
defining a variable is not enough to use it.
You must also give it a value.
If you do not, you will get an error.
In C++ that is not the case.
In C++, if we don't use this variable, it is an error.
If we tried to print out the variable y, it is an error,
but it is not a syntax or a compiler time error.
It is a logical error.
And so to use a variable, you must provide it a value
by using initialization, provide an initial value,
assignment, copy a new value into the object
after it's been created,
or input, like we did for annual salary.
That's just a special form of assignment.
So I want to talk about each of these four things
before we stop today's lecture.
So initializing variables--
so the variable definition doesn't create it.
If I do this, it's--
when you create the variable with a definition,
you have to initialize it or otherwise populate it.
Again, it's not a syntax error.
It is a logic error.
And there are three ways to initialize a variable.
There is the new way that we have in C++11.
Double x--or double c embraces the initial value.
This is called uniform initialization.
It didn't work before C++11.
Of course, that's 10 years old now.
This is called legacy initialization,
double a equals 2.5.
This is not direct--not assignment.
We'll talk about what assignment is in a second.
And this is direct initialization
with the value inside the parenthesis.
You should prefer this top one now.
You should prefer the top one because in most languages,
if I were to write this--
now I'm just going to write some code here.
If I were to write this in int x equals 3.15,
most of you who have taken Java
would recognize that that is an error, right?
We can't store a 3.15 if x is an integer.
We will lose the .15.
In C++, that's not an error.
It simply throws away the .5
and converts it automatically to 3.
And that's kind of error-prone, isn't it?
You might have meant to make something a double,
and instead you made it an int,
and you saw the 3.15,
and you thought, "For sure, I've made it a double."
And so if we use the other kind of syntax here,
if we instead wrote it like that,
when we compiled our program,
it would say that that is an error.
So prefer this one with the braces
instead of the old legacy style,
which permits you to lose some precision on your variables.
The same thing is true with assignment.
So assignment doesn't have the type in front of it.
It's not creating a value with initial value.
So, for instance, look at this.
Again, I'm going to go back here
and just put code inside here.
I can do this, int x.
Okay, so that's assignment.
I can do this, int y.
But I cannot do this, int z.
z equals 4.
So this statement here is an assignment.
It can only happen when your program runs.
This statement isn't an initialization.
It happens when your program is compiled.
And so assignments are executable statements.
They can only appear inside of a function.
They only are executed when the program runs.
The other thing about assignment is just like initialization,
if you use this traditional style, num equals 3.159,
even if num is an int or a character,
it will do that assignment.
And that obviously is kind of error prone.
So you should get in the habit, when you use assignment,
of putting the value inside braces.
Now if n2 is an integer, the compiler will warn me,
"Oh, you're trying to put the wrong kind of value in that integer.
Do you really mean to do that?"
And so again, C++11 has added several safety features
that allow you to catch your errors earlier
rather than later with a bug that appears in your code.
Finally, the third way we can populate a variable
is through input, like we did with annual salary.
Okay, so let me talk about assignment.
So assignment stores a value in a variable.
The assignment operator is the equals token.
It doesn't mean a quality like it would be in algebra.
And assignment is an expression, not a statement.
That means it has a value.
That means I can say this.
Again, I'm just using up one of my homework assignments here.
I can say a equals b equals 7.
That's because this expression copies 7 to b.
That's the side effect.
b is changed to 7.
And the whole thing has a value.
The value of that expression is 7,
which is then copied to a in that case.
So assignment is an expression, not a statement.
Now of course, this, a equals 3, is an assignment statement
because I made it a statement by putting a semicolon at the end of it.
Okay, so the assignment statement has three parts.
The object where the value is going to be stored.
That appears on the left of the assignment operator,
and so it's called an L value.
An L value has to be an object.
That means it has to be a region where we can store values.
That means it has to be addressable.
The assignment operator, the equals sign, as I mentioned before,
is not the equivalency operator.
And finally, the value to be stored.
This appears on the right-hand side, so it's called an R value.
And so let me give you another couple of examples here.
Again, messing up my piece of homework code here.
So int a equals 3, b equals 5.
So I can write b equals a.
In this case, a is an R value, b is an L value.
I can write b equals 7.
Again, b is an L value, 7 is an R value.
I cannot write 7 equals b.
I can't do that because the thing on the left is not an object in memory.
It's not a place where I can store stuff.
It is not an L value.
One other thing about L values is we have one kind of L value that you cannot assign to.
And that's called a non-modifiable L value.
So const int x equals 3.
So that's illegal because x is an L value because it appeared on the left-hand side of this assignment operator,
but the const made it non-modifiable, so I can never again assign to it.
I can only assign to it in its initial value.
So constants are non-modifiable L values.
Arrays are also non-modifiable L values.
The last thing we looked at in this lecture is input.
So for numeric input, we're going to use cn and the extraction operator.
So these arrows pointing away from cn signify that we're extracting or reading characters from cn,
and we're putting the result in this variable over here.
Now the way the cn object works is it reads and it discards leading whitespace characters.
So the user can type in space space 42.
That's perfectly fine.
Once it finds a character, so the user has typed in space space, discarded those, 42,
it reads the characters and it matches the characters to the type of the variable.
Suppose my type of my variable was an int.
It would match the four and it would say, "Yes, I can use that," and it would save that variable.
Reads the two. "Yes, I can do that."
And then suppose the user typed x, so 42x.
When it finds a character that doesn't match, it stops reading.
So now the cn object has read and saved two characters, a four and a two, those two characters.
It takes those two characters, reading is finished, and it converts those characters to binary data.
It would convert the two characters, the character ASCII character four and the ASCII character two,
convert those to the binary number 42, and it would store it in this variable.
Now the question is, what happens if the input doesn't match the type of the variable?
In other words, what happens if we said cn variable, the variable was of type int, and the person typed in dog?
Well, in Java, what happens, and Python as well, the code goes into some kind of exception.
Your program crashes, essentially, and prints nice red error messages, depending on the type of IDE you have.
In C++, that doesn't happen. We say that cn goes into a fail state.
It simply stops reading any other input until you deal with it.
There is no runtime exception like there is in Java.
Now, what if we had this statement, cn variable, the variable was an int,
and we already saw that they could type in 42 dog, and it would read the 42, okay.
We saw that they couldn't type in dog, cn would fail.
What if they don't type in anything?
Well, if they don't type in anything, if there is no input waiting, the program blocks.
That's because the keyboard driver, basically, when you say cn variable,
control is transferred from your program over to the keyboard device driver of the user.
The device driver is telling it, wait a second, I'll wait for the user to type.
So, you've seen when this happens, that you basically get a blinking cursor on the screen as the program waits for input.
Okay, so that's it for lecture two. I'll see you next time.
