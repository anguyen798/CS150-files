1
00:00:00,000 --> 00:00:00,000
Hi everyone, this is Steve Gilbert.

2
00:00:00,000 --> 00:00:00,000
Welcome to Lecture 19, where we're going to talk

3
00:00:00,000 --> 00:00:00,000
about arrays and pointers.

4
00:00:00,000 --> 00:00:00,000
Now, an array is like a vector, except it's built in.

5
00:00:00,000 --> 00:00:00,000
So it's a built in derived type.

6
00:00:00,000 --> 00:00:00,000
What do we mean by a derived type?

7
00:00:00,000 --> 00:00:00,000
A derived type is one that is built from another type.

8
00:00:00,000 --> 00:00:00,000
So a pointer is a derived type.

9
00:00:00,000 --> 00:00:00,000
You just can't have a raw pointer that is not of any type.

10
00:00:00,000 --> 00:00:00,000
It has to be a pointer to an integer or a pointer

11
00:00:00,000 --> 00:00:00,000
to a double, and so forth.

12
00:00:00,000 --> 00:00:00,000
And an array is the same way.

13
00:00:00,000 --> 00:00:00,000
We can't just have an array that collects anything.

14
00:00:00,000 --> 00:00:00,000
We have to have an array of int or an array of double.

15
00:00:00,000 --> 00:00:00,000
So it's a built in derived type for collecting elements.

16
00:00:00,000 --> 00:00:00,000
Now, we use the term array in Java as well,

17
00:00:00,000 --> 00:00:00,000
but arrays are quite, quite different in C++.

18
00:00:00,000 --> 00:00:00,000
They are much closer to the actual machine type,

19
00:00:00,000 --> 00:00:00,000
the way that your CPU works and memory works under the hood.

20
00:00:00,000 --> 00:00:00,000
So like the vector, they're a homogeneous collection.

21
00:00:00,000 --> 00:00:00,000
All of them has to be the same type.

22
00:00:00,000 --> 00:00:00,000
And like a vector, we have continuous storage,

23
00:00:00,000 --> 00:00:00,000
contiguous storage, meaning one element right next

24
00:00:00,000 --> 00:00:00,000
to each other, and random access,

25
00:00:00,000 --> 00:00:00,000
direct access to any element.

26
00:00:00,000 --> 00:00:00,000
So let's see how we define an array.

27
00:00:00,000 --> 00:00:00,000
So to define an array, we give the base type double,

28
00:00:00,000 --> 00:00:00,000
the name of the array, and then in brackets afterwards,

29
00:00:00,000 --> 00:00:00,000
the number of elements inside the array.

30
00:00:00,000 --> 00:00:00,000
So unlike Java, where you could create an array variable,

31
00:00:00,000 --> 00:00:00,000
double nums bracket bracket or double bracket bracket nums,

32
00:00:00,000 --> 00:00:00,000
you cannot create an array variable

33
00:00:00,000 --> 00:00:00,000
without specifying how many elements you want.

34
00:00:00,000 --> 00:00:00,000
And that capacity must be a constant,

35
00:00:00,000 --> 00:00:00,000
and it must be known at compile time.

36
00:00:00,000 --> 00:00:00,000
Again, this is different than Java.

37
00:00:00,000 --> 00:00:00,000
In Java, you could ask the user how big an array,

38
00:00:00,000 --> 00:00:00,000
and then you could create a new array with that size.

39
00:00:00,000 --> 00:00:00,000
You can't create a regular, what we call a static array,

40
00:00:00,000 --> 00:00:00,000
that way in C++.

41
00:00:00,000 --> 00:00:00,000
Now, this array definition will allocate an entire block.

42
00:00:00,000 --> 00:00:00,000
So int a5, if we put that line inside a function,

43
00:00:00,000 --> 00:00:00,000
will allocate a block of five integers on the heap.

44
00:00:00,000 --> 00:00:00,000
There is no separate variable that points to this.

45
00:00:00,000 --> 00:00:00,000
The address is simply, the name a is simply the address

46
00:00:00,000 --> 00:00:00,000
of the first element.

47
00:00:00,000 --> 00:00:00,000
There's no additional, what we would call,

48
00:00:00,000 --> 00:00:00,000
metadata associated with it.

49
00:00:00,000 --> 00:00:00,000
Now, the access is sequential.

50
00:00:00,000 --> 00:00:00,000
One right on top of another on the stack, and contiguous.

51
00:00:00,000 --> 00:00:00,000
So we can simply go from one to another,

52
00:00:00,000 --> 00:00:00,000
simply by using addresses.

53
00:00:00,000 --> 00:00:00,000
So if we want the element at 795,

54
00:00:00,000 --> 00:00:00,000
we just take the address a,

55
00:00:00,000 --> 00:00:00,000
and add 795 times the size of whatever the element is.

56
00:00:00,000 --> 00:00:00,000
So the size of int, in this case.

57
00:00:00,000 --> 00:00:00,000
And that gives us the address.

58
00:00:00,000 --> 00:00:00,000
So it's simple, simple arithmetic.

59
00:00:00,000 --> 00:00:00,000
It's very, very fast.

60
00:00:00,000 --> 00:00:00,000
And as a matter of fact, it's even faster than it looks like,

61
00:00:00,000 --> 00:00:00,000
because your CPU has dedicated address circuits that know how

62
00:00:00,000 --> 00:00:00,000
to do these calculations without having to go

63
00:00:00,000 --> 00:00:00,000
through the regular addition

64
00:00:00,000 --> 00:00:00,000
and multiplication part of the CPU.

65
00:00:00,000 --> 00:00:00,000
So there is really no faster way to store data in memory

66
00:00:00,000 --> 00:00:00,000
at all than built-in arrays.

67
00:00:00,000 --> 00:00:00,000
Now, arrays can be initialized in all versions of C++.

68
00:00:00,000 --> 00:00:00,000
And so I can allocate space for four elements,

69
00:00:00,000 --> 00:00:00,000
and I can supply values for all four of them.

70
00:00:00,000 --> 00:00:00,000
Now, notice this is slightly different than what we did

71
00:00:00,000 --> 00:00:00,000
with vectors, because with vectors,

72
00:00:00,000 --> 00:00:00,000
we didn't use the equal sign here.

73
00:00:00,000 --> 00:00:00,000
The equal sign's required as part of the syntax.

74
00:00:00,000 --> 00:00:00,000
So I've allocated and initialized four elements.

75
00:00:00,000 --> 00:00:00,000
I can allocate more and only initialize one,

76
00:00:00,000 --> 00:00:00,000
in which case the remaining elements will be initialized

77
00:00:00,000 --> 00:00:00,000
to zero as well.

78
00:00:00,000 --> 00:00:00,000
Now, not because I put zero inside here.

79
00:00:00,000 --> 00:00:00,000
If I had to put four, the first element would be initialized

80
00:00:00,000 --> 00:00:00,000
to four, and the remaining elements would be initialized

81
00:00:00,000 --> 00:00:00,000
to zero.

82
00:00:00,000 --> 00:00:00,000
What happens if I do this?

83
00:00:00,000 --> 00:00:00,000
Allocate room for three and provide four initializers.

84
00:00:00,000 --> 00:00:00,000
Well, C++ won't let you do that,

85
00:00:00,000 --> 00:00:00,000
and it simply doesn't compile.

86
00:00:00,000 --> 00:00:00,000
How about if I don't allocate any space?

87
00:00:00,000 --> 00:00:00,000
I just leave that blank.

88
00:00:00,000 --> 00:00:00,000
That's fine as well.

89
00:00:00,000 --> 00:00:00,000
C++ will come along, and it will count the number of elements,

90
00:00:00,000 --> 00:00:00,000
and it will implicitly fill this three in for you.

91
00:00:00,000 --> 00:00:00,000
Now, there's one new thing in C++11.

92
00:00:00,000 --> 00:00:00,000
So all versions of C++ work like this.

93
00:00:00,000 --> 00:00:00,000
In C++11, you can simply default initialize it just

94
00:00:00,000 --> 00:00:00,000
by putting braces after it.

95
00:00:00,000 --> 00:00:00,000
If you do not initialize it, the elements are just random.

96
00:00:00,000 --> 00:00:00,000
Now, the individual elements are indexed or subscripted,

97
00:00:00,000 --> 00:00:00,000
just like they would in a vector,

98
00:00:00,000 --> 00:00:00,000
and you access them using the subscript operator.

99
00:00:00,000 --> 00:00:00,000
So A and then the subscript.

100
00:00:00,000 --> 00:00:00,000
That subscript can go from zero to whatever the capacity

101
00:00:00,000 --> 00:00:00,000
of the array is minus one.

102
00:00:00,000 --> 00:00:00,000
So if A has four elements, the elements would be zero, one,

103
00:00:00,000 --> 00:00:00,000
two, three, capacity is five.

104
00:00:00,000 --> 00:00:00,000
What happens with an array if we go out of bounds?

105
00:00:00,000 --> 00:00:00,000
We saw with the vector that it was undefined

106
00:00:00,000 --> 00:00:00,000
if we use the subscript operator,

107
00:00:00,000 --> 00:00:00,000
but we could use V.at three,

108
00:00:00,000 --> 00:00:00,000
and we could throw an exception if that happens.

109
00:00:00,000 --> 00:00:00,000
There's no thing like that for arrays.

110
00:00:00,000 --> 00:00:00,000
If you go out of bounds, you simply get undefined behavior.

111
00:00:00,000 --> 00:00:00,000
The program may crash.

112
00:00:00,000 --> 00:00:00,000
It may access parts of memory it should not.

113
00:00:00,000 --> 00:00:00,000
It may overwrite other variables inside your program.

114
00:00:00,000 --> 00:00:00,000
So you don't know what it's going to do.

115
00:00:00,000 --> 00:00:00,000
What you do know is that it is never an exception.

116
00:00:00,000 --> 00:00:00,000
It is never an exception.

117
00:00:00,000 --> 00:00:00,000
C++ does not throw exceptions for out of bounds.

118
00:00:00,000 --> 00:00:00,000
You may get a segmentation fault, as I said,

119
00:00:00,000 --> 00:00:00,000
if the area you're reading and writing to is outside the

120
00:00:00,000 --> 00:00:00,000
segment that the operating system allows you to write to,

121
00:00:00,000 --> 00:00:00,000
or you may simply overwrite other variables

122
00:00:00,000 --> 00:00:00,000
in your own program.

123
00:00:00,000 --> 00:00:00,000
Now, there's no array variable like there is in Java.

124
00:00:00,000 --> 00:00:00,000
So this is what an array would look like in Java.

125
00:00:00,000 --> 00:00:00,000
We create an array variable, and then we'd create

126
00:00:00,000 --> 00:00:00,000
or allocate room for 10 arrays, or 10 ints.

127
00:00:00,000 --> 00:00:00,000
The 10 ints would be on the heap.

128
00:00:00,000 --> 00:00:00,000
That would be the array,

129
00:00:00,000 --> 00:00:00,000
and the variable would be separate from the array.

130
00:00:00,000 --> 00:00:00,000
That doesn't happen in Java.

131
00:00:00,000 --> 00:00:00,000
There's not these two parts with a variable and an array.

132
00:00:00,000 --> 00:00:00,000
Instead, or that doesn't happen in C++.

133
00:00:00,000 --> 00:00:00,000
Excuse me.

134
00:00:00,000 --> 00:00:00,000
Instead, in C++, the array name acts

135
00:00:00,000 --> 00:00:00,000
like a constant pointer or literal.

136
00:00:00,000 --> 00:00:00,000
Because of that, because there is no array variable,

137
00:00:00,000 --> 00:00:00,000
you can't assign or compare using array names.

138
00:00:00,000 --> 00:00:00,000
So here I have two arrays.

139
00:00:00,000 --> 00:00:00,000
A1 has three elements.

140
00:00:00,000 --> 00:00:00,000
It's initialized, 2, 3, 4.

141
00:00:00,000 --> 00:00:00,000
A2 also has three elements of the same type,

142
00:00:00,000 --> 00:00:00,000
but they're uninitialized.

143
00:00:00,000 --> 00:00:00,000
Could I initialize A2 by simply assigning A1?

144
00:00:00,000 --> 00:00:00,000
No, you cannot.

145
00:00:00,000 --> 00:00:00,000
A2 and A1 are addresses.

146
00:00:00,000 --> 00:00:00,000
Imagine it's address 1,000 and 2,000.

147
00:00:00,000 --> 00:00:00,000
That's like writing 2,000 equals 1,000.

148
00:00:00,000 --> 00:00:00,000
Again, in your code, you can see why that wouldn't compile.

149
00:00:00,000 --> 00:00:00,000
It is okay, of course, to assign

150
00:00:00,000 --> 00:00:00,000
to different arrays using the elements

151
00:00:00,000 --> 00:00:00,000
or the subscripted name.

152
00:00:00,000 --> 00:00:00,000
So we could say A2 sub 0 equals A1 sub 0.

153
00:00:00,000 --> 00:00:00,000
And you could write a loop that would go through

154
00:00:00,000 --> 00:00:00,000
and assign each of those.

155
00:00:00,000 --> 00:00:00,000
You might think, well, you notice on the first line there,

156
00:00:00,000 --> 00:00:00,000
I could assign to A1 using these braces,

157
00:00:00,000 --> 00:00:00,000
what we call an initializer list.

158
00:00:00,000 --> 00:00:00,000
Can I do that to assign to A2?

159
00:00:00,000 --> 00:00:00,000
No. You can only do that when you're initializing the thing.

160
00:00:00,000 --> 00:00:00,000
You cannot use it for assignment later.

161
00:00:00,000 --> 00:00:00,000
That simply doesn't work.

162
00:00:00,000 --> 00:00:00,000
Finally, you can do this.

163
00:00:00,000 --> 00:00:00,000
If A2 equals equals A3, okay, well,

164
00:00:00,000 --> 00:00:00,000
actually I don't have an A3 here.

165
00:00:00,000 --> 00:00:00,000
It probably should say if A1 equals equals A2.

166
00:00:00,000 --> 00:00:00,000
But both of those would be perfectly legal.

167
00:00:00,000 --> 00:00:00,000
They will compile, but they are really not very smart.

168
00:00:00,000 --> 00:00:00,000
That's because, again, A1 and A2 are different arrays.

169
00:00:00,000 --> 00:00:00,000
That means all A1 and A2 are are addresses.

170
00:00:00,000 --> 00:00:00,000
So we're not comparing what's at those addresses to see

171
00:00:00,000 --> 00:00:00,000
if they're the same.

172
00:00:00,000 --> 00:00:00,000
We're comparing the addresses themselves.

173
00:00:00,000 --> 00:00:00,000
So address 1000 is never, never,

174
00:00:00,000 --> 00:00:00,000
ever going to be equal to address 2000.

175
00:00:00,000 --> 00:00:00,000
By definition, that's false.

176
00:00:00,000 --> 00:00:00,000
So the compiler can't check things

177
00:00:00,000 --> 00:00:00,000
that simply don't make sense that way.

178
00:00:00,000 --> 00:00:00,000
It can only check things that are illegal.

179
00:00:00,000 --> 00:00:00,000
Now, the array does not carry around its size like a vector.

180
00:00:00,000 --> 00:00:00,000
As I mentioned, there is no metadata associated

181
00:00:00,000 --> 00:00:00,000
with an array like there is with a vector.

182
00:00:00,000 --> 00:00:00,000
There is no A dot length data member or field

183
00:00:00,000 --> 00:00:00,000
as there is with Java arrays.

184
00:00:00,000 --> 00:00:00,000
Now, the compiler knows the size of an array

185
00:00:00,000 --> 00:00:00,000
when it's declared, however.

186
00:00:00,000 --> 00:00:00,000
And so if you're in scope of that declaration,

187
00:00:00,000 --> 00:00:00,000
the compiler knows that information.

188
00:00:00,000 --> 00:00:00,000
So I can find out in scope, here I've created an array A,

189
00:00:00,000 --> 00:00:00,000
I can find the size of this declaration in bytes if I'm

190
00:00:00,000 --> 00:00:00,000
in the scope of this declaration.

191
00:00:00,000 --> 00:00:00,000
And if I want to find the number of elements,

192
00:00:00,000 --> 00:00:00,000
all I do is divide the size of the whole array by the size

193
00:00:00,000 --> 00:00:00,000
of the first element.

194
00:00:00,000 --> 00:00:00,000
And since they're all the same size by definition,

195
00:00:00,000 --> 00:00:00,000
this will give me the number of elements in the array.

196
00:00:00,000 --> 00:00:00,000
But again, only in scope.

197
00:00:00,000 --> 00:00:00,000
C++11 added a new way to do that.

198
00:00:00,000 --> 00:00:00,000
We can take the array and pass it to end and subtract begin

199
00:00:00,000 --> 00:00:00,000
from it, and that will give us the number of elements.

200
00:00:00,000 --> 00:00:00,000
And finally, in C++14,

201
00:00:00,000 --> 00:00:00,000
they had a new function simply called size

202
00:00:00,000 --> 00:00:00,000
that will also work on arrays.

203
00:00:00,000 --> 00:00:00,000
So you could pass A to standard size,

204
00:00:00,000 --> 00:00:00,000
and you could get back the number of elements in the array.

205
00:00:00,000 --> 00:00:00,000
Again, I want to stress this, this only works

206
00:00:00,000 --> 00:00:00,000
when the array is in scope,

207
00:00:00,000 --> 00:00:00,000
not when you've passed the array to a function.

208
00:00:00,000 --> 00:00:00,000
All right.

209
00:00:00,000 --> 00:00:00,000
So how -- if we have an array, it doesn't have any metadata,

210
00:00:00,000 --> 00:00:00,000
it doesn't know how long the function is,

211
00:00:00,000 --> 00:00:00,000
it doesn't have a size member function,

212
00:00:00,000 --> 00:00:00,000
it doesn't have a length data member, how does the loop know

213
00:00:00,000 --> 00:00:00,000
how to stop in your function if when you pass the array

214
00:00:00,000 --> 00:00:00,000
to a function, the only thing the function gets is the address

215
00:00:00,000 --> 00:00:00,000
of the first element?

216
00:00:00,000 --> 00:00:00,000
Well, number first method, we could pass the allocated

217
00:00:00,000 --> 00:00:00,000
or maximum size along with the address.

218
00:00:00,000 --> 00:00:00,000
Method two, we could use a sentinel

219
00:00:00,000 --> 00:00:00,000
to mark the end of the array.

220
00:00:00,000 --> 00:00:00,000
Number three, we could calculate a pointer to the end,

221
00:00:00,000 --> 00:00:00,000
and we could pass that pointer to the end as well

222
00:00:00,000 --> 00:00:00,000
and write an iterator loop.

223
00:00:00,000 --> 00:00:00,000
We could pass -- use the begin and end iterators

224
00:00:00,000 --> 00:00:00,000
and pass those instead of the address of the first element.

225
00:00:00,000 --> 00:00:00,000
Or finally, inside the scope of the array

226
00:00:00,000 --> 00:00:00,000
where it's declared, we can use a for each loop.

227
00:00:00,000 --> 00:00:00,000
So we're going to do that in our only exercise today.

228
00:00:00,000 --> 00:00:00,000
We're going to create some arrays, and we're going

229
00:00:00,000 --> 00:00:00,000
to loop through them.

230
00:00:00,000 --> 00:00:00,000
So go ahead and open arrays.cpp in your workspace,

231
00:00:00,000 --> 00:00:00,000
and then let's create five arrays.

232
00:00:00,000 --> 00:00:00,000
A three-element int, a four-element char,

233
00:00:00,000 --> 00:00:00,000
a five-element long, a six-element float,

234
00:00:00,000 --> 00:00:00,000
and a seven-element double.

235
00:00:00,000 --> 00:00:00,000
Okay. So I've got arrays.cpp open over here,

236
00:00:00,000 --> 00:00:00,000
and I want to create my arrays.

237
00:00:00,000 --> 00:00:00,000
So I can -- first for my three-element int,

238
00:00:00,000 --> 00:00:00,000
I could do const int iSize -- I'll do it like this --

239
00:00:00,000 --> 00:00:00,000
k iSize equals three.

240
00:00:00,000 --> 00:00:00,000
And then I could do int integer array IA equals kSize.

241
00:00:00,000 --> 00:00:00,000
Now, what would happen -- what would happen if I were

242
00:00:00,000 --> 00:00:00,000
to take off this const in front of this, if I were to take off

243
00:00:00,000 --> 00:00:00,000
that const in front of it?

244
00:00:00,000 --> 00:00:00,000
First, let's do make on this.

245
00:00:00,000 --> 00:00:00,000
Let me make my shell so I'm over in that folder, of course.

246
00:00:00,000 --> 00:00:00,000
Okay. So I'm in A, and that's k iSize.

247
00:00:00,000 --> 00:00:00,000
So that was giving me an error because I had spelled that wrong.

248
00:00:00,000 --> 00:00:00,000
So make, and I don't have any problems with that at all.

249
00:00:00,000 --> 00:00:00,000
Okay. Now I'm going to remove the int from this,

250
00:00:00,000 --> 00:00:00,000
const from that, and try it again.

251
00:00:00,000 --> 00:00:00,000
And you will probably find that it will compile.

252
00:00:00,000 --> 00:00:00,000
Okay. That's because most --

253
00:00:00,000 --> 00:00:00,000
and if we were doing this in Visual Studio,

254
00:00:00,000 --> 00:00:00,000
it would not compile.

255
00:00:00,000 --> 00:00:00,000
Visual Studio would be correct in that case.

256
00:00:00,000 --> 00:00:00,000
What I can do over here is open up my make file

257
00:00:00,000 --> 00:00:00,000
and add an extra flag on the flags, and say I want

258
00:00:00,000 --> 00:00:00,000
to make this pedantic, and that will ensure

259
00:00:00,000 --> 00:00:00,000
that it only uses the C++ standard.

260
00:00:00,000 --> 00:00:00,000
Now when I do make, notice it says ISO C++ forbids an area --

261
00:00:00,000 --> 00:00:00,000
a variable length array IA.

262
00:00:00,000 --> 00:00:00,000
So this needs to be const to be correct,

263
00:00:00,000 --> 00:00:00,000
even if in some compilers you can get away with it.

264
00:00:00,000 --> 00:00:00,000
In some compilers you can get away with it.

265
00:00:00,000 --> 00:00:00,000
But since it's not really correct according

266
00:00:00,000 --> 00:00:00,000
to the language, you shouldn't do it.

267
00:00:00,000 --> 00:00:00,000
So we could create an array like this.

268
00:00:00,000 --> 00:00:00,000
This is uninitialized.

269
00:00:00,000 --> 00:00:00,000
So let's create an array with four chars.

270
00:00:00,000 --> 00:00:00,000
So char CA, and put the brackets there

271
00:00:00,000 --> 00:00:00,000
and initialize it like this.

272
00:00:00,000 --> 00:00:00,000
Brace brace semicolon.

273
00:00:00,000 --> 00:00:00,000
C -- hold on, I'm having a hard time getting my fingers

274
00:00:00,000 --> 00:00:00,000
on the right keys here.

275
00:00:00,000 --> 00:00:00,000
A P -- and I'm going to put a terminator in here, a sentinel,

276
00:00:00,000 --> 00:00:00,000
that we're going to look for when we process

277
00:00:00,000 --> 00:00:00,000
that array, okay?

278
00:00:00,000 --> 00:00:00,000
A sentinel, okay?

279
00:00:00,000 --> 00:00:00,000
And notice this time I didn't initialize it.

280
00:00:00,000 --> 00:00:00,000
We're going to create a five element long.

281
00:00:00,000 --> 00:00:00,000
So char LA.

282
00:00:00,000 --> 00:00:00,000
You can put in a literal like that.

283
00:00:00,000 --> 00:00:00,000
And for our LA we'll do it 10, 20, 30.

284
00:00:00,000 --> 00:00:00,000
And we'll find out that there won't be a 40 or 50,

285
00:00:00,000 --> 00:00:00,000
it'll just be zeros and zeros for that last one.

286
00:00:00,000 --> 00:00:00,000
A six element float.

287
00:00:00,000 --> 00:00:00,000
[ Typing ]

288
00:00:00,000 --> 00:00:00,000
Okay, now you might notice

289
00:00:00,000 --> 00:00:00,000
that these are not floats inside of here, these are doubles.

290
00:00:00,000 --> 00:00:00,000
But because this is initialization,

291
00:00:00,000 --> 00:00:00,000
this will require a conversion to convert it

292
00:00:00,000 --> 00:00:00,000
down to the floats.

293
00:00:00,000 --> 00:00:00,000
If you didn't want that conversion,

294
00:00:00,000 --> 00:00:00,000
we could make each one a float.

295
00:00:00,000 --> 00:00:00,000
[ Typing ]

296
00:00:00,000 --> 00:00:00,000
Like that.

297
00:00:00,000 --> 00:00:00,000
That's always a better thing, you know,

298
00:00:00,000 --> 00:00:00,000
to say in your code exactly what you're trying to do.

299
00:00:00,000 --> 00:00:00,000
Okay, and finally we had our double, double DA.

300
00:00:00,000 --> 00:00:00,000
And I'm going to use C++11.

301
00:00:00,000 --> 00:00:00,000
And just default initialize everything to zero, okay?

302
00:00:00,000 --> 00:00:00,000
Everything to zero.

303
00:00:00,000 --> 00:00:00,000
All right, let's do make here again on this.

304
00:00:00,000 --> 00:00:00,000
And now it compiles without errors.

305
00:00:00,000 --> 00:00:00,000
So that's initializing and creating five arrays.

306
00:00:00,000 --> 00:00:00,000
Now we're going to print each array using the array name

307
00:00:00,000 --> 00:00:00,000
and see what happens.

308
00:00:00,000 --> 00:00:00,000
So this is one print using the array name.

309
00:00:00,000 --> 00:00:00,000
So I'm going to C out.

310
00:00:00,000 --> 00:00:00,000
I'm going to print the array name as well.

311
00:00:00,000 --> 00:00:00,000
So I'm going to print IA equals IA.

312
00:00:00,000 --> 00:00:00,000
CA equals CA.

313
00:00:00,000 --> 00:00:00,000
C out. LA. Oops.

314
00:00:00,000 --> 00:00:00,000
LA equals LA.

315
00:00:00,000 --> 00:00:00,000
C out. FA equals FA.

316
00:00:00,000 --> 00:00:00,000
And C out.

317
00:00:00,000 --> 00:00:00,000
DA.

318
00:00:00,000 --> 00:00:00,000
DA didn't turn blue.

319
00:00:00,000 --> 00:00:00,000
Oh, there it turned blue.

320
00:00:00,000 --> 00:00:00,000
Okay. So let's go ahead and do make run.

321
00:00:00,000 --> 00:00:00,000
Nothing ran.

322
00:00:00,000 --> 00:00:00,000
Oh, I didn't.

323
00:00:00,000 --> 00:00:00,000
No. Let me save it and do make once again.

324
00:00:00,000 --> 00:00:00,000
Okay. I'm going to pause this while I figure

325
00:00:00,000 --> 00:00:00,000
out what's going on right now.

326
00:00:00,000 --> 00:00:00,000
Because that doesn't make any sense at all.

327
00:00:00,000 --> 00:00:00,000
Oh, no. I don't need to pause it.

328
00:00:00,000 --> 00:00:00,000
I just need to look and that my return zero is

329
00:00:00,000 --> 00:00:00,000
up there before my print.

330
00:00:00,000 --> 00:00:00,000
Which is a bad thing.

331
00:00:00,000 --> 00:00:00,000
Okay. So let's do make run.

332
00:00:00,000 --> 00:00:00,000
Okay. So IA prints out.

333
00:00:00,000 --> 00:00:00,000
IA is simply the address for where I starts.

334
00:00:00,000 --> 00:00:00,000
CA doesn't print out the address where the C starts.

335
00:00:00,000 --> 00:00:00,000
It prints out cat.

336
00:00:00,000 --> 00:00:00,000
LA. So I apparently made a mistake here.

337
00:00:00,000 --> 00:00:00,000
LA prints that.

338
00:00:00,000 --> 00:00:00,000
FA doesn't appear to be -- oh, no.

339
00:00:00,000 --> 00:00:00,000
There's FA.

340
00:00:00,000 --> 00:00:00,000
LA prints there and then seems to print a new line at the end.

341
00:00:00,000 --> 00:00:00,000
I'm not quite sure why.

342
00:00:00,000 --> 00:00:00,000
What did we do with LA?

343
00:00:00,000 --> 00:00:00,000
LA we initialized to three elements, right?

344
00:00:00,000 --> 00:00:00,000
And it's five long.

345
00:00:00,000 --> 00:00:00,000
So I'm not sure why LA is not printing -- oh, you know.

346
00:00:00,000 --> 00:00:00,000
I made LA a char.

347
00:00:00,000 --> 00:00:00,000
I'm supposed to make it a long.

348
00:00:00,000 --> 00:00:00,000
So again, user error here.

349
00:00:00,000 --> 00:00:00,000
User error here.

350
00:00:00,000 --> 00:00:00,000
Okay. Make run.

351
00:00:00,000 --> 00:00:00,000
Okay. So IA, LA, FA, DA, all of those print the address

352
00:00:00,000 --> 00:00:00,000
of the first element of the array.

353
00:00:00,000 --> 00:00:00,000
CA does not.

354
00:00:00,000 --> 00:00:00,000
So to explain why CA does not, look at this piece of code.

355
00:00:00,000 --> 00:00:00,000
Okay? What is this quote?

356
00:00:00,000 --> 00:00:00,000
Is that a string object?

357
00:00:00,000 --> 00:00:00,000
No, it is not a string object.

358
00:00:00,000 --> 00:00:00,000
It is an array of characters terminated with a null,

359
00:00:00,000 --> 00:00:00,000
what we call a C string.

360
00:00:00,000 --> 00:00:00,000
And so C out has an overloaded operator that looks like this

361
00:00:00,000 --> 00:00:00,000
or string has an overloaded operator that looks like this.

362
00:00:00,000 --> 00:00:00,000
O stream ref operator.

363
00:00:00,000 --> 00:00:00,000
O stream ref out const char star S or CS for C string.

364
00:00:00,000 --> 00:00:00,000
Okay? So when we pass CA here,

365
00:00:00,000 --> 00:00:00,000
what we're doing is we're passing a pointer

366
00:00:00,000 --> 00:00:00,000
to a constant character or a pointer to a char.

367
00:00:00,000 --> 00:00:00,000
And so it's treating it exactly the same way it treats this.

368
00:00:00,000 --> 00:00:00,000
So for all arrays, we will get the address IA, LA, FA, and DA.

369
00:00:00,000 --> 00:00:00,000
But for character arrays, we will actually get the sequence

370
00:00:00,000 --> 00:00:00,000
of characters that's inside it.

371
00:00:00,000 --> 00:00:00,000
What do I do if I want to find out where the address

372
00:00:00,000 --> 00:00:00,000
where CA is?

373
00:00:00,000 --> 00:00:00,000
What I can do is I can cast this, so static cast void pointer.

374
00:00:00,000 --> 00:00:00,000
In other words, a raw pointer to nothing, CA.

375
00:00:00,000 --> 00:00:00,000
And now if I run that, make run, notice we'll get the addresses

376
00:00:00,000 --> 00:00:00,000
where each of these items are stored in memory.

377
00:00:00,000 --> 00:00:00,000
These are all stored in the stack because they're

378
00:00:00,000 --> 00:00:00,000
in the local storage.

379
00:00:00,000 --> 00:00:00,000
If I had created all of these outside of this function,

380
00:00:00,000 --> 00:00:00,000
this global variables, they would be

381
00:00:00,000 --> 00:00:00,000
in the static storage area.

382
00:00:00,000 --> 00:00:00,000
All right.

383
00:00:00,000 --> 00:00:00,000
So we've created them.

384
00:00:00,000 --> 00:00:00,000
We've seen that the name of the array is just an address.

385
00:00:00,000 --> 00:00:00,000
Now let's print the contents of each array.

386
00:00:00,000 --> 00:00:00,000
And I'm going to use five different loops,

387
00:00:00,000 --> 00:00:00,000
the five different loops we had on the previous slide.

388
00:00:00,000 --> 00:00:00,000
Okay? So let's start.

389
00:00:00,000 --> 00:00:00,000
Print the arrays, array contents.

390
00:00:00,000 --> 00:00:00,000
And let's start is a traditional loop with size.

391
00:00:00,000 --> 00:00:00,000
So I'm going to print IA.

392
00:00:00,000 --> 00:00:00,000
We have a constant for IA.

393
00:00:00,000 --> 00:00:00,000
So I'm going to say for I equals zero, IIA less than KI size,

394
00:00:00,000 --> 00:00:00,000
plus plus I.

395
00:00:00,000 --> 00:00:00,000
C out IA. Let me go there.

396
00:00:00,000 --> 00:00:00,000
IA at I. And let me just do space.

397
00:00:00,000 --> 00:00:00,000
And let me print.

398
00:00:00,000 --> 00:00:00,000
[ Typing ]

399
00:00:00,000 --> 00:00:00,000
Okay. So let's print.

400
00:00:00,000 --> 00:00:00,000
Let's do that first one, make run.

401
00:00:00,000 --> 00:00:00,000
And here's our first array.

402
00:00:00,000 --> 00:00:00,000
You can see I have three elements.

403
00:00:00,000 --> 00:00:00,000
They're uninitialized.

404
00:00:00,000 --> 00:00:00,000
So they're just random values.

405
00:00:00,000 --> 00:00:00,000
Now notice I didn't use the fence post algorithm here.

406
00:00:00,000 --> 00:00:00,000
I used an algorithm where we have a space before

407
00:00:00,000 --> 00:00:00,000
and after each element here.

408
00:00:00,000 --> 00:00:00,000
And so I didn't need to print the first one separately.

409
00:00:00,000 --> 00:00:00,000
I used this fence post for the next ones.

410
00:00:00,000 --> 00:00:00,000
So now we're going to do 2B, use a sentinel.

411
00:00:00,000 --> 00:00:00,000
Of course, you saw we could just print out the string.

412
00:00:00,000 --> 00:00:00,000
But I want to show you how a sentinel works.

413
00:00:00,000 --> 00:00:00,000
So here I'll use a sentinel.

414
00:00:00,000 --> 00:00:00,000
So I'll say C out CA equals.

415
00:00:00,000 --> 00:00:00,000
I use square brackets.

416
00:00:00,000 --> 00:00:00,000
[ Typing ]

417
00:00:00,000 --> 00:00:00,000
I'll say for.

418
00:00:00,000 --> 00:00:00,000
[ Typing ]

419
00:00:00,000 --> 00:00:00,000
And here we're going to say CA at I not equal

420
00:00:00,000 --> 00:00:00,000
to the null character.

421
00:00:00,000 --> 00:00:00,000
So you notice I'm not using size for my bounds at all.

422
00:00:00,000 --> 00:00:00,000
I'm using the sentinel in there.

423
00:00:00,000 --> 00:00:00,000
[ Typing ]

424
00:00:00,000 --> 00:00:00,000
I want actually a space between each one.

425
00:00:00,000 --> 00:00:00,000
And we'll print that.

426
00:00:00,000 --> 00:00:00,000
[ Typing ]

427
00:00:00,000 --> 00:00:00,000
And C out.

428
00:00:00,000 --> 00:00:00,000
[ Typing ]

429
00:00:00,000 --> 00:00:00,000
Okay. So here's CA using a sentinel loop.

430
00:00:00,000 --> 00:00:00,000
Let me clear that.

431
00:00:00,000 --> 00:00:00,000
Demake run.

432
00:00:00,000 --> 00:00:00,000
So here's CAT.

433
00:00:00,000 --> 00:00:00,000
Notice we didn't take the length

434
00:00:00,000 --> 00:00:00,000
into consideration at all with CA.

435
00:00:00,000 --> 00:00:00,000
We just took into consideration the fact

436
00:00:00,000 --> 00:00:00,000
that it contained a terminating character.

437
00:00:00,000 --> 00:00:00,000
A sentinel character.

438
00:00:00,000 --> 00:00:00,000
Okay. All right.

439
00:00:00,000 --> 00:00:00,000
Our third kind of loop.

440
00:00:00,000 --> 00:00:00,000
Third kind of loop is calculate a pointer to the end.

441
00:00:00,000 --> 00:00:00,000
Okay. And then we're going to use that.

442
00:00:00,000 --> 00:00:00,000
[ Typing ]

443
00:00:00,000 --> 00:00:00,000
To see.

444
00:00:00,000 --> 00:00:00,000
[ Typing ]

445
00:00:00,000 --> 00:00:00,000
And we're going to calculate a pointer to the end

446
00:00:00,000 --> 00:00:00,000
with the size of it.

447
00:00:00,000 --> 00:00:00,000
So this is going to be -- our third one is going

448
00:00:00,000 --> 00:00:00,000
to be LA and it's five long.

449
00:00:00,000 --> 00:00:00,000
[ Typing ]

450
00:00:00,000 --> 00:00:00,000
And so we're going to --

451
00:00:00,000 --> 00:00:00,000
[ Typing ]

452
00:00:00,000 --> 00:00:00,000
LA equals the opening bracket.

453
00:00:00,000 --> 00:00:00,000
And let's actually on this one since I know --

454
00:00:00,000 --> 00:00:00,000
[ Typing ]

455
00:00:00,000 --> 00:00:00,000
We print the first one up there.

456
00:00:00,000 --> 00:00:00,000
[ Typing ]

457
00:00:00,000 --> 00:00:00,000
Okay. Now we don't want to go to the size.

458
00:00:00,000 --> 00:00:00,000
What we want to do is say for I equals zero, LA plus I.

459
00:00:00,000 --> 00:00:00,000
So actually let's create the pointer to it

460
00:00:00,000 --> 00:00:00,000
because when we're calling a function we would pass this

461
00:00:00,000 --> 00:00:00,000
pointer to it.

462
00:00:00,000 --> 00:00:00,000
So I'll say auto end P equals LA plus the size

463
00:00:00,000 --> 00:00:00,000
of LA divided by the size of LA sub zero.

464
00:00:00,000 --> 00:00:00,000
Okay. So I've calculated a pointer to the end.

465
00:00:00,000 --> 00:00:00,000
Okay. I'm going to use a pointer to the beginning.

466
00:00:00,000 --> 00:00:00,000
[ Typing ]

467
00:00:00,000 --> 00:00:00,000
For a long pointer P equals LA, P less than end P, P plus plus.

468
00:00:00,000 --> 00:00:00,000
[ Typing ]

469
00:00:00,000 --> 00:00:00,000
LA plus one.

470
00:00:00,000 --> 00:00:00,000
[ Typing ]

471
00:00:00,000 --> 00:00:00,000
Oh, not an end.

472
00:00:00,000 --> 00:00:00,000
Okay. Not an end.

473
00:00:00,000 --> 00:00:00,000
Okay. So here we're just using pointers, right,

474
00:00:00,000 --> 00:00:00,000
a pointer to the beginning and a pointer to the end.

475
00:00:00,000 --> 00:00:00,000
And we calculate that pointer to the end

476
00:00:00,000 --> 00:00:00,000
by taking the size of LA, its allocated size,

477
00:00:00,000 --> 00:00:00,000
divided by the size of the first element

478
00:00:00,000 --> 00:00:00,000
which gives us the number of elements.

479
00:00:00,000 --> 00:00:00,000
This will give us a pointer right past the end.

480
00:00:00,000 --> 00:00:00,000
And we'll see how square bracket ends up.

481
00:00:00,000 --> 00:00:00,000
Okay. Let's try that third one.

482
00:00:00,000 --> 00:00:00,000
I have end there instead of P end or end P.

483
00:00:00,000 --> 00:00:00,000
[ Typing ]

484
00:00:00,000 --> 00:00:00,000
Okay. And then we got our 10, 20, 30.

485
00:00:00,000 --> 00:00:00,000
And as I mentioned, we only initialized the first three

486
00:00:00,000 --> 00:00:00,000
so the last two are initialized to zero.

487
00:00:00,000 --> 00:00:00,000
Unlike this one up here where everything is uninitialized.

488
00:00:00,000 --> 00:00:00,000
Everything is uninitialized.

489
00:00:00,000 --> 00:00:00,000
Okay. Okay.

490
00:00:00,000 --> 00:00:00,000
So that was 2C for 2D.

491
00:00:00,000 --> 00:00:00,000
[ Typing ]

492
00:00:00,000 --> 00:00:00,000
We can just use iterators.

493
00:00:00,000 --> 00:00:00,000
[ Typing ]

494
00:00:00,000 --> 00:00:00,000
Let's see how FA.

495
00:00:00,000 --> 00:00:00,000
[ Typing ]

496
00:00:00,000 --> 00:00:00,000
And we'll do star, begin, FA.

497
00:00:00,000 --> 00:00:00,000
Print out the first element.

498
00:00:00,000 --> 00:00:00,000
[ Typing ]

499
00:00:00,000 --> 00:00:00,000
For auto iter equals begin FA plus 1.

500
00:00:00,000 --> 00:00:00,000
Iter not equal to end FA plus plus iter.

501
00:00:00,000 --> 00:00:00,000
[ Typing ]

502
00:00:00,000 --> 00:00:00,000
And for 2E.

503
00:00:00,000 --> 00:00:00,000
[ Typing ]

504
00:00:00,000 --> 00:00:00,000
Now all of these will work inside a function

505
00:00:00,000 --> 00:00:00,000
if you pass the arguments.

506
00:00:00,000 --> 00:00:00,000
If you pass up here the size as an argument.

507
00:00:00,000 --> 00:00:00,000
This you don't need to pass anything.

508
00:00:00,000 --> 00:00:00,000
If it's got a terminator in it, you're fine.

509
00:00:00,000 --> 00:00:00,000
A sentinel in it.

510
00:00:00,000 --> 00:00:00,000
This you would have to pass this second argument, the end pointer.

511
00:00:00,000 --> 00:00:00,000
This you'd have to pass both begin and end to the function

512
00:00:00,000 --> 00:00:00,000
to do your calculation.

513
00:00:00,000 --> 00:00:00,000
And for this one, only works inside a loop.

514
00:00:00,000 --> 00:00:00,000
This one would not work inside a function.

515
00:00:00,000 --> 00:00:00,000
So this is the range for loop.

516
00:00:00,000 --> 00:00:00,000
Okay.

517
00:00:00,000 --> 00:00:00,000
[ Typing ]

518
00:00:00,000 --> 00:00:00,000
So this is a little harder.

519
00:00:00,000 --> 00:00:00,000
If we want to do -- this is going to be DA equals square bracket.

520
00:00:00,000 --> 00:00:00,000
And we're going to do DA sub zero.

521
00:00:00,000 --> 00:00:00,000
We're going -- so this one with a range for loop,

522
00:00:00,000 --> 00:00:00,000
it's kind of hard to do the fence post algorithm.

523
00:00:00,000 --> 00:00:00,000
And so we're going to have to create a Boolean.

524
00:00:00,000 --> 00:00:00,000
[ Typing ]

525
00:00:00,000 --> 00:00:00,000
We're going to have to go for auto E and DA.

526
00:00:00,000 --> 00:00:00,000
If printing C out comma E. And then that will skip the first one.

527
00:00:00,000 --> 00:00:00,000
We'll turn on the printing for the second one.

528
00:00:00,000 --> 00:00:00,000
Okay. So a little hard to do fence post with the range base loop

529
00:00:00,000 --> 00:00:00,000
because it goes through every element in the array.

530
00:00:00,000 --> 00:00:00,000
Okay. So that's it.

531
00:00:00,000 --> 00:00:00,000
Let's go ahead and try these out.

532
00:00:00,000 --> 00:00:00,000
Do make run.

533
00:00:00,000 --> 00:00:00,000
And here's our last one.

534
00:00:00,000 --> 00:00:00,000
This one, remember, we initialized all to zeros like that.

535
00:00:00,000 --> 00:00:00,000
All to zeros like that.

536
00:00:00,000 --> 00:00:00,000
Okay. We're going to do one more thing here.

537
00:00:00,000 --> 00:00:00,000
[ Typing ]

538
00:00:00,000 --> 00:00:00,000
And that is I'm going to try and read and write outside

539
00:00:00,000 --> 00:00:00,000
of the array bounds before printing.

540
00:00:00,000 --> 00:00:00,000
And we want to see what happens to the other arrays.

541
00:00:00,000 --> 00:00:00,000
So this, like I said, it's undefined.

542
00:00:00,000 --> 00:00:00,000
You're not sure exactly what's going to happen.

543
00:00:00,000 --> 00:00:00,000
But I want to show you

544
00:00:00,000 --> 00:00:00,000
that the compiler won't stop us from doing this.

545
00:00:00,000 --> 00:00:00,000
So let's come up here.

546
00:00:00,000 --> 00:00:00,000
After we've printed out those names.

547
00:00:00,000 --> 00:00:00,000
It's going to be part three.

548
00:00:00,000 --> 00:00:00,000
[ Typing ]

549
00:00:00,000 --> 00:00:00,000
So let's say FA sub minus 2 equals 3.

550
00:00:00,000 --> 00:00:00,000
And let's say LA.

551
00:00:00,000 --> 00:00:00,000
How big was LA?

552
00:00:00,000 --> 00:00:00,000
LA was 5.

553
00:00:00,000 --> 00:00:00,000
LA sub 7 equals 15.

554
00:00:00,000 --> 00:00:00,000
Okay. So 3 and 15.

555
00:00:00,000 --> 00:00:00,000
Now let's run it again.

556
00:00:00,000 --> 00:00:00,000
I want you to see what it looked like before.

557
00:00:00,000 --> 00:00:00,000
So here's what it looked like before.

558
00:00:00,000 --> 00:00:00,000
We'll do make run.

559
00:00:00,000 --> 00:00:00,000
[ Typing ]

560
00:00:00,000 --> 00:00:00,000
And now look down here at DA.

561
00:00:00,000 --> 00:00:00,000
At DA. And notice that we have this value put inside here.

562
00:00:00,000 --> 00:00:00,000
So by changing FA, we actually changed DA.

563
00:00:00,000 --> 00:00:00,000
Now it doesn't look like the one we did

564
00:00:00,000 --> 00:00:00,000
in LA actually overwrote any other variables.

565
00:00:00,000 --> 00:00:00,000
But it could have.

566
00:00:00,000 --> 00:00:00,000
We could have kept going and changed.

567
00:00:00,000 --> 00:00:00,000
We were writing at LA 7.

568
00:00:00,000 --> 00:00:00,000
Let's write it LA 9.

569
00:00:00,000 --> 00:00:00,000
Let's try it again and see if the LA changes anything.

570
00:00:00,000 --> 00:00:00,000
So we'll do make run again.

571
00:00:00,000 --> 00:00:00,000
And okay.

572
00:00:00,000 --> 00:00:00,000
So this looking at LA, that looks like that's the LA is the

573
00:00:00,000 --> 00:00:00,000
one I'm changing.

574
00:00:00,000 --> 00:00:00,000
Looks like the FA, I didn't actually affect any

575
00:00:00,000 --> 00:00:00,000
of the other variables.

576
00:00:00,000 --> 00:00:00,000
So we'd have to look at these addresses.

577
00:00:00,000 --> 00:00:00,000
We'd have to draw ourselves a little memory map.

578
00:00:00,000 --> 00:00:00,000
And we'd be able to tell what happens

579
00:00:00,000 --> 00:00:00,000
when we write outside of that.

580
00:00:00,000 --> 00:00:00,000
But you notice it didn't give me a syntax error.

581
00:00:00,000 --> 00:00:00,000
It didn't give me a compiler error.

582
00:00:00,000 --> 00:00:00,000
It simply overwrote parts of my other program.

583
00:00:00,000 --> 00:00:00,000
Those are very, very hard bugs to find.

584
00:00:00,000 --> 00:00:00,000
Okay. So that's it for Lecture 19.

585
00:00:00,000 --> 00:00:00,000
When you come on back for Lecture 20,

586
00:00:00,000 --> 00:00:00,000
we'll look at some algorithms for arrays.

