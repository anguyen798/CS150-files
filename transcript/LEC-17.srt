1
00:00:00,000 --> 00:00:00,000
Hello everyone, this is Steve Gilbert.

2
00:00:00,000 --> 00:00:00,000
Welcome to week 5 and lecture 17.

3
00:00:00,000 --> 00:00:00,000
So today we're going to be talking about memory and pointers.

4
00:00:00,000 --> 00:00:00,000
In the next lecture we're going to be working with graphics.

5
00:00:00,000 --> 00:00:00,000
So before we do that though, let's do a little bit of review on vectors.

6
00:00:00,000 --> 00:00:00,000
So we create vectors by specifying the kind of thing

7
00:00:00,000 --> 00:00:00,000
that they're going to hold, called the base type.

8
00:00:00,000 --> 00:00:00,000
So v1 is a vector of int, v2 is a vector of int, all of these are vector of int.

9
00:00:00,000 --> 00:00:00,000
When we can create them, we can pass additional arguments to their constructor.

10
00:00:00,000 --> 00:00:00,000
And so if we pass a single integer, it says I want v2 to be an array of 10 integers,

11
00:00:00,000 --> 00:00:00,000
or a vector of 10 integers, zero initialized.

12
00:00:00,000 --> 00:00:00,000
If I don't want them zero initialized, I can pass two integers.

13
00:00:00,000 --> 00:00:00,000
So v3 is an array of three integers, all three are initialized to four.

14
00:00:00,000 --> 00:00:00,000
Or if I don't use the parentheses after the constructor,

15
00:00:00,000 --> 00:00:00,000
when I'm constructing the object, if I use braces instead,

16
00:00:00,000 --> 00:00:00,000
I'm saying that I want simply the values three and four.

17
00:00:00,000 --> 00:00:00,000
I'm list initializing them.

18
00:00:00,000 --> 00:00:00,000
We saw that we could access the individual elements in a vector with at,

19
00:00:00,000 --> 00:00:00,000
or front and back to get the first and the last one,

20
00:00:00,000 --> 00:00:00,000
or the square brackets, or the square brackets.

21
00:00:00,000 --> 00:00:00,000
We have members that change the object.

22
00:00:00,000 --> 00:00:00,000
We can get pushback and popback.

23
00:00:00,000 --> 00:00:00,000
Those both mutate the object.

24
00:00:00,000 --> 00:00:00,000
Pushback adds an item to the end of the list,

25
00:00:00,000 --> 00:00:00,000
and popback removes that item that's at the end of the list.

26
00:00:00,000 --> 00:00:00,000
Of course, if you call popback on an empty vector, you'll have an error.

27
00:00:00,000 --> 00:00:00,000
Size is an accessor.

28
00:00:00,000 --> 00:00:00,000
It tells us how many elements the array has.

29
00:00:00,000 --> 00:00:00,000
And we looked at several different loops in our exercises in the last lecture.

30
00:00:00,000 --> 00:00:00,000
We used the range-based loop.

31
00:00:00,000 --> 00:00:00,000
We can use the range-based loop with references, and so forth.

32
00:00:00,000 --> 00:00:00,000
So to just make this a little bit less theoretical,

33
00:00:00,000 --> 00:00:00,000
let's go ahead and do some vector function practice.

34
00:00:00,000 --> 00:00:00,000
So you pass passing vectors as function parameters.

35
00:00:00,000 --> 00:00:00,000
You always use a const vector ref, or a vector ref for an input or output parameter.

36
00:00:00,000 --> 00:00:00,000
We will never, ever pass a vector by value.

37
00:00:00,000 --> 00:00:00,000
We can also return a vector from a function.

38
00:00:00,000 --> 00:00:00,000
You simply create an empty vector.

39
00:00:00,000 --> 00:00:00,000
We did this with the next to the last version of unique in the last lecture.

40
00:00:00,000 --> 00:00:00,000
Fill it in, and then return it.

41
00:00:00,000 --> 00:00:00,000
Now, that makes a copy.

42
00:00:00,000 --> 00:00:00,000
And so adding an output parameter-- in other words,

43
00:00:00,000 --> 00:00:00,000
passing in an empty vector by reference-- may be more efficient.

44
00:00:00,000 --> 00:00:00,000
But actually, modern compilers will actually optimize that copy away.

45
00:00:00,000 --> 00:00:00,000
Since C++ 11, they're required to do that.

46
00:00:00,000 --> 00:00:00,000
Now, imagine that you are writing a program that is going to a web

47
00:00:00,000 --> 00:00:00,000
application, say, and you're writing the guts of it in C++.

48
00:00:00,000 --> 00:00:00,000
And you need to process the-- on the phone, on a phone--

49
00:00:00,000 --> 00:00:00,000
you need to process the camera roll.

50
00:00:00,000 --> 00:00:00,000
And all your application does is it looks through a person's camera roll,

51
00:00:00,000 --> 00:00:00,000
and it shows them a view of the pictures that have a cute cat in it.

52
00:00:00,000 --> 00:00:00,000
Now, you might think that you would pass in the camera roll as a vector of images.

53
00:00:00,000 --> 00:00:00,000
But remember, each image is quite large, so we don't want to make a copy.

54
00:00:00,000 --> 00:00:00,000
But because we're using input parameters, a const vector ref, we won't make a copy.

55
00:00:00,000 --> 00:00:00,000
It'll be very, very inefficient.

56
00:00:00,000 --> 00:00:00,000
We won't make duplicates of all those millions and millions of bytes.

57
00:00:00,000 --> 00:00:00,000
However, if you want to show them your pictures that have cats in it--

58
00:00:00,000 --> 00:00:00,000
the pictures of the cute cat pictures-- you

59
00:00:00,000 --> 00:00:00,000
may be tempted to create an empty vector of pictures,

60
00:00:00,000 --> 00:00:00,000
fill it in with just the cat pictures, and then return it.

61
00:00:00,000 --> 00:00:00,000
And that would be very, very inefficient,

62
00:00:00,000 --> 00:00:00,000
because we would make duplicates of all those millions of bytes

63
00:00:00,000 --> 00:00:00,000
of each cat picture, when really all we need to do

64
00:00:00,000 --> 00:00:00,000
is return a vector of the indexes into the camera roll.

65
00:00:00,000 --> 00:00:00,000
And then all your application would do is have to look at that.

66
00:00:00,000 --> 00:00:00,000
So that's very, very common to return a vector of indexes

67
00:00:00,000 --> 00:00:00,000
that's then used to index into the original vector.

68
00:00:00,000 --> 00:00:00,000
So for our first exercise here, we're going to complete these three functions.

69
00:00:00,000 --> 00:00:00,000
So again, make sure you've gone to week five, the second tab for Tuesday,

70
00:00:00,000 --> 00:00:00,000
on enumerations and memory.

71
00:00:00,000 --> 00:00:00,000
Gone to the lecture exercise and click the link for the starter form.

72
00:00:00,000 --> 00:00:00,000
When you have the starter form here, we're going to do these exercises right there.

73
00:00:00,000 --> 00:00:00,000
These exercises right there.

74
00:00:00,000 --> 00:00:00,000
So let's go over.

75
00:00:00,000 --> 00:00:00,000
Let's look at IC17.

76
00:00:00,000 --> 00:00:00,000
Let's look in vectors.h.

77
00:00:00,000 --> 00:00:00,000
These are the files we're going to create.

78
00:00:00,000 --> 00:00:00,000
And let's look at vectors.cpp.

79
00:00:00,000 --> 00:00:00,000
Now, if you don't modify these and you just click a couple of them,

80
00:00:00,000 --> 00:00:00,000
it doesn't reopen it, which is kind of frustrating.

81
00:00:00,000 --> 00:00:00,000
So I'm going to open vectors.cpp and put my name on it.

82
00:00:00,000 --> 00:00:00,000
Now I'm going to open vectors.h, and it'll open a new tab at the top,

83
00:00:00,000 --> 00:00:00,000
which is what I want.

84
00:00:00,000 --> 00:00:00,000
So here are the functions we want.

85
00:00:00,000 --> 00:00:00,000
We want to write swap ins, match up, and copy evens.

86
00:00:00,000 --> 00:00:00,000
So I'm going to copy all of those.

87
00:00:00,000 --> 00:00:00,000
So I don't simply have to go back and forth between them.

88
00:00:00,000 --> 00:00:00,000
And then as we do it, I'll remove the comments.

89
00:00:00,000 --> 00:00:00,000
So let's take our things here and just stub them out so that our code will always compile.

90
00:00:00,000 --> 00:00:00,000
So that's void.

91
00:00:00,000 --> 00:00:00,000
This function returns an int.

92
00:00:00,000 --> 00:00:00,000
And so I'm going to just return 0 here.

93
00:00:00,000 --> 00:00:00,000
Again, just to get a skeleton that works, copy evens.

94
00:00:00,000 --> 00:00:00,000
OK, so this is returning a vector.

95
00:00:00,000 --> 00:00:00,000
So I'm going to create a vector int the result.

96
00:00:00,000 --> 00:00:00,000
And I'm going to return the result.

97
00:00:00,000 --> 00:00:00,000
OK, let's get a shell here.

98
00:00:00,000 --> 00:00:00,000
And I can close that.

99
00:00:00,000 --> 00:00:00,000
And let's just do make test to make sure that our code compiles

100
00:00:00,000 --> 00:00:00,000
and we don't have any syntax errors on it.

101
00:00:00,000 --> 00:00:00,000
We don't, OK?

102
00:00:00,000 --> 00:00:00,000
So now we can go back to thinking about the code.

103
00:00:00,000 --> 00:00:00,000
So this first function we're going to write is going to have one parameter,

104
00:00:00,000 --> 00:00:00,000
which is an input/output parameter, a vector of int named nums.

105
00:00:00,000 --> 00:00:00,000
And if the vector length is greater than 0, then we're going to swap the first and last element.

106
00:00:00,000 --> 00:00:00,000
Now actually, it should be if the vector length is greater than 1,

107
00:00:00,000 --> 00:00:00,000
because if the vector length is 1, swapping the first and last elements gives me the same result.

108
00:00:00,000 --> 00:00:00,000
So I want to say if nums size is greater than 1, I'm going to swap them.

109
00:00:00,000 --> 00:00:00,000
Now to swap them, I have to temporarily save one value.

110
00:00:00,000 --> 00:00:00,000
And so I'm saving the first and the last.

111
00:00:00,000 --> 00:00:00,000
So I could do it four or five different ways.

112
00:00:00,000 --> 00:00:00,000
So first, I'm going to say int temp equals nums sub 0 or nums front,

113
00:00:00,000 --> 00:00:00,000
because it's a vector, or nums at 0.

114
00:00:00,000 --> 00:00:00,000
Now, so we can use all three of those, nums sub 0, nums.front, nums at.

115
00:00:00,000 --> 00:00:00,000
I like using nums.front, because it's kind of, you know, it's expressive.

116
00:00:00,000 --> 00:00:00,000
So I'm going to say, so I saved the first one.

117
00:00:00,000 --> 00:00:00,000
So now I'm going to change the first one, nums.front equals nums.back.

118
00:00:00,000 --> 00:00:00,000
And again, for nums.back, we could have written nums at nums size minus 1.

119
00:00:00,000 --> 00:00:00,000
Certainly nums.back is easier than doing that, right?

120
00:00:00,000 --> 00:00:00,000
And again, we could have used the square brackets with the same expression.

121
00:00:00,000 --> 00:00:00,000
And finally, I'm going to say nums.back equals temp.

122
00:00:00,000 --> 00:00:00,000
So this algorithm is called the swap algorithm.

123
00:00:00,000 --> 00:00:00,000
And in fact, it's in the standard library.

124
00:00:00,000 --> 00:00:00,000
So you generally don't need to write it yourself.

125
00:00:00,000 --> 00:00:00,000
You can just call the one in the standard library, and it will work fine.

126
00:00:00,000 --> 00:00:00,000
Okay, let's try it.

127
00:00:00,000 --> 00:00:00,000
Let's open our shell.

128
00:00:00,000 --> 00:00:00,000
Let's do make test.

129
00:00:00,000 --> 00:00:00,000
And all of our swap ins here should work fine.

130
00:00:00,000 --> 00:00:00,000
For the second function we're going to write,

131
00:00:00,000 --> 00:00:00,000
we're given a vector int nums1 and nums2 of the same length.

132
00:00:00,000 --> 00:00:00,000
And for every element in nums1, consider the corresponding element nums2 at the same index.

133
00:00:00,000 --> 00:00:00,000
So nums1 sub 0, nums2 sub 0.

134
00:00:00,000 --> 00:00:00,000
Return the count of the number of times that the two elements differ by 2 or less, but are not equal.

135
00:00:00,000 --> 00:00:00,000
So a couple different conditions.

136
00:00:00,000 --> 00:00:00,000
So we're returning a count, so I'm just going to call that variable.

137
00:00:00,000 --> 00:00:00,000
It matches 0, and I'm going to return the matches.

138
00:00:00,000 --> 00:00:00,000
Now I'm going to visit each element in both vectors.

139
00:00:00,000 --> 00:00:00,000
So could we use a range-based loop? No.

140
00:00:00,000 --> 00:00:00,000
We need to use a standard while or for loop. I'll use while.

141
00:00:00,000 --> 00:00:00,000
And because it told us they're the same length, I don't need to worry about that.

142
00:00:00,000 --> 00:00:00,000
That would be a slightly different problem.

143
00:00:00,000 --> 00:00:00,000
So I'm going to say for size t, i equals 0,

144
00:00:00,000 --> 00:00:00,000
len equals nums1.size. Again, it doesn't matter which one I use because they're the same size.

145
00:00:00,000 --> 00:00:00,000
i less than len, plus plus i.

146
00:00:00,000 --> 00:00:00,000
OK, so now if nums1 at i is not equal to nums2 at i,

147
00:00:00,000 --> 00:00:00,000
and again, for nums2 I'll do it like that, just so you can see that you can use either one of those.

148
00:00:00,000 --> 00:00:00,000
I try and train my fingers to do at.

149
00:00:00,000 --> 00:00:00,000
So if those are not equal, and the two elements differ by two or less,

150
00:00:00,000 --> 00:00:00,000
so how do we find out if something differs from each other?

151
00:00:00,000 --> 00:00:00,000
We subtract it.

152
00:00:00,000 --> 00:00:00,000
So nums1 at i minus nums2 at i is two or less, less than or equal to two.

153
00:00:00,000 --> 00:00:00,000
Then we're going to say matches plus plus.

154
00:00:00,000 --> 00:00:00,000
Now if you test this, you'll see a slight problem. Let's test it and see what that problem is.

155
00:00:00,000 --> 00:00:00,000
Oh, actually we didn't see it. Oh yeah, two of them didn't pass.

156
00:00:00,000 --> 00:00:00,000
So the problem is that when we take this, this only works if nums1 is larger than nums2.

157
00:00:00,000 --> 00:00:00,000
In the case where that's not the case, in cases where that is not the case,

158
00:00:00,000 --> 00:00:00,000
so in this case num1 is larger than num2, and I'm subtracting in this case.

159
00:00:00,000 --> 00:00:00,000
So it's not working in that case.

160
00:00:00,000 --> 00:00:00,000
So I need to think slightly different about that.

161
00:00:00,000 --> 00:00:00,000
This gives me the difference, but the difference can be positive or negative.

162
00:00:00,000 --> 00:00:00,000
So what do I really want to do?

163
00:00:00,000 --> 00:00:00,000
I want the absolute value of that difference.

164
00:00:00,000 --> 00:00:00,000
So I'm going to use the function from cmath,

165
00:00:00,000 --> 00:00:00,000
or actually this version of abs is from cstandard lib.

166
00:00:00,000 --> 00:00:00,000
So I have to include cmath in here.

167
00:00:00,000 --> 00:00:00,000
So it's from cstandard lib that knows how to use integers.

168
00:00:00,000 --> 00:00:00,000
I didn't include cstandard lib, so I probably should include.

169
00:00:00,000 --> 00:00:00,000
So include cstandard lib using standard abs.

170
00:00:00,000 --> 00:00:00,000
Okay, so let's try our code again for that function.

171
00:00:00,000 --> 00:00:00,000
Okay, and now all of the matchups work 100%.

172
00:00:00,000 --> 00:00:00,000
Okay, for the last test we're going to be doing here,

173
00:00:00,000 --> 00:00:00,000
we're going to be doing -- so I'm going to get rid of my code for this.

174
00:00:00,000 --> 00:00:00,000
The last review exercise we're doing is one where we're returning a vector.

175
00:00:00,000 --> 00:00:00,000
So we're getting a vector of positive ints.

176
00:00:00,000 --> 00:00:00,000
We're going to return a new vector array of length count,

177
00:00:00,000 --> 00:00:00,000
containing the first even numbers from the original vector.

178
00:00:00,000 --> 00:00:00,000
The original vector will contain at least count even numbers,

179
00:00:00,000 --> 00:00:00,000
but it may contain more.

180
00:00:00,000 --> 00:00:00,000
So we have two input vectors, or two input values.

181
00:00:00,000 --> 00:00:00,000
Nums is a vector of int, so it's const vector ref.

182
00:00:00,000 --> 00:00:00,000
And ecount is the number of even numbers in the return vector.

183
00:00:00,000 --> 00:00:00,000
Now you might wonder why I didn't do ecount like that.

184
00:00:00,000 --> 00:00:00,000
Now you could do that, but then you'd have to keep track of where you are in the two vectors.

185
00:00:00,000 --> 00:00:00,000
And it's actually easier to do it like this.

186
00:00:00,000 --> 00:00:00,000
While result size is less than ecount.

187
00:00:00,000 --> 00:00:00,000
As soon as we have the correct number of items in result,

188
00:00:00,000 --> 00:00:00,000
then our function is completely over.

189
00:00:00,000 --> 00:00:00,000
We're done with what we need to do.

190
00:00:00,000 --> 00:00:00,000
So what we want to do is we want to look through nums.

191
00:00:00,000 --> 00:00:00,000
So I want to say for --

192
00:00:00,000 --> 00:00:00,000
Oh no, actually I don't want to look through nums.

193
00:00:00,000 --> 00:00:00,000
I want to say size pi equals zero.

194
00:00:00,000 --> 00:00:00,000
If nums at i remainder two equals zero,

195
00:00:00,000 --> 00:00:00,000
if nums at i is even, then add it to the result.

196
00:00:00,000 --> 00:00:00,000
So add the number at i to the result.

197
00:00:00,000 --> 00:00:00,000
Each time we go through the loop, of course, we need to do i++.

198
00:00:00,000 --> 00:00:00,000
So we're looking at the correct element in nums.

199
00:00:00,000 --> 00:00:00,000
So this is not a counter controlled loop.

200
00:00:00,000 --> 00:00:00,000
This counter is being used to index into this.

201
00:00:00,000 --> 00:00:00,000
So the loop is only going to stop when result size gets to ecount.

202
00:00:00,000 --> 00:00:00,000
But our counter is actually being used to index into this while we go through that loop.

203
00:00:00,000 --> 00:00:00,000
OK, so let's see if copy evens works.

204
00:00:00,000 --> 00:00:00,000
And there copy evens works perfectly now.

205
00:00:00,000 --> 00:00:00,000
Copy evens works perfectly.

206
00:00:00,000 --> 00:00:00,000
OK, so a little review from the last lesson, last lecture.

207
00:00:00,000 --> 00:00:00,000
Let's go and talk about new items today.

208
00:00:00,000 --> 00:00:00,000
We're going to start looking at lower level.

209
00:00:00,000 --> 00:00:00,000
We're going to start drilling down into your computer and how your computer actually works.

210
00:00:00,000 --> 00:00:00,000
When you run a program, when you run an executable,

211
00:00:00,000 --> 00:00:00,000
your program runs a little part at the beginning of it called the startup code.

212
00:00:00,000 --> 00:00:00,000
That startup code is usually a function called start that is added by the linker.

213
00:00:00,000 --> 00:00:00,000
What that does is it sets the machine registers and it allocates memory.

214
00:00:00,000 --> 00:00:00,000
And so the memory it allocates is divided into sections.

215
00:00:00,000 --> 00:00:00,000
And machine registers point to each of these.

216
00:00:00,000 --> 00:00:00,000
So the static area, the part that's loaded directly from disk,

217
00:00:00,000 --> 00:00:00,000
this is in memory a picture of the image that you have on disk.

218
00:00:00,000 --> 00:00:00,000
This static area has code.

219
00:00:00,000 --> 00:00:00,000
That's the section marked down here as text.

220
00:00:00,000 --> 00:00:00,000
And it has all of your global variables.

221
00:00:00,000 --> 00:00:00,000
They're loaded into memory from disk when the program ends.

222
00:00:00,000 --> 00:00:00,000
And the machine registers, the code segment is set to point to this code.

223
00:00:00,000 --> 00:00:00,000
The data segment is set to point to these global areas.

224
00:00:00,000 --> 00:00:00,000
Those are registers on the machine.

225
00:00:00,000 --> 00:00:00,000
At the opposite end from where the memory is loaded into code,

226
00:00:00,000 --> 00:00:00,000
at a higher address up here, we have something called the stack.

227
00:00:00,000 --> 00:00:00,000
And again, this is just memory reserved for local variables and run time information.

228
00:00:00,000 --> 00:00:00,000
The return of disk, the mechanics of calling a function, parameters,

229
00:00:00,000 --> 00:00:00,000
all of that are placed in this area of memory called the stack.

230
00:00:00,000 --> 00:00:00,000
And as more items are added, the memory grows in this direction,

231
00:00:00,000 --> 00:00:00,000
down towards the static section.

232
00:00:00,000 --> 00:00:00,000
In between those is a third section.

233
00:00:00,000 --> 00:00:00,000
This is called the free store or the heap.

234
00:00:00,000 --> 00:00:00,000
And this is where dynamic variables are created.

235
00:00:00,000 --> 00:00:00,000
When you ask the operating system for some new data,

236
00:00:00,000 --> 00:00:00,000
for instance, when you're reading a file.

237
00:00:00,000 --> 00:00:00,000
So, for instance, if you ask the user to input a sentence,

238
00:00:00,000 --> 00:00:00,000
you don't know how long the sentence is.

239
00:00:00,000 --> 00:00:00,000
And so we cannot put that data on the stack or in the static storage area.

240
00:00:00,000 --> 00:00:00,000
It has to be determined depending on how much data they do.

241
00:00:00,000 --> 00:00:00,000
And the string class does that for you automatically.

242
00:00:00,000 --> 00:00:00,000
We'll work with the heap in a little bit.

243
00:00:00,000 --> 00:00:00,000
But right now, just know that it's where dynamic memory, like strings and vectors, go.

244
00:00:00,000 --> 00:00:00,000
So, with variables and functions as well, we have three related concepts.

245
00:00:00,000 --> 00:00:00,000
The first concept is scope.

246
00:00:00,000 --> 00:00:00,000
Where in your code can you see a name from?

247
00:00:00,000 --> 00:00:00,000
So scope is visibility.

248
00:00:00,000 --> 00:00:00,000
And C++ has two kinds of scope.

249
00:00:00,000 --> 00:00:00,000
Something that is created inside a block.

250
00:00:00,000 --> 00:00:00,000
For instance, a function body or the body of a for loop or an if statement.

251
00:00:00,000 --> 00:00:00,000
Something that's created inside the block is only visible from the point it's created

252
00:00:00,000 --> 00:00:00,000
to the end of the block that it was created in.

253
00:00:00,000 --> 00:00:00,000
Now sometimes this will be called local scope, but it's really not local scope, it's block scope.

254
00:00:00,000 --> 00:00:00,000
If you create something outside of a block, it has what's called file scope.

255
00:00:00,000 --> 00:00:00,000
File scope means that that name is visible from the point it's created to the end of the file that it was created in.

256
00:00:00,000 --> 00:00:00,000
Including inside any blocks.

257
00:00:00,000 --> 00:00:00,000
So block scope and file scope.

258
00:00:00,000 --> 00:00:00,000
Secondly, we have duration.

259
00:00:00,000 --> 00:00:00,000
In other words, how long does an item stay in memory?

260
00:00:00,000 --> 00:00:00,000
Now global variables, variables that are loaded into the static storage area,

261
00:00:00,000 --> 00:00:00,000
they persist as long as your program runs.

262
00:00:00,000 --> 00:00:00,000
You start running the program, the variable is created right at that moment.

263
00:00:00,000 --> 00:00:00,000
You stop running the program, the variable goes away.

264
00:00:00,000 --> 00:00:00,000
It stays at the same location.

265
00:00:00,000 --> 00:00:00,000
So static in this sense means it doesn't move.

266
00:00:00,000 --> 00:00:00,000
Now when you create a local variable, when does it come into existence?

267
00:00:00,000 --> 00:00:00,000
When the code is executed, that creates it.

268
00:00:00,000 --> 00:00:00,000
When does it go away?

269
00:00:00,000 --> 00:00:00,000
When the function or the block that you created it in ends.

270
00:00:00,000 --> 00:00:00,000
And so these variables are created on the stack up here, as I mentioned before,

271
00:00:00,000 --> 00:00:00,000
and they have what we call automatic duration.

272
00:00:00,000 --> 00:00:00,000
So they're automatic variables.

273
00:00:00,000 --> 00:00:00,000
Finally, we have variables, I mentioned them just briefly before,

274
00:00:00,000 --> 00:00:00,000
we're not going to create any now, that have dynamic duration.

275
00:00:00,000 --> 00:00:00,000
In other words, in one part of your program you can say,

276
00:00:00,000 --> 00:00:00,000
create this variable now, we do that with a new operator, like you do in Java,

277
00:00:00,000 --> 00:00:00,000
and in another part of this program we can say,

278
00:00:00,000 --> 00:00:00,000
I'm done with this, you can have it back to the operating system.

279
00:00:00,000 --> 00:00:00,000
Finally, when we have multiple files working together,

280
00:00:00,000 --> 00:00:00,000
those files are linked together.

281
00:00:00,000 --> 00:00:00,000
So you compile two CPP files, you link them together,

282
00:00:00,000 --> 00:00:00,000
which variables and which functions from which file can be used in which other file.

283
00:00:00,000 --> 00:00:00,000
So linkage determines which files and which functions can be used in each other.

284
00:00:00,000 --> 00:00:00,000
So if something has internal linkage,

285
00:00:00,000 --> 00:00:00,000
if I create a variable in one file using file scope,

286
00:00:00,000 --> 00:00:00,000
in other words, outside of a function,

287
00:00:00,000 --> 00:00:00,000
that variable can have internal linkage,

288
00:00:00,000 --> 00:00:00,000
meaning it can only be used inside that file,

289
00:00:00,000 --> 00:00:00,000
or it can have external linkage,

290
00:00:00,000 --> 00:00:00,000
meaning I can use it in that file and any other files that are linked in.

291
00:00:00,000 --> 00:00:00,000
So internal or external linkage,

292
00:00:00,000 --> 00:00:00,000
both of these have to do with functions and global variables.

293
00:00:00,000 --> 00:00:00,000
All other variables, local variables, have no linkage.

294
00:00:00,000 --> 00:00:00,000
They can only be used in the function that they're created in.

295
00:00:00,000 --> 00:00:00,000
So let's go look at a program, F1 and F2.

296
00:00:00,000 --> 00:00:00,000
I'm going to try and open them side by side.

297
00:00:00,000 --> 00:00:00,000
This is the first time we've been using this IDE right here.

298
00:00:00,000 --> 00:00:00,000
So this might be an interesting video.

299
00:00:00,000 --> 00:00:00,000
So here's F1 and here's F2.

300
00:00:00,000 --> 00:00:00,000
That's good.

301
00:00:00,000 --> 00:00:00,000
That's F1 and F2.

302
00:00:00,000 --> 00:00:00,000
Let me...

303
00:00:00,000 --> 00:00:00,000
I've got F1 and F2.

304
00:00:00,000 --> 00:00:00,000
I'm still trying to do it. There's F2.

305
00:00:00,000 --> 00:00:00,000
That's pretty good, and I'll move this over there.

306
00:00:00,000 --> 00:00:00,000
So here's F1 and F2.

307
00:00:00,000 --> 00:00:00,000
Notice that there's only one main function in F1 and F2.

308
00:00:00,000 --> 00:00:00,000
Actually, let me do one more thing.

309
00:00:00,000 --> 00:00:00,000
I'm going to open up a terminal on that folder.

310
00:00:00,000 --> 00:00:00,000
I'm simply going to type "nick run."

311
00:00:00,000 --> 00:00:00,000
Main first calls the function C.

312
00:00:00,000 --> 00:00:00,000
C is not defined in file F2, but it is linked together, and it's defined in file F1.

313
00:00:00,000 --> 00:00:00,000
So function C is over here, and it prints out the variables A and B.

314
00:00:00,000 --> 00:00:00,000
Now notice A is defined outside of any function here. It's a global variable.

315
00:00:00,000 --> 00:00:00,000
B also is defined outside of every function, and it's a global variable.

316
00:00:00,000 --> 00:00:00,000
So it prints out A and B, and so we get 37, and there's a new line.

317
00:00:00,000 --> 00:00:00,000
Then it calls the function D.

318
00:00:00,000 --> 00:00:00,000
So here's the function D.

319
00:00:00,000 --> 00:00:00,000
It creates a local variable E, another local variable F, 5 and 6,

320
00:00:00,000 --> 00:00:00,000
and it prints out A, B, E, and F.

321
00:00:00,000 --> 00:00:00,000
So we get 37 like we did before, and 56 just like you'd expect.

322
00:00:00,000 --> 00:00:00,000
Then we increment this variable F right here.

323
00:00:00,000 --> 00:00:00,000
So now we set A to 12, B to 13, and we call C again.

324
00:00:00,000 --> 00:00:00,000
So it's going to print A and B.

325
00:00:00,000 --> 00:00:00,000
So notice that the variable A lives over here.

326
00:00:00,000 --> 00:00:00,000
It's defined in F1, and we're changing it over here in F2.

327
00:00:00,000 --> 00:00:00,000
It's declared here so we can use it, and the function C is declared there so we can use it.

328
00:00:00,000 --> 00:00:00,000
But now when I print A and B, you would expect to get 12 and 13.

329
00:00:00,000 --> 00:00:00,000
But it looks like this file has its own copy of B, and so instead I get 12 and 7.

330
00:00:00,000 --> 00:00:00,000
So this A changes to 12, but this B doesn't change to 13.

331
00:00:00,000 --> 00:00:00,000
It still says 7, so I get 127.

332
00:00:00,000 --> 00:00:00,000
Then I call D again.

333
00:00:00,000 --> 00:00:00,000
E is set to that.

334
00:00:00,000 --> 00:00:00,000
It looks like F is set to 6.

335
00:00:00,000 --> 00:00:00,000
I print A, B, E, and F, but instead of getting 12, 7, 5, 6, I get 12, 7, 5, 7.

336
00:00:00,000 --> 00:00:00,000
So apparently this F++ kept this variable in the past.

337
00:00:00,000 --> 00:00:00,000
So let me explain what is happening here.

338
00:00:00,000 --> 00:00:00,000
Variables and functions have what we call external linkage and file scope.

339
00:00:00,000 --> 00:00:00,000
So all these variables, all these functions are visible from here down to here.

340
00:00:00,000 --> 00:00:00,000
File scope, external linkage, static duration.

341
00:00:00,000 --> 00:00:00,000
Now, local variables like E has block scope.

342
00:00:00,000 --> 00:00:00,000
It's visible only from here to the end of the function.

343
00:00:00,000 --> 00:00:00,000
F has block scope visible from there to the end of the duration.

344
00:00:00,000 --> 00:00:00,000
However, for these variables, this has automatic duration,

345
00:00:00,000 --> 00:00:00,000
meaning it comes into existence on the stack and is destroyed when the function ends.

346
00:00:00,000 --> 00:00:00,000
Because of this keyword static here, we're saying F is going to be stored in the static storage area,

347
00:00:00,000 --> 00:00:00,000
not on the stack, which is why when I increment it after calling the function once,

348
00:00:00,000 --> 00:00:00,000
the next time we come around, it's not reset to 6 here.

349
00:00:00,000 --> 00:00:00,000
It has the value 7 down there.

350
00:00:00,000 --> 00:00:00,000
It has the value 7.

351
00:00:00,000 --> 00:00:00,000
That leaves only one thing left to explain,

352
00:00:00,000 --> 00:00:00,000
and that is why is this word static in front of this variable and this function?

353
00:00:00,000 --> 00:00:00,000
We saw what it meant here with this local variable.

354
00:00:00,000 --> 00:00:00,000
It means it still cannot be used anywhere other than the function.

355
00:00:00,000 --> 00:00:00,000
It has block scope.

356
00:00:00,000 --> 00:00:00,000
Yeah, it has block scope.

357
00:00:00,000 --> 00:00:00,000
It only can be seen here.

358
00:00:00,000 --> 00:00:00,000
Even though it's stored the whole time your program is running, unlike E in this case.

359
00:00:00,000 --> 00:00:00,000
The static in front of a function or a global variable means that it has internal linkage.

360
00:00:00,000 --> 00:00:00,000
So this B will always and only be this B.

361
00:00:00,000 --> 00:00:00,000
It will never be this B over here.

362
00:00:00,000 --> 00:00:00,000
It will never be that B over here.

363
00:00:00,000 --> 00:00:00,000
These are two separate B's that are only visible inside their own function,

364
00:00:00,000 --> 00:00:00,000
or only exist inside their own function.

365
00:00:00,000 --> 00:00:00,000
So when I set B equal to 13 here, I get this B, not this B.

366
00:00:00,000 --> 00:00:00,000
When I set A equal to 12 here, I get this A.

367
00:00:00,000 --> 00:00:00,000
Now, why can I use this A inside this function?

368
00:00:00,000 --> 00:00:00,000
Because it's obviously not in scope.

369
00:00:00,000 --> 00:00:00,000
I brought it into scope by declaring it.

370
00:00:00,000 --> 00:00:00,000
So I declared A, I declared C, we now know the name, and I can use A and C in that function.

371
00:00:00,000 --> 00:00:00,000
So we had some exercises we're going to do with this and some questions.

372
00:00:00,000 --> 00:00:00,000
So I want to see what will happen in line 1 if I remove the word extern from this.

373
00:00:00,000 --> 00:00:00,000
What if I just change that to int A?

374
00:00:00,000 --> 00:00:00,000
Do I get an error now when I try and do make run?

375
00:00:00,000 --> 00:00:00,000
So make run.

376
00:00:00,000 --> 00:00:00,000
Yes, I get an error.

377
00:00:00,000 --> 00:00:00,000
So now, when the linker comes along, it sees two copies of A.

378
00:00:00,000 --> 00:00:00,000
Both of them could be used in either file, but you can't have two things that have the same name.

379
00:00:00,000 --> 00:00:00,000
So I have multiple definitions of A.

380
00:00:00,000 --> 00:00:00,000
It's a linker error.

381
00:00:00,000 --> 00:00:00,000
So I'm going to come over here and I'm just going to put my answer here.

382
00:00:00,000 --> 00:00:00,000
Oops. Save the wrong thing.

383
00:00:00,000 --> 00:00:00,000
Copy that.

384
00:00:00,000 --> 00:00:00,000
Again, that copy didn't work, did it?

385
00:00:00,000 --> 00:00:00,000
From the thing.

386
00:00:00,000 --> 00:00:00,000
So I'm going to do that.

387
00:00:00,000 --> 00:00:00,000
Right click.

388
00:00:00,000 --> 00:00:00,000
Can't seem to get a copy of the terminal.

389
00:00:00,000 --> 00:00:00,000
So I'm just going to type in multiple definitions of A.

390
00:00:00,000 --> 00:00:00,000
It's only one definition of each object in an executable.

391
00:00:00,000 --> 00:00:00,000
That's called the one definition rule or the ODR, the one definition rule.

392
00:00:00,000 --> 00:00:00,000
I still want to see if I can copy that.

393
00:00:00,000 --> 00:00:00,000
Doesn't look like it.

394
00:00:00,000 --> 00:00:00,000
Weird.

395
00:00:00,000 --> 00:00:00,000
Okay, so we're going to put extern back to that.

396
00:00:00,000 --> 00:00:00,000
Okay, let's look at the second one here.

397
00:00:00,000 --> 00:00:00,000
Now we're going to remove the word static from the definition of B on F1.

398
00:00:00,000 --> 00:00:00,000
Does the program still compile and link?

399
00:00:00,000 --> 00:00:00,000
Does the program run differently?

400
00:00:00,000 --> 00:00:00,000
Does the change to B on F2.cpp line 9 have any effect since B now has external linkage in file 1?

401
00:00:00,000 --> 00:00:00,000
So I'm going to remove the static from B on line 5 in F1.

402
00:00:00,000 --> 00:00:00,000
And I'm going to do make run.

403
00:00:00,000 --> 00:00:00,000
Now, 3756, 12757 runs exactly the same.

404
00:00:00,000 --> 00:00:00,000
So the answer is no difference.

405
00:00:00,000 --> 00:00:00,000
Runs the same.

406
00:00:00,000 --> 00:00:00,000
Can you remove the static from both definitions of B?

407
00:00:00,000 --> 00:00:00,000
Let's remove it over here.

408
00:00:00,000 --> 00:00:00,000
Let's do make run.

409
00:00:00,000 --> 00:00:00,000
Oops, no, multiple definitions of B.

410
00:00:00,000 --> 00:00:00,000
Okay, I've discovered how to copy.

411
00:00:00,000 --> 00:00:00,000
It looks like you just select the text, right click.

412
00:00:00,000 --> 00:00:00,000
Apparently it's copied here.

413
00:00:00,000 --> 00:00:00,000
And I can go error, multiple definitions of B.

414
00:00:00,000 --> 00:00:00,000
We're breaking the ODR rule.

415
00:00:00,000 --> 00:00:00,000
So again, we can't have two variables B with external linkage just like we can't have two A's.

416
00:00:00,000 --> 00:00:00,000
So let's turn them back to internal linkage.

417
00:00:00,000 --> 00:00:00,000
Right where we left off.

418
00:00:00,000 --> 00:00:00,000
Okay, now in F1 we have a declaration for C.

419
00:00:00,000 --> 00:00:00,000
Let's add a call to the declaration for D.

420
00:00:00,000 --> 00:00:00,000
So just like I have the function C here, I have a declaration for C here and I can call C here.

421
00:00:00,000 --> 00:00:00,000
Can I do the same thing for D?

422
00:00:00,000 --> 00:00:00,000
So can I write void D and then call the function D from here?

423
00:00:00,000 --> 00:00:00,000
Let's see.

424
00:00:00,000 --> 00:00:00,000
So make run.

425
00:00:00,000 --> 00:00:00,000
No, we have an undefined reference to D.

426
00:00:00,000 --> 00:00:00,000
That's because in a function if you have static in front of it, it means give this function internal linkage.

427
00:00:00,000 --> 00:00:00,000
The function D can only be called from F1.

428
00:00:00,000 --> 00:00:00,000
It cannot be called from FT.

429
00:00:00,000 --> 00:00:00,000
So let's copy our error message there.

430
00:00:00,000 --> 00:00:00,000
So function has internal linkage and only be used in file F1.cpp.

431
00:00:00,000 --> 00:00:00,000
Okay, so let's remove that.

432
00:00:00,000 --> 00:00:00,000
So that didn't work.

433
00:00:00,000 --> 00:00:00,000
Now, can we add an extern declaration?

434
00:00:00,000 --> 00:00:00,000
So notice that I could use the variable A over here by adding an extern over there.

435
00:00:00,000 --> 00:00:00,000
Can I use an extern to allow me to use the variables E and F?

436
00:00:00,000 --> 00:00:00,000
So let's do extern int E, extern int F.

437
00:00:00,000 --> 00:00:00,000
Let's do E equals 4, F equals 12.

438
00:00:00,000 --> 00:00:00,000
And let's compile that and try it.

439
00:00:00,000 --> 00:00:00,000
So make run.

440
00:00:00,000 --> 00:00:00,000
Now we've got two things here.

441
00:00:00,000 --> 00:00:00,000
Notice I have an undefined.

442
00:00:00,000 --> 00:00:00,000
Copy both those.

443
00:00:00,000 --> 00:00:00,000
And here's what happens.

444
00:00:00,000 --> 00:00:00,000
Both variables are locals so they have no linkage.

445
00:00:00,000 --> 00:00:00,000
Can't be used outside of function D.

446
00:00:00,000 --> 00:00:00,000
So that's the explanation for what happens there.

447
00:00:00,000 --> 00:00:00,000
Okay, so that doesn't work.

448
00:00:00,000 --> 00:00:00,000
Let's see what other questions we had.

449
00:00:00,000 --> 00:00:00,000
If I remove the static from the definition of the local variable F, what happens?

450
00:00:00,000 --> 00:00:00,000
So first let's make run.

451
00:00:00,000 --> 00:00:00,000
So 37, 37, 56, 127, 127, 57.

452
00:00:00,000 --> 00:00:00,000
I'm going to remove static.

453
00:00:00,000 --> 00:00:00,000
I'm going to do make run.

454
00:00:00,000 --> 00:00:00,000
Notice now that the variable F doesn't retain this F++.

455
00:00:00,000 --> 00:00:00,000
Now this variable has automatic duration.

456
00:00:00,000 --> 00:00:00,000
It's stored on the stack.

457
00:00:00,000 --> 00:00:00,000
Before it was stored in the static storage area and it didn't move.

458
00:00:00,000 --> 00:00:00,000
So each time we come into this function we get a new copy of F here.

459
00:00:00,000 --> 00:00:00,000
Before we did not.

460
00:00:00,000 --> 00:00:00,000
So notice the 57 and the 56.

461
00:00:00,000 --> 00:00:00,000
This is where it's stored in the static storage area.

462
00:00:00,000 --> 00:00:00,000
This is where it's stored on the stack.

463
00:00:00,000 --> 00:00:00,000
So we can say F no longer retains its value between function calls

464
00:00:00,000 --> 00:00:00,000
because it now has automatic storage instead of static storage.

465
00:00:00,000 --> 00:00:00,000
Okay, so we looked at linkage.

466
00:00:00,000 --> 00:00:00,000
We looked at changing duration.

467
00:00:00,000 --> 00:00:00,000
Put that back the way it was before.

468
00:00:00,000 --> 00:00:00,000
Now let's just change the order of these two functions here in F1.

469
00:00:00,000 --> 00:00:00,000
I'm just going to grab C.

470
00:00:00,000 --> 00:00:00,000
And I'm going to move it up above D here.

471
00:00:00,000 --> 00:00:00,000
And I'm going to do make run.

472
00:00:00,000 --> 00:00:00,000
And this is the first time I've got a red error here.

473
00:00:00,000 --> 00:00:00,000
Red error says D was not declared in this scope.

474
00:00:00,000 --> 00:00:00,000
D was not declared in this scope.

475
00:00:00,000 --> 00:00:00,000
So I see D right here.

476
00:00:00,000 --> 00:00:00,000
Why isn't it declared in this scope?

477
00:00:00,000 --> 00:00:00,000
Well, remember this has to do with scope.

478
00:00:00,000 --> 00:00:00,000
So this is a scope problem.

479
00:00:00,000 --> 00:00:00,000
So notice that C has file scope.

480
00:00:00,000 --> 00:00:00,000
It's visible from there to there.

481
00:00:00,000 --> 00:00:00,000
It's visible from its point of declaration to the end of the file.

482
00:00:00,000 --> 00:00:00,000
D also has file scope.

483
00:00:00,000 --> 00:00:00,000
It's visible from its point of declaration to there.

484
00:00:00,000 --> 00:00:00,000
But I'm trying to use D up here.

485
00:00:00,000 --> 00:00:00,000
So I'm using D before it's defined or declared.

486
00:00:00,000 --> 00:00:00,000
So it is out of scope.

487
00:00:00,000 --> 00:00:00,000
So using D before defined or declared.

488
00:00:00,000 --> 00:00:00,000
So it is out of scope.

489
00:00:00,000 --> 00:00:00,000
And let me, it says show me, so let me.

490
00:00:00,000 --> 00:00:00,000
And I'm just right clicking.

491
00:00:00,000 --> 00:00:00,000
Even though there's no symbol that anything happened.

492
00:00:00,000 --> 00:00:00,000
And I'm pasting in what I just real clicked there.

493
00:00:00,000 --> 00:00:00,000
All right, so a little bit of exploration with memory.

494
00:00:00,000 --> 00:00:00,000
So let's go explore a little bit more about variables, sizes, and addresses.

495
00:00:00,000 --> 00:00:00,000
So all variables have three addresses.

496
00:00:00,000 --> 00:00:00,000
So if I want to put something in a variable, I use its name.

497
00:00:00,000 --> 00:00:00,000
I don't say put something in that storage location that's at address 3000.

498
00:00:00,000 --> 00:00:00,000
I don't use its memory address.

499
00:00:00,000 --> 00:00:00,000
I use its name.

500
00:00:00,000 --> 00:00:00,000
All variables have a type that determines what I can store in the variable.

501
00:00:00,000 --> 00:00:00,000
I can't store an integer in a string.

502
00:00:00,000 --> 00:00:00,000
I can't store a string in an integer variable.

503
00:00:00,000 --> 00:00:00,000
It also determines what valid operations can happen to that data.

504
00:00:00,000 --> 00:00:00,000
And finally, inside that storage location, we have some data or some state or some value.

505
00:00:00,000 --> 00:00:00,000
We call that the value.

506
00:00:00,000 --> 00:00:00,000
Now, when you have a variable, you can also, instead of using the name, find out exactly where it is located.

507
00:00:00,000 --> 00:00:00,000
And so that operator is called the address of operator.

508
00:00:00,000 --> 00:00:00,000
It's the ampersand, and it's used in front of a variable instead of after a type.

509
00:00:00,000 --> 00:00:00,000
So after a type, we're saying int ref n.

510
00:00:00,000 --> 00:00:00,000
n is a reference to an integer.

511
00:00:00,000 --> 00:00:00,000
Before a variable, cout ampersand n says give me the address of n.

512
00:00:00,000 --> 00:00:00,000
So the address of operator returns the location of the object.

513
00:00:00,000 --> 00:00:00,000
And the size of operator returns its storage size in bytes.

514
00:00:00,000 --> 00:00:00,000
So we can see more technical details about how data is actually stored in memory, not just the logical details.

515
00:00:00,000 --> 00:00:00,000
So let's do that in our next exercise.

516
00:00:00,000 --> 00:00:00,000
Let's print the address and size of each variable by saying n lives at-- this is the address-- and uses xx bytes.

517
00:00:00,000 --> 00:00:00,000
So let me close F1 and F2.

518
00:00:00,000 --> 00:00:00,000
Let me close that terminal, throw it away.

519
00:00:00,000 --> 00:00:00,000
Let's come down here to C and open up variables.cpp.

520
00:00:00,000 --> 00:00:00,000
I actually need to open a terminal so we can run it.

521
00:00:00,000 --> 00:00:00,000
Let me right-click on C, open a terminal.

522
00:00:00,000 --> 00:00:00,000
OK, so here I've created a variable with file scope, static storage duration.

523
00:00:00,000 --> 00:00:00,000
It's a constant, pi.

524
00:00:00,000 --> 00:00:00,000
It's a global.

525
00:00:00,000 --> 00:00:00,000
And here I have created a variable n, an int, a string, and an employee object.

526
00:00:00,000 --> 00:00:00,000
So a structured variable.

527
00:00:00,000 --> 00:00:00,000
And here I've printed out the various names.

528
00:00:00,000 --> 00:00:00,000
Now obviously I have to have an overloaded operator for me to be able to print out the waiter, but I do.

529
00:00:00,000 --> 00:00:00,000
So now what we want to do is we want to print out the address and size of each one using this.

530
00:00:00,000 --> 00:00:00,000
So I'm going to say cl n lives at-- and to get where n lives, I'm going to take the address of n.

531
00:00:00,000 --> 00:00:00,000
And to get the number of bytes that n uses, I'm going to use size of n.

532
00:00:00,000 --> 00:00:00,000
OK, so there's n.

533
00:00:00,000 --> 00:00:00,000
Let's look at some of the other variables.

534
00:00:00,000 --> 00:00:00,000
I'll just copy that.

535
00:00:00,000 --> 00:00:00,000
So how about pi?

536
00:00:00,000 --> 00:00:00,000
So I take the address of pi.

537
00:00:00,000 --> 00:00:00,000
See how many bytes that uses.

538
00:00:00,000 --> 00:00:00,000
Let's take name.

539
00:00:00,000 --> 00:00:00,000
So I take the address of name and the size of name.

540
00:00:00,000 --> 00:00:00,000
And finally, how about the waiter?

541
00:00:00,000 --> 00:00:00,000
So I take the address of that variable waiter, where it lives, and the amount of space it uses.

542
00:00:00,000 --> 00:00:00,000
OK, let's run it.

543
00:00:00,000 --> 00:00:00,000
Do make run.

544
00:00:00,000 --> 00:00:00,000
So here's the name of this variable.

545
00:00:00,000 --> 00:00:00,000
Here's the value it stores.

546
00:00:00,000 --> 00:00:00,000
Here is where it lives.

547
00:00:00,000 --> 00:00:00,000
Now this is a hexadecimal address.

548
00:00:00,000 --> 00:00:00,000
And since it's an int, it uses four bytes.

549
00:00:00,000 --> 00:00:00,000
Pi lives at an entirely different address.

550
00:00:00,000 --> 00:00:00,000
Now you notice that this address is much smaller than this address.

551
00:00:00,000 --> 00:00:00,000
It's 0x5, meaning it's closer to zero.

552
00:00:00,000 --> 00:00:00,000
It's at the bottom of memory.

553
00:00:00,000 --> 00:00:00,000
This is at the top of memory.

554
00:00:00,000 --> 00:00:00,000
This is on the stack, as is this, as is this.

555
00:00:00,000 --> 00:00:00,000
And these are next to each other in the stack if we looked at these values in something other than hexadecimal.

556
00:00:00,000 --> 00:00:00,000
Pointers are always printed in hexadecimal or base 16 numbers.

557
00:00:00,000 --> 00:00:00,000
So my integer uses four bytes.

558
00:00:00,000 --> 00:00:00,000
My double uses eight bytes.

559
00:00:00,000 --> 00:00:00,000
My name uses 32 bytes.

560
00:00:00,000 --> 00:00:00,000
Now this will vary from compiler to compiler.

561
00:00:00,000 --> 00:00:00,000
We're on GCC, on a Unix operating system, and we use 32 byte strings.

562
00:00:00,000 --> 00:00:00,000
And waiter, which is a structure, uses 40 bytes for the parts that are inside the waiter.

563
00:00:00,000 --> 00:00:00,000
Now, let's talk about pointers.

564
00:00:00,000 --> 00:00:00,000
So we've seen how we can print out the address of a variable.

565
00:00:00,000 --> 00:00:00,000
Could we store that in another variable?

566
00:00:00,000 --> 00:00:00,000
Yes. These variables are called pointers.

567
00:00:00,000 --> 00:00:00,000
So pointers don't hold integers or hold doubles.

568
00:00:00,000 --> 00:00:00,000
They hold addresses of other variables.

569
00:00:00,000 --> 00:00:00,000
So that's how they got their name, because since the address is another variable,

570
00:00:00,000 --> 00:00:00,000
we say that variable points to another variable.

571
00:00:00,000 --> 00:00:00,000
We create a pointer like this.

572
00:00:00,000 --> 00:00:00,000
The kind of thing we're pointing to, the point E, a star, and the name of the pointer.

573
00:00:00,000 --> 00:00:00,000
So here's an example with int pointer.

574
00:00:00,000 --> 00:00:00,000
So iPointer is a pointer to an integer.

575
00:00:00,000 --> 00:00:00,000
You read this from the right to the left.

576
00:00:00,000 --> 00:00:00,000
You find the name. iPointer is a pointer to an integer.

577
00:00:00,000 --> 00:00:00,000
Now, you might wonder about the space before or after the star. It doesn't matter.

578
00:00:00,000 --> 00:00:00,000
I could write int star and put the star next to the int, put the star next to the iPointer.

579
00:00:00,000 --> 00:00:00,000
It's entirely irrelevant.

580
00:00:00,000 --> 00:00:00,000
However, you need to make sure that every pointer variable has its own star.

581
00:00:00,000 --> 00:00:00,000
So if I were to write this, int star iPointer, comma, i, i is not a pointer.

582
00:00:00,000 --> 00:00:00,000
i is an int.

583
00:00:00,000 --> 00:00:00,000
So iPointer is a pointer to an int. i is an int, not a pointer to an int.

584
00:00:00,000 --> 00:00:00,000
Now, unless you initialize a pointer, it just points to a random address in memory.

585
00:00:00,000 --> 00:00:00,000
It's uninitialized.

586
00:00:00,000 --> 00:00:00,000
And that is very, very, very bad.

587
00:00:00,000 --> 00:00:00,000
So you can initialize a pointer using no pointer, that keyword,

588
00:00:00,000 --> 00:00:00,000
or you can put in just zero.

589
00:00:00,000 --> 00:00:00,000
That signifies that the pointer is unused.

590
00:00:00,000 --> 00:00:00,000
Now, you might wonder, could I initialize a pointer with this address, that number, like that?

591
00:00:00,000 --> 00:00:00,000
And the answer is no, you cannot.

592
00:00:00,000 --> 00:00:00,000
In early versions of C, you could, but now you cannot.

593
00:00:00,000 --> 00:00:00,000
No other literal integer value is permitted.

594
00:00:00,000 --> 00:00:00,000
Now, you can return, you can call the address of operator,

595
00:00:00,000 --> 00:00:00,000
which is what we just used to print out the addresses,

596
00:00:00,000 --> 00:00:00,000
so that address operator returns an address,

597
00:00:00,000 --> 00:00:00,000
and we can use that to initialize a pointer.

598
00:00:00,000 --> 00:00:00,000
We could use the new operator,

599
00:00:00,000 --> 00:00:00,000
which we're going to look at in our section on dynamic memory,

600
00:00:00,000 --> 00:00:00,000
and initialize a pointer with the new operator, memory on the heap,

601
00:00:00,000 --> 00:00:00,000
or we could use a function that uses one of these techniques,

602
00:00:00,000 --> 00:00:00,000
or one of the C functions, that sort of thing.

603
00:00:00,000 --> 00:00:00,000
So let's complete part two of variables.cpp,

604
00:00:00,000 --> 00:00:00,000
and add some pointers inside there.

605
00:00:00,000 --> 00:00:00,000
Now, there's nothing to print for this part,

606
00:00:00,000 --> 00:00:00,000
but what I'm going to do is I'm going to create some pointers,

607
00:00:00,000 --> 00:00:00,000
and you can create the pointer like this,

608
00:00:00,000 --> 00:00:00,000
so int pointer ip, int pointer, equals the address of n.

609
00:00:00,000 --> 00:00:00,000
We could do it like this, const double pointer dp

610
00:00:00,000 --> 00:00:00,000
equals the address of pi.

611
00:00:00,000 --> 00:00:00,000
Could we just say double pointer dp equals the address of pi?

612
00:00:00,000 --> 00:00:00,000
Let's see what happens if we did make on that.

613
00:00:00,000 --> 00:00:00,000
Now, it says that's an error,

614
00:00:00,000 --> 00:00:00,000
because this, the address, pi, is a constant double,

615
00:00:00,000 --> 00:00:00,000
and taking the address of a constant double

616
00:00:00,000 --> 00:00:00,000
doesn't lead a double pointer, it leads a const double pointer.

617
00:00:00,000 --> 00:00:00,000
Now, could we do this?

618
00:00:00,000 --> 00:00:00,000
We could do that, right?

619
00:00:00,000 --> 00:00:00,000
So this is going to be initialized with whatever this returns,

620
00:00:00,000 --> 00:00:00,000
and so we could just use auto for that as well.

621
00:00:00,000 --> 00:00:00,000
So let's do a string pointer sp equals the address of name,

622
00:00:00,000 --> 00:00:00,000
and an employee pointer ep equals the address of my waiter.

623
00:00:00,000 --> 00:00:00,000
So you notice I can put the star in front of the variable.

624
00:00:00,000 --> 00:00:00,000
I can use auto and skip the star altogether.

625
00:00:00,000 --> 00:00:00,000
I can put it in front of the type.

626
00:00:00,000 --> 00:00:00,000
It doesn't make any difference to the syntax there.

627
00:00:00,000 --> 00:00:00,000
Okay, so a pointer is a variable.

628
00:00:00,000 --> 00:00:00,000
That means it has a name, a type, and a value.

629
00:00:00,000 --> 00:00:00,000
The value inside the pointer, we call its explicit value.

630
00:00:00,000 --> 00:00:00,000
That's, in other words, what's inside the memory.

631
00:00:00,000 --> 00:00:00,000
That's the address it contains.

632
00:00:00,000 --> 00:00:00,000
But a pointer has a second value called its indirect value.

633
00:00:00,000 --> 00:00:00,000
That's the value of the variable that it points to.

634
00:00:00,000 --> 00:00:00,000
We retrieve that by using the indirection or dereferencing operator, the star,

635
00:00:00,000 --> 00:00:00,000
just like we did with iterators in vectors.

636
00:00:00,000 --> 00:00:00,000
So here I have an integer, 3.

637
00:00:00,000 --> 00:00:00,000
I've got a box in memory.

638
00:00:00,000 --> 00:00:00,000
I put 3 inside the box.

639
00:00:00,000 --> 00:00:00,000
I create a second box in memory, pa,

640
00:00:00,000 --> 00:00:00,000
and inside pa, I put the address of this first box.

641
00:00:00,000 --> 00:00:00,000
Now, to print out what's in the box,

642
00:00:00,000 --> 00:00:00,000
print out the 3, I can print out the name of the variable,

643
00:00:00,000 --> 00:00:00,000
or I can dereference the pointer.

644
00:00:00,000 --> 00:00:00,000
Dereference a pointer says,

645
00:00:00,000 --> 00:00:00,000
go to the address that the pointer contains

646
00:00:00,000 --> 00:00:00,000
and give me back the value that's at that location.

647
00:00:00,000 --> 00:00:00,000
Now, notice the star I've used twice in these two lines.

648
00:00:00,000 --> 00:00:00,000
I've used it on line 1 where I'm declaring the pointer, int star pa.

649
00:00:00,000 --> 00:00:00,000
This star here means pa is a pointer to int.

650
00:00:00,000 --> 00:00:00,000
It's called the pointer declarator operator.

651
00:00:00,000 --> 00:00:00,000
This star doesn't have int star in front of it.

652
00:00:00,000 --> 00:00:00,000
It's just star pa.

653
00:00:00,000 --> 00:00:00,000
This is a unary operator, and it's the dereferencing operator.

654
00:00:00,000 --> 00:00:00,000
Now, the star means something different when declaring the pointer

655
00:00:00,000 --> 00:00:00,000
or when dereferencing it.

656
00:00:00,000 --> 00:00:00,000
Sometimes students get confused with that.

657
00:00:00,000 --> 00:00:00,000
Now, the pointer also has an address which could be stored.

658
00:00:00,000 --> 00:00:00,000
So I could say int star star or int star star star.

659
00:00:00,000 --> 00:00:00,000
So int star star star pa is a pointer to a pointer to a pointer to an int.

660
00:00:00,000 --> 00:00:00,000
So let's complete part 3, and we're going to print out

661
00:00:00,000 --> 00:00:00,000
IP contains, what its explicit value is,

662
00:00:00,000 --> 00:00:00,000
is stored at, its address, and the value that it points to.

663
00:00:00,000 --> 00:00:00,000
Okay, so let's print the cout,

664
00:00:00,000 --> 00:00:00,000
and I'm just going to put quotes around the xxx's

665
00:00:00,000 --> 00:00:00,000
where we're going to replace it.

666
00:00:00,000 --> 00:00:00,000
And let's do several of those.

667
00:00:00,000 --> 00:00:00,000
So there's IP, DP, SP, and EP.

668
00:00:00,000 --> 00:00:00,000
So this is DP, SP, and EP.

669
00:00:00,000 --> 00:00:00,000
And for this part, we're going to say IP.

670
00:00:00,000 --> 00:00:00,000
Right?

671
00:00:00,000 --> 00:00:00,000
That's what it contains.

672
00:00:00,000 --> 00:00:00,000
Like any variable, you use its name to get what it contains.

673
00:00:00,000 --> 00:00:00,000
And DP, and SP, and EP.

674
00:00:00,000 --> 00:00:00,000
Okay, to get what value it has,

675
00:00:00,000 --> 00:00:00,000
now I'm going to try and use a trick here in Visual Studio.

676
00:00:00,000 --> 00:00:00,000
I'm going to click there.

677
00:00:00,000 --> 00:00:00,000
I'm going to hold down my alt key and click there.

678
00:00:00,000 --> 00:00:00,000
No, that didn't seem to work.

679
00:00:00,000 --> 00:00:00,000
I'm going to click there.

680
00:00:00,000 --> 00:00:00,000
I'm going to hold down my alt key while I drag through.

681
00:00:00,000 --> 00:00:00,000
Let's see if that works.

682
00:00:00,000 --> 00:00:00,000
I'm going to try and copy that.

683
00:00:00,000 --> 00:00:00,000
And I'm going to go here.

684
00:00:00,000 --> 00:00:00,000
No, it didn't work.

685
00:00:00,000 --> 00:00:00,000
I'm not quite sure on this editor how to get multi-line cursors.

686
00:00:00,000 --> 00:00:00,000
Oh, you know how I think I can do?

687
00:00:00,000 --> 00:00:00,000
I think I can hold down my alt key and the shift key.

688
00:00:00,000 --> 00:00:00,000
No, didn't work.

689
00:00:00,000 --> 00:00:00,000
I'm messing up.

690
00:00:00,000 --> 00:00:00,000
I shouldn't be experimenting while I'm talking.

691
00:00:00,000 --> 00:00:00,000
Let's just go ahead and do this manually.

692
00:00:00,000 --> 00:00:00,000
So this is going to be the address of IP.

693
00:00:00,000 --> 00:00:00,000
This is going to be the address of DP.

694
00:00:00,000 --> 00:00:00,000
And this is going to be the address of SP.

695
00:00:00,000 --> 00:00:00,000
And this is going to be the address of EP.

696
00:00:00,000 --> 00:00:00,000
Now let's bring this one down here like that.

697
00:00:00,000 --> 00:00:00,000
And that.

698
00:00:00,000 --> 00:00:00,000
It's going to be easier to see.

699
00:00:00,000 --> 00:00:00,000
And that.

700
00:00:00,000 --> 00:00:00,000
And that.

701
00:00:00,000 --> 00:00:00,000
So the last one is what it points to.

702
00:00:00,000 --> 00:00:00,000
And it points to star IP.

703
00:00:00,000 --> 00:00:00,000
And star DP.

704
00:00:00,000 --> 00:00:00,000
Star SP.

705
00:00:00,000 --> 00:00:00,000
And star EP.

706
00:00:00,000 --> 00:00:00,000
So star EP dereferences this variable.

707
00:00:00,000 --> 00:00:00,000
This gives me the value in the variable.

708
00:00:00,000 --> 00:00:00,000
This gives me the location of the variable.

709
00:00:00,000 --> 00:00:00,000
This dereferences gives me its indirect value.

710
00:00:00,000 --> 00:00:00,000
Okay, let's open a terminal on that.

711
00:00:00,000 --> 00:00:00,000
And then let's do make run.

712
00:00:00,000 --> 00:00:00,000
And we can see the output of it.

713
00:00:00,000 --> 00:00:00,000
So when we did IP, we pointed it to N.

714
00:00:00,000 --> 00:00:00,000
So N lives at this address.

715
00:00:00,000 --> 00:00:00,000
Now if we look inside IP, that's the address we find.

716
00:00:00,000 --> 00:00:00,000
Notice that IP itself is stored at a completely different address.

717
00:00:00,000 --> 00:00:00,000
But when we dereference IP, we get the same value that N had inside it here.

718
00:00:00,000 --> 00:00:00,000
N had inside it.

719
00:00:00,000 --> 00:00:00,000
Alright, so those are pointer basics.

720
00:00:00,000 --> 00:00:00,000
Now a pointer input parameter should be const.

721
00:00:00,000 --> 00:00:00,000
So if I have a function, I'm passing a pointer to it.

722
00:00:00,000 --> 00:00:00,000
And I don't want to change what that pointer points to.

723
00:00:00,000 --> 00:00:00,000
The pointer should be const.

724
00:00:00,000 --> 00:00:00,000
If you don't put the const there, it will act like a reference.

725
00:00:00,000 --> 00:00:00,000
So if I write int F and I pass int P, int star P.

726
00:00:00,000 --> 00:00:00,000
That means that this pointer can change what P is pointing to.

727
00:00:00,000 --> 00:00:00,000
It can change what P is pointing to.

728
00:00:00,000 --> 00:00:00,000
So we're going to do that.

729
00:00:00,000 --> 00:00:00,000
So this is just an example to show how we can use pointers instead of references for output parameters.

730
00:00:00,000 --> 00:00:00,000
So we're going to write a function that takes a pointer to int.

731
00:00:00,000 --> 00:00:00,000
We're going to fill the pointer's indirect value with a random number.

732
00:00:00,000 --> 00:00:00,000
We're going to call one of the library functions called rand that's in the C standard library.

733
00:00:00,000 --> 00:00:00,000
In main, we're going to create an int variable that's uninitialized.

734
00:00:00,000 --> 00:00:00,000
We're going to pass its address to the function.

735
00:00:00,000 --> 00:00:00,000
So when we call the function, we won't pass the variable name.

736
00:00:00,000 --> 00:00:00,000
We'll use the address of the operator to pass it.

737
00:00:00,000 --> 00:00:00,000
And then we're going to print the value both before and calling the function.

738
00:00:00,000 --> 00:00:00,000
So let's close that terminal.

739
00:00:00,000 --> 00:00:00,000
Let's close variables.cpp.

740
00:00:00,000 --> 00:00:00,000
Go down to D.

741
00:00:00,000 --> 00:00:00,000
So write a function that takes a pointer to int as its only parameter inside the function.

742
00:00:00,000 --> 00:00:00,000
Fill the pointer's indirect value with a random number.

743
00:00:00,000 --> 00:00:00,000
So it's not returning anything.

744
00:00:00,000 --> 00:00:00,000
We'll call it randomize.

745
00:00:00,000 --> 00:00:00,000
It's going to take a pointer to an int, an int pointer p.

746
00:00:00,000 --> 00:00:00,000
Now if I assigned to p, I would change the value in the pointer.

747
00:00:00,000 --> 00:00:00,000
I would point it somewhere else.

748
00:00:00,000 --> 00:00:00,000
I don't want to do that.

749
00:00:00,000 --> 00:00:00,000
I want to assign to what p points to.

750
00:00:00,000 --> 00:00:00,000
Star p equals, and I'm just going to call the rand function from c standard lib.

751
00:00:00,000 --> 00:00:00,000
That will just give me a random number.

752
00:00:00,000 --> 00:00:00,000
Now you might wonder about this first line on line 21 here.

753
00:00:00,000 --> 00:00:00,000
What this does is this gets the time on your hardware clock

754
00:00:00,000 --> 00:00:00,000
and what we call seeds the random number generator.

755
00:00:00,000 --> 00:00:00,000
So each time we run this function we'll get a different value.

756
00:00:00,000 --> 00:00:00,000
If you took this off, you would get the same value each time.

757
00:00:00,000 --> 00:00:00,000
It would be statistically random, but it would be exactly the same value each time you called the function.

758
00:00:00,000 --> 00:00:00,000
Okay, so let's create an int variable.

759
00:00:00,000 --> 00:00:00,000
I'm going to initialize it.

760
00:00:00,000 --> 00:00:00,000
It says uninitialize.

761
00:00:00,000 --> 00:00:00,000
I'm going to print the value of my variable.

762
00:00:00,000 --> 00:00:00,000
See how before n is n.

763
00:00:00,000 --> 00:00:00,000
I'm going to do that afterwards as well.

764
00:00:00,000 --> 00:00:00,000
I'm going to change that before to after.

765
00:00:00,000 --> 00:00:00,000
Now I'm going to call the function.

766
00:00:00,000 --> 00:00:00,000
I can't simply say randomize n because the function doesn't want an integer.

767
00:00:00,000 --> 00:00:00,000
It wants a pointer to integer.

768
00:00:00,000 --> 00:00:00,000
So to call it with a pointer to integer, I can generate one by taking the address of n.

769
00:00:00,000 --> 00:00:00,000
So this is an output parameter as a pointer.

770
00:00:00,000 --> 00:00:00,000
So let's try that.

771
00:00:00,000 --> 00:00:00,000
Let's get a shell here.

772
00:00:00,000 --> 00:00:00,000
Let me do make run.

773
00:00:00,000 --> 00:00:00,000
So notice before it had the value I put in it, 42.

774
00:00:00,000 --> 00:00:00,000
After calling the function randomize with its address, the function took that address, changed the value inside n,

775
00:00:00,000 --> 00:00:00,000
and when I print out n, it's an entirely different number.

776
00:00:00,000 --> 00:00:00,000
Now as I said, the code here seeds the random number generator,

777
00:00:00,000 --> 00:00:00,000
so every time you run this, you should get a different value.

778
00:00:00,000 --> 00:00:00,000
Let me try it once again.

779
00:00:00,000 --> 00:00:00,000
Yes, notice I'm getting an entirely different value for the random number here this second time.

780
00:00:00,000 --> 00:00:00,000
So that's a pointer as an output parameter.

781
00:00:00,000 --> 00:00:00,000
Alright, that's all we're going to do today.

782
00:00:00,000 --> 00:00:00,000
And when you come back, we're going to look at using pointers like this and output parameters to modify images.

783
00:00:00,000 --> 00:00:00,000
Thank you.

