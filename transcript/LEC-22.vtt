WEBVTT

00:00:00.000 --> 00:00:00.000
 Hello everyone, this is Steve Gilbert. Welcome to lecture 22 on C-style strings.

00:00:00.000 --> 00:00:00.000
 So let's talk about C-style strings.

00:00:00.000 --> 00:00:00.000
 A C-string is a character array that was used for traditional or built-in strings in C.

00:00:00.000 --> 00:00:00.000
 These were inherited by C++.

00:00:00.000 --> 00:00:00.000
 So if I create an array, I can actually initialize it, a char array,

00:00:00.000 --> 00:00:00.000
 I can initialize it with what we call a string literal, with just "hello" in double quotes.

00:00:00.000 --> 00:00:00.000
 That will initialize or create an array that has six elements in it.

00:00:00.000 --> 00:00:00.000
 So notice the different ways we could do that.

00:00:00.000 --> 00:00:00.000
 We could allocate it by saying "greeting6 = hello" or we could do it the same way we do all the other arrays.

00:00:00.000 --> 00:00:00.000
 We could say "greeting =" and then put in the "h" and the "e" and the "l" and the "l" and the "o"

00:00:00.000 --> 00:00:00.000
 along with one additional value.

00:00:00.000 --> 00:00:00.000
 Now notice when we initialize a C-style string or a character array,

00:00:00.000 --> 00:00:00.000
 we don't need to use braces or commas as with the additional array.

00:00:00.000 --> 00:00:00.000
 We don't need to use this third style right here.

00:00:00.000 --> 00:00:00.000
 We can just do it by putting in the string itself.

00:00:00.000 --> 00:00:00.000
 Now the array that's created when we do this occupies six bytes, not five.

00:00:00.000 --> 00:00:00.000
 It has one byte for each of the characters, the "h" and the "e" and the "l" and the "l" and the "o."

00:00:00.000 --> 00:00:00.000
 That's followed by a binary zero, the zero character.

00:00:00.000 --> 00:00:00.000
 It's not the integer zero, it's the character with the ASCII value zero.

00:00:00.000 --> 00:00:00.000
 We call this the null terminator.

00:00:00.000 --> 00:00:00.000
 You notice I've spelled null with a single "l" there.

00:00:00.000 --> 00:00:00.000
 So null is the name of the character with the ASCII value zero.

00:00:00.000 --> 00:00:00.000
 If you look at an ASCII character set, let's go see if we can find one in our web browser here.

00:00:00.000 --> 00:00:00.000
 Let's look up ASCII table.

00:00:00.000 --> 00:00:00.000
 If we look up an ASCII table, you'll notice that these characters have names.

00:00:00.000 --> 00:00:00.000
 So the character that has the decimal value zero has the name "nul."

00:00:00.000 --> 00:00:00.000
 And so that was just the ASCII name for the character that had the value zero, the ASCII character zero.

00:00:00.000 --> 00:00:00.000
 Sometimes students get that confused with "null."

00:00:00.000 --> 00:00:00.000
 An "null" is something different.

00:00:00.000 --> 00:00:00.000
 It also has the value zero, but it's the C representation of a pointer with the value zero.

00:00:00.000 --> 00:00:00.000
 We actually don't use "null" in C++. We use "nullpointer" instead, which is an entirely different type.

00:00:00.000 --> 00:00:00.000
 Now, let's look at two examples of C-style strings.

00:00:00.000 --> 00:00:00.000
 Here's the one I just showed you, "pet1 = dog."

00:00:00.000 --> 00:00:00.000
 That is the equivalent to this.

00:00:00.000 --> 00:00:00.000
 "char pet1 [] =" and then embraces initializing the D, the O, the G.

00:00:00.000 --> 00:00:00.000
 And even though in this top one we don't see the null character, that null character is actually there.

00:00:00.000 --> 00:00:00.000
 So the memories are allocated for four characters in user space.

00:00:00.000 --> 00:00:00.000
 That means in your space that you can make a change to.

00:00:00.000 --> 00:00:00.000
 So "pet1" is, its type is an array of four characters.

00:00:00.000 --> 00:00:00.000
 It's a block of four characters, and if we created this in the static storage area,

00:00:00.000 --> 00:00:00.000
 in other words, outside any function, it would be in the static area.

00:00:00.000 --> 00:00:00.000
 If we created it on the stack, in other words, inside a function, it would be on the stack.

00:00:00.000 --> 00:00:00.000
 This is slightly different.

00:00:00.000 --> 00:00:00.000
 So "pet2" is a pointer. "pet2" is a pointer, and it points to the first character of an array of four characters.

00:00:00.000 --> 00:00:00.000
 So there is still a "cat" null character out there, but that "cat" null character is not stored in your space.

00:00:00.000 --> 00:00:00.000
 It's not stored on the stack. It's not stored on the static storage area.

00:00:00.000 --> 00:00:00.000
 It's stored in a section of read-only memory, a special part of the static storage area.

00:00:00.000 --> 00:00:00.000
 Now, in C, this is allowed. In C++, this is actually not really correct.

00:00:00.000 --> 00:00:00.000
 In C++, because this is stored in a read-only memory section, C++ said,

00:00:00.000 --> 00:00:00.000
 "Well, we should allow the compiler to know that, and so we should write it as const char*."

00:00:00.000 --> 00:00:00.000
 So in C++, if you write this, you'll probably get some kind of warning or error.

00:00:00.000 --> 00:00:00.000
 Now, notice that I can take this pointer, char*pet2=cat, and I can reassign it to "pet1."

00:00:00.000 --> 00:00:00.000
 I can say "pet2=pet1," because "pet2" is a pointer. That pointer can be changed, but I could not do the opposite.

00:00:00.000 --> 00:00:00.000
 I could not say "pet1=pet2." "pet1" is fixed.

00:00:00.000 --> 00:00:00.000
 It is a constant address of the first character here.

00:00:00.000 --> 00:00:00.000
 So the standard library inherited a collection of functions in the header called "cstring."

00:00:00.000 --> 00:00:00.000
 Now, C and older C++ implementations will use the header called "string.h."

00:00:00.000 --> 00:00:00.000
 All of the headers in C++ that start with "c," like "cstring," are inherited from the C language, and the C standard library.

00:00:00.000 --> 00:00:00.000
 So let's look first at how we find the size of a string, if we want to loop through it.

00:00:00.000 --> 00:00:00.000
 With a C++ string, like "a" here, we get the length by calling "a.length" or "a.size."

00:00:00.000 --> 00:00:00.000
 We call a member function because a C++ string is an object of a class.

00:00:00.000 --> 00:00:00.000
 "b" is a C string. In other words, it's an array of 1, 2, 3, 4, 5, 6, 7, 8 characters.

00:00:00.000 --> 00:00:00.000
 And it's stored in this array on the stack, in this case.

00:00:00.000 --> 00:00:00.000
 And we will get the size by passing the array "b" to a function called "strlen."

00:00:00.000 --> 00:00:00.000
 So "strlen" is in this header file "cstring."

00:00:00.000 --> 00:00:00.000
 Now, if we want to loop through the string, with a C string, we have to use the traditional "for" loop.

00:00:00.000 --> 00:00:00.000
 You'd have to do "i < len b."

00:00:00.000 --> 00:00:00.000
 With a C++ string, we can still do this, but we can do this as well.

00:00:00.000 --> 00:00:00.000
 You can't do this with a C-style string.

00:00:00.000 --> 00:00:00.000
 So, again, C strings and C++ strings are different kinds of things.

00:00:00.000 --> 00:00:00.000
 Now, to assign or copy a string in C++, you do it exactly the same way that an integer does.

00:00:00.000 --> 00:00:00.000
 You say "string a = hello."

00:00:00.000 --> 00:00:00.000
 And to make a copy of "a," you do "string b = a."

00:00:00.000 --> 00:00:00.000
 So that means that we have two copies of the word "hello."

00:00:00.000 --> 00:00:00.000
 How do we do that in C?

00:00:00.000 --> 00:00:00.000
 Well, in C, we have one string here.

00:00:00.000 --> 00:00:00.000
 Now, notice I'm using the second time, where I have a constant character.

00:00:00.000 --> 00:00:00.000
 And this is in read-only memory.

00:00:00.000 --> 00:00:00.000
 I have an array that I'm going to copy that into, "b."

00:00:00.000 --> 00:00:00.000
 I've allocated enough space to hold it.

00:00:00.000 --> 00:00:00.000
 And I'm going to call the function in C string called "strcpy."

00:00:00.000 --> 00:00:00.000
 S-T-R-C-P-Y.

00:00:00.000 --> 00:00:00.000
 And I'm going to copy into "b" this array all the characters from "a."

00:00:00.000 --> 00:00:00.000
 Now, how this works is the loop inside the function strcpy simply copies the first character into "b."

00:00:00.000 --> 00:00:00.000
 Then it copies the second character following that, the third character, the fourth character, the fifth character.

00:00:00.000 --> 00:00:00.000
 And then it copies the null character, and then it stops.

00:00:00.000 --> 00:00:00.000
 Now, because of that, you have to make sure that the destination, here "b" is the destination where we're going to put the characters,

00:00:00.000 --> 00:00:00.000
 has sufficient space to store all of the characters plus the null byte.

00:00:00.000 --> 00:00:00.000
 Let's look at string concatenation.

00:00:00.000 --> 00:00:00.000
 So C++ string concatenation works like this.

00:00:00.000 --> 00:00:00.000
 You create a string "a," and then you add "a" to another string, "beautiful" in this case, and we create another string.

00:00:00.000 --> 00:00:00.000
 So we have one string "a" that has "hello" in it, and "b" that has "hello, beautiful."

00:00:00.000 --> 00:00:00.000
 If we want to do the same thing in C, what we have to do is create the C string we're going to copy from.

00:00:00.000 --> 00:00:00.000
 We create the C string we're going to copy to, and initialize it with the value that we're starting with.

00:00:00.000 --> 00:00:00.000
 And then we use a function called "string cat," or "strcat."

00:00:00.000 --> 00:00:00.000
 So this is string concatenation.

00:00:00.000 --> 00:00:00.000
 And it will concatenate into "b."

00:00:00.000 --> 00:00:00.000
 Now here, it's going to do the same thing.

00:00:00.000 --> 00:00:00.000
 It's going to start copying from "a" into "b," but before it does that, it's going to loop all the way down here until it finds the null byte.

00:00:00.000 --> 00:00:00.000
 And so when it copies this space, it's going to overwrite the null byte here.

00:00:00.000 --> 00:00:00.000
 And then it's going to copy the "b" and the "e" and the "a" and the "t" and so forth until it gets to the null byte here.

00:00:00.000 --> 00:00:00.000
 It will copy there, and then "b" will contain "hello, beautiful."

00:00:00.000 --> 00:00:00.000
 Again, it's entirely up to you to make sure the destination, in this case "b," has sufficient space to store all the characters from "hello"

00:00:00.000 --> 00:00:00.000
 and all the characters from "beautiful" and the null byte at the end of it.

00:00:00.000 --> 00:00:00.000
 Now, for string comparison, with C++ strings, you treat them just like integers.

00:00:00.000 --> 00:00:00.000
 If string "a" is "hello" and "b" is something that's unknown, you just say if "a" equals equals "b," just like you would with integers.

00:00:00.000 --> 00:00:00.000
 If "a" is less than "b" to see if it appears before "b" in the dictionary.

00:00:00.000 --> 00:00:00.000
 If "a" is greater than "b" to see if it falls later than "a" in the dictionary.

00:00:00.000 --> 00:00:00.000
 In C, you cannot use the relational operators.

00:00:00.000 --> 00:00:00.000
 You could use the equals equals sign, but as we saw with arrays, using equals equals with arrays is legal.

00:00:00.000 --> 00:00:00.000
 In other words, it compiles, but it's stupid. It doesn't work.

00:00:00.000 --> 00:00:00.000
 So, if we have two C strings, "a" is "hello" and "b" is whatever,

00:00:00.000 --> 00:00:00.000
 then we call the function strcmp and pass "a" and "b" to it.

00:00:00.000 --> 00:00:00.000
 If "a" and "b" have the same characters in the same order, it returns zero. There is no difference.

00:00:00.000 --> 00:00:00.000
 If "a" would appear less than "b," or in other words, it would appear before "b" in the dictionary,

00:00:00.000 --> 00:00:00.000
 then it returns a number that is less than zero.

00:00:00.000 --> 00:00:00.000
 And if "a" would appear after "b" in the dictionary, it returns greater than zero.

00:00:00.000 --> 00:00:00.000
 Now, notice strcmp is not a predicate or Boolean function.

00:00:00.000 --> 00:00:00.000
 It doesn't return true and false. It returns three values, zero, less than zero, or greater than zero.

00:00:00.000 --> 00:00:00.000
 And so it's very common to forget that. It's a common bug to think that it is a Boolean function.

00:00:00.000 --> 00:00:00.000
 And of course, because of the way C++ works, it will take that zero or non-zero and turn it into true and false.

00:00:00.000 --> 00:00:00.000
 You generally will not get the answer that you expect.

00:00:00.000 --> 00:00:00.000
 So remember when you call strcmp to test the value that's returned from strcmp.

00:00:00.000 --> 00:00:00.000
 Okay, so let's go ahead and open our first exercise.

00:00:00.000 --> 00:00:00.000
 This is a function called mincat.

00:00:00.000 --> 00:00:00.000
 We're going to use the standard C-string functions to write a function that concatenates two C-string literals.

00:00:00.000 --> 00:00:00.000
 So s1 and s2 are the two strings.

00:00:00.000 --> 00:00:00.000
 Out is an array of characters where the answer goes.

00:00:00.000 --> 00:00:00.000
 Now remember, we cannot return arrays, so we could not return a C-string.

00:00:00.000 --> 00:00:00.000
 So this is an output parameter.

00:00:00.000 --> 00:00:00.000
 Maxlen is the size of the output array.

00:00:00.000 --> 00:00:00.000
 And so we have to make sure that we don't overstep the size of that.

00:00:00.000 --> 00:00:00.000
 So here's how we're going to do that.

00:00:00.000 --> 00:00:00.000
 We're going to find the length of the shorter string and put it in the variable called len.

00:00:00.000 --> 00:00:00.000
 Then when we concatenate, we're going to concatenate only the last len characters from the longer string.

00:00:00.000 --> 00:00:00.000
 So in the problem you'll see several examples.

00:00:00.000 --> 00:00:00.000
 So let's switch over to our IDE here.

00:00:00.000 --> 00:00:00.000
 And I've already opened ic22a mincat.cpp.

00:00:00.000 --> 00:00:00.000
 I'm going to move that down a little bit and we'll look at it.

00:00:00.000 --> 00:00:00.000
 So we're going to write a function named mincat.

00:00:00.000 --> 00:00:00.000
 We're going to be given two C-string literals.

00:00:00.000 --> 00:00:00.000
 We're going to append them together.

00:00:00.000 --> 00:00:00.000
 And we're going to return the results in the third argument, a non-constant array of char.

00:00:00.000 --> 00:00:00.000
 The fourth parameter is the size of the array.

00:00:00.000 --> 00:00:00.000
 If the input strings are different lengths, then we'll omit the leading characters from the longer string

00:00:00.000 --> 00:00:00.000
 so it's the same length as the shorter string.

00:00:00.000 --> 00:00:00.000
 So if we try to concatenate "hello" and "hi", the shorter string has only two characters.

00:00:00.000 --> 00:00:00.000
 And so we're only going to use the two last characters from "hello".

00:00:00.000 --> 00:00:00.000
 And so that will concatenate as "low" and "hi".

00:00:00.000 --> 00:00:00.000
 Now the strings can be of any length.

00:00:00.000 --> 00:00:00.000
 Now if the combined string output is larger than the space available,

00:00:00.000 --> 00:00:00.000
 then we're going to divide the available space in half, after leaving room for the terminator of course,

00:00:00.000 --> 00:00:00.000
 and concatenate the last n characters from each string.

00:00:00.000 --> 00:00:00.000
 So we're going to use the functions from the C-string header.

00:00:00.000 --> 00:00:00.000
 We're not going to use any of the C++ string library.

00:00:00.000 --> 00:00:00.000
 So let's write that here.

00:00:00.000 --> 00:00:00.000
 Now notice it's not going to return anything as a function.

00:00:00.000 --> 00:00:00.000
 It's going to be really a procedure.

00:00:00.000 --> 00:00:00.000
 So we're going to call it "mincat".

00:00:00.000 --> 00:00:00.000
 It's going to take a const char * s1, const char * s2,

00:00:00.000 --> 00:00:00.000
 a char out that is going to have, we don't know how many lengths,

00:00:00.000 --> 00:00:00.000
 and a size t for max length.

00:00:00.000 --> 00:00:00.000
 Okay, so that's all we need to do to stub that out.

00:00:00.000 --> 00:00:00.000
 Let's open a terminal on that window by right clicking and open an integrated terminal.

00:00:00.000 --> 00:00:00.000
 And then let's just do "make" to make sure that it compiles.

00:00:00.000 --> 00:00:00.000
 It should, right? We haven't really done anything other than put in the parameters and everything.

00:00:00.000 --> 00:00:00.000
 Okay, so I need to know the lengths of these.

00:00:00.000 --> 00:00:00.000
 How do I find the length of s1 and s2?

00:00:00.000 --> 00:00:00.000
 So I'm going to say

00:00:00.000 --> 00:00:00.000
 size t, or int if you want,

00:00:00.000 --> 00:00:00.000
 len1 = strlen s1.

00:00:00.000 --> 00:00:00.000
 So call the function strlen.

00:00:00.000 --> 00:00:00.000
 So size t, len2 = strlen s2.

00:00:00.000 --> 00:00:00.000
 Now I need to create the length that's going to be the shorter of it.

00:00:00.000 --> 00:00:00.000
 So size t, len =

00:00:00.000 --> 00:00:00.000
 and here I'm going to use the conditional operator.

00:00:00.000 --> 00:00:00.000
 So len1 < len2

00:00:00.000 --> 00:00:00.000
 question mark, I'm going to use len1.

00:00:00.000 --> 00:00:00.000
 Otherwise I'm going to use len2.

00:00:00.000 --> 00:00:00.000
 You could use an if statement, but it would be a little bit longer and take a little bit more time.

00:00:00.000 --> 00:00:00.000
 Now, what we want to do

00:00:00.000 --> 00:00:00.000
 is we want to concatenate into out

00:00:00.000 --> 00:00:00.000
 s1 and s2

00:00:00.000 --> 00:00:00.000
 but only the len characters.

00:00:00.000 --> 00:00:00.000
 So we're going to say str

00:00:00.000 --> 00:00:00.000
 the last len characters.

00:00:00.000 --> 00:00:00.000
 So we're going to say strcopy

00:00:00.000 --> 00:00:00.000
 our first thing.

00:00:00.000 --> 00:00:00.000
 We're going to copy into out.

00:00:00.000 --> 00:00:00.000
 We're going to take len

00:00:00.000 --> 00:00:00.000
 s1

00:00:00.000 --> 00:00:00.000
 plus len1.

00:00:00.000 --> 00:00:00.000
 Now remember s1 is a pointer.

00:00:00.000 --> 00:00:00.000
 It's an address.

00:00:00.000 --> 00:00:00.000
 We add len1 to it and what are we pointing to?

00:00:00.000 --> 00:00:00.000
 We're pointing to the null byte in s2.

00:00:00.000 --> 00:00:00.000
 Now if I subtract len from that

00:00:00.000 --> 00:00:00.000
 what I have is the number of characters

00:00:00.000 --> 00:00:00.000
 for the first item.

00:00:00.000 --> 00:00:00.000
 Now I'm going to concatenate s2.

00:00:00.000 --> 00:00:00.000
 So I'm going to say strcap

00:00:00.000 --> 00:00:00.000
 not strcopy. I'm going to concatenate into out.

00:00:00.000 --> 00:00:00.000
 I'm going to copy s2

00:00:00.000 --> 00:00:00.000
 plus len2.

00:00:00.000 --> 00:00:00.000
 So move that pointer down to the end

00:00:00.000 --> 00:00:00.000
 and remove it back, len characters.

00:00:00.000 --> 00:00:00.000
 Okay, let's go ahead and try that.

00:00:00.000 --> 00:00:00.000
 Let's do make test.

00:00:00.000 --> 00:00:00.000
 And it looks like it worked except for three of them.

00:00:00.000 --> 00:00:00.000
 And that is because this only has five characters available.

00:00:00.000 --> 00:00:00.000
 So it works fine if we have an unlimited number of characters

00:00:00.000 --> 00:00:00.000
 available in the answer or out parameter.

00:00:00.000 --> 00:00:00.000
 But if we don't have an unlimited number of characters

00:00:00.000 --> 00:00:00.000
 we have a problem.

00:00:00.000 --> 00:00:00.000
 So we haven't done this second part here.

00:00:00.000 --> 00:00:00.000
 We haven't done this part right here if the combined output

00:00:00.000 --> 00:00:00.000
 is larger than the space available.

00:00:00.000 --> 00:00:00.000
 So let's do that right here.

00:00:00.000 --> 00:00:00.000
 We'll say if

00:00:00.000 --> 00:00:00.000
 if len times two

00:00:00.000 --> 00:00:00.000
 is greater than

00:00:00.000 --> 00:00:00.000
 maxlen plus one

00:00:00.000 --> 00:00:00.000
 that means it won't fit, right?

00:00:00.000 --> 00:00:00.000
 And if that's the case we have to set len

00:00:00.000 --> 00:00:00.000
 equal to maxlen

00:00:00.000 --> 00:00:00.000
 minus one. So allow to the null byte

00:00:00.000 --> 00:00:00.000
 divided by two. So each character, each string can only use

00:00:00.000 --> 00:00:00.000
 that amount of space.

00:00:00.000 --> 00:00:00.000
 Okay, let's try it again.

00:00:00.000 --> 00:00:00.000
 Let's clear that with control L and do make test.

00:00:00.000 --> 00:00:00.000
 And we got all of them working correctly.

00:00:00.000 --> 00:00:00.000
 I'm going to show you in a second something else about C style strings.

00:00:00.000 --> 00:00:00.000
 Many people say, well, you know, this is all good and fine

00:00:00.000 --> 00:00:00.000
 but why would I want to do this when I already have the C++ string class?

00:00:00.000 --> 00:00:00.000
 What can I do with this that I can't do with the C++ string class?

00:00:00.000 --> 00:00:00.000
 Well, the reason that we want to learn to use the C

00:00:00.000 --> 00:00:00.000
 string type in addition to the C++ string type

00:00:00.000 --> 00:00:00.000
 is because we want to interact with things like

00:00:00.000 --> 00:00:00.000
 the operating system. So all operating systems

00:00:00.000 --> 00:00:00.000
 from the newest, Mac OS X, Windows,

00:00:00.000 --> 00:00:00.000
 Linux, all of them are written in the C language.

00:00:00.000 --> 00:00:00.000
 And if you want to talk to the operating system,

00:00:00.000 --> 00:00:00.000
 if you want to write a Windows program, you must use

00:00:00.000 --> 00:00:00.000
 the C programming language to do that. Or some other

00:00:00.000 --> 00:00:00.000
 higher level language that translates it to C for you, like C#.

00:00:00.000 --> 00:00:00.000
 So let's look at something in B here.

00:00:00.000 --> 00:00:00.000
 PNV

00:00:00.000 --> 00:00:00.000
 and let's bring that down there, that's too high.

00:00:00.000 --> 00:00:00.000
 And let's open a terminal on B.

00:00:00.000 --> 00:00:00.000
 Open an integrated terminal so we have a fresh terminal down there. I can close the other ones.

00:00:00.000 --> 00:00:00.000
 And what we want to do

00:00:00.000 --> 00:00:00.000
 is in the operating system, this is true for Windows,

00:00:00.000 --> 00:00:00.000
 for the Mac, for Linux of course, which we're working on,

00:00:00.000 --> 00:00:00.000
 variables that are used among

00:00:00.000 --> 00:00:00.000
 different programs can be set in an area of memory called the environment.

00:00:00.000 --> 00:00:00.000
 So this is not global inside your program, it's global

00:00:00.000 --> 00:00:00.000
 outside your program. So for instance, if I want to know

00:00:00.000 --> 00:00:00.000
 actually I'll just show you what all the variables are.

00:00:00.000 --> 00:00:00.000
 So if I do printenv in Unix,

00:00:00.000 --> 00:00:00.000
 in Windows the command would just be set and hit enter,

00:00:00.000 --> 00:00:00.000
 it goes and it prints a list of those variables

00:00:00.000 --> 00:00:00.000
 and tells me what the values of those variables are.

00:00:00.000 --> 00:00:00.000
 So notice that there's a variable called githubapiurl.

00:00:00.000 --> 00:00:00.000
 There's a variable called workdeer.

00:00:00.000 --> 00:00:00.000
 There's a variable called gemhome and so forth.

00:00:00.000 --> 00:00:00.000
 And so these variables are set into

00:00:00.000 --> 00:00:00.000
 the environment. We set several of these variables when we configured

00:00:00.000 --> 00:00:00.000
 our IDE. Remember when you configure your IDE

00:00:00.000 --> 00:00:00.000
 or when you reset your IDE,

00:00:00.000 --> 00:00:00.000
 it will set things like your CS150 username

00:00:00.000 --> 00:00:00.000
 and so forth. Those are in the environment.

00:00:00.000 --> 00:00:00.000
 Well this command printenv is just a program

00:00:00.000 --> 00:00:00.000
 and it's a program that reads a global array

00:00:00.000 --> 00:00:00.000
 of character pointers and so that is written

00:00:00.000 --> 00:00:00.000
 as char star

00:00:00.000 --> 00:00:00.000
 a bracket or environ bracket

00:00:00.000 --> 00:00:00.000
 or we can write it as using simply two stars like that.

00:00:00.000 --> 00:00:00.000
 And so we are going to write a program

00:00:00.000 --> 00:00:00.000
 that does the same thing as this. And I want to show you how easy this is to do

00:00:00.000 --> 00:00:00.000
 but you have to know about C style strings.

00:00:00.000 --> 00:00:00.000
 So this variable is declared

00:00:00.000 --> 00:00:00.000
 in the operating system, is defined in the operating system

00:00:00.000 --> 00:00:00.000
 and we want to use it in our program.

00:00:00.000 --> 00:00:00.000
 So how do you use a variable in one program

00:00:00.000 --> 00:00:00.000
 that's declared in another or defined in another? You make it

00:00:00.000 --> 00:00:00.000
 external. So we're going to declare this variable.

00:00:00.000 --> 00:00:00.000
 We're not going to define it. We're going to say extern

00:00:00.000 --> 00:00:00.000
 char star star environment.

00:00:00.000 --> 00:00:00.000
 So now we can use that variable.

00:00:00.000 --> 00:00:00.000
 That variable has been declared or defined elsewhere.

00:00:00.000 --> 00:00:00.000
 We have declared it in our program and so we can use that

00:00:00.000 --> 00:00:00.000
 to connect to the operating system.

00:00:00.000 --> 00:00:00.000
 So if I dereference environment

00:00:00.000 --> 00:00:00.000
 what I get is a pointer to a character.

00:00:00.000 --> 00:00:00.000
 In other words what I get is a C style string.

00:00:00.000 --> 00:00:00.000
 And so what I want to say

00:00:00.000 --> 00:00:00.000
 is while

00:00:00.000 --> 00:00:00.000
 actually I want to create a variable. I'll call it p.

00:00:00.000 --> 00:00:00.000
 So auto p equals

00:00:00.000 --> 00:00:00.000
 environment.

00:00:00.000 --> 00:00:00.000
 In other words I don't want to change

00:00:00.000 --> 00:00:00.000
 environment.

00:00:00.000 --> 00:00:00.000
 And you might wonder why don't you put const there if you don't want to change it.

00:00:00.000 --> 00:00:00.000
 That's because in C, which the operating system was written in,

00:00:00.000 --> 00:00:00.000
 they didn't have const. They didn't use const like that.

00:00:00.000 --> 00:00:00.000
 So we're going to say auto p equals environment

00:00:00.000 --> 00:00:00.000
 while star p

00:00:00.000 --> 00:00:00.000
 while

00:00:00.000 --> 00:00:00.000
 while star p is not equal to the null pointer

00:00:00.000 --> 00:00:00.000
 we're going to print out

00:00:00.000 --> 00:00:00.000
 that variable.

00:00:00.000 --> 00:00:00.000
 Okay now this actually won't quite work

00:00:00.000 --> 00:00:00.000
 correctly. If you notice the end of this it tells us

00:00:00.000 --> 00:00:00.000
 the name of the program. This environmental variable underscore

00:00:00.000 --> 00:00:00.000
 is the name of the program we're actually running.

00:00:00.000 --> 00:00:00.000
 So we're going to compile this. The name is p_env

00:00:00.000 --> 00:00:00.000
 So we're going to say make p_env

00:00:00.000 --> 00:00:00.000
 and then we're going to run

00:00:00.000 --> 00:00:00.000
 p_env dash p_env

00:00:00.000 --> 00:00:00.000
 and we did not get what we wanted

00:00:00.000 --> 00:00:00.000
 oops, let me control c to stop it. Ah!

00:00:00.000 --> 00:00:00.000
 It crashed. So what did I forget here? I forgot the fact

00:00:00.000 --> 00:00:00.000
 that the first time we're going to be pointing to the first string but we're going to continue

00:00:00.000 --> 00:00:00.000
 to be pointing to the same string each time. So we have an endless loop

00:00:00.000 --> 00:00:00.000
 that is just pointing to the first environmental variable and

00:00:00.000 --> 00:00:00.000
 printing it over and over and over again. So

00:00:00.000 --> 00:00:00.000
 to go to the next one, what do we have to do? We have to increment the

00:00:00.000 --> 00:00:00.000
 pointer. Okay, let's build that

00:00:00.000 --> 00:00:00.000
 again

00:00:00.000 --> 00:00:00.000
 and let's run it again.

00:00:00.000 --> 00:00:00.000
 Okay, so now notice we got exactly

00:00:00.000 --> 00:00:00.000
 the same thing we had before.

00:00:00.000 --> 00:00:00.000
 My github user is sgilbertstudent

00:00:00.000 --> 00:00:00.000
 and so we have written

00:00:00.000 --> 00:00:00.000
 a program that has exactly the

00:00:00.000 --> 00:00:00.000
 same output as a

00:00:00.000 --> 00:00:00.000
 built in piece of code.

00:00:00.000 --> 00:00:00.000
 We couldn't do this with C++ strings

00:00:00.000 --> 00:00:00.000
 you have to use C style strings and pointers

00:00:00.000 --> 00:00:00.000
 to do this.

00:00:00.000 --> 00:00:00.000
 Now to process

00:00:00.000 --> 00:00:00.000
 C style strings, what you do is you treat them

00:00:00.000 --> 00:00:00.000
 exactly like an array, except

00:00:00.000 --> 00:00:00.000
 you're not worried about the length of it. You assume that there's a

00:00:00.000 --> 00:00:00.000
 terminating null character in the array. And so

00:00:00.000 --> 00:00:00.000
 instead of counter controlled loops, we're going to use a sentinel

00:00:00.000 --> 00:00:00.000
 loop, like this example of the strlen function.

00:00:00.000 --> 00:00:00.000
 So strlen here is returning an int, the actual version

00:00:00.000 --> 00:00:00.000
 of strlen returns a size T. And it's

00:00:00.000 --> 00:00:00.000
 going to create a counter i, and while

00:00:00.000 --> 00:00:00.000
 s at i is not equal to the null character, it's

00:00:00.000 --> 00:00:00.000
 going to increment i. At the end of that, i will have

00:00:00.000 --> 00:00:00.000
 the count of the number of characters in the

00:00:00.000 --> 00:00:00.000
 string. So the traditional C library string functions

00:00:00.000 --> 00:00:00.000
 all depend on that null character at the end

00:00:00.000 --> 00:00:00.000
 of the string. Now you can write your

00:00:00.000 --> 00:00:00.000
 code using array syntax. There's no loss of

00:00:00.000 --> 00:00:00.000
 efficiency, if you're more comfortable with that it's perfectly fine, but

00:00:00.000 --> 00:00:00.000
 it's more common to use pointer syntax. So here's a version

00:00:00.000 --> 00:00:00.000
 of strlen that uses pointer syntax. Notice

00:00:00.000 --> 00:00:00.000
 s is a const char star, or a pointer

00:00:00.000 --> 00:00:00.000
 to a const character. We have length, and

00:00:00.000 --> 00:00:00.000
 while star s is not equal to the null byte,

00:00:00.000 --> 00:00:00.000
 we dereference the pointer s, it's not equal to the null byte,

00:00:00.000 --> 00:00:00.000
 we increment s to go to the next character,

00:00:00.000 --> 00:00:00.000
 and we also increment the length. So we get a pointer

00:00:00.000 --> 00:00:00.000
 to a constant character, while s doesn't point to the terminating null

00:00:00.000 --> 00:00:00.000
 byte, we move s and we count the character.

00:00:00.000 --> 00:00:00.000
 So this is much more common to use pointers

00:00:00.000 --> 00:00:00.000
 with C style strings than it is with arrays. As I

00:00:00.000 --> 00:00:00.000
 mentioned though, there is no loss of efficiency if you use

00:00:00.000 --> 00:00:00.000
 array syntax. So if you're more comfortable with that, you're perfectly

00:00:00.000 --> 00:00:00.000
 fine using that.

00:00:00.000 --> 00:00:00.000
 Now, it's also very common to use a much more

00:00:00.000 --> 00:00:00.000
 concise syntax when processing C strings

00:00:00.000 --> 00:00:00.000
 with pointers. So notice this just has three lines,

00:00:00.000 --> 00:00:00.000
 the length is zero, while star s plus plus

00:00:00.000 --> 00:00:00.000
 len plus plus return len. So this is

00:00:00.000 --> 00:00:00.000
 a very, very common C string idiom.

00:00:00.000 --> 00:00:00.000
 You should recognize it and understand it. I don't necessarily encourage you to

00:00:00.000 --> 00:00:00.000
 write this kind of code. It is no more efficient than the

00:00:00.000 --> 00:00:00.000
 more understandable code on the previous page. It just took

00:00:00.000 --> 00:00:00.000
 a little bit of fewer typing. So let me just go

00:00:00.000 --> 00:00:00.000
 through why that works so you understand it.

00:00:00.000 --> 00:00:00.000
 So star s will dereference the pointer

00:00:00.000 --> 00:00:00.000
 s. Dereference the pointer s. However

00:00:00.000 --> 00:00:00.000
 this is not star s, it's star s plus plus.

00:00:00.000 --> 00:00:00.000
 And so plus plus and

00:00:00.000 --> 00:00:00.000
 star have the same precedence.

00:00:00.000 --> 00:00:00.000
 So the s has to know whether to do the plus plus first or the

00:00:00.000 --> 00:00:00.000
 star first. And because the precedence is the

00:00:00.000 --> 00:00:00.000
 same, that won't help it decide. And so it has to fall

00:00:00.000 --> 00:00:00.000
 back on what we call the tiebreaker rule, associativity, and

00:00:00.000 --> 00:00:00.000
 decide does this go left to right, star s, and then

00:00:00.000 --> 00:00:00.000
 increment it, which would mean incrementing the value

00:00:00.000 --> 00:00:00.000
 that was at s, or does it mean plus plus s

00:00:00.000 --> 00:00:00.000
 and then dereference the plus plus s.

00:00:00.000 --> 00:00:00.000
 And these are right associative.

00:00:00.000 --> 00:00:00.000
 Most operators, arithmetic operators, are less

00:00:00.000 --> 00:00:00.000
 associated. These are right associative, so the plus plus goes first

00:00:00.000 --> 00:00:00.000
 with the tiebreaker rule. Now the value

00:00:00.000 --> 00:00:00.000
 returned from s plus plus is not

00:00:00.000 --> 00:00:00.000
 the pointer s after it's been changed

00:00:00.000 --> 00:00:00.000
 it's the pointer s before it's changed, because

00:00:00.000 --> 00:00:00.000
 this is post-increment. So we take the value

00:00:00.000 --> 00:00:00.000
 that s had before it was changed, we change s

00:00:00.000 --> 00:00:00.000
 move it to the second character, return the value of s

00:00:00.000 --> 00:00:00.000
 that it had before it was changed, dereference that

00:00:00.000 --> 00:00:00.000
 and if that is not the null character

00:00:00.000 --> 00:00:00.000
 if it's the null character, this is false. If it

00:00:00.000 --> 00:00:00.000
 is the null character, then we increment

00:00:00.000 --> 00:00:00.000
 length, and finally we return length. So this stops

00:00:00.000 --> 00:00:00.000
 when it dereferences the null character.

00:00:00.000 --> 00:00:00.000
 Now again, if we look at the previous

00:00:00.000 --> 00:00:00.000
 example, here we're explicitly saying

00:00:00.000 --> 00:00:00.000
 while star s is not equal to the null character. Here

00:00:00.000 --> 00:00:00.000
 we're implicitly saying that. And so I think it's

00:00:00.000 --> 00:00:00.000
 better always to be explicit. I would prefer that you write code that is

00:00:00.000 --> 00:00:00.000
 a little clearer and easier to understand. But if you don't understand

00:00:00.000 --> 00:00:00.000
 what this does, when you actually read C code, and you

00:00:00.000 --> 00:00:00.000
 see this very common idiom, you'll be confused.

00:00:00.000 --> 00:00:00.000
 Okay, so we are going

00:00:00.000 --> 00:00:00.000
 to finish up this lecture by looking at

00:00:00.000 --> 00:00:00.000
 an example. This is from the online

00:00:00.000 --> 00:00:00.000
 C-String practice problems in, not coding

00:00:00.000 --> 00:00:00.000
 bat, in Code Step-by-Step. There's

00:00:00.000 --> 00:00:00.000
 a link on the home page. But the online version wants to use

00:00:00.000 --> 00:00:00.000
 the library functions. The version we're going to use is not going to use any

00:00:00.000 --> 00:00:00.000
 library function. It's very similar to what you'll be asked to do for

00:00:00.000 --> 00:00:00.000
 PEO8. So we're going to open

00:00:00.000 --> 00:00:00.000
 countmatches.cpp. We're going to look through an array

00:00:00.000 --> 00:00:00.000
 of C-style strings, just like we did with PN.

00:00:00.000 --> 00:00:00.000
 We're going to count the number of strings that contain the first string.

00:00:00.000 --> 00:00:00.000
 And so this is the really tricky part right here that you need to learn

00:00:00.000 --> 00:00:00.000
 to understand to do well on PEO8. How do

00:00:00.000 --> 00:00:00.000
 you see if one string is contained inside another

00:00:00.000 --> 00:00:00.000
 string? So I'm going to solve it two ways. I'm going to solve it first using

00:00:00.000 --> 00:00:00.000
 array notation, and then I'll do it using pointer notation.

00:00:00.000 --> 00:00:00.000
 It's a little easier actually with pointer notation, I think.

00:00:00.000 --> 00:00:00.000
 But you may prefer it with array notation.

00:00:00.000 --> 00:00:00.000
 So let's pop that up. Let's go ahead and

00:00:00.000 --> 00:00:00.000
 close the things we had previously.

00:00:00.000 --> 00:00:00.000
 [typing]

00:00:00.000 --> 00:00:00.000
 [typing]

00:00:00.000 --> 00:00:00.000
 Okay, so

00:00:00.000 --> 00:00:00.000
 countmatches.cpp. Let's close those

00:00:00.000 --> 00:00:00.000
 two and let's open a shell on that one.

00:00:00.000 --> 00:00:00.000
 Yes, we have a shell open on C.

00:00:00.000 --> 00:00:00.000
 Okay, now notice

00:00:00.000 --> 00:00:00.000
 I'm going to put my name inside here.

00:00:00.000 --> 00:00:00.000
 You can put your name and section and date at the top

00:00:00.000 --> 00:00:00.000
 if you want. You don't have to, but this is the one that is important. So we're writing

00:00:00.000 --> 00:00:00.000
 a function called countmatches, and it accepts a string

00:00:00.000 --> 00:00:00.000
 to match, a const char char, an array of characters. So you can

00:00:00.000 --> 00:00:00.000
 really see it here. That's how it's called.

00:00:00.000 --> 00:00:00.000
 So if we know that, we know what to write here. And it's going to return the number

00:00:00.000 --> 00:00:00.000
 of times that it matches. So we'll say int countmatches

00:00:00.000 --> 00:00:00.000
 const char

00:00:00.000 --> 00:00:00.000
 star str

00:00:00.000 --> 00:00:00.000
 str

00:00:00.000 --> 00:00:00.000
 Let's call that, it has it as strs

00:00:00.000 --> 00:00:00.000
 up there, but let's call this one arrays.

00:00:00.000 --> 00:00:00.000
 So

00:00:00.000 --> 00:00:00.000
 that's our

00:00:00.000 --> 00:00:00.000
 array.

00:00:00.000 --> 00:00:00.000
 And then we're going to have a size T.

00:00:00.000 --> 00:00:00.000
 This is the length

00:00:00.000 --> 00:00:00.000
 of the array.

00:00:00.000 --> 00:00:00.000
 So that's pretty easy to loop through this array.

00:00:00.000 --> 00:00:00.000
 So let's go ahead and run this.

00:00:00.000 --> 00:00:00.000
 So we'll go for size

00:00:00.000 --> 00:00:00.000
 T, i = 0

00:00:00.000 --> 00:00:00.000
 i < n++i

00:00:00.000 --> 00:00:00.000
 And then what we want is

00:00:00.000 --> 00:00:00.000
 arr sub i and see if it contains the string.

00:00:00.000 --> 00:00:00.000
 Now instead of actually doing that,

00:00:00.000 --> 00:00:00.000
 I'm going to write a function. So I'm going to write my function

00:00:00.000 --> 00:00:00.000
 right up here, because the function is the guts of what we want.

00:00:00.000 --> 00:00:00.000
 So I'm going to say if

00:00:00.000 --> 00:00:00.000
 if contains

00:00:00.000 --> 00:00:00.000
 arr sub i

00:00:00.000 --> 00:00:00.000
 str

00:00:00.000 --> 00:00:00.000
 Here's what I want to write.

00:00:00.000 --> 00:00:00.000
 if arr

00:00:00.000 --> 00:00:00.000
 i contains str

00:00:00.000 --> 00:00:00.000
 So figuring out how to put that in a function is

00:00:00.000 --> 00:00:00.000
 hard.

00:00:00.000 --> 00:00:00.000
 Or is in

00:00:00.000 --> 00:00:00.000
 if is in

00:00:00.000 --> 00:00:00.000
 contains is nicer.

00:00:00.000 --> 00:00:00.000
 It's hard to know whether to put the arr first or the string,

00:00:00.000 --> 00:00:00.000
 but I would want to say if arr i contains the string,

00:00:00.000 --> 00:00:00.000
 then what I want to do is update my result.

00:00:00.000 --> 00:00:00.000
 So result++

00:00:00.000 --> 00:00:00.000
 Of course we haven't created our result, so int result

00:00:00.000 --> 00:00:00.000
 equals 0

00:00:00.000 --> 00:00:00.000
 and return result

00:00:00.000 --> 00:00:00.000
 So that's simple enough that that looks like it should work okay.

00:00:00.000 --> 00:00:00.000
 So the hard part of this is figuring out how to write

00:00:00.000 --> 00:00:00.000
 contains. So we're going to have

00:00:00.000 --> 00:00:00.000
 two strings. It's going to be a boolean

00:00:00.000 --> 00:00:00.000
 contains const char

00:00:00.000 --> 00:00:00.000
 star s1 and const

00:00:00.000 --> 00:00:00.000
 char star s2

00:00:00.000 --> 00:00:00.000
 and let's just return

00:00:00.000 --> 00:00:00.000
 false here.

00:00:00.000 --> 00:00:00.000
 And if we find it, we'll return true.

00:00:00.000 --> 00:00:00.000
 Okay, so we actually have enough here. We have enough to

00:00:00.000 --> 00:00:00.000
 stub it. We've stubbed it out. And so we can try it. So we can say

00:00:00.000 --> 00:00:00.000
 make test

00:00:00.000 --> 00:00:00.000
 and we see none of those

00:00:00.000 --> 00:00:00.000
 fail because it returns 0 in each case, right? It doesn't find any.

00:00:00.000 --> 00:00:00.000
 And so now

00:00:00.000 --> 00:00:00.000
 we're ready to think about contains. So contains

00:00:00.000 --> 00:00:00.000
 is going to be arr sub i and if we look at

00:00:00.000 --> 00:00:00.000
 this example right here, we'll see arr sub i is going to be

00:00:00.000 --> 00:00:00.000
 rainbow. So does rainbow contain o?

00:00:00.000 --> 00:00:00.000
 It does. So

00:00:00.000 --> 00:00:00.000
 imagine, and I said I was going to

00:00:00.000 --> 00:00:00.000
 do this two ways, right? I was going to do it with an array

00:00:00.000 --> 00:00:00.000
 and a string and so

00:00:00.000 --> 00:00:00.000
 let's do it first with an array.

00:00:00.000 --> 00:00:00.000
 Okay, so

00:00:00.000 --> 00:00:00.000
 we need to have a couple of variables.

00:00:00.000 --> 00:00:00.000
 One variable is going to go through s1.

00:00:00.000 --> 00:00:00.000
 So I'm going to do size t for these.

00:00:00.000 --> 00:00:00.000
 You can do int. It's fine.

00:00:00.000 --> 00:00:00.000
 And I'll call that i1.

00:00:00.000 --> 00:00:00.000
 And so we're going to say while

00:00:00.000 --> 00:00:00.000
 s1

00:00:00.000 --> 00:00:00.000
 at i1 is not equal to the

00:00:00.000 --> 00:00:00.000
 null character

00:00:00.000 --> 00:00:00.000
 i1++

00:00:00.000 --> 00:00:00.000
 That will walk us

00:00:00.000 --> 00:00:00.000
 through this string. That will walk us through this string.

00:00:00.000 --> 00:00:00.000
 Now we want to

00:00:00.000 --> 00:00:00.000
 at each point in here, we want to see if

00:00:00.000 --> 00:00:00.000
 s2 is at that point. So we're going to create

00:00:00.000 --> 00:00:00.000
 another variable, i2.

00:00:00.000 --> 00:00:00.000
 So size p i2

00:00:00.000 --> 00:00:00.000
 and we're going to say

00:00:00.000 --> 00:00:00.000
 while

00:00:00.000 --> 00:00:00.000
 s2

00:00:00.000 --> 00:00:00.000
 i2

00:00:00.000 --> 00:00:00.000
 is equal to

00:00:00.000 --> 00:00:00.000
 s1

00:00:00.000 --> 00:00:00.000
 i1

00:00:00.000 --> 00:00:00.000
 plus i2

00:00:00.000 --> 00:00:00.000
 because we're going to have to look at the first character here

00:00:00.000 --> 00:00:00.000
 the first character here, the second character here

00:00:00.000 --> 00:00:00.000
 the second character here, and so we're going to have to offset s1

00:00:00.000 --> 00:00:00.000
 by not only its index, but the index

00:00:00.000 --> 00:00:00.000
 of the second character.

00:00:00.000 --> 00:00:00.000
 So while those are the same

00:00:00.000 --> 00:00:00.000
 and s2

00:00:00.000 --> 00:00:00.000
 i2 is not equal to

00:00:00.000 --> 00:00:00.000
 the null character and

00:00:00.000 --> 00:00:00.000
 s1 i1 plus i2

00:00:00.000 --> 00:00:00.000
 is not equal to the

00:00:00.000 --> 00:00:00.000
 null character

00:00:00.000 --> 00:00:00.000
 we're going to increment i2

00:00:00.000 --> 00:00:00.000
 i2++

00:00:00.000 --> 00:00:00.000
 That means that at some point

00:00:00.000 --> 00:00:00.000
 we're either going to read all of s2

00:00:00.000 --> 00:00:00.000
 and this is going to fail or

00:00:00.000 --> 00:00:00.000
 the characters are not going to match

00:00:00.000 --> 00:00:00.000
 like that will immediately not match when we try to compare the o here to the r there

00:00:00.000 --> 00:00:00.000
 will drop out. So after we drop out

00:00:00.000 --> 00:00:00.000
 in other words this while loop is guaranteed to drop out

00:00:00.000 --> 00:00:00.000
 it's guaranteed to drop out

00:00:00.000 --> 00:00:00.000
 and after we drop out, if we are looking at the null

00:00:00.000 --> 00:00:00.000
 character after the end of this ow

00:00:00.000 --> 00:00:00.000
 in other words if

00:00:00.000 --> 00:00:00.000
 s2 i2 is equal to the null character

00:00:00.000 --> 00:00:00.000
 then we have found our character. So if

00:00:00.000 --> 00:00:00.000
 s2 sub i2

00:00:00.000 --> 00:00:00.000
 equals the null character

00:00:00.000 --> 00:00:00.000
 then

00:00:00.000 --> 00:00:00.000
 got a parenthesis in the wrong place there

00:00:00.000 --> 00:00:00.000
 then we're just going to return true

00:00:00.000 --> 00:00:00.000
 ok so this is doing contains

00:00:00.000 --> 00:00:00.000
 now we have actually one problem here and you'll see it here

00:00:00.000 --> 00:00:00.000
 in a minute. It actually works for most of the

00:00:00.000 --> 00:00:00.000
 characters but not for all of them. So we'll go make tests

00:00:00.000 --> 00:00:00.000
 and you can see it doesn't work for this one

00:00:00.000 --> 00:00:00.000
 and this one. So what is s2

00:00:00.000 --> 00:00:00.000
 in these two cases? It's the null string

00:00:00.000 --> 00:00:00.000
 it's the empty string and notice we have this little

00:00:00.000 --> 00:00:00.000
 sentence here. The empty string is a substring of any string

00:00:00.000 --> 00:00:00.000
 you may assume, so an empty string is a substring

00:00:00.000 --> 00:00:00.000
 of any string. So what that means is we have to say

00:00:00.000 --> 00:00:00.000
 if star

00:00:00.000 --> 00:00:00.000
 if s2 sub 0 equals

00:00:00.000 --> 00:00:00.000
 the null string, or the null byte

00:00:00.000 --> 00:00:00.000
 then it's the empty string so we're going to return

00:00:00.000 --> 00:00:00.000
 true. That means it matches any string. So we have this

00:00:00.000 --> 00:00:00.000
 special case here for this sentence right in here

00:00:00.000 --> 00:00:00.000
 and that should take us from 67%

00:00:00.000 --> 00:00:00.000
 to 100%

00:00:00.000 --> 00:00:00.000
 so that does

00:00:00.000 --> 00:00:00.000
 take us to 100%. Now let's do one more

00:00:00.000 --> 00:00:00.000
 let's do one more and that is

00:00:00.000 --> 00:00:00.000
 I want to, I'm going to leave this here so you can

00:00:00.000 --> 00:00:00.000
 see it. I'm going to change its name

00:00:00.000 --> 00:00:00.000
 to xcontains. So we won't

00:00:00.000 --> 00:00:00.000
 actually be calling it. And I'm going to

00:00:00.000 --> 00:00:00.000
 write a version of contains that only uses pointers

00:00:00.000 --> 00:00:00.000
 so bool

00:00:00.000 --> 00:00:00.000
 contains const char star

00:00:00.000 --> 00:00:00.000
 s1 const char star s2

00:00:00.000 --> 00:00:00.000
 I'm going to

00:00:00.000 --> 00:00:00.000
 say file

00:00:00.000 --> 00:00:00.000
 star

00:00:00.000 --> 00:00:00.000
 s1 is not equal to the null character

00:00:00.000 --> 00:00:00.000
 and of course you know we could write this as file

00:00:00.000 --> 00:00:00.000
 star s1. I mean that would be the same

00:00:00.000 --> 00:00:00.000
 thing.

00:00:00.000 --> 00:00:00.000
 s1++

00:00:00.000 --> 00:00:00.000
 If we get down here we're going to return false

00:00:00.000 --> 00:00:00.000
 if

00:00:00.000 --> 00:00:00.000
 star s2

00:00:00.000 --> 00:00:00.000
 equals the null character or if not

00:00:00.000 --> 00:00:00.000
 star s2 we're going to return true

00:00:00.000 --> 00:00:00.000
 and here we're going to try and do the same thing we did before

00:00:00.000 --> 00:00:00.000
 so I'm going to create a couple of pointers. I'm going to say

00:00:00.000 --> 00:00:00.000
 auto p1 equals s1

00:00:00.000 --> 00:00:00.000
 auto p2 equals s2

00:00:00.000 --> 00:00:00.000
 while star p1 equals

00:00:00.000 --> 00:00:00.000
 star p2 and

00:00:00.000 --> 00:00:00.000
 star p1 is not equal to the

00:00:00.000 --> 00:00:00.000
 null character or while star p1

00:00:00.000 --> 00:00:00.000
 and star p2 is not

00:00:00.000 --> 00:00:00.000
 equal to the null character

00:00:00.000 --> 00:00:00.000
 hold on I'm having a hard time

00:00:00.000 --> 00:00:00.000
 finding that character there

00:00:00.000 --> 00:00:00.000
 null character

00:00:00.000 --> 00:00:00.000
 we're going to do p1++ p2++

00:00:00.000 --> 00:00:00.000
 now when we get

00:00:00.000 --> 00:00:00.000
 out of this if p2

00:00:00.000 --> 00:00:00.000
 which is pointing to s2 if that is pointing

00:00:00.000 --> 00:00:00.000
 to the null byte in other words if we got out of this loop because

00:00:00.000 --> 00:00:00.000
 that was true then the

00:00:00.000 --> 00:00:00.000
 character is there so if

00:00:00.000 --> 00:00:00.000
 star p2 is equal to the null byte

00:00:00.000 --> 00:00:00.000
 return true

00:00:00.000 --> 00:00:00.000
 I find this a little bit easier mainly

00:00:00.000 --> 00:00:00.000
 because when I'm using pointers I don't have to do this addition

00:00:00.000 --> 00:00:00.000
 here of the offsets to get the value and that

00:00:00.000 --> 00:00:00.000
 part kind of always confuses me here so I find this a little bit

00:00:00.000 --> 00:00:00.000
 clearer and cleaner

00:00:00.000 --> 00:00:00.000
 in your text this algorithm is shown at the last

00:00:00.000 --> 00:00:00.000
 part of this chapter and so it's important that you learn and

00:00:00.000 --> 00:00:00.000
 memorize this algorithm so let's go ahead and copy

00:00:00.000 --> 00:00:00.000
 that or test it let's do make test

00:00:00.000 --> 00:00:00.000
 and we got 100% once

00:00:00.000 --> 00:00:00.000
 again. Okay so that's it for lecture

00:00:00.000 --> 00:00:00.000
 22 I will see you guys next time

00:00:00.000 --> 00:00:00.000
 Thank you.

