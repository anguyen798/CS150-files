Hello everyone, this is Steve Gilbert. Welcome to lecture 21. We're going to continue talking about arrays. In this lecture, partially filled arrays and two-dimensional arrays.
So let's start right in with partially filled arrays. So often you'll use only a portion of an array.
So here I have an array. You can see it has 10 elements, but I'm really only using the first four elements.
And since the array size can't change, when you're working with arrays, you need to plan for the worst case.
You need to make the allocated array large enough to hold the maximum data that your problem will use.
Then you create a couple of extra variables. Capacity over here is going to represent the worst case, your allocated size.
And size is going to be the effective size of the array.
Now under the hood, this is how the vector class actually works. It kind of does this magic for you.
But now that we're working with arrays, which are built into the language, we're going to see how that works.
So go ahead and open up the first exercise here. So go ahead and go to week 6.
Go to partially filled arrays. Click the lecture exercise. On the lecture exercise, click the link for the starter form.
Let me click it here. Make a copy.
And this will be the set of instructions we're going to use.
So we're going to write three template functions which should work for any numeric type.
ToString, the parameter is going to be the array and the number of elements.
We're going to return a string with each element separated by a space.
No commas this time. And the element surrounded by brackets.
ReadArray, this is going to read from cin and it's going to read into an array and return the size as a size t.
We'll end with a non-numeric sentinel, so people can type in a q.
Or filling the entire array will end the input. Either one of those.
And finally indexOf. For indexOf we're going to return the index or the position of the first occurrence of the value that we want to find.
You find the prototypes of partial.h and we're going to test with makeTest.
So let's go over here. Let's open up IC21A.
And partial.h is going to have our prototypes. Notice it's created a static constant not found.
And these are our template functions.
Notice here in the header file I've written the templates.
What we're going to do is we're just going to copy those templates.
Those prototypes.
And we're going to go into partial.cpp.
And we're going to implement them right there.
Now remember when you implement a template function you need to include the template class T or type name T as well.
Put our name on the top of it.
So let's look at the steps we need to do these exercises.
First we're going to look at filling or reading from input.
Now I want to read a new value from input.
And I want to put it right here in position 4.
Notice size is already set to 4.
So the equivalent of pushback for a partially filled array, pushback in vector of course,
simply puts the value into A at size.
So we'll put the value inside here and we'll increment size.
Of course that only works if size is less than capacity.
So let's look at that exercise here.
That part.
So that's going to be the read array.
Reads from C and stores values at the end of the array.
Our parameter A is the array.
It's an input/output parameter.
And capacity is going to be the number of elements.
It's going to return the current size.
So this is assuming, notice we didn't pass in the current size,
so it's assuming that size is going to start out at 0.
So size T size equals 0.
And we're going to then return that size.
Okay, so now we need to read values into elements.
What type are the elements?
The elements are of type T.
So we're going to need to make a T in.
This is the value we're going to read.
And it can be integer, it can be double, it can be any numeric type.
And so we're going to keep reading while size is less than capacity.
And we can successfully read a value.
If there's a non-numeric terminator in there, like a Q, this will stop.
So we'll say CNN.
Okay, so there's our loop to read an array.
And so we'll say A at size equals N, and size plus plus.
And of course we've returned size here.
We've returned size.
Now let's go ahead and stub these other two out so we can --
So I'm just going to return not found for this first one.
So it's going to return not found or the index of it.
And for this one, two string.
I'm going to return not done.
Okay, so let's open a terminal on that.
And let's go ahead and do make to make sure it compiles.
Okay, no syntax errors. Let's do make test.
Okay, it says we've got 20%, so read array actually seems to work.
Two string, we haven't done anything on yet.
Read array int.
When I called two string on it, of course that's not done.
And here's read array int.
And since we're using index -- oh no, this is index.
Read array int right here.
And read array double both seem to work right now.
So both of those seem to work.
Alright, let's put that away and let's go to our next one we want to write here.
Which is printing or two string.
Now we can't use operator, the output operator, because the array doesn't know its size.
So we need to write a two string that we could use in place of that.
So we want to write two string, but we only want to print the valid elements.
Again, this is review, we're going to do the fence post algorithm.
We want the elements values separated by a single space.
So we're going to print the delimiter.
If there are any elements, print the first one.
Use a loop to print the remaining elements.
Proceed each by the separator. After the if, print the closing, the limiter.
Now there are a couple ways to do this. I don't remember which one I did for my test.
Let's see if we got s-stream. We don't have s-stream up here.
So let's see if we can do it with two string.
If not, we'll need to include s-stream.
So what we'll do is return
so string result
and we'll return result.
And let's say result
equals the opening
bracket.
If size is greater than zero,
result plus equals two string
from the string class
a sub zero.
And then for size t, i equals one,
i less than size.
And let's change this to
size t size.
Notice the parameter says it's supposed to be named size and my thing had it set to n right there, which is a mistake.
i less than size plus plus i.
Result plus equals
a space plus two string
a sub i.
And
then after the if
plus equals closing thing
and we'll return the result.
Now this may or may not work. I think it'll work with the integers.
I'm not sure it'll work with the doubles.
In fact, it does work perfectly fine with the doubles.
But I don't think it'll give us exactly this output. I think it'll give us output that
has slightly more decimal places. But let's try it and see.
So we can make tests.
Okay, and I missed a semicolon there.
Right there on line 20.
You know, remember when you're looking at these errors, it'll tell you what the line is in the file right there.
Partial cpp line 20.
Make tests.
Okay, so two string for integers works perfectly fine.
Two string for doubles is giving me actually slightly more than I wanted.
So actually the two string for double is perfectly fine, but so that it matches our test, let's do it the way we looked at before.
And so let's include sstream in this.
And let's comment out all this.
So that's the method using two string to do it.
Two string built into the string class.
So we'll use ostring, stream out.
Out.
If size greater than zero.
Out a sub zero.
For size t, i equals one, i less than size, plus plus i.
Out space a sub i.
Out.
And return out string.
Okay, so this will fix the problem we have right here when it expects 130139, but it founds 130386.
It finds one more decimal place when I do two string there.
And so let's go ahead and try it once again.
And two string for doubles works the way the test is expecting it.
Now there's nothing wrong with doing it the other way.
Just my test program is expecting the output in a particular way using the ostring stream.
Okay, the last thing we're going to look at is the index of, oh no.
I don't have a slide on index of.
So let's just go ahead and look at the instructions for index of.
Index of is a linear search.
We're going to look through from the beginning of the array.
Notice the array is not changed.
And we're going to look through this value.
That should be, again, for my documentation, it calls it value.
I've called it val there.
That's a mistake.
And we're going to say for size p, i equals zero, i less than size, plus plus i.
If a at i equals val, q, we're going to return i.
And if it's not equal to value, we're going to return not found.
Okay, let's try that.
That's our last check.
Let's do make test.
And that passes 100%.
Okay, for our second group down here, we want to look at erasing elements.
We're going to write an erase template function which searches for an element in the partially filled array
and removes it if found, keeping the array in order.
We're going to use make test to test your code.
The parameters are the array, the number of elements,
that's an output parameter.
Actually, it's an input and output parameter because it has a value going in
and it will have a different value going out, the value to remove.
We'll retrieve true if a value was removed, false if not.
Notice you'll find several examples inside run.
So how do we erase an element?
Now, unlike vector, there is no erase function.
So if I want to delete this element, the 0, 1, 2, 3, 4, if I want to delete element 4,
what I have to do is move element 5 into its position,
move element 6 into the position where 5 was,
move element 7 into the position where 6 was,
and then delete the size.
So find the element that matches the value, decrement the size,
shift the elements left, and then update the index.
Finally, we're going to return, in this case, not the elements removed,
but we're going to return true or false.
So if we couldn't find it, we'll return false.
So let's go over there and let's close those two terminals, let's close partial,
let's open up B,
let's get partial.cpp and grab our prototype,
and put our name on here,
and define our function template right there,
and return false, and we'll stub that out.
So let's open a shell.
Let's do make test.
Okay, and our code compiles and runs. Doesn't exactly work.
Okay, so I'm going to start with this array, I'm going to try and erase 5, that should be true,
and then I should have 2, 8, 11, since I'm not erasing anything yet, I have that.
So now we'll look at how to erase it.
So let's close our terminal here, and let's look at that algorithm.
So A is an input out parameter, this is an input out parameter, size.
And val, I call that value here, so I'm having a problem keeping my documentation and my name actually in sync here.
Okay, so let's find the element val.
So for size p, i equals 0, i less than size, plus plus i,
if a sub i equals val, let's call it value in both cases.
Make it the same in this one and the previous one.
If a sub i equals the value, then I've found the one that I want to delete,
and so I'm going to return true, I found it, and I'm going to delete it.
So the steps, I found the element number 1, I'm going to decrement the size, so size minus minus,
and I'm going to shift all the elements left.
So for size p, j equals i, j less than size, j plus plus, a sub j equals a sub j plus 1.
So the current element, where val was, I'm going to replace with the one that was right after it.
And then I'm going to do the next thing until I get to the size.
Of course we deleted one, so we're going to return true.
So let's try that and see if it works.
We'll do make test.
And so I deleted 5 from a, and so a now has 2, 8, 11, 14.
I delete 14, the element in the last position, it has 2, 8, 11.
I try and delete 1, it returns false because 1 isn't found.
I try and delete 2, the element in the beginning, and 2 is erased from a,
and so a has 8 and 11 afterwards.
We do the same thing with a double because it's a template function,
and it works perfectly fine for both types of values.
Alright, so that's erasing.
How about inserting elements into an array?
With inserting elements into an array, you do a shift, just like with deletions,
but the shift has to happen not starting at the place where you want to insert,
but it has to start at the end.
You have to shift the last element into the first unused element,
the next to the last element into the next unused element,
the element in front of that, and now we have two copies of this element,
and we can overwrite that element with the value.
So I want to insert 3.25 into this array that has 4 elements.
So to insert it, I first have to check to make sure size is greater or equal to capacity.
Now in this exercise, the one we're going to do here,
we're not going to return true or false.
We're going to return a pointer.
So, again, we could return the value.
We could return an index.
We could return true or false.
We could return a count.
All of those would be possible and we'd have to keep track of them.
In this case, we're going to return the address of the element that was inserted,
very similar to what an iterator actually does,
and I want to insert 3.25.
So what I start by doing is creating a variable
and set it to the first element that is larger than value.
So I loop through, I say, "Is .3 larger than 3.25?"
No.
"Is 2.3 larger than 3.25?"
No.
"Is 7.1 larger than 3.25?"
Oh, yes it is.
So this is my position.
My position is going to be position 2.
Then I'm going to copy elements from size, which is 4, down to pos.
I'm going to move the 9.5 into the 4, the 7.1 into the 9.5.
Now I'm at pos, I'm at 2.
I'm going to add the element, the 3.5, where the 7.1 is now,
and I'm going to increment the size so it goes from 4 to 5.
In this case, we're going to return the address of the added element.
OK, so let's go ahead and close this terminal, close this version of partial,
open up the one from C.
So I'll just copy from partial.h,
I'll open up partial.cpp and paste it in there,
and I'll put my name on the top of this.
OK, so this is going to insert an int value into the array A,
keeping the elements in order.
So I am going to check first to make sure that the size is less than capacity.
So if size is greater or equal to capacity,
I have no room to add the item, so I'm going to return null pointer.
Now I know I have room to add an item, so I'm simply going to find out where it is added.
So I'm going to say size p pos equals 0,
while pos is less than size,
and A sub pos is less than value.
And then I'm going to say pos plus plus.
OK, so pos will be pointing to the element that is greater or equal to value.
And so this means we're going to insert in front of any equal items.
Equal items will be pushed to the right.
OK, so now pos is the value.
I need to do for size p i equals size i greater than pos minus minus pos.
And I need to say A sub i equals A sub i minus 1.
The one in front of it gets copied there.
Now I need to add the element at pos.
I need to say A sub pos equals our value.
We've inserted it.
I need to increment the size, size plus plus, because we've added a new element in it.
And I need to return the address of the added element.
So I need to return the address of A at pos.
Now we can also write this as A plus pos.
That would be the same.
We could use address arithmetic instead of the address operator to do that.
OK, let's open a shell on this.
Right click, open an integrated terminal.
Let's close that.
Let's do make test.
OK, I got an unexpected qualifier on line 21 in partial.cpp.
Line 21, and that's because I meant to delete that,
and I accidentally hit the key below the backspace key and added in a backslash.
OK, make test.
OK.
OK, obviously my code doesn't work, so I have made a mistake.
I have an empty array, capacity 5.
I insert 4 into it, that's fine.
Then I insert 1. I expect 1, 4, but I found 4, 4.
Then I found 4, 4, 4.
Insert 5.
So let's look at our code here.
Either the pos, I'm figuring out, well pos is less than size,
and a at pos is less than value pos.
OK, so we need to look at this second one and trace through it together.
And this is a good thing to do to debug your code.
So we want this one when the array is, has the value 4 in it.
So size is, so this is false.
Size t pos is 0, size t pos is going to be looking at that.
We're trying to insert 1.
So a sub 0
is a sub 0 before
it's not less than value, 4 less than 1 would be false, would drop out.
So pos should be 0.
For i equals size 1, i greater than pos,
minus minus pos, so i is greater than pos, i is 1, pos is 0.
So a sub 1 equals pos, so we put the 4 in that.
That works fine.
Then a sub 0 equals 1,
so this plus plus return a.
OK, I'm going to, I'm going to pos this while I figure this out kind of on my own.
Because it looks like that code is correct and it's obviously not working.
Alright folks, I'm back. It took me a long time to figure out what I had done wrong.
You notice in this loop I'm setting i to size, i greater than pos.
Then I'm decrementing pos, that would be like decrementing length, I should be decrementing i.
And so now I believe our insertion will work correctly.
Yes, so now we correctly insert, inserts it in the correct place.
So sometimes you just have to look at those things for a while to find out what you did wrong.
Alright, now let's talk about multidimensional arrays.
So a multidimensional array we logically think of as rows and columns, right, like a spreadsheet, a matrix.
Internally, however, it's stored linearly.
Memory is linear and it's stored linearly as an array of an arrays.
The second row in the array follows the last element of the first row.
Now the syntax for 2D arrays is a little bit different than it is in Java.
2D arrays are not used as much as they are in Java because they're much less flexible in C++.
So first we have to have constants for both the rows and the columns.
And so here I've created a two-dimensional array with rows and columns.
Looks pretty similar to what you do in Java, except for the fact that these need to be constants.
You can default initialize it starting in C++11, so it's not uninitialized.
And you can initialize it by providing rows and columns inside.
Now if I left off these inner braces, it would still give me, as long as columns is three here,
notice I don't need to supply the rows in that case, and it would still give me two rows of three columns.
Two rows of three columns, even if I left off the inner braces.
The inner braces would not be required.
What the inner braces do is allow you to initialize each row separately.
So suppose I initialized row one just with one element and brace, and then row two with four, five, and six.
Row one would have one, zero, zero, and row two would have then the four, five, and six inside it.
So that's how you can initialize a two-dimensional array.
Now you access the elements using row and column.
This is called row major order.
If you access outside the bounds, for instance, if I wrote balances zero sub six,
you can see zero has zero, one, two, three, four, five, six, looks like it would be right here.
We know, however, that row one is immediately following it.
We could just line up these rows right here, and so we know that this would access one sub zero.
That would normally work, but technically it's undefined behavior.
So you should probably avoid doing it, although I've never seen it not work, but you should avoid doing that.
You can calculate the number of rows.
So you have an array, it's been declared, you want to calculate the number of rows.
Now normally you'll store those in constant variables, right, or in constants.
But if you have a two-dimensional array and you want to know the number of rows,
it's exactly like finding the number of elements in a one-dimensional array.
The size of A divided by the size of A sub zero.
Because A sub zero is not this first element, this first row is A sub zero.
So that's dividing the whole size, the number of bytes allocated for the two-dimensional array,
by the number of bytes allocated for the first row.
If you want to find the first column, you take the size of the first row,
size of A sub zero, and divide that by the size of A sub zero sub zero.
A sub zero sub zero.
Now when you're passing a two-dimensional array to a function,
you have to specify the number of columns as a constant.
So in Java, we can write it this second way, where I have the illegal here on my slide.
We can just say that n is a two-dimensional array of ints,
and we can find out the rows and the columns at run time.
We cannot in C++.
So this function odds will only work with arrays that have this fixed number of columns.
Now if you only want to process a particular column,
then you could pass an additional argument for that column.
Now you can take a single row from a two-dimensional array,
and you can pass it to a function that takes a one-dimensional array just by subscripting it.
So A sub zero in this element is not the first int,
it's the first row of five ints will be passed to that.
So we're going to look at an exercise here that tries processing two-dimensional arrays.
Again, as I mentioned, these are not really used a lot in C++,
but I just want you to get some practice doing it.
So we're going to write several versions of a function called average.
So let's go ahead and close our partial, close that,
go and in D, open up A2DH, which we're going to make some changes to,
so put your name on it, and summer 2022.
And we're going to put some prototypes right here.
Arrays must have a constant second dimension.
Change this for different size 2D arrays.
So here in my prototype, all my test programs are doing it for 10 columns is the constant size.
So that's the maximum columns.
What we're going to do is something similar to partially filled arrays for 2D arrays.
So first we're going to write a function called average that's going to take a 2D array.
All of these will return a double down here.
So this is going to take a 2D array of ints, the number of rows, the number of columns,
and we're going to default the columns to max calls.
So we're going to say double average.
It is going to be a constant A.
Now we don't have to supply the rows, but we do have to supply max calls.
And it's going to be size T rows and size T columns.
And we'll default that to max calls.
So if they don't pass that last argument, it will print out 10 columns, right?
Or it will use 10 columns.
Now we're going to write an average function that takes a one dimensional array of int in the columns.
So double average, constant A, bracket, bracket, size T columns equals max calls.
And finally we're going to take a 2D array of int, and it's going to average the numbers in columns.
So it's going to take columns and column.
So double average, constant A, max calls, size T rows, size T columns, size T column.
And let's open up a shell on this so I can make the thing a little bit wider.
Ok, so here are our three prototypes for the functions we're going to write.
Now notice I have a prototype here that will print a 2D array in this form.
Notice it will print the rows surrounded so it's kind of a fence post with the interior one, just the values like that.
And it is going to print on this stream.
It takes the rows and the size T is max calls.
Now if we open up A2.cpp, put our name on it, our ID at least.
You'll see I've already completed the A out function.
So you notice it's using rows and columns here, rows and columns for the number of elements to print.
And so if columns is anything other than max call, it will only print that number of elements.
So it's like a partially filled array.
So we have an array that looks like this.
One, two, three, four, zero, zero, zero, zero, zero, zero, zero, and six, seven, eight, nine, zero, zero, zero, zero, zero, zero, zero, and three, five, seven, nine, zero, zero, zero, zero, zero.
Now we only want to use these first four columns.
We don't want to use the rest of it.
So we're passing an array that looks like this whole thing, but we're only using this part of it inside here.
And so that way we can make different rows and different columns.
So that's the idea of partially filled arrays with two-dimensional arrays.
So let's grab our code for A2.h.
And let's bring our functions over here.
OK, now you remember when we bring a prototype over, if it has any default arguments, we need to remove those default arguments.
So let's put the bottom on it.
So even though this thing is allocated max col size, we're only going to use columns.
So we're going to say double sum is zero.
Or size PR equals zero, R less than rows, R plus plus. Or size TC equals zero, C less than columns, C plus plus.
Sum plus equals A at rows, R, and C at the row and column.
So now we have the sum here, and we can return sum divided by rows times columns.
The number of elements. So here is averaging. You need to use a nested loop when you're averaging a two-dimensional array.
Now, we haven't handled any error checking here, so what if rows and columns is zero?
Of course, we would have an error here. And we should check that.
And you'll notice down here, I did that with an assert.
Actually, I checked a different assert.
Okay, so we're going to average a single column. So double sum is zero.
Or size TI equals zero, I less than columns, I plus plus.
Sum plus equals A sub I.
Return sum divided by columns. Again, no error checking there to make sure that that's not zero.
And this one is going to look very similar.
So double sum. Or size TR equals zero, R less than rows, R plus plus. Sum plus equals A sub R sub column.
Alright, so we're only adding one column there. And then return sum divided by the number of rows.
Alright, so let's go ahead and try it out.
Let's do make first to make sure we don't have any syntax errors. Nope.
Let's do make test.
Okay, so here is A out and I've supplied a size four when I do it.
Here's A out. If I don't supply a value, I only supply the three arguments.
And so notice it's printing those extra zeros at the end that we didn't use.
Here's the average of all the used elements.
And so that's average values, rows. And because there's only four.
Here's the average of all the elements, which would not give us the right value, right?
Because we're not really using these.
So we'd want to call it with average, take in the values, the number of rows that we're using,
and the number of columns that are actually in use.
Here's the average of the second row. Here's the average of the second row, only four columns.
Notice you call it again by passing that default argument that was the default argument.
And here's the average of the third column in the entire array.
Okay, so that's it for lecture 21. I'll see you next time for our next lecture.
