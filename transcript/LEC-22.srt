1
00:00:00,000 --> 00:00:00,000
Hello everyone, this is Steve Gilbert. Welcome to lecture 22 on C-style strings.

2
00:00:00,000 --> 00:00:00,000
So let's talk about C-style strings.

3
00:00:00,000 --> 00:00:00,000
A C-string is a character array that was used for traditional or built-in strings in C.

4
00:00:00,000 --> 00:00:00,000
These were inherited by C++.

5
00:00:00,000 --> 00:00:00,000
So if I create an array, I can actually initialize it, a char array,

6
00:00:00,000 --> 00:00:00,000
I can initialize it with what we call a string literal, with just "hello" in double quotes.

7
00:00:00,000 --> 00:00:00,000
That will initialize or create an array that has six elements in it.

8
00:00:00,000 --> 00:00:00,000
So notice the different ways we could do that.

9
00:00:00,000 --> 00:00:00,000
We could allocate it by saying "greeting6 = hello" or we could do it the same way we do all the other arrays.

10
00:00:00,000 --> 00:00:00,000
We could say "greeting =" and then put in the "h" and the "e" and the "l" and the "l" and the "o"

11
00:00:00,000 --> 00:00:00,000
along with one additional value.

12
00:00:00,000 --> 00:00:00,000
Now notice when we initialize a C-style string or a character array,

13
00:00:00,000 --> 00:00:00,000
we don't need to use braces or commas as with the additional array.

14
00:00:00,000 --> 00:00:00,000
We don't need to use this third style right here.

15
00:00:00,000 --> 00:00:00,000
We can just do it by putting in the string itself.

16
00:00:00,000 --> 00:00:00,000
Now the array that's created when we do this occupies six bytes, not five.

17
00:00:00,000 --> 00:00:00,000
It has one byte for each of the characters, the "h" and the "e" and the "l" and the "l" and the "o."

18
00:00:00,000 --> 00:00:00,000
That's followed by a binary zero, the zero character.

19
00:00:00,000 --> 00:00:00,000
It's not the integer zero, it's the character with the ASCII value zero.

20
00:00:00,000 --> 00:00:00,000
We call this the null terminator.

21
00:00:00,000 --> 00:00:00,000
You notice I've spelled null with a single "l" there.

22
00:00:00,000 --> 00:00:00,000
So null is the name of the character with the ASCII value zero.

23
00:00:00,000 --> 00:00:00,000
If you look at an ASCII character set, let's go see if we can find one in our web browser here.

24
00:00:00,000 --> 00:00:00,000
Let's look up ASCII table.

25
00:00:00,000 --> 00:00:00,000
If we look up an ASCII table, you'll notice that these characters have names.

26
00:00:00,000 --> 00:00:00,000
So the character that has the decimal value zero has the name "nul."

27
00:00:00,000 --> 00:00:00,000
And so that was just the ASCII name for the character that had the value zero, the ASCII character zero.

28
00:00:00,000 --> 00:00:00,000
Sometimes students get that confused with "null."

29
00:00:00,000 --> 00:00:00,000
An "null" is something different.

30
00:00:00,000 --> 00:00:00,000
It also has the value zero, but it's the C representation of a pointer with the value zero.

31
00:00:00,000 --> 00:00:00,000
We actually don't use "null" in C++. We use "nullpointer" instead, which is an entirely different type.

32
00:00:00,000 --> 00:00:00,000
Now, let's look at two examples of C-style strings.

33
00:00:00,000 --> 00:00:00,000
Here's the one I just showed you, "pet1 = dog."

34
00:00:00,000 --> 00:00:00,000
That is the equivalent to this.

35
00:00:00,000 --> 00:00:00,000
"char pet1 [] =" and then embraces initializing the D, the O, the G.

36
00:00:00,000 --> 00:00:00,000
And even though in this top one we don't see the null character, that null character is actually there.

37
00:00:00,000 --> 00:00:00,000
So the memories are allocated for four characters in user space.

38
00:00:00,000 --> 00:00:00,000
That means in your space that you can make a change to.

39
00:00:00,000 --> 00:00:00,000
So "pet1" is, its type is an array of four characters.

40
00:00:00,000 --> 00:00:00,000
It's a block of four characters, and if we created this in the static storage area,

41
00:00:00,000 --> 00:00:00,000
in other words, outside any function, it would be in the static area.

42
00:00:00,000 --> 00:00:00,000
If we created it on the stack, in other words, inside a function, it would be on the stack.

43
00:00:00,000 --> 00:00:00,000
This is slightly different.

44
00:00:00,000 --> 00:00:00,000
So "pet2" is a pointer. "pet2" is a pointer, and it points to the first character of an array of four characters.

45
00:00:00,000 --> 00:00:00,000
So there is still a "cat" null character out there, but that "cat" null character is not stored in your space.

46
00:00:00,000 --> 00:00:00,000
It's not stored on the stack. It's not stored on the static storage area.

47
00:00:00,000 --> 00:00:00,000
It's stored in a section of read-only memory, a special part of the static storage area.

48
00:00:00,000 --> 00:00:00,000
Now, in C, this is allowed. In C++, this is actually not really correct.

49
00:00:00,000 --> 00:00:00,000
In C++, because this is stored in a read-only memory section, C++ said,

50
00:00:00,000 --> 00:00:00,000
"Well, we should allow the compiler to know that, and so we should write it as const char*."

51
00:00:00,000 --> 00:00:00,000
So in C++, if you write this, you'll probably get some kind of warning or error.

52
00:00:00,000 --> 00:00:00,000
Now, notice that I can take this pointer, char*pet2=cat, and I can reassign it to "pet1."

53
00:00:00,000 --> 00:00:00,000
I can say "pet2=pet1," because "pet2" is a pointer. That pointer can be changed, but I could not do the opposite.

54
00:00:00,000 --> 00:00:00,000
I could not say "pet1=pet2." "pet1" is fixed.

55
00:00:00,000 --> 00:00:00,000
It is a constant address of the first character here.

56
00:00:00,000 --> 00:00:00,000
So the standard library inherited a collection of functions in the header called "cstring."

57
00:00:00,000 --> 00:00:00,000
Now, C and older C++ implementations will use the header called "string.h."

58
00:00:00,000 --> 00:00:00,000
All of the headers in C++ that start with "c," like "cstring," are inherited from the C language, and the C standard library.

59
00:00:00,000 --> 00:00:00,000
So let's look first at how we find the size of a string, if we want to loop through it.

60
00:00:00,000 --> 00:00:00,000
With a C++ string, like "a" here, we get the length by calling "a.length" or "a.size."

61
00:00:00,000 --> 00:00:00,000
We call a member function because a C++ string is an object of a class.

62
00:00:00,000 --> 00:00:00,000
"b" is a C string. In other words, it's an array of 1, 2, 3, 4, 5, 6, 7, 8 characters.

63
00:00:00,000 --> 00:00:00,000
And it's stored in this array on the stack, in this case.

64
00:00:00,000 --> 00:00:00,000
And we will get the size by passing the array "b" to a function called "strlen."

65
00:00:00,000 --> 00:00:00,000
So "strlen" is in this header file "cstring."

66
00:00:00,000 --> 00:00:00,000
Now, if we want to loop through the string, with a C string, we have to use the traditional "for" loop.

67
00:00:00,000 --> 00:00:00,000
You'd have to do "i < len b."

68
00:00:00,000 --> 00:00:00,000
With a C++ string, we can still do this, but we can do this as well.

69
00:00:00,000 --> 00:00:00,000
You can't do this with a C-style string.

70
00:00:00,000 --> 00:00:00,000
So, again, C strings and C++ strings are different kinds of things.

71
00:00:00,000 --> 00:00:00,000
Now, to assign or copy a string in C++, you do it exactly the same way that an integer does.

72
00:00:00,000 --> 00:00:00,000
You say "string a = hello."

73
00:00:00,000 --> 00:00:00,000
And to make a copy of "a," you do "string b = a."

74
00:00:00,000 --> 00:00:00,000
So that means that we have two copies of the word "hello."

75
00:00:00,000 --> 00:00:00,000
How do we do that in C?

76
00:00:00,000 --> 00:00:00,000
Well, in C, we have one string here.

77
00:00:00,000 --> 00:00:00,000
Now, notice I'm using the second time, where I have a constant character.

78
00:00:00,000 --> 00:00:00,000
And this is in read-only memory.

79
00:00:00,000 --> 00:00:00,000
I have an array that I'm going to copy that into, "b."

80
00:00:00,000 --> 00:00:00,000
I've allocated enough space to hold it.

81
00:00:00,000 --> 00:00:00,000
And I'm going to call the function in C string called "strcpy."

82
00:00:00,000 --> 00:00:00,000
S-T-R-C-P-Y.

83
00:00:00,000 --> 00:00:00,000
And I'm going to copy into "b" this array all the characters from "a."

84
00:00:00,000 --> 00:00:00,000
Now, how this works is the loop inside the function strcpy simply copies the first character into "b."

85
00:00:00,000 --> 00:00:00,000
Then it copies the second character following that, the third character, the fourth character, the fifth character.

86
00:00:00,000 --> 00:00:00,000
And then it copies the null character, and then it stops.

87
00:00:00,000 --> 00:00:00,000
Now, because of that, you have to make sure that the destination, here "b" is the destination where we're going to put the characters,

88
00:00:00,000 --> 00:00:00,000
has sufficient space to store all of the characters plus the null byte.

89
00:00:00,000 --> 00:00:00,000
Let's look at string concatenation.

90
00:00:00,000 --> 00:00:00,000
So C++ string concatenation works like this.

91
00:00:00,000 --> 00:00:00,000
You create a string "a," and then you add "a" to another string, "beautiful" in this case, and we create another string.

92
00:00:00,000 --> 00:00:00,000
So we have one string "a" that has "hello" in it, and "b" that has "hello, beautiful."

93
00:00:00,000 --> 00:00:00,000
If we want to do the same thing in C, what we have to do is create the C string we're going to copy from.

94
00:00:00,000 --> 00:00:00,000
We create the C string we're going to copy to, and initialize it with the value that we're starting with.

95
00:00:00,000 --> 00:00:00,000
And then we use a function called "string cat," or "strcat."

96
00:00:00,000 --> 00:00:00,000
So this is string concatenation.

97
00:00:00,000 --> 00:00:00,000
And it will concatenate into "b."

98
00:00:00,000 --> 00:00:00,000
Now here, it's going to do the same thing.

99
00:00:00,000 --> 00:00:00,000
It's going to start copying from "a" into "b," but before it does that, it's going to loop all the way down here until it finds the null byte.

100
00:00:00,000 --> 00:00:00,000
And so when it copies this space, it's going to overwrite the null byte here.

101
00:00:00,000 --> 00:00:00,000
And then it's going to copy the "b" and the "e" and the "a" and the "t" and so forth until it gets to the null byte here.

102
00:00:00,000 --> 00:00:00,000
It will copy there, and then "b" will contain "hello, beautiful."

103
00:00:00,000 --> 00:00:00,000
Again, it's entirely up to you to make sure the destination, in this case "b," has sufficient space to store all the characters from "hello"

104
00:00:00,000 --> 00:00:00,000
and all the characters from "beautiful" and the null byte at the end of it.

105
00:00:00,000 --> 00:00:00,000
Now, for string comparison, with C++ strings, you treat them just like integers.

106
00:00:00,000 --> 00:00:00,000
If string "a" is "hello" and "b" is something that's unknown, you just say if "a" equals equals "b," just like you would with integers.

107
00:00:00,000 --> 00:00:00,000
If "a" is less than "b" to see if it appears before "b" in the dictionary.

108
00:00:00,000 --> 00:00:00,000
If "a" is greater than "b" to see if it falls later than "a" in the dictionary.

109
00:00:00,000 --> 00:00:00,000
In C, you cannot use the relational operators.

110
00:00:00,000 --> 00:00:00,000
You could use the equals equals sign, but as we saw with arrays, using equals equals with arrays is legal.

111
00:00:00,000 --> 00:00:00,000
In other words, it compiles, but it's stupid. It doesn't work.

112
00:00:00,000 --> 00:00:00,000
So, if we have two C strings, "a" is "hello" and "b" is whatever,

113
00:00:00,000 --> 00:00:00,000
then we call the function strcmp and pass "a" and "b" to it.

114
00:00:00,000 --> 00:00:00,000
If "a" and "b" have the same characters in the same order, it returns zero. There is no difference.

115
00:00:00,000 --> 00:00:00,000
If "a" would appear less than "b," or in other words, it would appear before "b" in the dictionary,

116
00:00:00,000 --> 00:00:00,000
then it returns a number that is less than zero.

117
00:00:00,000 --> 00:00:00,000
And if "a" would appear after "b" in the dictionary, it returns greater than zero.

118
00:00:00,000 --> 00:00:00,000
Now, notice strcmp is not a predicate or Boolean function.

119
00:00:00,000 --> 00:00:00,000
It doesn't return true and false. It returns three values, zero, less than zero, or greater than zero.

120
00:00:00,000 --> 00:00:00,000
And so it's very common to forget that. It's a common bug to think that it is a Boolean function.

121
00:00:00,000 --> 00:00:00,000
And of course, because of the way C++ works, it will take that zero or non-zero and turn it into true and false.

122
00:00:00,000 --> 00:00:00,000
You generally will not get the answer that you expect.

123
00:00:00,000 --> 00:00:00,000
So remember when you call strcmp to test the value that's returned from strcmp.

124
00:00:00,000 --> 00:00:00,000
Okay, so let's go ahead and open our first exercise.

125
00:00:00,000 --> 00:00:00,000
This is a function called mincat.

126
00:00:00,000 --> 00:00:00,000
We're going to use the standard C-string functions to write a function that concatenates two C-string literals.

127
00:00:00,000 --> 00:00:00,000
So s1 and s2 are the two strings.

128
00:00:00,000 --> 00:00:00,000
Out is an array of characters where the answer goes.

129
00:00:00,000 --> 00:00:00,000
Now remember, we cannot return arrays, so we could not return a C-string.

130
00:00:00,000 --> 00:00:00,000
So this is an output parameter.

131
00:00:00,000 --> 00:00:00,000
Maxlen is the size of the output array.

132
00:00:00,000 --> 00:00:00,000
And so we have to make sure that we don't overstep the size of that.

133
00:00:00,000 --> 00:00:00,000
So here's how we're going to do that.

134
00:00:00,000 --> 00:00:00,000
We're going to find the length of the shorter string and put it in the variable called len.

135
00:00:00,000 --> 00:00:00,000
Then when we concatenate, we're going to concatenate only the last len characters from the longer string.

136
00:00:00,000 --> 00:00:00,000
So in the problem you'll see several examples.

137
00:00:00,000 --> 00:00:00,000
So let's switch over to our IDE here.

138
00:00:00,000 --> 00:00:00,000
And I've already opened ic22a mincat.cpp.

139
00:00:00,000 --> 00:00:00,000
I'm going to move that down a little bit and we'll look at it.

140
00:00:00,000 --> 00:00:00,000
So we're going to write a function named mincat.

141
00:00:00,000 --> 00:00:00,000
We're going to be given two C-string literals.

142
00:00:00,000 --> 00:00:00,000
We're going to append them together.

143
00:00:00,000 --> 00:00:00,000
And we're going to return the results in the third argument, a non-constant array of char.

144
00:00:00,000 --> 00:00:00,000
The fourth parameter is the size of the array.

145
00:00:00,000 --> 00:00:00,000
If the input strings are different lengths, then we'll omit the leading characters from the longer string

146
00:00:00,000 --> 00:00:00,000
so it's the same length as the shorter string.

147
00:00:00,000 --> 00:00:00,000
So if we try to concatenate "hello" and "hi", the shorter string has only two characters.

148
00:00:00,000 --> 00:00:00,000
And so we're only going to use the two last characters from "hello".

149
00:00:00,000 --> 00:00:00,000
And so that will concatenate as "low" and "hi".

150
00:00:00,000 --> 00:00:00,000
Now the strings can be of any length.

151
00:00:00,000 --> 00:00:00,000
Now if the combined string output is larger than the space available,

152
00:00:00,000 --> 00:00:00,000
then we're going to divide the available space in half, after leaving room for the terminator of course,

153
00:00:00,000 --> 00:00:00,000
and concatenate the last n characters from each string.

154
00:00:00,000 --> 00:00:00,000
So we're going to use the functions from the C-string header.

155
00:00:00,000 --> 00:00:00,000
We're not going to use any of the C++ string library.

156
00:00:00,000 --> 00:00:00,000
So let's write that here.

157
00:00:00,000 --> 00:00:00,000
Now notice it's not going to return anything as a function.

158
00:00:00,000 --> 00:00:00,000
It's going to be really a procedure.

159
00:00:00,000 --> 00:00:00,000
So we're going to call it "mincat".

160
00:00:00,000 --> 00:00:00,000
It's going to take a const char * s1, const char * s2,

161
00:00:00,000 --> 00:00:00,000
a char out that is going to have, we don't know how many lengths,

162
00:00:00,000 --> 00:00:00,000
and a size t for max length.

163
00:00:00,000 --> 00:00:00,000
Okay, so that's all we need to do to stub that out.

164
00:00:00,000 --> 00:00:00,000
Let's open a terminal on that window by right clicking and open an integrated terminal.

165
00:00:00,000 --> 00:00:00,000
And then let's just do "make" to make sure that it compiles.

166
00:00:00,000 --> 00:00:00,000
It should, right? We haven't really done anything other than put in the parameters and everything.

167
00:00:00,000 --> 00:00:00,000
Okay, so I need to know the lengths of these.

168
00:00:00,000 --> 00:00:00,000
How do I find the length of s1 and s2?

169
00:00:00,000 --> 00:00:00,000
So I'm going to say

170
00:00:00,000 --> 00:00:00,000
size t, or int if you want,

171
00:00:00,000 --> 00:00:00,000
len1 = strlen s1.

172
00:00:00,000 --> 00:00:00,000
So call the function strlen.

173
00:00:00,000 --> 00:00:00,000
So size t, len2 = strlen s2.

174
00:00:00,000 --> 00:00:00,000
Now I need to create the length that's going to be the shorter of it.

175
00:00:00,000 --> 00:00:00,000
So size t, len =

176
00:00:00,000 --> 00:00:00,000
and here I'm going to use the conditional operator.

177
00:00:00,000 --> 00:00:00,000
So len1 < len2

178
00:00:00,000 --> 00:00:00,000
question mark, I'm going to use len1.

179
00:00:00,000 --> 00:00:00,000
Otherwise I'm going to use len2.

180
00:00:00,000 --> 00:00:00,000
You could use an if statement, but it would be a little bit longer and take a little bit more time.

181
00:00:00,000 --> 00:00:00,000
Now, what we want to do

182
00:00:00,000 --> 00:00:00,000
is we want to concatenate into out

183
00:00:00,000 --> 00:00:00,000
s1 and s2

184
00:00:00,000 --> 00:00:00,000
but only the len characters.

185
00:00:00,000 --> 00:00:00,000
So we're going to say str

186
00:00:00,000 --> 00:00:00,000
the last len characters.

187
00:00:00,000 --> 00:00:00,000
So we're going to say strcopy

188
00:00:00,000 --> 00:00:00,000
our first thing.

189
00:00:00,000 --> 00:00:00,000
We're going to copy into out.

190
00:00:00,000 --> 00:00:00,000
We're going to take len

191
00:00:00,000 --> 00:00:00,000
s1

192
00:00:00,000 --> 00:00:00,000
plus len1.

193
00:00:00,000 --> 00:00:00,000
Now remember s1 is a pointer.

194
00:00:00,000 --> 00:00:00,000
It's an address.

195
00:00:00,000 --> 00:00:00,000
We add len1 to it and what are we pointing to?

196
00:00:00,000 --> 00:00:00,000
We're pointing to the null byte in s2.

197
00:00:00,000 --> 00:00:00,000
Now if I subtract len from that

198
00:00:00,000 --> 00:00:00,000
what I have is the number of characters

199
00:00:00,000 --> 00:00:00,000
for the first item.

200
00:00:00,000 --> 00:00:00,000
Now I'm going to concatenate s2.

201
00:00:00,000 --> 00:00:00,000
So I'm going to say strcap

202
00:00:00,000 --> 00:00:00,000
not strcopy. I'm going to concatenate into out.

203
00:00:00,000 --> 00:00:00,000
I'm going to copy s2

204
00:00:00,000 --> 00:00:00,000
plus len2.

205
00:00:00,000 --> 00:00:00,000
So move that pointer down to the end

206
00:00:00,000 --> 00:00:00,000
and remove it back, len characters.

207
00:00:00,000 --> 00:00:00,000
Okay, let's go ahead and try that.

208
00:00:00,000 --> 00:00:00,000
Let's do make test.

209
00:00:00,000 --> 00:00:00,000
And it looks like it worked except for three of them.

210
00:00:00,000 --> 00:00:00,000
And that is because this only has five characters available.

211
00:00:00,000 --> 00:00:00,000
So it works fine if we have an unlimited number of characters

212
00:00:00,000 --> 00:00:00,000
available in the answer or out parameter.

213
00:00:00,000 --> 00:00:00,000
But if we don't have an unlimited number of characters

214
00:00:00,000 --> 00:00:00,000
we have a problem.

215
00:00:00,000 --> 00:00:00,000
So we haven't done this second part here.

216
00:00:00,000 --> 00:00:00,000
We haven't done this part right here if the combined output

217
00:00:00,000 --> 00:00:00,000
is larger than the space available.

218
00:00:00,000 --> 00:00:00,000
So let's do that right here.

219
00:00:00,000 --> 00:00:00,000
We'll say if

220
00:00:00,000 --> 00:00:00,000
if len times two

221
00:00:00,000 --> 00:00:00,000
is greater than

222
00:00:00,000 --> 00:00:00,000
maxlen plus one

223
00:00:00,000 --> 00:00:00,000
that means it won't fit, right?

224
00:00:00,000 --> 00:00:00,000
And if that's the case we have to set len

225
00:00:00,000 --> 00:00:00,000
equal to maxlen

226
00:00:00,000 --> 00:00:00,000
minus one. So allow to the null byte

227
00:00:00,000 --> 00:00:00,000
divided by two. So each character, each string can only use

228
00:00:00,000 --> 00:00:00,000
that amount of space.

229
00:00:00,000 --> 00:00:00,000
Okay, let's try it again.

230
00:00:00,000 --> 00:00:00,000
Let's clear that with control L and do make test.

231
00:00:00,000 --> 00:00:00,000
And we got all of them working correctly.

232
00:00:00,000 --> 00:00:00,000
I'm going to show you in a second something else about C style strings.

233
00:00:00,000 --> 00:00:00,000
Many people say, well, you know, this is all good and fine

234
00:00:00,000 --> 00:00:00,000
but why would I want to do this when I already have the C++ string class?

235
00:00:00,000 --> 00:00:00,000
What can I do with this that I can't do with the C++ string class?

236
00:00:00,000 --> 00:00:00,000
Well, the reason that we want to learn to use the C

237
00:00:00,000 --> 00:00:00,000
string type in addition to the C++ string type

238
00:00:00,000 --> 00:00:00,000
is because we want to interact with things like

239
00:00:00,000 --> 00:00:00,000
the operating system. So all operating systems

240
00:00:00,000 --> 00:00:00,000
from the newest, Mac OS X, Windows,

241
00:00:00,000 --> 00:00:00,000
Linux, all of them are written in the C language.

242
00:00:00,000 --> 00:00:00,000
And if you want to talk to the operating system,

243
00:00:00,000 --> 00:00:00,000
if you want to write a Windows program, you must use

244
00:00:00,000 --> 00:00:00,000
the C programming language to do that. Or some other

245
00:00:00,000 --> 00:00:00,000
higher level language that translates it to C for you, like C#.

246
00:00:00,000 --> 00:00:00,000
So let's look at something in B here.

247
00:00:00,000 --> 00:00:00,000
PNV

248
00:00:00,000 --> 00:00:00,000
and let's bring that down there, that's too high.

249
00:00:00,000 --> 00:00:00,000
And let's open a terminal on B.

250
00:00:00,000 --> 00:00:00,000
Open an integrated terminal so we have a fresh terminal down there. I can close the other ones.

251
00:00:00,000 --> 00:00:00,000
And what we want to do

252
00:00:00,000 --> 00:00:00,000
is in the operating system, this is true for Windows,

253
00:00:00,000 --> 00:00:00,000
for the Mac, for Linux of course, which we're working on,

254
00:00:00,000 --> 00:00:00,000
variables that are used among

255
00:00:00,000 --> 00:00:00,000
different programs can be set in an area of memory called the environment.

256
00:00:00,000 --> 00:00:00,000
So this is not global inside your program, it's global

257
00:00:00,000 --> 00:00:00,000
outside your program. So for instance, if I want to know

258
00:00:00,000 --> 00:00:00,000
actually I'll just show you what all the variables are.

259
00:00:00,000 --> 00:00:00,000
So if I do printenv in Unix,

260
00:00:00,000 --> 00:00:00,000
in Windows the command would just be set and hit enter,

261
00:00:00,000 --> 00:00:00,000
it goes and it prints a list of those variables

262
00:00:00,000 --> 00:00:00,000
and tells me what the values of those variables are.

263
00:00:00,000 --> 00:00:00,000
So notice that there's a variable called githubapiurl.

264
00:00:00,000 --> 00:00:00,000
There's a variable called workdeer.

265
00:00:00,000 --> 00:00:00,000
There's a variable called gemhome and so forth.

266
00:00:00,000 --> 00:00:00,000
And so these variables are set into

267
00:00:00,000 --> 00:00:00,000
the environment. We set several of these variables when we configured

268
00:00:00,000 --> 00:00:00,000
our IDE. Remember when you configure your IDE

269
00:00:00,000 --> 00:00:00,000
or when you reset your IDE,

270
00:00:00,000 --> 00:00:00,000
it will set things like your CS150 username

271
00:00:00,000 --> 00:00:00,000
and so forth. Those are in the environment.

272
00:00:00,000 --> 00:00:00,000
Well this command printenv is just a program

273
00:00:00,000 --> 00:00:00,000
and it's a program that reads a global array

274
00:00:00,000 --> 00:00:00,000
of character pointers and so that is written

275
00:00:00,000 --> 00:00:00,000
as char star

276
00:00:00,000 --> 00:00:00,000
a bracket or environ bracket

277
00:00:00,000 --> 00:00:00,000
or we can write it as using simply two stars like that.

278
00:00:00,000 --> 00:00:00,000
And so we are going to write a program

279
00:00:00,000 --> 00:00:00,000
that does the same thing as this. And I want to show you how easy this is to do

280
00:00:00,000 --> 00:00:00,000
but you have to know about C style strings.

281
00:00:00,000 --> 00:00:00,000
So this variable is declared

282
00:00:00,000 --> 00:00:00,000
in the operating system, is defined in the operating system

283
00:00:00,000 --> 00:00:00,000
and we want to use it in our program.

284
00:00:00,000 --> 00:00:00,000
So how do you use a variable in one program

285
00:00:00,000 --> 00:00:00,000
that's declared in another or defined in another? You make it

286
00:00:00,000 --> 00:00:00,000
external. So we're going to declare this variable.

287
00:00:00,000 --> 00:00:00,000
We're not going to define it. We're going to say extern

288
00:00:00,000 --> 00:00:00,000
char star star environment.

289
00:00:00,000 --> 00:00:00,000
So now we can use that variable.

290
00:00:00,000 --> 00:00:00,000
That variable has been declared or defined elsewhere.

291
00:00:00,000 --> 00:00:00,000
We have declared it in our program and so we can use that

292
00:00:00,000 --> 00:00:00,000
to connect to the operating system.

293
00:00:00,000 --> 00:00:00,000
So if I dereference environment

294
00:00:00,000 --> 00:00:00,000
what I get is a pointer to a character.

295
00:00:00,000 --> 00:00:00,000
In other words what I get is a C style string.

296
00:00:00,000 --> 00:00:00,000
And so what I want to say

297
00:00:00,000 --> 00:00:00,000
is while

298
00:00:00,000 --> 00:00:00,000
actually I want to create a variable. I'll call it p.

299
00:00:00,000 --> 00:00:00,000
So auto p equals

300
00:00:00,000 --> 00:00:00,000
environment.

301
00:00:00,000 --> 00:00:00,000
In other words I don't want to change

302
00:00:00,000 --> 00:00:00,000
environment.

303
00:00:00,000 --> 00:00:00,000
And you might wonder why don't you put const there if you don't want to change it.

304
00:00:00,000 --> 00:00:00,000
That's because in C, which the operating system was written in,

305
00:00:00,000 --> 00:00:00,000
they didn't have const. They didn't use const like that.

306
00:00:00,000 --> 00:00:00,000
So we're going to say auto p equals environment

307
00:00:00,000 --> 00:00:00,000
while star p

308
00:00:00,000 --> 00:00:00,000
while

309
00:00:00,000 --> 00:00:00,000
while star p is not equal to the null pointer

310
00:00:00,000 --> 00:00:00,000
we're going to print out

311
00:00:00,000 --> 00:00:00,000
that variable.

312
00:00:00,000 --> 00:00:00,000
Okay now this actually won't quite work

313
00:00:00,000 --> 00:00:00,000
correctly. If you notice the end of this it tells us

314
00:00:00,000 --> 00:00:00,000
the name of the program. This environmental variable underscore

315
00:00:00,000 --> 00:00:00,000
is the name of the program we're actually running.

316
00:00:00,000 --> 00:00:00,000
So we're going to compile this. The name is p_env

317
00:00:00,000 --> 00:00:00,000
So we're going to say make p_env

318
00:00:00,000 --> 00:00:00,000
and then we're going to run

319
00:00:00,000 --> 00:00:00,000
p_env dash p_env

320
00:00:00,000 --> 00:00:00,000
and we did not get what we wanted

321
00:00:00,000 --> 00:00:00,000
oops, let me control c to stop it. Ah!

322
00:00:00,000 --> 00:00:00,000
It crashed. So what did I forget here? I forgot the fact

323
00:00:00,000 --> 00:00:00,000
that the first time we're going to be pointing to the first string but we're going to continue

324
00:00:00,000 --> 00:00:00,000
to be pointing to the same string each time. So we have an endless loop

325
00:00:00,000 --> 00:00:00,000
that is just pointing to the first environmental variable and

326
00:00:00,000 --> 00:00:00,000
printing it over and over and over again. So

327
00:00:00,000 --> 00:00:00,000
to go to the next one, what do we have to do? We have to increment the

328
00:00:00,000 --> 00:00:00,000
pointer. Okay, let's build that

329
00:00:00,000 --> 00:00:00,000
again

330
00:00:00,000 --> 00:00:00,000
and let's run it again.

331
00:00:00,000 --> 00:00:00,000
Okay, so now notice we got exactly

332
00:00:00,000 --> 00:00:00,000
the same thing we had before.

333
00:00:00,000 --> 00:00:00,000
My github user is sgilbertstudent

334
00:00:00,000 --> 00:00:00,000
and so we have written

335
00:00:00,000 --> 00:00:00,000
a program that has exactly the

336
00:00:00,000 --> 00:00:00,000
same output as a

337
00:00:00,000 --> 00:00:00,000
built in piece of code.

338
00:00:00,000 --> 00:00:00,000
We couldn't do this with C++ strings

339
00:00:00,000 --> 00:00:00,000
you have to use C style strings and pointers

340
00:00:00,000 --> 00:00:00,000
to do this.

341
00:00:00,000 --> 00:00:00,000
Now to process

342
00:00:00,000 --> 00:00:00,000
C style strings, what you do is you treat them

343
00:00:00,000 --> 00:00:00,000
exactly like an array, except

344
00:00:00,000 --> 00:00:00,000
you're not worried about the length of it. You assume that there's a

345
00:00:00,000 --> 00:00:00,000
terminating null character in the array. And so

346
00:00:00,000 --> 00:00:00,000
instead of counter controlled loops, we're going to use a sentinel

347
00:00:00,000 --> 00:00:00,000
loop, like this example of the strlen function.

348
00:00:00,000 --> 00:00:00,000
So strlen here is returning an int, the actual version

349
00:00:00,000 --> 00:00:00,000
of strlen returns a size T. And it's

350
00:00:00,000 --> 00:00:00,000
going to create a counter i, and while

351
00:00:00,000 --> 00:00:00,000
s at i is not equal to the null character, it's

352
00:00:00,000 --> 00:00:00,000
going to increment i. At the end of that, i will have

353
00:00:00,000 --> 00:00:00,000
the count of the number of characters in the

354
00:00:00,000 --> 00:00:00,000
string. So the traditional C library string functions

355
00:00:00,000 --> 00:00:00,000
all depend on that null character at the end

356
00:00:00,000 --> 00:00:00,000
of the string. Now you can write your

357
00:00:00,000 --> 00:00:00,000
code using array syntax. There's no loss of

358
00:00:00,000 --> 00:00:00,000
efficiency, if you're more comfortable with that it's perfectly fine, but

359
00:00:00,000 --> 00:00:00,000
it's more common to use pointer syntax. So here's a version

360
00:00:00,000 --> 00:00:00,000
of strlen that uses pointer syntax. Notice

361
00:00:00,000 --> 00:00:00,000
s is a const char star, or a pointer

362
00:00:00,000 --> 00:00:00,000
to a const character. We have length, and

363
00:00:00,000 --> 00:00:00,000
while star s is not equal to the null byte,

364
00:00:00,000 --> 00:00:00,000
we dereference the pointer s, it's not equal to the null byte,

365
00:00:00,000 --> 00:00:00,000
we increment s to go to the next character,

366
00:00:00,000 --> 00:00:00,000
and we also increment the length. So we get a pointer

367
00:00:00,000 --> 00:00:00,000
to a constant character, while s doesn't point to the terminating null

368
00:00:00,000 --> 00:00:00,000
byte, we move s and we count the character.

369
00:00:00,000 --> 00:00:00,000
So this is much more common to use pointers

370
00:00:00,000 --> 00:00:00,000
with C style strings than it is with arrays. As I

371
00:00:00,000 --> 00:00:00,000
mentioned though, there is no loss of efficiency if you use

372
00:00:00,000 --> 00:00:00,000
array syntax. So if you're more comfortable with that, you're perfectly

373
00:00:00,000 --> 00:00:00,000
fine using that.

374
00:00:00,000 --> 00:00:00,000
Now, it's also very common to use a much more

375
00:00:00,000 --> 00:00:00,000
concise syntax when processing C strings

376
00:00:00,000 --> 00:00:00,000
with pointers. So notice this just has three lines,

377
00:00:00,000 --> 00:00:00,000
the length is zero, while star s plus plus

378
00:00:00,000 --> 00:00:00,000
len plus plus return len. So this is

379
00:00:00,000 --> 00:00:00,000
a very, very common C string idiom.

380
00:00:00,000 --> 00:00:00,000
You should recognize it and understand it. I don't necessarily encourage you to

381
00:00:00,000 --> 00:00:00,000
write this kind of code. It is no more efficient than the

382
00:00:00,000 --> 00:00:00,000
more understandable code on the previous page. It just took

383
00:00:00,000 --> 00:00:00,000
a little bit of fewer typing. So let me just go

384
00:00:00,000 --> 00:00:00,000
through why that works so you understand it.

385
00:00:00,000 --> 00:00:00,000
So star s will dereference the pointer

386
00:00:00,000 --> 00:00:00,000
s. Dereference the pointer s. However

387
00:00:00,000 --> 00:00:00,000
this is not star s, it's star s plus plus.

388
00:00:00,000 --> 00:00:00,000
And so plus plus and

389
00:00:00,000 --> 00:00:00,000
star have the same precedence.

390
00:00:00,000 --> 00:00:00,000
So the s has to know whether to do the plus plus first or the

391
00:00:00,000 --> 00:00:00,000
star first. And because the precedence is the

392
00:00:00,000 --> 00:00:00,000
same, that won't help it decide. And so it has to fall

393
00:00:00,000 --> 00:00:00,000
back on what we call the tiebreaker rule, associativity, and

394
00:00:00,000 --> 00:00:00,000
decide does this go left to right, star s, and then

395
00:00:00,000 --> 00:00:00,000
increment it, which would mean incrementing the value

396
00:00:00,000 --> 00:00:00,000
that was at s, or does it mean plus plus s

397
00:00:00,000 --> 00:00:00,000
and then dereference the plus plus s.

398
00:00:00,000 --> 00:00:00,000
And these are right associative.

399
00:00:00,000 --> 00:00:00,000
Most operators, arithmetic operators, are less

400
00:00:00,000 --> 00:00:00,000
associated. These are right associative, so the plus plus goes first

401
00:00:00,000 --> 00:00:00,000
with the tiebreaker rule. Now the value

402
00:00:00,000 --> 00:00:00,000
returned from s plus plus is not

403
00:00:00,000 --> 00:00:00,000
the pointer s after it's been changed

404
00:00:00,000 --> 00:00:00,000
it's the pointer s before it's changed, because

405
00:00:00,000 --> 00:00:00,000
this is post-increment. So we take the value

406
00:00:00,000 --> 00:00:00,000
that s had before it was changed, we change s

407
00:00:00,000 --> 00:00:00,000
move it to the second character, return the value of s

408
00:00:00,000 --> 00:00:00,000
that it had before it was changed, dereference that

409
00:00:00,000 --> 00:00:00,000
and if that is not the null character

410
00:00:00,000 --> 00:00:00,000
if it's the null character, this is false. If it

411
00:00:00,000 --> 00:00:00,000
is the null character, then we increment

412
00:00:00,000 --> 00:00:00,000
length, and finally we return length. So this stops

413
00:00:00,000 --> 00:00:00,000
when it dereferences the null character.

414
00:00:00,000 --> 00:00:00,000
Now again, if we look at the previous

415
00:00:00,000 --> 00:00:00,000
example, here we're explicitly saying

416
00:00:00,000 --> 00:00:00,000
while star s is not equal to the null character. Here

417
00:00:00,000 --> 00:00:00,000
we're implicitly saying that. And so I think it's

418
00:00:00,000 --> 00:00:00,000
better always to be explicit. I would prefer that you write code that is

419
00:00:00,000 --> 00:00:00,000
a little clearer and easier to understand. But if you don't understand

420
00:00:00,000 --> 00:00:00,000
what this does, when you actually read C code, and you

421
00:00:00,000 --> 00:00:00,000
see this very common idiom, you'll be confused.

422
00:00:00,000 --> 00:00:00,000
Okay, so we are going

423
00:00:00,000 --> 00:00:00,000
to finish up this lecture by looking at

424
00:00:00,000 --> 00:00:00,000
an example. This is from the online

425
00:00:00,000 --> 00:00:00,000
C-String practice problems in, not coding

426
00:00:00,000 --> 00:00:00,000
bat, in Code Step-by-Step. There's

427
00:00:00,000 --> 00:00:00,000
a link on the home page. But the online version wants to use

428
00:00:00,000 --> 00:00:00,000
the library functions. The version we're going to use is not going to use any

429
00:00:00,000 --> 00:00:00,000
library function. It's very similar to what you'll be asked to do for

430
00:00:00,000 --> 00:00:00,000
PEO8. So we're going to open

431
00:00:00,000 --> 00:00:00,000
countmatches.cpp. We're going to look through an array

432
00:00:00,000 --> 00:00:00,000
of C-style strings, just like we did with PN.

433
00:00:00,000 --> 00:00:00,000
We're going to count the number of strings that contain the first string.

434
00:00:00,000 --> 00:00:00,000
And so this is the really tricky part right here that you need to learn

435
00:00:00,000 --> 00:00:00,000
to understand to do well on PEO8. How do

436
00:00:00,000 --> 00:00:00,000
you see if one string is contained inside another

437
00:00:00,000 --> 00:00:00,000
string? So I'm going to solve it two ways. I'm going to solve it first using

438
00:00:00,000 --> 00:00:00,000
array notation, and then I'll do it using pointer notation.

439
00:00:00,000 --> 00:00:00,000
It's a little easier actually with pointer notation, I think.

440
00:00:00,000 --> 00:00:00,000
But you may prefer it with array notation.

441
00:00:00,000 --> 00:00:00,000
So let's pop that up. Let's go ahead and

442
00:00:00,000 --> 00:00:00,000
close the things we had previously.

443
00:00:00,000 --> 00:00:00,000
[typing]

444
00:00:00,000 --> 00:00:00,000
[typing]

445
00:00:00,000 --> 00:00:00,000
Okay, so

446
00:00:00,000 --> 00:00:00,000
countmatches.cpp. Let's close those

447
00:00:00,000 --> 00:00:00,000
two and let's open a shell on that one.

448
00:00:00,000 --> 00:00:00,000
Yes, we have a shell open on C.

449
00:00:00,000 --> 00:00:00,000
Okay, now notice

450
00:00:00,000 --> 00:00:00,000
I'm going to put my name inside here.

451
00:00:00,000 --> 00:00:00,000
You can put your name and section and date at the top

452
00:00:00,000 --> 00:00:00,000
if you want. You don't have to, but this is the one that is important. So we're writing

453
00:00:00,000 --> 00:00:00,000
a function called countmatches, and it accepts a string

454
00:00:00,000 --> 00:00:00,000
to match, a const char char, an array of characters. So you can

455
00:00:00,000 --> 00:00:00,000
really see it here. That's how it's called.

456
00:00:00,000 --> 00:00:00,000
So if we know that, we know what to write here. And it's going to return the number

457
00:00:00,000 --> 00:00:00,000
of times that it matches. So we'll say int countmatches

458
00:00:00,000 --> 00:00:00,000
const char

459
00:00:00,000 --> 00:00:00,000
star str

460
00:00:00,000 --> 00:00:00,000
str

461
00:00:00,000 --> 00:00:00,000
Let's call that, it has it as strs

462
00:00:00,000 --> 00:00:00,000
up there, but let's call this one arrays.

463
00:00:00,000 --> 00:00:00,000
So

464
00:00:00,000 --> 00:00:00,000
that's our

465
00:00:00,000 --> 00:00:00,000
array.

466
00:00:00,000 --> 00:00:00,000
And then we're going to have a size T.

467
00:00:00,000 --> 00:00:00,000
This is the length

468
00:00:00,000 --> 00:00:00,000
of the array.

469
00:00:00,000 --> 00:00:00,000
So that's pretty easy to loop through this array.

470
00:00:00,000 --> 00:00:00,000
So let's go ahead and run this.

471
00:00:00,000 --> 00:00:00,000
So we'll go for size

472
00:00:00,000 --> 00:00:00,000
T, i = 0

473
00:00:00,000 --> 00:00:00,000
i < n++i

474
00:00:00,000 --> 00:00:00,000
And then what we want is

475
00:00:00,000 --> 00:00:00,000
arr sub i and see if it contains the string.

476
00:00:00,000 --> 00:00:00,000
Now instead of actually doing that,

477
00:00:00,000 --> 00:00:00,000
I'm going to write a function. So I'm going to write my function

478
00:00:00,000 --> 00:00:00,000
right up here, because the function is the guts of what we want.

479
00:00:00,000 --> 00:00:00,000
So I'm going to say if

480
00:00:00,000 --> 00:00:00,000
if contains

481
00:00:00,000 --> 00:00:00,000
arr sub i

482
00:00:00,000 --> 00:00:00,000
str

483
00:00:00,000 --> 00:00:00,000
Here's what I want to write.

484
00:00:00,000 --> 00:00:00,000
if arr

485
00:00:00,000 --> 00:00:00,000
i contains str

486
00:00:00,000 --> 00:00:00,000
So figuring out how to put that in a function is

487
00:00:00,000 --> 00:00:00,000
hard.

488
00:00:00,000 --> 00:00:00,000
Or is in

489
00:00:00,000 --> 00:00:00,000
if is in

490
00:00:00,000 --> 00:00:00,000
contains is nicer.

491
00:00:00,000 --> 00:00:00,000
It's hard to know whether to put the arr first or the string,

492
00:00:00,000 --> 00:00:00,000
but I would want to say if arr i contains the string,

493
00:00:00,000 --> 00:00:00,000
then what I want to do is update my result.

494
00:00:00,000 --> 00:00:00,000
So result++

495
00:00:00,000 --> 00:00:00,000
Of course we haven't created our result, so int result

496
00:00:00,000 --> 00:00:00,000
equals 0

497
00:00:00,000 --> 00:00:00,000
and return result

498
00:00:00,000 --> 00:00:00,000
So that's simple enough that that looks like it should work okay.

499
00:00:00,000 --> 00:00:00,000
So the hard part of this is figuring out how to write

500
00:00:00,000 --> 00:00:00,000
contains. So we're going to have

501
00:00:00,000 --> 00:00:00,000
two strings. It's going to be a boolean

502
00:00:00,000 --> 00:00:00,000
contains const char

503
00:00:00,000 --> 00:00:00,000
star s1 and const

504
00:00:00,000 --> 00:00:00,000
char star s2

505
00:00:00,000 --> 00:00:00,000
and let's just return

506
00:00:00,000 --> 00:00:00,000
false here.

507
00:00:00,000 --> 00:00:00,000
And if we find it, we'll return true.

508
00:00:00,000 --> 00:00:00,000
Okay, so we actually have enough here. We have enough to

509
00:00:00,000 --> 00:00:00,000
stub it. We've stubbed it out. And so we can try it. So we can say

510
00:00:00,000 --> 00:00:00,000
make test

511
00:00:00,000 --> 00:00:00,000
and we see none of those

512
00:00:00,000 --> 00:00:00,000
fail because it returns 0 in each case, right? It doesn't find any.

513
00:00:00,000 --> 00:00:00,000
And so now

514
00:00:00,000 --> 00:00:00,000
we're ready to think about contains. So contains

515
00:00:00,000 --> 00:00:00,000
is going to be arr sub i and if we look at

516
00:00:00,000 --> 00:00:00,000
this example right here, we'll see arr sub i is going to be

517
00:00:00,000 --> 00:00:00,000
rainbow. So does rainbow contain o?

518
00:00:00,000 --> 00:00:00,000
It does. So

519
00:00:00,000 --> 00:00:00,000
imagine, and I said I was going to

520
00:00:00,000 --> 00:00:00,000
do this two ways, right? I was going to do it with an array

521
00:00:00,000 --> 00:00:00,000
and a string and so

522
00:00:00,000 --> 00:00:00,000
let's do it first with an array.

523
00:00:00,000 --> 00:00:00,000
Okay, so

524
00:00:00,000 --> 00:00:00,000
we need to have a couple of variables.

525
00:00:00,000 --> 00:00:00,000
One variable is going to go through s1.

526
00:00:00,000 --> 00:00:00,000
So I'm going to do size t for these.

527
00:00:00,000 --> 00:00:00,000
You can do int. It's fine.

528
00:00:00,000 --> 00:00:00,000
And I'll call that i1.

529
00:00:00,000 --> 00:00:00,000
And so we're going to say while

530
00:00:00,000 --> 00:00:00,000
s1

531
00:00:00,000 --> 00:00:00,000
at i1 is not equal to the

532
00:00:00,000 --> 00:00:00,000
null character

533
00:00:00,000 --> 00:00:00,000
i1++

534
00:00:00,000 --> 00:00:00,000
That will walk us

535
00:00:00,000 --> 00:00:00,000
through this string. That will walk us through this string.

536
00:00:00,000 --> 00:00:00,000
Now we want to

537
00:00:00,000 --> 00:00:00,000
at each point in here, we want to see if

538
00:00:00,000 --> 00:00:00,000
s2 is at that point. So we're going to create

539
00:00:00,000 --> 00:00:00,000
another variable, i2.

540
00:00:00,000 --> 00:00:00,000
So size p i2

541
00:00:00,000 --> 00:00:00,000
and we're going to say

542
00:00:00,000 --> 00:00:00,000
while

543
00:00:00,000 --> 00:00:00,000
s2

544
00:00:00,000 --> 00:00:00,000
i2

545
00:00:00,000 --> 00:00:00,000
is equal to

546
00:00:00,000 --> 00:00:00,000
s1

547
00:00:00,000 --> 00:00:00,000
i1

548
00:00:00,000 --> 00:00:00,000
plus i2

549
00:00:00,000 --> 00:00:00,000
because we're going to have to look at the first character here

550
00:00:00,000 --> 00:00:00,000
the first character here, the second character here

551
00:00:00,000 --> 00:00:00,000
the second character here, and so we're going to have to offset s1

552
00:00:00,000 --> 00:00:00,000
by not only its index, but the index

553
00:00:00,000 --> 00:00:00,000
of the second character.

554
00:00:00,000 --> 00:00:00,000
So while those are the same

555
00:00:00,000 --> 00:00:00,000
and s2

556
00:00:00,000 --> 00:00:00,000
i2 is not equal to

557
00:00:00,000 --> 00:00:00,000
the null character and

558
00:00:00,000 --> 00:00:00,000
s1 i1 plus i2

559
00:00:00,000 --> 00:00:00,000
is not equal to the

560
00:00:00,000 --> 00:00:00,000
null character

561
00:00:00,000 --> 00:00:00,000
we're going to increment i2

562
00:00:00,000 --> 00:00:00,000
i2++

563
00:00:00,000 --> 00:00:00,000
That means that at some point

564
00:00:00,000 --> 00:00:00,000
we're either going to read all of s2

565
00:00:00,000 --> 00:00:00,000
and this is going to fail or

566
00:00:00,000 --> 00:00:00,000
the characters are not going to match

567
00:00:00,000 --> 00:00:00,000
like that will immediately not match when we try to compare the o here to the r there

568
00:00:00,000 --> 00:00:00,000
will drop out. So after we drop out

569
00:00:00,000 --> 00:00:00,000
in other words this while loop is guaranteed to drop out

570
00:00:00,000 --> 00:00:00,000
it's guaranteed to drop out

571
00:00:00,000 --> 00:00:00,000
and after we drop out, if we are looking at the null

572
00:00:00,000 --> 00:00:00,000
character after the end of this ow

573
00:00:00,000 --> 00:00:00,000
in other words if

574
00:00:00,000 --> 00:00:00,000
s2 i2 is equal to the null character

575
00:00:00,000 --> 00:00:00,000
then we have found our character. So if

576
00:00:00,000 --> 00:00:00,000
s2 sub i2

577
00:00:00,000 --> 00:00:00,000
equals the null character

578
00:00:00,000 --> 00:00:00,000
then

579
00:00:00,000 --> 00:00:00,000
got a parenthesis in the wrong place there

580
00:00:00,000 --> 00:00:00,000
then we're just going to return true

581
00:00:00,000 --> 00:00:00,000
ok so this is doing contains

582
00:00:00,000 --> 00:00:00,000
now we have actually one problem here and you'll see it here

583
00:00:00,000 --> 00:00:00,000
in a minute. It actually works for most of the

584
00:00:00,000 --> 00:00:00,000
characters but not for all of them. So we'll go make tests

585
00:00:00,000 --> 00:00:00,000
and you can see it doesn't work for this one

586
00:00:00,000 --> 00:00:00,000
and this one. So what is s2

587
00:00:00,000 --> 00:00:00,000
in these two cases? It's the null string

588
00:00:00,000 --> 00:00:00,000
it's the empty string and notice we have this little

589
00:00:00,000 --> 00:00:00,000
sentence here. The empty string is a substring of any string

590
00:00:00,000 --> 00:00:00,000
you may assume, so an empty string is a substring

591
00:00:00,000 --> 00:00:00,000
of any string. So what that means is we have to say

592
00:00:00,000 --> 00:00:00,000
if star

593
00:00:00,000 --> 00:00:00,000
if s2 sub 0 equals

594
00:00:00,000 --> 00:00:00,000
the null string, or the null byte

595
00:00:00,000 --> 00:00:00,000
then it's the empty string so we're going to return

596
00:00:00,000 --> 00:00:00,000
true. That means it matches any string. So we have this

597
00:00:00,000 --> 00:00:00,000
special case here for this sentence right in here

598
00:00:00,000 --> 00:00:00,000
and that should take us from 67%

599
00:00:00,000 --> 00:00:00,000
to 100%

600
00:00:00,000 --> 00:00:00,000
so that does

601
00:00:00,000 --> 00:00:00,000
take us to 100%. Now let's do one more

602
00:00:00,000 --> 00:00:00,000
let's do one more and that is

603
00:00:00,000 --> 00:00:00,000
I want to, I'm going to leave this here so you can

604
00:00:00,000 --> 00:00:00,000
see it. I'm going to change its name

605
00:00:00,000 --> 00:00:00,000
to xcontains. So we won't

606
00:00:00,000 --> 00:00:00,000
actually be calling it. And I'm going to

607
00:00:00,000 --> 00:00:00,000
write a version of contains that only uses pointers

608
00:00:00,000 --> 00:00:00,000
so bool

609
00:00:00,000 --> 00:00:00,000
contains const char star

610
00:00:00,000 --> 00:00:00,000
s1 const char star s2

611
00:00:00,000 --> 00:00:00,000
I'm going to

612
00:00:00,000 --> 00:00:00,000
say file

613
00:00:00,000 --> 00:00:00,000
star

614
00:00:00,000 --> 00:00:00,000
s1 is not equal to the null character

615
00:00:00,000 --> 00:00:00,000
and of course you know we could write this as file

616
00:00:00,000 --> 00:00:00,000
star s1. I mean that would be the same

617
00:00:00,000 --> 00:00:00,000
thing.

618
00:00:00,000 --> 00:00:00,000
s1++

619
00:00:00,000 --> 00:00:00,000
If we get down here we're going to return false

620
00:00:00,000 --> 00:00:00,000
if

621
00:00:00,000 --> 00:00:00,000
star s2

622
00:00:00,000 --> 00:00:00,000
equals the null character or if not

623
00:00:00,000 --> 00:00:00,000
star s2 we're going to return true

624
00:00:00,000 --> 00:00:00,000
and here we're going to try and do the same thing we did before

625
00:00:00,000 --> 00:00:00,000
so I'm going to create a couple of pointers. I'm going to say

626
00:00:00,000 --> 00:00:00,000
auto p1 equals s1

627
00:00:00,000 --> 00:00:00,000
auto p2 equals s2

628
00:00:00,000 --> 00:00:00,000
while star p1 equals

629
00:00:00,000 --> 00:00:00,000
star p2 and

630
00:00:00,000 --> 00:00:00,000
star p1 is not equal to the

631
00:00:00,000 --> 00:00:00,000
null character or while star p1

632
00:00:00,000 --> 00:00:00,000
and star p2 is not

633
00:00:00,000 --> 00:00:00,000
equal to the null character

634
00:00:00,000 --> 00:00:00,000
hold on I'm having a hard time

635
00:00:00,000 --> 00:00:00,000
finding that character there

636
00:00:00,000 --> 00:00:00,000
null character

637
00:00:00,000 --> 00:00:00,000
we're going to do p1++ p2++

638
00:00:00,000 --> 00:00:00,000
now when we get

639
00:00:00,000 --> 00:00:00,000
out of this if p2

640
00:00:00,000 --> 00:00:00,000
which is pointing to s2 if that is pointing

641
00:00:00,000 --> 00:00:00,000
to the null byte in other words if we got out of this loop because

642
00:00:00,000 --> 00:00:00,000
that was true then the

643
00:00:00,000 --> 00:00:00,000
character is there so if

644
00:00:00,000 --> 00:00:00,000
star p2 is equal to the null byte

645
00:00:00,000 --> 00:00:00,000
return true

646
00:00:00,000 --> 00:00:00,000
I find this a little bit easier mainly

647
00:00:00,000 --> 00:00:00,000
because when I'm using pointers I don't have to do this addition

648
00:00:00,000 --> 00:00:00,000
here of the offsets to get the value and that

649
00:00:00,000 --> 00:00:00,000
part kind of always confuses me here so I find this a little bit

650
00:00:00,000 --> 00:00:00,000
clearer and cleaner

651
00:00:00,000 --> 00:00:00,000
in your text this algorithm is shown at the last

652
00:00:00,000 --> 00:00:00,000
part of this chapter and so it's important that you learn and

653
00:00:00,000 --> 00:00:00,000
memorize this algorithm so let's go ahead and copy

654
00:00:00,000 --> 00:00:00,000
that or test it let's do make test

655
00:00:00,000 --> 00:00:00,000
and we got 100% once

656
00:00:00,000 --> 00:00:00,000
again. Okay so that's it for lecture

657
00:00:00,000 --> 00:00:00,000
22 I will see you guys next time

658
00:00:00,000 --> 00:00:00,000
Thank you.

