
1
00:00:00,000 --> 00:00:08,000
Hello folks, this is Steve Gilbert. Welcome to lecture 2 on C++ syntax and variables.

2
00:00:08,000 --> 00:00:22,000
So before you get started, make sure that you've gone over to lecture 2 and you've started the, uh, downloaded the, uh, starter file, the in-class exercises file here.

3
00:00:22,000 --> 00:00:26,000
This is going to be the problem that we're going to work on today.

4
00:00:26,000 --> 00:00:33,000
So let's talk about what computers actually do.

5
00:00:33,000 --> 00:00:35,000
What do computers actually do?

6
00:00:35,000 --> 00:00:45,000
Well, computers take input, which is raw data, they convert that input or process it, and they output it as information.

7
00:00:45,000 --> 00:00:51,000
This is the fundamental process that every piece of computing goes through.

8
00:00:51,000 --> 00:01:07,000
It's kind of like a Cuisinart. With my Cuisinart I can take onions, I can take peppers, I can take tomatoes, and I can put them in the Cuisinart, and the Cuisinart will chop them and process them, and I will get salsa as my output.

9
00:01:07,000 --> 00:01:17,000
So we're going to look at this input processing and output, uh, technique while writing a C++ IPO program.

10
00:01:17,000 --> 00:01:22,000
So let's go ahead and look at the instructions for that program.

11
00:01:22,000 --> 00:01:25,000
So here's our problem description.

12
00:01:25,000 --> 00:01:33,000
Workers at a particular company have won a 7.6% pay increase, retroactive for six months.

13
00:01:33,000 --> 00:01:46,000
We're going to write a program that takes an employee's previous annual salary as input, and outputs the amount of retroactive pay to the employee, the new annual salary, and the new monthly salary.

14
00:01:46,000 --> 00:01:52,000
Use a variable declaration with the modifier const to express the pay increase.

15
00:01:52,000 --> 00:01:59,000
Then the instructions give us some, uh, a picture showing us what the output looks like.

16
00:01:59,000 --> 00:02:02,000
This should be called a mockup or a sample run.

17
00:02:02,000 --> 00:02:06,000
So you notice we're going to ask the user to enter the current annual salary.

18
00:02:06,000 --> 00:02:09,000
They're going to type in a number, 10,000 here.

19
00:02:09,000 --> 00:02:14,000
And then it's going to print out the new annual, the new monthly, and retroactive salary.

20
00:02:14,000 --> 00:02:18,000
And it has those three numbers inside a set of brackets.

21
00:02:18,000 --> 00:02:25,000
Those brackets are simply to make it easy for us to test the code to make sure that we have the output.

22
00:02:25,000 --> 00:02:30,000
So, how do we solve this problem?

23
00:02:30,000 --> 00:02:33,000
Well, how do we solve any computer problem?

24
00:02:33,000 --> 00:02:40,000
We solve any computer problem by designing the inputs, the outputs, and the calculations.

25
00:02:40,000 --> 00:02:43,000
So let's talk about that, and let's look at that.

26
00:02:43,000 --> 00:02:46,000
Now I'm going to go over to our IDE.

27
00:02:46,000 --> 00:02:49,000
I have opened up the problem over here.

28
00:02:49,000 --> 00:02:55,000
And so notice this is in our IC folder that we downloaded when you first started.

29
00:02:55,000 --> 00:03:03,000
And in the IC folder, in IC02, for lecture two, notice we have a lib salary calc A.

30
00:03:03,000 --> 00:03:09,000
This is a binary library that's going to contain the testing code and so forth.

31
00:03:09,000 --> 00:03:14,000
We have a make file, which is going to control the building of the program.

32
00:03:14,000 --> 00:03:18,000
And we have the file that we're going to work on, salary calc.

33
00:03:18,000 --> 00:03:20,000
So click that, open it up.

34
00:03:20,000 --> 00:03:26,000
You can drag the terminal down here near the bottom so it's not taking up so much space.

35
00:03:26,000 --> 00:03:33,000
And we're going to go ahead and put our names on this in two places, just like you saw with the homework.

36
00:03:33,000 --> 00:03:36,000
So, Steven Gilbert.

37
00:03:36,000 --> 00:03:40,000
And for the date, I'm just going to put the semester.

38
00:03:40,000 --> 00:03:47,000
Actually, I'm going to put CS150 so I could perhaps use this video for another semester.

39
00:03:47,000 --> 00:03:55,000
Secondly, we're always going to make sure you put in your user name, your Canvas login name here.

40
00:03:55,000 --> 00:03:58,000
It needs to be all in lower case.

41
00:03:58,000 --> 00:04:00,000
Mine's S. Gilbert.

42
00:04:00,000 --> 00:04:05,000
Yours will be whatever you use to log into the CS150 Homework Console.

43
00:04:05,000 --> 00:04:09,000
And we're going to put one line that describes what the program does.

44
00:04:09,000 --> 00:04:24,000
And it's going to calculate wages after salary increase.

45
00:04:24,000 --> 00:04:33,000
Now, to figure out the inputs, outputs, and processing, the easiest way to do that is simply to take the problem over here.

46
00:04:33,000 --> 00:04:37,000
I'm going to copy it from the problem description.

47
00:04:37,000 --> 00:04:42,000
Come over to our IDE.

48
00:04:42,000 --> 00:04:47,000
And paste it in here where it says "Add your implementation comments" here.

49
00:04:47,000 --> 00:04:49,000
So I'm just going to paste that there.

50
00:04:49,000 --> 00:04:54,000
And then I'm going to go ahead and I'm just going to break that into multiple lines.

51
00:04:54,000 --> 00:05:03,000
I'm just using my mouse and the Enter key.

52
00:05:03,000 --> 00:05:14,000
And I'm going to make it into a nice comment so that I can read it when I'm working on my code, rather than having to keep going back to the instructions.

53
00:05:14,000 --> 00:05:19,000
Now, I'm going to select all this code, just with my mouse like that.

54
00:05:19,000 --> 00:05:23,000
Then I'm going to hold down my Control key and the forward slash key.

55
00:05:23,000 --> 00:05:25,000
It's the one with the question mark on it.

56
00:05:25,000 --> 00:05:35,000
And notice that that is going to comment that code out so that I can look at this and find out what the inputs, outputs, and processing are.

57
00:05:35,000 --> 00:05:40,000
So, what are the inputs that we can see from this problem statement?

58
00:05:40,000 --> 00:05:46,000
Well, it says it's going to take an employee's previous annual salary.

59
00:05:46,000 --> 00:06:05,000
So I'm going to write here as a comment, "Input, annual salary."

60
00:06:05,000 --> 00:06:08,000
Now, what is the output?

61
00:06:08,000 --> 00:06:13,000
It's going to output the amount of retroactive pay.

62
00:06:13,000 --> 00:06:24,000
So, outputs is retroactive pay.

63
00:06:24,000 --> 00:06:39,000
It is new annual and monthly salaries.

64
00:06:39,000 --> 00:06:44,000
Okay, so I know that I have the input.

65
00:06:44,000 --> 00:06:47,000
The output, is anything given about this problem?

66
00:06:47,000 --> 00:06:49,000
Or do we assume anything?

67
00:06:49,000 --> 00:07:11,000
So, given or the assumption is that pay increase is 7.6% for 6 months.

68
00:07:11,000 --> 00:07:26,000
So, the pay increase is 7.6%. The retroactive pay is for 6 months.

69
00:07:26,000 --> 00:07:34,000
Okay, so let's figure out, so we've figured out what the inputs, the output, and the salary is.

70
00:07:34,000 --> 00:07:38,000
So now we need to figure out how to calculate the salary.

71
00:07:38,000 --> 00:07:43,000
We need to put in the algorithms here.

72
00:07:43,000 --> 00:07:47,000
So again, we do this before we write a single line of code.

73
00:07:47,000 --> 00:07:50,000
We figure out what we're going to do.

74
00:07:50,000 --> 00:08:19,000
So, the processing step for new annual is going to be take the annual salary and multiply it times 1 plus the pay increase.

75
00:08:19,000 --> 00:08:47,000
Okay, now that we have the new annual salary for the new monthly, I'm going to take the new annual salary and divide it by 12.

76
00:08:47,000 --> 00:08:54,000
12 for the month per year.

77
00:08:54,000 --> 00:08:57,000
And finally, we have one last piece of processing.

78
00:08:57,000 --> 00:09:01,000
I need the retro pay.

79
00:09:01,000 --> 00:09:12,000
And that I'm going to get by taking the new annual, the old annual, new annual, which will be larger.

80
00:09:12,000 --> 00:09:26,000
Subtracting the old annual and then dividing that whole thing, that difference, by 2.

81
00:09:26,000 --> 00:09:33,000
Because remember, they're only getting paid for 6 months and 6 months is half of a year.

82
00:09:33,000 --> 00:09:42,000
Okay, so once I've done that, I can get rid of my problem statement that I've put up here.

83
00:09:42,000 --> 00:09:50,000
And I have a plan or a goal or a way to start.

84
00:09:50,000 --> 00:09:54,000
So this is what we did.

85
00:09:54,000 --> 00:09:59,000
We designed the inputs, the outputs, and the calculations.

86
00:09:59,000 --> 00:10:04,000
And then we added our IDs and our comments to the file.

87
00:10:04,000 --> 00:10:11,000
Now step 2 for these kinds of programs is always just to mock up the input and the output.

88
00:10:11,000 --> 00:10:14,000
And use literals for each piece.

89
00:10:14,000 --> 00:10:18,000
So let's look at what the output looks like.

90
00:10:18,000 --> 00:10:24,000
So this is what the output should look like. I'm just going to copy it here.

91
00:10:24,000 --> 00:10:28,000
I'm going to come over to my IDE.

92
00:10:28,000 --> 00:10:36,000
And I'm going to paste it here where it says write your code here.

93
00:10:36,000 --> 00:10:44,000
Now, one neat thing you can do with your editor is I can hold down my Alt key.

94
00:10:44,000 --> 00:10:49,000
And I can move it through two lines like that.

95
00:10:49,000 --> 00:10:55,000
Oh no, I can't.

96
00:10:55,000 --> 00:10:59,000
No, I take that back. We can do it in the old editor. We can't do it in the next editor.

97
00:10:59,000 --> 00:11:02,000
So I'm just going to select those lines I'm going to tab over.

98
00:11:02,000 --> 00:11:10,000
And then I'm going to put quotes around the parts that I want to stay as is.

99
00:11:10,000 --> 00:11:14,000
Quote.

100
00:11:14,000 --> 00:11:17,000
Quote.

101
00:11:17,000 --> 00:11:25,000
And quote.

102
00:11:25,000 --> 00:11:30,000
Quote.

103
00:11:30,000 --> 00:11:42,000
So the part that's going to stay plain text, I'm putting inside quotes to turn it into a string.

104
00:11:42,000 --> 00:11:46,000
And now I'm just going to use the cout object on that to print that out.

105
00:11:46,000 --> 00:11:52,000
I'm going to say cout. I'm going to print out that first string part.

106
00:11:52,000 --> 00:11:54,000
Then I'm going to print out the dollars.

107
00:11:54,000 --> 00:11:58,000
And then that's the end of that line, so I'm going to print an end line.

108
00:11:58,000 --> 00:12:00,000
I'm going to do the same thing for the second line.

109
00:12:00,000 --> 00:12:05,000
Cout.

110
00:12:05,000 --> 00:12:07,000
I'm going to print that text.

111
00:12:07,000 --> 00:12:12,000
Now here I don't really like a long line, so I'm going to bring this one down like that.

112
00:12:12,000 --> 00:12:16,000
Tab it over so it's indented.

113
00:12:16,000 --> 00:12:20,000
And put the operator there, the output operator.

114
00:12:20,000 --> 00:12:23,000
I'm going to put the output operator between those two pieces.

115
00:12:23,000 --> 00:12:27,000
The output operator between those two pieces.

116
00:12:27,000 --> 00:12:30,000
The output operator between those two pieces.

117
00:12:30,000 --> 00:12:33,000
Those two pieces.

118
00:12:33,000 --> 00:12:35,000
Those two pieces.

119
00:12:35,000 --> 00:12:42,000
And finally a new line at the end of it.

120
00:12:42,000 --> 00:12:50,000
Okay, so now I have figured out what I want to do. I've planned.

121
00:12:50,000 --> 00:12:56,000
I have mocked up the output. Let's see if it works.

122
00:12:56,000 --> 00:13:01,000
We're going to do that by first making sure we're in this folder.

123
00:13:01,000 --> 00:13:08,000
The way we're going to do that is I'm going to right click on the A, that is the name of that folder, ICO2A.

124
00:13:08,000 --> 00:13:12,000
And I'm going to say Open in Integrated Terminal.

125
00:13:12,000 --> 00:13:19,000
And notice my terminal then is going to have the full path to where I'm building my program.

126
00:13:19,000 --> 00:13:26,000
If it doesn't have the full path, if it just says $, that means you're in the wrong folder.

127
00:13:26,000 --> 00:13:32,000
So let's run this. Let's do Make Run.

128
00:13:32,000 --> 00:13:37,000
So that compiles it, that runs it, that prints the output.

129
00:13:37,000 --> 00:13:42,000
And if I look at this output, enter the current salary, there's a space here like there should be.

130
00:13:42,000 --> 00:13:50,000
There's a space here and there's spaces and commas between each of these as there should be.

131
00:13:50,000 --> 00:13:55,000
And I compare that to this output. It looks almost the same.

132
00:13:55,000 --> 00:14:06,000
Now we have one slight problem here is that we don't have the correct number of decimal places for two of these numbers.

133
00:14:06,000 --> 00:14:10,000
I believe one of them is okay, the 6-7, yeah the 6-7 looks okay.

134
00:14:10,000 --> 00:14:15,000
These two aren't showing the decimal places. We'll see how to figure that out later.

135
00:14:15,000 --> 00:14:22,000
So again, this is the part that you can simply memorize and learn how to do.

136
00:14:22,000 --> 00:14:27,000
This is a technique for building these kinds of programs that you can do very quickly

137
00:14:27,000 --> 00:14:32,000
so you can get the format for the output correct.

138
00:14:32,000 --> 00:14:42,000
So now, let's go ahead and talk about variables and values to actually solve this program.

139
00:14:42,000 --> 00:14:52,000
And so, okay, so we ran it and we compared it to the hand output, handout.

140
00:14:52,000 --> 00:14:55,000
And now we're going to talk about variables and values.

141
00:14:55,000 --> 00:15:03,000
So what's a variable? A variable is simply a box that is made out of memory.

142
00:15:03,000 --> 00:15:14,000
So your computer has a CPU, it has memory, it has external storage like a hard disk or something like that.

143
00:15:14,000 --> 00:15:20,000
It has input and output devices. But memory and CPU are the main parts of it.

144
00:15:20,000 --> 00:15:24,000
And memory is where we are going to store data.

145
00:15:24,000 --> 00:15:32,000
So if I take three or four blocks of memory, what we call bytes, that could be a box.

146
00:15:32,000 --> 00:15:40,000
Programs store their data that they get for input and they process in things called variables.

147
00:15:40,000 --> 00:15:44,000
So a variable is like a box and it has a label on it.

148
00:15:44,000 --> 00:15:49,000
The label is going to describe the kind of thing that's in the box.

149
00:15:49,000 --> 00:15:55,000
The box is memory, the label is its name.

150
00:15:55,000 --> 00:15:59,000
Now with this box, we can put something into it.

151
00:15:59,000 --> 00:16:04,000
That means we can initialize a variable with a value.

152
00:16:04,000 --> 00:16:09,000
We can take something out of it. That means we can read it or print it or output it.

153
00:16:09,000 --> 00:16:11,000
Finally, we can change what's in the box.

154
00:16:11,000 --> 00:16:16,000
We can assign to the variable and put a new value into the box.

155
00:16:16,000 --> 00:16:19,000
So this is just an analogy, of course.

156
00:16:19,000 --> 00:16:24,000
It's a way of thinking about what's going on with variables.

157
00:16:24,000 --> 00:16:28,000
Now the size of the box restricts what you can put in it.

158
00:16:28,000 --> 00:16:31,000
If you have a little box, you might put jewelry in it.

159
00:16:31,000 --> 00:16:35,000
If you have a bigger box, you might put a hat or something like that in it.

160
00:16:35,000 --> 00:16:39,000
So the size of the box restricts what you can store.

161
00:16:39,000 --> 00:16:44,000
Again, this is an analogy. If you have one byte, you can store a certain amount of things.

162
00:16:44,000 --> 00:16:50,000
If you have ten bytes, you can store something larger and a different kind of thing.

163
00:16:50,000 --> 00:16:55,000
So this concept, the fact that variables hold data

164
00:16:55,000 --> 00:17:01,000
and that data can be different types is called a values type.

165
00:17:01,000 --> 00:17:08,000
So inside a variable, we call that information, the things that are in that byte, its value.

166
00:17:08,000 --> 00:17:12,000
A variable can have different values as the program runs.

167
00:17:12,000 --> 00:17:18,000
It might start out with one value, and later on as the program runs, we'll change it to a different value.

168
00:17:18,000 --> 00:17:22,000
There are also different kinds of values we can put in variables.

169
00:17:22,000 --> 00:17:26,000
We have different kinds of containers for each of those values.

170
00:17:26,000 --> 00:17:32,000
So if you go down to 7-Eleven and you buy coffee, they give you one kind of container to hold the coffee.

171
00:17:32,000 --> 00:17:36,000
If you buy a Big Gulp or a Slurpee, they give you a different kind of container.

172
00:17:36,000 --> 00:17:39,000
Popcorn goes in a different kind of container as well.

173
00:17:39,000 --> 00:17:46,000
In addition, you can have different sizes of containers for the same kind of things.

174
00:17:46,000 --> 00:17:53,000
So you could buy a Big Gulp, which is 32 ounces, or a Super Big Gulp, which is 64 ounces.

175
00:17:53,000 --> 00:17:59,000
We do something similar with variables and values.

176
00:17:59,000 --> 00:18:05,000
So a value is a quantity of data.

177
00:18:05,000 --> 00:18:10,000
So 1 is a value. 3.1459 is a value.

178
00:18:10,000 --> 00:18:13,000
Steve is a value, in double quotes.

179
00:18:13,000 --> 00:18:16,000
D is a value, in single quotes.

180
00:18:16,000 --> 00:18:18,000
True is a value.

181
00:18:18,000 --> 00:18:22,000
And each of those values represent different kinds of things.

182
00:18:22,000 --> 00:18:25,000
1 represents an integer.

183
00:18:25,000 --> 00:18:30,000
3.1459 represents a floating point or real number.

184
00:18:30,000 --> 00:18:34,000
Steve, in double quotes, represents what we call a string.

185
00:18:34,000 --> 00:18:37,000
D represents a character.

186
00:18:37,000 --> 00:18:40,000
And true represents a Boolean value.

187
00:18:40,000 --> 00:18:42,000
You've already seen the objects Cout.

188
00:18:42,000 --> 00:18:45,000
Cout represents a stream object.

189
00:18:45,000 --> 00:18:50,000
So values are quantities of data.

190
00:18:50,000 --> 00:18:59,000
Now, the kind of value is called the variables type.

191
00:18:59,000 --> 00:19:05,000
And our formal definition for a value is simply a set of bits.

192
00:19:05,000 --> 00:19:09,000
So if you have one byte, you have eight bits.

193
00:19:09,000 --> 00:19:14,000
If you have two bytes, you have 16 bits.

194
00:19:14,000 --> 00:19:20,000
If we take those bits by themselves, they don't have any meaning.

195
00:19:20,000 --> 00:19:24,000
If we interpret them according to their type, they have a meaning.

196
00:19:24,000 --> 00:19:30,000
So if we say that this byte in memory is a character,

197
00:19:30,000 --> 00:19:33,000
it may represent the letter capital A.

198
00:19:33,000 --> 00:19:38,000
If we take the same set of bits, exactly the same set of bits,

199
00:19:38,000 --> 00:19:42,000
and we say, no, we're going to interpret that as an integer,

200
00:19:42,000 --> 00:19:45,000
it would have the value 65.

201
00:19:45,000 --> 00:19:52,000
So a value is a set of bits that we interpret according to its type.

202
00:19:52,000 --> 00:19:57,000
So if that's a value, what is a variable?

203
00:19:57,000 --> 00:19:59,000
So a variable, I've already given you an analogy.

204
00:19:59,000 --> 00:20:01,000
It's a box of memory.

205
00:20:01,000 --> 00:20:06,000
But mainly, but formally, it's a named storage location

206
00:20:06,000 --> 00:20:08,000
that holds a value.

207
00:20:08,000 --> 00:20:13,000
Now in C++, we can use pretty much the same names

208
00:20:13,000 --> 00:20:16,000
that you would use in Java or Python.

209
00:20:16,000 --> 00:20:22,000
Generally, the name has to start with a upper or lowercase letter,

210
00:20:22,000 --> 00:20:26,000
and it can contain numbers or underscores.

211
00:20:26,000 --> 00:20:28,000
It cannot contain spaces.

212
00:20:28,000 --> 00:20:30,000
It cannot contain hyphens.

213
00:20:30,000 --> 00:20:34,000
There are some other requirements about where the underscores can appear.

214
00:20:34,000 --> 00:20:38,000
It cannot contain dollar signs like some names in Java can.

215
00:20:38,000 --> 00:20:42,000
And the names all have to be ASCII characters.

216
00:20:42,000 --> 00:20:45,000
They cannot be Unicode characters.

217
00:20:45,000 --> 00:20:49,000
So in Java, for instance, although I'm sure most of you never did this,

218
00:20:49,000 --> 00:20:54,000
you could use the symbol pi, which is, of course, a Greek letter,

219
00:20:54,000 --> 00:20:56,000
as the name of a variable.

220
00:20:56,000 --> 00:20:59,000
You can't do that in C++.

221
00:20:59,000 --> 00:21:04,000
So a variable is a named storage location that holds a value.

222
00:21:04,000 --> 00:21:08,000
It's not the same as a value.

223
00:21:08,000 --> 00:21:12,000
We say that a variable is something that we can point to it in memory

224
00:21:12,000 --> 00:21:15,000
if we visualize memory and say,

225
00:21:15,000 --> 00:21:19,000
"This variable lives at that location."

226
00:21:19,000 --> 00:21:21,000
We say that it's addressable.

227
00:21:21,000 --> 00:21:25,000
And the name we use for things that are addressable like that

228
00:21:25,000 --> 00:21:27,000
are objects.

229
00:21:27,000 --> 00:21:31,000
So variables and objects, kind of in the lower case,

230
00:21:31,000 --> 00:21:34,000
not the object-oriented sense of objects,

231
00:21:34,000 --> 00:21:38,000
are things in memory that hold a value

232
00:21:38,000 --> 00:21:41,000
and that they're addressable.

233
00:21:41,000 --> 00:21:47,000
Now, each variable holds values of one type.

234
00:21:47,000 --> 00:21:50,000
What that means is, unlike, say, Python,

235
00:21:50,000 --> 00:21:52,000
those of you who came from Python,

236
00:21:52,000 --> 00:21:55,000
you cannot create a variable A

237
00:21:55,000 --> 00:21:58,000
and put an integer in it at one time

238
00:21:58,000 --> 00:22:01,000
and then put a string in it at another time.

239
00:22:01,000 --> 00:22:04,000
Each variable holds a value of one type.

240
00:22:04,000 --> 00:22:12,000
So we say that these variables are strongly typed in C++.

241
00:22:12,000 --> 00:22:17,000
Now, to create, that is, to declare and to define a variable,

242
00:22:17,000 --> 00:22:19,000
we do two things.

243
00:22:19,000 --> 00:22:23,000
We give it a name, and we specify the kind of thing it holds,

244
00:22:23,000 --> 00:22:25,000
or its type.

245
00:22:25,000 --> 00:22:31,000
So the syntax is just type, space, name, semicolon.

246
00:22:31,000 --> 00:22:34,000
Now, of course, you might wonder, if we do that,

247
00:22:34,000 --> 00:22:37,000
what value is going to be in it?

248
00:22:37,000 --> 00:22:40,000
Well, no value or a random value.

249
00:22:40,000 --> 00:22:44,000
Now, in Java and in Python, if you did this,

250
00:22:44,000 --> 00:22:47,000
if you just said type name, well, Python doesn't have types,

251
00:22:47,000 --> 00:22:50,000
but in Java, if we said int a,

252
00:22:50,000 --> 00:22:52,000
we can use that variable a.

253
00:22:52,000 --> 00:22:55,000
In C++, we can, but it's really a mistake

254
00:22:55,000 --> 00:22:59,000
because we haven't given the variable an initial value.

255
00:22:59,000 --> 00:23:03,000
So we can give the variable an initial value when we create it.

256
00:23:03,000 --> 00:23:05,000
This is called initialization.

257
00:23:05,000 --> 00:23:08,000
And there are several syntaxes for this.

258
00:23:08,000 --> 00:23:09,000
You might wonder why.

259
00:23:09,000 --> 00:23:13,000
That's because C++ has been around since the early '90s,

260
00:23:13,000 --> 00:23:16,000
and as time's gone on, they've changed the syntax.

261
00:23:16,000 --> 00:23:18,000
The syntax has been updated.

262
00:23:18,000 --> 00:23:22,000
So this is called legacy or traditional initialization.

263
00:23:22,000 --> 00:23:24,000
It looks kind of like assignment,

264
00:23:24,000 --> 00:23:26,000
but it's not really the same thing.

265
00:23:26,000 --> 00:23:28,000
It's just creating the variable

266
00:23:28,000 --> 00:23:30,000
and giving it an initial value when you create it.

267
00:23:30,000 --> 00:23:32,000
We can do it this way.

268
00:23:32,000 --> 00:23:37,000
So type name, and we put the value in parentheses after the name.

269
00:23:37,000 --> 00:23:41,000
This was in the original version of C++.

270
00:23:41,000 --> 00:23:45,000
And in the newest version of C++, C++11,

271
00:23:45,000 --> 00:23:49,000
we can actually use braces, curly braces around the value.

272
00:23:49,000 --> 00:23:52,000
And this has some advantages.

273
00:23:52,000 --> 00:23:56,000
So as you go forward, you generally should prefer this third reason,

274
00:23:56,000 --> 00:23:58,000
although most of us, or many of us,

275
00:23:58,000 --> 00:24:04,000
probably still use the first one just for, you know, from habit.

276
00:24:04,000 --> 00:24:09,000
Now the equals sign here when we say name equals value,

277
00:24:09,000 --> 00:24:13,000
of course, doesn't mean equality as it is in algebra.

278
00:24:13,000 --> 00:24:17,000
What it means is copy the stuff from the right

279
00:24:17,000 --> 00:24:19,000
into the variable on the left,

280
00:24:19,000 --> 00:24:26,000
or initialize name with this value.

281
00:24:26,000 --> 00:24:29,000
Okay, so let's create a variable.

282
00:24:29,000 --> 00:24:31,000
Let's go back to our problem.

283
00:24:31,000 --> 00:24:35,000
Let's create a variable to hold the current salary.

284
00:24:35,000 --> 00:24:40,000
Now the question is, what kind of thing should it be?

285
00:24:40,000 --> 00:24:43,000
C++ has two families of numbers.

286
00:24:43,000 --> 00:24:47,000
They have integers, and they have real or floating point numbers.

287
00:24:47,000 --> 00:24:51,000
Integers are whole, discrete numbers.

288
00:24:51,000 --> 00:24:54,000
And floating point numbers, or real numbers,

289
00:24:54,000 --> 00:24:56,000
may have a fractional part.

290
00:24:56,000 --> 00:25:02,000
And so our salary could have a fractional part.

291
00:25:02,000 --> 00:25:07,000
In other words, someone could make, you know, $1,000.52.

292
00:25:07,000 --> 00:25:12,000
And so we would want to use a real or floating point number.

293
00:25:12,000 --> 00:25:17,000
Like Java, the most common real or floating point number we use

294
00:25:17,000 --> 00:25:20,000
is called double.

295
00:25:20,000 --> 00:25:28,000
So let's create a double variable.

296
00:25:28,000 --> 00:25:31,000
So I'm going to create, and I'm going to do it,

297
00:25:31,000 --> 00:25:33,000
I'm actually going to divide my code here.

298
00:25:33,000 --> 00:25:35,000
I'm going to put three more comments.

299
00:25:35,000 --> 00:25:40,000
I'm going to say this is the input section.

300
00:25:40,000 --> 00:25:44,000
I'm going to say this is the processing section.

301
00:25:44,000 --> 00:25:49,000
And then I'm going to say this is the output section.

302
00:25:49,000 --> 00:25:52,000
And I always do that when I write an IPO program.

303
00:25:52,000 --> 00:26:00,000
So I keep track of the sequence of instructions as I type them.

304
00:26:00,000 --> 00:26:04,000
So we're going to create a variable.

305
00:26:04,000 --> 00:26:07,000
Its type is going to be double.

306
00:26:07,000 --> 00:26:15,000
And its name is going to be annual salary.

307
00:26:15,000 --> 00:26:20,000
Now, this is called snake case.

308
00:26:20,000 --> 00:26:24,000
And you're free to use that style.

309
00:26:24,000 --> 00:26:33,000
Or we could write it as --

310
00:26:33,000 --> 00:26:37,000
this is called camel case.

311
00:26:37,000 --> 00:26:41,000
And this is popular in Java, of course.

312
00:26:41,000 --> 00:26:43,000
It's the current style.

313
00:26:43,000 --> 00:26:45,000
So you can use either one of those.

314
00:26:45,000 --> 00:26:48,000
I have no preference on those,

315
00:26:48,000 --> 00:26:51,000
although I'm going to use the annual salary,

316
00:26:51,000 --> 00:26:56,000
the one that is camel case.

317
00:26:56,000 --> 00:26:58,000
Actually, I do have a preference on them,

318
00:26:58,000 --> 00:27:00,000
but I don't have a preference for this class.

319
00:27:00,000 --> 00:27:02,000
You're free to use either one.

320
00:27:02,000 --> 00:27:05,000
I just find the camel case a little easier to type.

321
00:27:05,000 --> 00:27:20,000
Don't do this.

322
00:27:20,000 --> 00:27:22,000
Don't start it with an uppercase character.

323
00:27:22,000 --> 00:27:28,000
So this is fine, all lowercase, separated by underscore.

324
00:27:28,000 --> 00:27:29,000
This is fine.

325
00:27:29,000 --> 00:27:34,000
Start with a lowercase and use capital letters as the interior.

326
00:27:34,000 --> 00:27:36,000
So it's camel case.

327
00:27:36,000 --> 00:27:38,000
This is called proper case.

328
00:27:38,000 --> 00:27:43,000
We'll use proper case for classes and structures.

329
00:27:43,000 --> 00:27:44,000
So there's annual salary.

330
00:27:44,000 --> 00:27:49,000
Now the question is, what should I initialize that with?

331
00:27:49,000 --> 00:27:54,000
In other words, annual salary has no value.

332
00:27:54,000 --> 00:27:59,000
What should I initialize it with?

333
00:27:59,000 --> 00:28:03,000
The answer is, we shouldn't initialize this with anything.

334
00:28:03,000 --> 00:28:05,000
We want to get the input from the user.

335
00:28:05,000 --> 00:28:07,000
We want to get the input.

336
00:28:07,000 --> 00:28:11,000
We want to get the value from input.

337
00:28:11,000 --> 00:28:15,000
We don't want to give it an initial starting value.

338
00:28:15,000 --> 00:28:17,000
And so to get the value from input,

339
00:28:17,000 --> 00:28:21,000
we use an object that is similar to cout.

340
00:28:21,000 --> 00:28:26,000
This object is called cin, the character input object,

341
00:28:26,000 --> 00:28:30,000
which will allow us to type from the keyboard.

342
00:28:30,000 --> 00:28:35,000
Think of cin as similar to the scanner in Java,

343
00:28:35,000 --> 00:28:38,000
if you're familiar with the Java programming language.

344
00:28:38,000 --> 00:28:42,000
And to do that, we'll simply say cin.

345
00:28:42,000 --> 00:28:45,000
This is called the extraction operator,

346
00:28:45,000 --> 00:28:49,000
and we'll extract from cin the characters,

347
00:28:49,000 --> 00:28:51,000
convert those characters to the value,

348
00:28:51,000 --> 00:28:55,000
and store the value inside the variable.

349
00:28:55,000 --> 00:29:01,000
So let's look at our problem here and see how we do that.

350
00:29:01,000 --> 00:29:05,000
So here's my annual salary.

351
00:29:05,000 --> 00:29:13,000
And so I'm going to say cin annual salary.

352
00:29:13,000 --> 00:29:16,000
Now we have to make one more change.

353
00:29:16,000 --> 00:29:19,000
Don't forget to make this change.

354
00:29:19,000 --> 00:29:23,000
Notice this 1,000 is really not supposed

355
00:29:23,000 --> 00:29:25,000
to be part of the output.

356
00:29:25,000 --> 00:29:28,000
This 1,000 is supposed to be what the user types in.

357
00:29:28,000 --> 00:29:32,000
So we need to come up here from our mockup,

358
00:29:32,000 --> 00:29:36,000
from our dummy data, and remove that 1,000.

359
00:29:36,000 --> 00:29:40,000
This endl, this new line, again,

360
00:29:40,000 --> 00:29:44,000
that new line is not supposed to be part of the output.

361
00:29:44,000 --> 00:29:49,000
We want the user to type their input directly after this,

362
00:29:49,000 --> 00:29:51,000
which is called the prompt.

363
00:29:51,000 --> 00:29:54,000
So we want to prompt them, we want to get the input,

364
00:29:54,000 --> 00:29:58,000
and so this endl goes away as well.

365
00:29:58,000 --> 00:30:00,000
Make sure you leave the semicolon.

366
00:30:00,000 --> 00:30:05,000
So when the user hits enter after typing in the annual salary,

367
00:30:05,000 --> 00:30:08,000
that will work.

368
00:30:08,000 --> 00:30:11,000
So let's just try that briefly.

369
00:30:11,000 --> 00:30:14,000
Let's just go up and let's just do make run again.

370
00:30:14,000 --> 00:30:18,000
You can just up arrow to get make run.

371
00:30:18,000 --> 00:30:21,000
And notice it stops now, and it waits for me

372
00:30:21,000 --> 00:30:23,000
to type something in.

373
00:30:23,000 --> 00:30:27,000
So I'm going to type in $10,000,

374
00:30:27,000 --> 00:30:29,000
and notice I get the same output.

375
00:30:29,000 --> 00:30:33,000
Of course, since our output isn't tied to our input at all,

376
00:30:33,000 --> 00:30:38,000
we'd get the same output no matter what we did in this case.

377
00:30:38,000 --> 00:30:41,000
So here is creating a variable

378
00:30:41,000 --> 00:30:50,000
and getting input into a variable.

379
00:30:50,000 --> 00:30:53,000
Now, processing.

380
00:30:53,000 --> 00:30:55,000
So we've done the input phase.

381
00:30:55,000 --> 00:30:57,000
The input phase is done.

382
00:30:57,000 --> 00:30:58,000
Now the processing phase.

383
00:30:58,000 --> 00:31:03,000
We want to turn our input into our desired output.

384
00:31:03,000 --> 00:31:08,000
And our desired output is annual and monthly salary

385
00:31:08,000 --> 00:31:11,000
or new annual and new monthly salary

386
00:31:11,000 --> 00:31:13,000
and the retroactive pay.

387
00:31:13,000 --> 00:31:19,000
And so we're going to create variables for each output value.

388
00:31:19,000 --> 00:31:23,000
So again, you can use, I'm going to be consistent here

389
00:31:23,000 --> 00:31:28,000
and use camel case, but again, feel free to use snake case

390
00:31:28,000 --> 00:31:30,000
if you prefer that.

391
00:31:30,000 --> 00:31:33,000
So these are going to be all doubles

392
00:31:33,000 --> 00:31:35,000
since our original was a double.

393
00:31:35,000 --> 00:31:45,000
So annual, I'll call that new annual.

394
00:31:45,000 --> 00:31:52,000
And double new monthly.

395
00:31:52,000 --> 00:31:59,000
And double retro pay.

396
00:31:59,000 --> 00:32:03,000
Now, we could now, that we have the variables,

397
00:32:03,000 --> 00:32:05,000
we could process them.

398
00:32:05,000 --> 00:32:08,000
And in C, that was very, very common.

399
00:32:08,000 --> 00:32:10,000
Many other languages that's common.

400
00:32:10,000 --> 00:32:13,000
But that's really not a good habit to get in.

401
00:32:13,000 --> 00:32:19,000
So instead of doing that, instead of doing int var

402
00:32:19,000 --> 00:32:22,000
and then on another line, putting in your calculation,

403
00:32:22,000 --> 00:32:26,000
you should initialize it on the line that calculates it.

404
00:32:26,000 --> 00:32:29,000
So let's just review our three algorithms.

405
00:32:29,000 --> 00:32:34,000
So the first one was we're going to let our new annual

406
00:32:34,000 --> 00:32:39,000
be the original times one plus the raised percent.

407
00:32:39,000 --> 00:32:42,000
We're going to let our monthly be the annual

408
00:32:42,000 --> 00:32:45,000
divided by the months per year.

409
00:32:45,000 --> 00:32:47,000
And we're going to let our retroactive pay

410
00:32:47,000 --> 00:32:53,000
be annual minus original divided by two.

411
00:32:53,000 --> 00:32:56,000
Now, we have to be careful when we do this.

412
00:32:56,000 --> 00:32:58,000
We have to be careful we put the parentheses

413
00:32:58,000 --> 00:33:02,000
in each correct place.

414
00:33:02,000 --> 00:33:04,000
So using that algorithm, I'm going to say

415
00:33:04,000 --> 00:33:14,000
my new annual is going to be my annual salary.

416
00:33:14,000 --> 00:33:17,000
Now, instead of that, we use star,

417
00:33:17,000 --> 00:33:23,000
just like in Java and Pascal and in Python.

418
00:33:23,000 --> 00:33:32,000
And this is going to be one plus the raised percent,

419
00:33:32,000 --> 00:33:35,000
which is 7.6%.

420
00:33:35,000 --> 00:33:37,000
But again, like other programming languages,

421
00:33:37,000 --> 00:33:39,000
we can't write it out like that.

422
00:33:39,000 --> 00:33:42,000
We have to write it out as this mathematical equivalent,

423
00:33:42,000 --> 00:33:47,000
which is 0.76 with a dot in front of it.

424
00:33:47,000 --> 00:33:51,000
And just like in algebra, we have to be aware

425
00:33:51,000 --> 00:33:55,000
of where the parentheses go in an expression.

426
00:33:55,000 --> 00:34:01,000
So in this expression, notice that this does

427
00:34:01,000 --> 00:34:03,000
multiplication before addition.

428
00:34:03,000 --> 00:34:08,000
And so this says annual times one plus 0.76.

429
00:34:08,000 --> 00:34:14,000
So that would give me a raise of 7 cents,

430
00:34:14,000 --> 00:34:16,000
not what I want for the year.

431
00:34:16,000 --> 00:34:24,000
So to get the addition to happen first,

432
00:34:24,000 --> 00:34:28,000
what I'm going to need to do is put parentheses around that.

433
00:34:28,000 --> 00:34:30,000
So that gives me the new annual salary.

434
00:34:30,000 --> 00:34:38,000
Our algorithm for the monthly was new annual

435
00:34:38,000 --> 00:34:44,000
divided by 12, or months per year.

436
00:34:44,000 --> 00:34:57,000
And the retro pay was the new annual, the larger one,

437
00:34:57,000 --> 00:35:12,000
minus the annual.

438
00:35:12,000 --> 00:35:15,000
That would give me the retroactive pay for one year,

439
00:35:15,000 --> 00:35:17,000
but we only get the retroactive pay for six months.

440
00:35:17,000 --> 00:35:22,000
So I'm going to divide it by two.

441
00:35:22,000 --> 00:35:25,000
And again here, if we didn't have the parentheses on,

442
00:35:25,000 --> 00:35:28,000
that would give me the new annual salary

443
00:35:28,000 --> 00:35:31,000
minus the annual salary divided by two,

444
00:35:31,000 --> 00:35:36,000
which again would be much more than I actually deserved

445
00:35:36,000 --> 00:35:38,000
in the output.

446
00:35:38,000 --> 00:35:41,000
So this is the calculation or the processing part.

447
00:35:41,000 --> 00:35:50,000
This is the calculation or the processing part.

448
00:35:50,000 --> 00:35:59,000
Okay, so now let's look at that pay increase, 7.6 amount.

449
00:35:59,000 --> 00:36:06,000
And you can see that here in this expression here, 7.6%.

450
00:36:06,000 --> 00:36:09,000
Now if someone reads that,

451
00:36:09,000 --> 00:36:15,000
they're going to wonder what that 7.6% means.

452
00:36:15,000 --> 00:36:20,000
We call that 7.6% a magic number.

453
00:36:20,000 --> 00:36:22,000
And we should avoid doing that.

454
00:36:22,000 --> 00:36:27,000
We should use named constants, not literal values in your code.

455
00:36:27,000 --> 00:36:30,000
As a matter of fact, there's a software engineering rule

456
00:36:30,000 --> 00:36:34,000
called the magic number rule that says that any literal

457
00:36:34,000 --> 00:36:40,000
other than zero, one, or minus one is suspect in your code.

458
00:36:40,000 --> 00:36:43,000
And you should think about replacing it.

459
00:36:43,000 --> 00:36:45,000
So to create a constant,

460
00:36:45,000 --> 00:36:48,000
we use something that's similar to Java with final,

461
00:36:48,000 --> 00:36:51,000
but instead we use a qualifier called const.

462
00:36:51,000 --> 00:36:58,000
And so const double, and here I'm using the Google style,

463
00:36:58,000 --> 00:37:03,000
which is to create constants starting with the lower case k

464
00:37:03,000 --> 00:37:05,000
and then proper case.

465
00:37:05,000 --> 00:37:10,000
Here's the Java style for this.

466
00:37:10,000 --> 00:37:13,000
I'm going to try and use the Google style from now on

467
00:37:13,000 --> 00:37:20,000
because in C++ all caps usually mean something called a macro.

468
00:37:20,000 --> 00:37:22,000
So let's go ahead and add that.

469
00:37:22,000 --> 00:37:25,000
And I'm going to actually add two constants

470
00:37:25,000 --> 00:37:28,000
to our example program here.

471
00:37:28,000 --> 00:37:36,000
So in my processing, I'm going to create a const,

472
00:37:36,000 --> 00:37:51,000
const double k raised percent equals 0.0776.

473
00:37:51,000 --> 00:37:55,000
See if I can type it right, 076.

474
00:37:55,000 --> 00:38:12,000
And then in my code I'm going to replace that with k raised percent.

475
00:38:12,000 --> 00:38:17,000
I'm not quite sure why I didn't pick up the name here.

476
00:38:17,000 --> 00:38:19,000
Let's see if I spelled it right.

477
00:38:19,000 --> 00:38:22,000
Yeah, it'll probably pick it up in a couple seconds.

478
00:38:22,000 --> 00:38:26,000
We're going to create a second one here for this months per year.

479
00:38:26,000 --> 00:38:31,000
So I'm going to say const, just to give you some practice,

480
00:38:31,000 --> 00:38:41,000
constant k months per year is 12.

481
00:38:41,000 --> 00:38:55,000
I think we all know that, but k months per year.

482
00:38:55,000 --> 00:38:57,000
Okay, that looks pretty good.

483
00:38:57,000 --> 00:39:03,000
Let's go ahead and try running it again.

484
00:39:03,000 --> 00:39:06,000
So to clear the terminal like this,

485
00:39:06,000 --> 00:39:10,000
you can hold down the control key and press L.

486
00:39:10,000 --> 00:39:12,000
So that will clear the terminal.

487
00:39:12,000 --> 00:39:15,000
So I'm going to say make run again.

488
00:39:15,000 --> 00:39:19,000
Okay, I got an error.

489
00:39:19,000 --> 00:39:24,000
That's because I put a period here instead of a semicolon.

490
00:39:24,000 --> 00:39:30,000
There I got a semicolon.

491
00:39:30,000 --> 00:39:34,000
So let's clear the terminal and run it again.

492
00:39:34,000 --> 00:39:44,000
Okay, so it wants my current salary $10,000.

493
00:39:44,000 --> 00:39:50,000
Okay, well my output actually, we actually kind of skipped one step.

494
00:39:50,000 --> 00:39:54,000
And that is I've done the input, I've done the processing,

495
00:39:54,000 --> 00:39:59,000
but my output I'm still using constants here, literals.

496
00:39:59,000 --> 00:40:04,000
And so I want to take new annual,

497
00:40:04,000 --> 00:40:08,000
and I want to replace this number that I put in there.

498
00:40:08,000 --> 00:40:10,000
And I want to replace new monthly,

499
00:40:10,000 --> 00:40:14,000
and I want to replace that number that I put in there.

500
00:40:14,000 --> 00:40:17,000
And I want to take retro pay,

501
00:40:17,000 --> 00:40:23,000
and I want to take replace that number that I put in there.

502
00:40:23,000 --> 00:40:27,000
So once we've done that,

503
00:40:27,000 --> 00:40:31,000
now let's go ahead and make run.

504
00:40:31,000 --> 00:40:34,000
This time when I put in the $10,000,

505
00:40:34,000 --> 00:40:37,000
it's actually doing my processing and calculation.

506
00:40:37,000 --> 00:40:41,000
If I put in different numbers, I'd get different values out.

507
00:40:41,000 --> 00:40:46,000
And, ooh, it actually even looks worse than it did before.

508
00:40:46,000 --> 00:40:48,000
I still don't have the periods here.

509
00:40:48,000 --> 00:40:51,000
I have three decimal places there,

510
00:40:51,000 --> 00:40:54,000
and I have no decimal places there.

511
00:40:54,000 --> 00:40:57,000
So let's tackle that next.

512
00:40:57,000 --> 00:41:01,000
How do we format real numbers?

513
00:41:01,000 --> 00:41:04,000
And we format real numbers with something called

514
00:41:04,000 --> 00:41:07,000
input/output manipulators.

515
00:41:07,000 --> 00:41:10,000
These are in a different header file.

516
00:41:10,000 --> 00:41:12,000
They are not in I/O Stream.

517
00:41:12,000 --> 00:41:16,000
They are in the header file called I/O Manip.

518
00:41:16,000 --> 00:41:18,000
And these are objects.

519
00:41:18,000 --> 00:41:21,000
These provide objects and functions

520
00:41:21,000 --> 00:41:25,000
that we can set inside and print out to the stream

521
00:41:25,000 --> 00:41:28,000
to modify the way the stream works.

522
00:41:28,000 --> 00:41:32,000
Now, we're only going to memorize one of these now.

523
00:41:32,000 --> 00:41:36,000
So we're going to put in the I/O Manip.

524
00:41:36,000 --> 00:41:38,000
And I've probably already put it at the top.

525
00:41:38,000 --> 00:41:43,000
Yeah, I've already put it here at the top for this problem.

526
00:41:43,000 --> 00:41:49,000
And we're going to say, before we do any output,

527
00:41:49,000 --> 00:41:52,000
we're going to say, I want all of my real numbers

528
00:41:52,000 --> 00:41:57,000
to appear in fixed format, meaning not scientific notation.

529
00:41:57,000 --> 00:42:00,000
And when those real numbers appear,

530
00:42:00,000 --> 00:42:03,000
I want their decimal places or their precision

531
00:42:03,000 --> 00:42:06,000
to be two decimal places.

532
00:42:06,000 --> 00:42:10,000
Now again, this only needs to appear once.

533
00:42:10,000 --> 00:42:13,000
It only needs to appear once.

534
00:42:13,000 --> 00:42:16,000
So let's try our running it again.

535
00:42:16,000 --> 00:42:22,000
Make run $10,000.

536
00:42:22,000 --> 00:42:26,000
And notice now, we get-- oh, actually, I got--

537
00:42:26,000 --> 00:42:29,000
these numbers are wrong, aren't they?

538
00:42:29,000 --> 00:42:31,000
Oh, I did 1,000, not 10,000.

539
00:42:31,000 --> 00:42:38,000
Let me do 10,000.

540
00:42:38,000 --> 00:42:41,000
OK, so this time I got my two decimals there.

541
00:42:41,000 --> 00:42:42,000
I got my 0.67.

542
00:42:42,000 --> 00:42:44,000
I got my two decimals there.

543
00:42:44,000 --> 00:42:52,000
Now, once we've run this,

544
00:42:52,000 --> 00:42:54,000
I'm going to maximize that panel size,

545
00:42:54,000 --> 00:42:58,000
and I can minimize it there rather than bringing it up and down.

546
00:42:58,000 --> 00:43:02,000
Once I've done this, I can test to make sure if it's correct.

547
00:43:02,000 --> 00:43:06,000
So I'm going to say, make test.

548
00:43:06,000 --> 00:43:12,000
And notice it will check for all of these different kinds of inputs

549
00:43:12,000 --> 00:43:15,000
for the original salary.

550
00:43:15,000 --> 00:43:20,000
Notice it will say here my name and the instructor tests.

551
00:43:20,000 --> 00:43:25,000
And this is what you're going to take a picture of for your screen.

552
00:43:25,000 --> 00:43:29,000
At the top, it wants a picture of your source code.

553
00:43:29,000 --> 00:43:34,000
And then you're going to paste in a picture of your test results there.

554
00:43:34,000 --> 00:43:37,000
So those are the two things we're going to turn in for this.

555
00:43:37,000 --> 00:43:42,000
We don't--I'm going to minimize that again.

556
00:43:42,000 --> 00:43:45,000
We don't, when we're doing in-class exercises,

557
00:43:45,000 --> 00:43:47,000
you won't do make submit.

558
00:43:47,000 --> 00:43:49,000
If you tried to do make submit, it would tell you,

559
00:43:49,000 --> 00:43:54,000
I'm sorry, there's nothing like that here, so make submit.

560
00:43:54,000 --> 00:43:58,000
It'll say, no, there's no rule to make the target submit.

561
00:43:58,000 --> 00:44:07,000
And so that simply means we don't do that for in-class exercises.

562
00:44:07,000 --> 00:44:11,000
Okay, so that's it for the in-class exercise.

563
00:44:11,000 --> 00:44:15,000
Let me talk to you a little bit more about variables.

564
00:44:15,000 --> 00:44:19,000
In this class, unlike your first programming class,

565
00:44:19,000 --> 00:44:25,000
we're actually going to talk about things at a more technical level.

566
00:44:25,000 --> 00:44:31,000
And so we're going to use vocabulary more literally or specifically.

567
00:44:31,000 --> 00:44:36,000
So we have five terms that we use with a variable.

568
00:44:36,000 --> 00:44:40,000
We also use these with functions and classes.

569
00:44:40,000 --> 00:44:46,000
So a declaration associates a name with a type.

570
00:44:46,000 --> 00:44:54,000
And so a declaration of a variable has this keyword extern in front of it.

571
00:44:54,000 --> 00:45:02,000
So when I say extern int x, I'm telling the compiler that x is of type int.

572
00:45:02,000 --> 00:45:08,000
This does not specifically create the variable at this point.

573
00:45:08,000 --> 00:45:13,000
The variable can be created somewhere else in your program.

574
00:45:13,000 --> 00:45:17,000
And the variables in your program must be declared

575
00:45:17,000 --> 00:45:20,000
for the rest of your program to compile.

576
00:45:20,000 --> 00:45:24,000
They do not need to be defined. For instance,

577
00:45:24,000 --> 00:45:28,000
in your homework you have a variable assignment.

578
00:45:28,000 --> 00:45:30,000
Let's go look at one of your homeworks.

579
00:45:30,000 --> 00:45:32,000
So I'm going to go up to homework.

580
00:45:32,000 --> 00:45:35,000
I'm going to go homework 1.

581
00:45:35,000 --> 00:45:39,000
I'm going to look at homework1.cpp.

582
00:45:39,000 --> 00:45:42,000
And I'm going to bring this down.

583
00:45:42,000 --> 00:45:45,000
And notice there's this string assignment.

584
00:45:45,000 --> 00:45:48,000
Notice it's not just string assignment.

585
00:45:48,000 --> 00:45:51,000
It's extern string assignment.

586
00:45:51,000 --> 00:45:58,000
That means that this variable, the compiler knows that assignment is a string,

587
00:45:58,000 --> 00:46:01,000
but it doesn't see the definition of that.

588
00:46:01,000 --> 00:46:04,000
It's defined somewhere else.

589
00:46:04,000 --> 00:46:10,000
In this case, it's defined in this file, libh01.a.

590
00:46:10,000 --> 00:46:13,000
It's defined in some compile code.

591
00:46:13,000 --> 00:46:21,000
So a declaration allows us to use a variable that is defined elsewhere.

592
00:46:21,000 --> 00:46:28,000
A definition is something that actually creates an object or code.

593
00:46:28,000 --> 00:46:36,000
So when I write int y, the compiler reserves enough space for an int

594
00:46:36,000 --> 00:46:43,000
and remembers that that particular space it reserved is only for an int.

595
00:46:43,000 --> 00:46:50,000
So this is called a definition or, in this case, a defining declaration.

596
00:46:50,000 --> 00:46:53,000
It both associates the name y with int,

597
00:46:53,000 --> 00:47:00,000
and it creates the variable or allocates the space for the variable y at that time.

598
00:47:00,000 --> 00:47:03,000
Now I'm going to kind of go ahead a little bit

599
00:47:03,000 --> 00:47:06,000
and talk about something we're going to talk about later.

600
00:47:06,000 --> 00:47:12,000
So if in this variable I say int y,

601
00:47:12,000 --> 00:47:17,000
I have created a variable y inside that function.

602
00:47:17,000 --> 00:47:19,000
It's only visible inside that function,

603
00:47:19,000 --> 00:47:24,000
and it has automatically managed the memory for it.

604
00:47:24,000 --> 00:47:30,000
If I come up here and I say int x, I've created a variable x,

605
00:47:30,000 --> 00:47:34,000
but that variable is not automatically managed.

606
00:47:34,000 --> 00:47:37,000
It's put in what we call the static storage area.

607
00:47:37,000 --> 00:47:40,000
This is what we call a global variable,

608
00:47:40,000 --> 00:47:45,000
and y down here is a local variable.

609
00:47:45,000 --> 00:47:50,000
So both of those are allocated in different regions of memory,

610
00:47:50,000 --> 00:47:54,000
and we'll talk about that much later in the course.

611
00:47:54,000 --> 00:48:01,000
Now, in Java and in the C# programming language,

612
00:48:01,000 --> 00:48:05,000
defining a variable is not enough to use it.

613
00:48:05,000 --> 00:48:08,000
You must also give it a value.

614
00:48:08,000 --> 00:48:11,000
If you do not, you will get an error.

615
00:48:11,000 --> 00:48:14,000
In C++ that is not the case.

616
00:48:14,000 --> 00:48:18,000
In C++, if we don't use this variable, it is an error.

617
00:48:18,000 --> 00:48:22,000
If we tried to print out the variable y, it is an error,

618
00:48:22,000 --> 00:48:27,000
but it is not a syntax or a compiler time error.

619
00:48:27,000 --> 00:48:30,000
It is a logical error.

620
00:48:30,000 --> 00:48:34,000
And so to use a variable, you must provide it a value

621
00:48:34,000 --> 00:48:39,000
by using initialization, provide an initial value,

622
00:48:39,000 --> 00:48:42,000
assignment, copy a new value into the object

623
00:48:42,000 --> 00:48:44,000
after it's been created,

624
00:48:44,000 --> 00:48:48,000
or input, like we did for annual salary.

625
00:48:48,000 --> 00:48:51,000
That's just a special form of assignment.

626
00:48:51,000 --> 00:48:53,000
So I want to talk about each of these four things

627
00:48:53,000 --> 00:48:57,000
before we stop today's lecture.

628
00:48:57,000 --> 00:49:00,000
So initializing variables--

629
00:49:00,000 --> 00:49:03,000
so the variable definition doesn't create it.

630
00:49:03,000 --> 00:49:07,000
If I do this, it's--

631
00:49:07,000 --> 00:49:10,000
when you create the variable with a definition,

632
00:49:10,000 --> 00:49:14,000
you have to initialize it or otherwise populate it.

633
00:49:14,000 --> 00:49:17,000
Again, it's not a syntax error.

634
00:49:17,000 --> 00:49:19,000
It is a logic error.

635
00:49:19,000 --> 00:49:22,000
And there are three ways to initialize a variable.

636
00:49:22,000 --> 00:49:27,000
There is the new way that we have in C++11.

637
00:49:27,000 --> 00:49:35,000
Double x--or double c embraces the initial value.

638
00:49:35,000 --> 00:49:37,000
This is called uniform initialization.

639
00:49:37,000 --> 00:49:40,000
It didn't work before C++11.

640
00:49:40,000 --> 00:49:43,000
Of course, that's 10 years old now.

641
00:49:43,000 --> 00:49:46,000
This is called legacy initialization,

642
00:49:46,000 --> 00:49:49,000
double a equals 2.5.

643
00:49:49,000 --> 00:49:53,000
This is not direct--not assignment.

644
00:49:53,000 --> 00:49:56,000
We'll talk about what assignment is in a second.

645
00:49:56,000 --> 00:49:58,000
And this is direct initialization

646
00:49:58,000 --> 00:50:02,000
with the value inside the parenthesis.

647
00:50:02,000 --> 00:50:05,000
You should prefer this top one now.

648
00:50:05,000 --> 00:50:11,000
You should prefer the top one because in most languages,

649
00:50:11,000 --> 00:50:12,000
if I were to write this--

650
00:50:12,000 --> 00:50:15,000
now I'm just going to write some code here.

651
00:50:15,000 --> 00:50:23,000
If I were to write this in int x equals 3.15,

652
00:50:23,000 --> 00:50:25,000
most of you who have taken Java

653
00:50:25,000 --> 00:50:29,000
would recognize that that is an error, right?

654
00:50:29,000 --> 00:50:33,000
We can't store a 3.15 if x is an integer.

655
00:50:33,000 --> 00:50:35,000
We will lose the .15.

656
00:50:35,000 --> 00:50:38,000
In C++, that's not an error.

657
00:50:38,000 --> 00:50:41,000
It simply throws away the .5

658
00:50:41,000 --> 00:50:44,000
and converts it automatically to 3.

659
00:50:44,000 --> 00:50:46,000
And that's kind of error-prone, isn't it?

660
00:50:46,000 --> 00:50:49,000
You might have meant to make something a double,

661
00:50:49,000 --> 00:50:51,000
and instead you made it an int,

662
00:50:51,000 --> 00:50:53,000
and you saw the 3.15,

663
00:50:53,000 --> 00:50:55,000
and you thought, "For sure, I've made it a double."

664
00:50:55,000 --> 00:50:59,000
And so if we use the other kind of syntax here,

665
00:50:59,000 --> 00:51:03,000
if we instead wrote it like that,

666
00:51:03,000 --> 00:51:05,000
when we compiled our program,

667
00:51:05,000 --> 00:51:08,000
it would say that that is an error.

668
00:51:08,000 --> 00:51:11,000
So prefer this one with the braces

669
00:51:11,000 --> 00:51:14,000
instead of the old legacy style,

670
00:51:14,000 --> 00:51:23,000
which permits you to lose some precision on your variables.

671
00:51:23,000 --> 00:51:25,000
The same thing is true with assignment.

672
00:51:25,000 --> 00:51:28,000
So assignment doesn't have the type in front of it.

673
00:51:28,000 --> 00:51:33,000
It's not creating a value with initial value.

674
00:51:33,000 --> 00:51:36,000
So, for instance, look at this.

675
00:51:36,000 --> 00:51:37,000
Again, I'm going to go back here

676
00:51:37,000 --> 00:51:40,000
and just put code inside here.

677
00:51:40,000 --> 00:51:44,000
I can do this, int x.

678
00:51:44,000 --> 00:51:46,000
Okay, so that's assignment.

679
00:51:46,000 --> 00:51:53,000
I can do this, int y.

680
00:51:53,000 --> 00:51:56,000
But I cannot do this, int z.

681
00:51:56,000 --> 00:51:58,000
z equals 4.

682
00:51:58,000 --> 00:52:02,000
So this statement here is an assignment.

683
00:52:02,000 --> 00:52:05,000
It can only happen when your program runs.

684
00:52:05,000 --> 00:52:08,000
This statement isn't an initialization.

685
00:52:08,000 --> 00:52:11,000
It happens when your program is compiled.

686
00:52:11,000 --> 00:52:16,000
And so assignments are executable statements.

687
00:52:16,000 --> 00:52:21,000
They can only appear inside of a function.

688
00:52:21,000 --> 00:52:27,000
They only are executed when the program runs.

689
00:52:27,000 --> 00:52:31,000
The other thing about assignment is just like initialization,

690
00:52:31,000 --> 00:52:37,000
if you use this traditional style, num equals 3.159,

691
00:52:37,000 --> 00:52:41,000
even if num is an int or a character,

692
00:52:41,000 --> 00:52:43,000
it will do that assignment.

693
00:52:43,000 --> 00:52:46,000
And that obviously is kind of error prone.

694
00:52:46,000 --> 00:52:50,000
So you should get in the habit, when you use assignment,

695
00:52:50,000 --> 00:52:53,000
of putting the value inside braces.

696
00:52:53,000 --> 00:52:57,000
Now if n2 is an integer, the compiler will warn me,

697
00:52:57,000 --> 00:53:00,000
"Oh, you're trying to put the wrong kind of value in that integer.

698
00:53:00,000 --> 00:53:03,000
Do you really mean to do that?"

699
00:53:03,000 --> 00:53:08,000
And so again, C++11 has added several safety features

700
00:53:08,000 --> 00:53:11,000
that allow you to catch your errors earlier

701
00:53:11,000 --> 00:53:15,000
rather than later with a bug that appears in your code.

702
00:53:15,000 --> 00:53:18,000
Finally, the third way we can populate a variable

703
00:53:18,000 --> 00:53:23,000
is through input, like we did with annual salary.

704
00:53:23,000 --> 00:53:27,000
Okay, so let me talk about assignment.

705
00:53:27,000 --> 00:53:31,000
So assignment stores a value in a variable.

706
00:53:31,000 --> 00:53:34,000
The assignment operator is the equals token.

707
00:53:34,000 --> 00:53:40,000
It doesn't mean a quality like it would be in algebra.

708
00:53:40,000 --> 00:53:45,000
And assignment is an expression, not a statement.

709
00:53:45,000 --> 00:53:47,000
That means it has a value.

710
00:53:47,000 --> 00:53:53,000
That means I can say this.

711
00:53:53,000 --> 00:54:03,000
Again, I'm just using up one of my homework assignments here.

712
00:54:03,000 --> 00:54:07,000
I can say a equals b equals 7.

713
00:54:07,000 --> 00:54:12,000
That's because this expression copies 7 to b.

714
00:54:12,000 --> 00:54:14,000
That's the side effect.

715
00:54:14,000 --> 00:54:16,000
b is changed to 7.

716
00:54:16,000 --> 00:54:18,000
And the whole thing has a value.

717
00:54:18,000 --> 00:54:20,000
The value of that expression is 7,

718
00:54:20,000 --> 00:54:24,000
which is then copied to a in that case.

719
00:54:24,000 --> 00:54:28,000
So assignment is an expression, not a statement.

720
00:54:28,000 --> 00:54:34,000
Now of course, this, a equals 3, is an assignment statement

721
00:54:34,000 --> 00:54:45,000
because I made it a statement by putting a semicolon at the end of it.

722
00:54:45,000 --> 00:54:48,000
Okay, so the assignment statement has three parts.

723
00:54:48,000 --> 00:54:52,000
The object where the value is going to be stored.

724
00:54:52,000 --> 00:54:55,000
That appears on the left of the assignment operator,

725
00:54:55,000 --> 00:54:59,000
and so it's called an L value.

726
00:54:59,000 --> 00:55:02,000
An L value has to be an object.

727
00:55:02,000 --> 00:55:06,000
That means it has to be a region where we can store values.

728
00:55:06,000 --> 00:55:09,000
That means it has to be addressable.

729
00:55:09,000 --> 00:55:13,000
The assignment operator, the equals sign, as I mentioned before,

730
00:55:13,000 --> 00:55:18,000
is not the equivalency operator.

731
00:55:18,000 --> 00:55:21,000
And finally, the value to be stored.

732
00:55:21,000 --> 00:55:25,000
This appears on the right-hand side, so it's called an R value.

733
00:55:25,000 --> 00:55:29,000
And so let me give you another couple of examples here.

734
00:55:29,000 --> 00:55:34,000
Again, messing up my piece of homework code here.

735
00:55:34,000 --> 00:55:41,000
So int a equals 3, b equals 5.

736
00:55:41,000 --> 00:55:44,000
So I can write b equals a.

737
00:55:44,000 --> 00:55:48,000
In this case, a is an R value, b is an L value.

738
00:55:48,000 --> 00:55:52,000
I can write b equals 7.

739
00:55:52,000 --> 00:55:57,000
Again, b is an L value, 7 is an R value.

740
00:55:57,000 --> 00:56:01,000
I cannot write 7 equals b.

741
00:56:01,000 --> 00:56:06,000
I can't do that because the thing on the left is not an object in memory.

742
00:56:06,000 --> 00:56:08,000
It's not a place where I can store stuff.

743
00:56:08,000 --> 00:56:11,000
It is not an L value.

744
00:56:11,000 --> 00:56:18,000
One other thing about L values is we have one kind of L value that you cannot assign to.

745
00:56:18,000 --> 00:56:21,000
And that's called a non-modifiable L value.

746
00:56:21,000 --> 00:56:28,000
So const int x equals 3.

747
00:56:28,000 --> 00:56:40,000
So that's illegal because x is an L value because it appeared on the left-hand side of this assignment operator,

748
00:56:40,000 --> 00:56:44,000
but the const made it non-modifiable, so I can never again assign to it.

749
00:56:44,000 --> 00:56:49,000
I can only assign to it in its initial value.

750
00:56:49,000 --> 00:56:57,000
So constants are non-modifiable L values.

751
00:56:57,000 --> 00:57:01,000
Arrays are also non-modifiable L values.

752
00:57:01,000 --> 00:57:06,000
The last thing we looked at in this lecture is input.

753
00:57:06,000 --> 00:57:13,000
So for numeric input, we're going to use cn and the extraction operator.

754
00:57:13,000 --> 00:57:22,000
So these arrows pointing away from cn signify that we're extracting or reading characters from cn,

755
00:57:22,000 --> 00:57:27,000
and we're putting the result in this variable over here.

756
00:57:27,000 --> 00:57:35,000
Now the way the cn object works is it reads and it discards leading whitespace characters.

757
00:57:35,000 --> 00:57:39,000
So the user can type in space space 42.

758
00:57:39,000 --> 00:57:41,000
That's perfectly fine.

759
00:57:41,000 --> 00:57:50,000
Once it finds a character, so the user has typed in space space, discarded those, 42,

760
00:57:50,000 --> 00:57:56,000
it reads the characters and it matches the characters to the type of the variable.

761
00:57:56,000 --> 00:57:59,000
Suppose my type of my variable was an int.

762
00:57:59,000 --> 00:58:07,000
It would match the four and it would say, "Yes, I can use that," and it would save that variable.

763
00:58:07,000 --> 00:58:10,000
Reads the two. "Yes, I can do that."

764
00:58:10,000 --> 00:58:15,000
And then suppose the user typed x, so 42x.

765
00:58:15,000 --> 00:58:20,000
When it finds a character that doesn't match, it stops reading.

766
00:58:20,000 --> 00:58:28,000
So now the cn object has read and saved two characters, a four and a two, those two characters.

767
00:58:28,000 --> 00:58:35,000
It takes those two characters, reading is finished, and it converts those characters to binary data.

768
00:58:35,000 --> 00:58:41,000
It would convert the two characters, the character ASCII character four and the ASCII character two,

769
00:58:41,000 --> 00:58:48,000
convert those to the binary number 42, and it would store it in this variable.

770
00:58:48,000 --> 00:58:55,000
Now the question is, what happens if the input doesn't match the type of the variable?

771
00:58:55,000 --> 00:59:06,000
In other words, what happens if we said cn variable, the variable was of type int, and the person typed in dog?

772
00:59:06,000 --> 00:59:14,000
Well, in Java, what happens, and Python as well, the code goes into some kind of exception.

773
00:59:14,000 --> 00:59:22,000
Your program crashes, essentially, and prints nice red error messages, depending on the type of IDE you have.

774
00:59:22,000 --> 00:59:30,000
In C++, that doesn't happen. We say that cn goes into a fail state.

775
00:59:30,000 --> 00:59:35,000
It simply stops reading any other input until you deal with it.

776
00:59:35,000 --> 00:59:41,000
There is no runtime exception like there is in Java.

777
00:59:41,000 --> 00:59:47,000
Now, what if we had this statement, cn variable, the variable was an int,

778
00:59:47,000 --> 00:59:55,000
and we already saw that they could type in 42 dog, and it would read the 42, okay.

779
00:59:55,000 --> 00:59:59,000
We saw that they couldn't type in dog, cn would fail.

780
00:59:59,000 --> 01:00:02,000
What if they don't type in anything?

781
01:00:02,000 --> 01:00:09,000
Well, if they don't type in anything, if there is no input waiting, the program blocks.

782
01:00:09,000 --> 01:00:14,000
That's because the keyboard driver, basically, when you say cn variable,

783
01:00:14,000 --> 01:00:23,000
control is transferred from your program over to the keyboard device driver of the user.

784
01:00:23,000 --> 01:00:29,000
The device driver is telling it, wait a second, I'll wait for the user to type.

785
01:00:29,000 --> 01:00:39,000
So, you've seen when this happens, that you basically get a blinking cursor on the screen as the program waits for input.

786
01:00:39,000 --> 01:00:44,000
Okay, so that's it for lecture two. I'll see you next time.


