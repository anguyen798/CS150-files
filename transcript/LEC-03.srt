1
00:00:00,000 --> 00:00:00,000
>> Hello folks, this is Steve Gilbert and welcome

2
00:00:00,000 --> 00:00:00,000
to lecture three on numbers and calculations.

3
00:00:00,000 --> 00:00:00,000
Before you start, make sure you've gone

4
00:00:00,000 --> 00:00:00,000
into the Thursday tab here on calculations in week one.

5
00:00:00,000 --> 00:00:00,000
You've clicked the link for the lecture exercise.

6
00:00:00,000 --> 00:00:00,000
When lecture three exercise comes up, click the link

7
00:00:00,000 --> 00:00:00,000
for the starter form, save a local copy

8
00:00:00,000 --> 00:00:00,000
and make sure you rename it so you can find it later

9
00:00:00,000 --> 00:00:00,000
when you get started.

10
00:00:00,000 --> 00:00:00,000
Okay, so let's go ahead and talk a little bit more

11
00:00:00,000 --> 00:00:00,000
about type concepts.

12
00:00:00,000 --> 00:00:00,000
So in the last lecture we talked about variables.

13
00:00:00,000 --> 00:00:00,000
A variable is a name storage location that holds a value.

14
00:00:00,000 --> 00:00:00,000
Variables and values both have types.

15
00:00:00,000 --> 00:00:00,000
And types have three characteristics.

16
00:00:00,000 --> 00:00:00,000
They have the domain, the operations

17
00:00:00,000 --> 00:00:00,000
and the representation of that type.

18
00:00:00,000 --> 00:00:00,000
So the domain simply means all values contained in that type.

19
00:00:00,000 --> 00:00:00,000
The domain for the type bool, for instance, is true and false.

20
00:00:00,000 --> 00:00:00,000
There are no other values maintained in that type.

21
00:00:00,000 --> 00:00:00,000
The domain for the type int is all the whole numbers

22
00:00:00,000 --> 00:00:00,000
within the range of the type.

23
00:00:00,000 --> 00:00:00,000
So the type for int is roughly plus or minus 2 billion

24
00:00:00,000 --> 00:00:00,000
for a 32-bit int or plus or minus 127 for an 8-bit int.

25
00:00:00,000 --> 00:00:00,000
Again, depending on the size.

26
00:00:00,000 --> 00:00:00,000
So all the values contained in that type.

27
00:00:00,000 --> 00:00:00,000
We could not put for an int, for an 8-bit int.

28
00:00:00,000 --> 00:00:00,000
We could not put a number that was larger.

29
00:00:00,000 --> 00:00:00,000
It would be outside of the domain.

30
00:00:00,000 --> 00:00:00,000
And we could not put a number

31
00:00:00,000 --> 00:00:00,000
that contained a fractional portion.

32
00:00:00,000 --> 00:00:00,000
Now the second thing with a type, so the values

33
00:00:00,000 --> 00:00:00,000
that can be contained in the type is the domain.

34
00:00:00,000 --> 00:00:00,000
The operations are what you can do with that value.

35
00:00:00,000 --> 00:00:00,000
So for the built-in types, these are specified

36
00:00:00,000 --> 00:00:00,000
by the C++ language.

37
00:00:00,000 --> 00:00:00,000
So for instance, in Java, we can use the remainder operator

38
00:00:00,000 --> 00:00:00,000
on the floating point or real number types.

39
00:00:00,000 --> 00:00:00,000
In C++, we cannot.

40
00:00:00,000 --> 00:00:00,000
The language prohibits that.

41
00:00:00,000 --> 00:00:00,000
So the language specifies what operations are available.

42
00:00:00,000 --> 00:00:00,000
Now for the library types, like the string type,

43
00:00:00,000 --> 00:00:00,000
things that are built into the C++ standard library,

44
00:00:00,000 --> 00:00:00,000
those are specified by the language specification.

45
00:00:00,000 --> 00:00:00,000
So the language standard

46
00:00:00,000 --> 00:00:00,000
and the language specification specifies the operations

47
00:00:00,000 --> 00:00:00,000
for that type.

48
00:00:00,000 --> 00:00:00,000
Of course, for user-defined types, the operations are

49
00:00:00,000 --> 00:00:00,000
defined by the person who wrote the class.

50
00:00:00,000 --> 00:00:00,000
Finally, the representation determines what bits,

51
00:00:00,000 --> 00:00:00,000
given a block of memory and a particular bit pattern,

52
00:00:00,000 --> 00:00:00,000
what does that mean?

53
00:00:00,000 --> 00:00:00,000
So if I say int, how many bytes are required

54
00:00:00,000 --> 00:00:00,000
and how are the bits inside that byte interpreted to be an int?

55
00:00:00,000 --> 00:00:00,000
The same thing if I say char or double or whatever.

56
00:00:00,000 --> 00:00:00,000
So in C++, unlike Java, the representation, in other words,

57
00:00:00,000 --> 00:00:00,000
how the bits are interpreted and the size, how many bytes are used

58
00:00:00,000 --> 00:00:00,000
for each type, differs by implementation.

59
00:00:00,000 --> 00:00:00,000
And we'll talk about that.

60
00:00:00,000 --> 00:00:00,000
Now, why aren't they all the same?

61
00:00:00,000 --> 00:00:00,000
Why don't they do the same thing as Java and make a byte type,

62
00:00:00,000 --> 00:00:00,000
which is 8-bit, a short byte, a short type,

63
00:00:00,000 --> 00:00:00,000
which is 16-bit and so forth?

64
00:00:00,000 --> 00:00:00,000
That's because different computer hardware is more

65
00:00:00,000 --> 00:00:00,000
efficient with different sizes.

66
00:00:00,000 --> 00:00:00,000
So this allows C++ to run to the best effect

67
00:00:00,000 --> 00:00:00,000
on the hardware you have.

68
00:00:00,000 --> 00:00:00,000
So these are the three characteristics

69
00:00:00,000 --> 00:00:00,000
that make up a type.

70
00:00:00,000 --> 00:00:00,000
We have several categories of types in C++.

71
00:00:00,000 --> 00:00:00,000
We have the built-in, primitive, or fundamental types.

72
00:00:00,000 --> 00:00:00,000
All of those worlds kind of mean the same thing.

73
00:00:00,000 --> 00:00:00,000
The things that are built into the language itself,

74
00:00:00,000 --> 00:00:00,000
not the library.

75
00:00:00,000 --> 00:00:00,000
That includes things like the integer types,

76
00:00:00,000 --> 00:00:00,000
the whole number types, the floating point

77
00:00:00,000 --> 00:00:00,000
or real number types, the character types,

78
00:00:00,000 --> 00:00:00,000
and the bool type.

79
00:00:00,000 --> 00:00:00,000
Now, very few of them, right?

80
00:00:00,000 --> 00:00:00,000
With those types, and actually with other types,

81
00:00:00,000 --> 00:00:00,000
we can derive new types.

82
00:00:00,000 --> 00:00:00,000
So these are called derived types or compound types.

83
00:00:00,000 --> 00:00:00,000
So I can take an array, I can take a char,

84
00:00:00,000 --> 00:00:00,000
and I can create an array of char.

85
00:00:00,000 --> 00:00:00,000
So an array of char is a different type than just char.

86
00:00:00,000 --> 00:00:00,000
It's derived from char, but it's a derived type.

87
00:00:00,000 --> 00:00:00,000
I can make a pointer to a double.

88
00:00:00,000 --> 00:00:00,000
I can make a reference to an integer.

89
00:00:00,000 --> 00:00:00,000
So arrays, pointers, and references are not their own

90
00:00:00,000 --> 00:00:00,000
independent types.

91
00:00:00,000 --> 00:00:00,000
They're based on or derived from other types.

92
00:00:00,000 --> 00:00:00,000
Thirdly, we have user-defined types.

93
00:00:00,000 --> 00:00:00,000
Types that are created in the library.

94
00:00:00,000 --> 00:00:00,000
Types that are created by you, the programmer.

95
00:00:00,000 --> 00:00:00,000
Types that interact with the rest of C++

96
00:00:00,000 --> 00:00:00,000
as if they were built-in types.

97
00:00:00,000 --> 00:00:00,000
And for these, we have enumerated types,

98
00:00:00,000 --> 00:00:00,000
that is single value, numbered, or scalar types.

99
00:00:00,000 --> 00:00:00,000
That's the enum type.

100
00:00:00,000 --> 00:00:00,000
We have struct for structured or record data types.

101
00:00:00,000 --> 00:00:00,000
And then we have classes for object-oriented programming.

102
00:00:00,000 --> 00:00:00,000
Finally, some of these types are used to build the things

103
00:00:00,000 --> 00:00:00,000
that are in the standard library.

104
00:00:00,000 --> 00:00:00,000
So we refer to these types as library types,

105
00:00:00,000 --> 00:00:00,000
even though they're structures or enumerations or classes.

106
00:00:00,000 --> 00:00:00,000
So types such as string and vector are not built

107
00:00:00,000 --> 00:00:00,000
into the C++ language.

108
00:00:00,000 --> 00:00:00,000
Instead, they're built into the standard library

109
00:00:00,000 --> 00:00:00,000
that comes with C++.

110
00:00:00,000 --> 00:00:00,000
Now, C++ is what we call statically typed.

111
00:00:00,000 --> 00:00:00,000
That means the types of the variables,

112
00:00:00,000 --> 00:00:00,000
the types of the functions are indicated in the source code.

113
00:00:00,000 --> 00:00:00,000
And so to show you exactly what that means, I have to kind

114
00:00:00,000 --> 00:00:00,000
of compare it to other languages.

115
00:00:00,000 --> 00:00:00,000
So Python, for instance, uses what's called dynamic typing.

116
00:00:00,000 --> 00:00:00,000
So this is the definition for a function named add

117
00:00:00,000 --> 00:00:00,000
that takes two arguments, A and B. What kind of value,

118
00:00:00,000 --> 00:00:00,000
if any, does add return?

119
00:00:00,000 --> 00:00:00,000
What kind of things are A and B?

120
00:00:00,000 --> 00:00:00,000
Well, you don't know when you're writing your code.

121
00:00:00,000 --> 00:00:00,000
When you run your code, A will be given a value.

122
00:00:00,000 --> 00:00:00,000
It will be a number.

123
00:00:00,000 --> 00:00:00,000
It will be a string.

124
00:00:00,000 --> 00:00:00,000
It will be a real number, an integer number.

125
00:00:00,000 --> 00:00:00,000
Similarly, you don't know

126
00:00:00,000 --> 00:00:00,000
until the program runs what the function will return.

127
00:00:00,000 --> 00:00:00,000
So this is called dynamic typing.

128
00:00:00,000 --> 00:00:00,000
A is not a specific kind of variable.

129
00:00:00,000 --> 00:00:00,000
B is not a specific kind of variable.

130
00:00:00,000 --> 00:00:00,000
It's given a value when the program runs,

131
00:00:00,000 --> 00:00:00,000
and its type is determined at that time.

132
00:00:00,000 --> 00:00:00,000
Static typing is what Pascal and Java and C++ use.

133
00:00:00,000 --> 00:00:00,000
That is, the types are determined explicitly

134
00:00:00,000 --> 00:00:00,000
when we declare or define the variables.

135
00:00:00,000 --> 00:00:00,000
So here is a function in C++.

136
00:00:00,000 --> 00:00:00,000
It would look very similar in Java.

137
00:00:00,000 --> 00:00:00,000
And notice that this specifically says

138
00:00:00,000 --> 00:00:00,000
that this function is going to return an integer.

139
00:00:00,000 --> 00:00:00,000
Notice the Python version does not say what kind

140
00:00:00,000 --> 00:00:00,000
of function that is.

141
00:00:00,000 --> 00:00:00,000
It also says that the two arguments, A and B,

142
00:00:00,000 --> 00:00:00,000
are both going to be integers.

143
00:00:00,000 --> 00:00:00,000
And so the types with static typing are determined

144
00:00:00,000 --> 00:00:00,000
when the program is compiled.

145
00:00:00,000 --> 00:00:00,000
Now we have a similar term that's often confused,

146
00:00:00,000 --> 00:00:00,000
and this is called strong typing.

147
00:00:00,000 --> 00:00:00,000
So strong typing means

148
00:00:00,000 --> 00:00:00,000
that a variable can only hold one kind of value.

149
00:00:00,000 --> 00:00:00,000
And so you might think, well, if I have a double value,

150
00:00:00,000 --> 00:00:00,000
and I try and assign -- if I have a double variable,

151
00:00:00,000 --> 00:00:00,000
and I try and assign --

152
00:00:00,000 --> 00:00:00,000
I'm actually going to open up our editor here,

153
00:00:00,000 --> 00:00:00,000
and I'm going to just create a new file here.

154
00:00:00,000 --> 00:00:00,000
I'll call it example.

155
00:00:00,000 --> 00:00:00,000
That's CPD.

156
00:00:00,000 --> 00:00:00,000
And so if I try and create a variable --

157
00:00:00,000 --> 00:00:00,000
and that is actually not very big.

158
00:00:00,000 --> 00:00:00,000
I'm going to -- I'm not quite sure why my font is so small

159
00:00:00,000 --> 00:00:00,000
when it's bigger over here.

160
00:00:00,000 --> 00:00:00,000
No, I guess it's about the same size.

161
00:00:00,000 --> 00:00:00,000
So double X equals 3.

162
00:00:00,000 --> 00:00:00,000
Now this works in both C++ and Java,

163
00:00:00,000 --> 00:00:00,000
but this is not an example of strong typing,

164
00:00:00,000 --> 00:00:00,000
because the value on the right, 3, is a whole number.

165
00:00:00,000 --> 00:00:00,000
The value variable on the left, where I'm putting that,

166
00:00:00,000 --> 00:00:00,000
is the wrong kind of thing to put it in.

167
00:00:00,000 --> 00:00:00,000
This is not an integer.

168
00:00:00,000 --> 00:00:00,000
This is an integer.

169
00:00:00,000 --> 00:00:00,000
And if we had strong typing only,

170
00:00:00,000 --> 00:00:00,000
then this would not compile, because we're trying

171
00:00:00,000 --> 00:00:00,000
to put the wrong kind of value in the wrong kind of box,

172
00:00:00,000 --> 00:00:00,000
the wrong kind of variable.

173
00:00:00,000 --> 00:00:00,000
And so what both Java and C++ do is they convert this 3

174
00:00:00,000 --> 00:00:00,000
to behind the scenes, invisibly, a 3.0.

175
00:00:00,000 --> 00:00:00,000
And so the 3.0 is what's put inside of that.

176
00:00:00,000 --> 00:00:00,000
This is called a promotion or a widening conversion.

177
00:00:00,000 --> 00:00:00,000
Now in Java, if we did this, int y equals 3.15,

178
00:00:00,000 --> 00:00:00,000
we would get a syntax error.

179
00:00:00,000 --> 00:00:00,000
So that's because this is too big.

180
00:00:00,000 --> 00:00:00,000
It's 64 bits.

181
00:00:00,000 --> 00:00:00,000
This is a 32-bit bucket.

182
00:00:00,000 --> 00:00:00,000
And the bits are arranged in a different pattern,

183
00:00:00,000 --> 00:00:00,000
because remember, the value is the set

184
00:00:00,000 --> 00:00:00,000
of bits interpreted according to its type.

185
00:00:00,000 --> 00:00:00,000
And so the bits that make up 3.15 are not the same

186
00:00:00,000 --> 00:00:00,000
as the bits that would go into the integer X. And so in Java,

187
00:00:00,000 --> 00:00:00,000
this is illegal, but in C++, it is not illegal.

188
00:00:00,000 --> 00:00:00,000
So in C++, we have strong typing,

189
00:00:00,000 --> 00:00:00,000
but we have implicit conversions,

190
00:00:00,000 --> 00:00:00,000
conversions that are not allowed in other languages.

191
00:00:00,000 --> 00:00:00,000
So in C++, this is okay.

192
00:00:00,000 --> 00:00:00,000
It's exactly as if we had written convert this 3.5

193
00:00:00,000 --> 00:00:00,000
to an int, throw away the .5 and store it into A.

194
00:00:00,000 --> 00:00:00,000
We won't get any errors.

195
00:00:00,000 --> 00:00:00,000
Now because of that, and because of the experience people have

196
00:00:00,000 --> 00:00:00,000
had with Java and C# in the last 10 or 15 years,

197
00:00:00,000 --> 00:00:00,000
people have realized that that leads to some kind of errors.

198
00:00:00,000 --> 00:00:00,000
And so in C++ now, if we want to make sure that we're doing,

199
00:00:00,000 --> 00:00:00,000
if we're not inadvertently losing data,

200
00:00:00,000 --> 00:00:00,000
we could do it like this instead of that.

201
00:00:00,000 --> 00:00:00,000
We could just put braces around this.

202
00:00:00,000 --> 00:00:00,000
And now, just like Java would get an error,

203
00:00:00,000 --> 00:00:00,000
which is what we expect, right?

204
00:00:00,000 --> 00:00:00,000
We would expect this narrowing conversion not to succeed.

205
00:00:00,000 --> 00:00:00,000
But in C++, if you use the traditional assignment,

206
00:00:00,000 --> 00:00:00,000
these narrowing conversions succeed.

207
00:00:00,000 --> 00:00:00,000
So sometimes people complain and say, "No,

208
00:00:00,000 --> 00:00:00,000
C++ is not strongly typed because I can put a double inside

209
00:00:00,000 --> 00:00:00,000
an int and it didn't tell me I made a mistake."

210
00:00:00,000 --> 00:00:00,000
Well, it is strongly typed,

211
00:00:00,000 --> 00:00:00,000
but it has these implicit conversions exactly

212
00:00:00,000 --> 00:00:00,000
like Java has the implicit conversions,

213
00:00:00,000 --> 00:00:00,000
but it will do a narrowing conversion.

214
00:00:00,000 --> 00:00:00,000
In other words, losing data, whereas Java will not.

215
00:00:00,000 --> 00:00:00,000
And again, if you want to avoid that,

216
00:00:00,000 --> 00:00:00,000
which I strongly recommend,

217
00:00:00,000 --> 00:00:00,000
what you should do is you should make sure

218
00:00:00,000 --> 00:00:00,000
that you use the curly braces when you do the assignment.

219
00:00:00,000 --> 00:00:00,000
Okay, so let's go ahead and look at the types now

220
00:00:00,000 --> 00:00:00,000
that are built in.

221
00:00:00,000 --> 00:00:00,000
So the first type we have, like Java, is a integer,

222
00:00:00,000 --> 00:00:00,000
which is a signed whole number.

223
00:00:00,000 --> 00:00:00,000
When we say a number is signed, we mean that the number

224
00:00:00,000 --> 00:00:00,000
or the variable can represent negative and positive numbers.

225
00:00:00,000 --> 00:00:00,000
Now in Java, ints are signed 32-bit whole numbers.

226
00:00:00,000 --> 00:00:00,000
In C++, that's not the case.

227
00:00:00,000 --> 00:00:00,000
I have worked on C++ compilers where integers were 16 bits,

228
00:00:00,000 --> 00:00:00,000
and the largest integer we could have was 32,767.

229
00:00:00,000 --> 00:00:00,000
Today, 32 is most common, just like Java,

230
00:00:00,000 --> 00:00:00,000
but 16-bit is still used in the microprocessor world,

231
00:00:00,000 --> 00:00:00,000
especially for embedded systems.

232
00:00:00,000 --> 00:00:00,000
So it must be at least 16 bits, or it can't be an int.

233
00:00:00,000 --> 00:00:00,000
That's what the language requires,

234
00:00:00,000 --> 00:00:00,000
but it could be 32 bits.

235
00:00:00,000 --> 00:00:00,000
In fact, an int could be 64 bits, and I expect to see

236
00:00:00,000 --> 00:00:00,000
that soon as processors get larger.

237
00:00:00,000 --> 00:00:00,000
We can modify the type int with a modifier

238
00:00:00,000 --> 00:00:00,000
that specifies the size.

239
00:00:00,000 --> 00:00:00,000
So we can write a long int, and we can leave off the word int

240
00:00:00,000 --> 00:00:00,000
and use long, just like Java does,

241
00:00:00,000 --> 00:00:00,000
and that must be at least 32 bits.

242
00:00:00,000 --> 00:00:00,000
Now in Java, a long must be 64 bits.

243
00:00:00,000 --> 00:00:00,000
Now in C++, that is not the case, and so many platforms,

244
00:00:00,000 --> 00:00:00,000
Visual C++, for instance,

245
00:00:00,000 --> 00:00:00,000
longs and ints are exactly the same size.

246
00:00:00,000 --> 00:00:00,000
They're 32 bits.

247
00:00:00,000 --> 00:00:00,000
Shorts, again, this is shorthand for short int,

248
00:00:00,000 --> 00:00:00,000
but you can just write short if you want, must be at least 16

249
00:00:00,000 --> 00:00:00,000
bits like they are in Java, but they can be 32 bits as well.

250
00:00:00,000 --> 00:00:00,000
So it would be possible for ints, longs,

251
00:00:00,000 --> 00:00:00,000
and shorts all to be the same size on a given platform.

252
00:00:00,000 --> 00:00:00,000
They usually aren't all the same size,

253
00:00:00,000 --> 00:00:00,000
but often several of them are.

254
00:00:00,000 --> 00:00:00,000
The platform we're going to be using, our Unix platform,

255
00:00:00,000 --> 00:00:00,000
is going to have 32-bit ints, 64-bit longs, 16-bit shorts,

256
00:00:00,000 --> 00:00:00,000
and all platforms now have long, long.

257
00:00:00,000 --> 00:00:00,000
This is an extension before C++11,

258
00:00:00,000 --> 00:00:00,000
but now all platforms have the ability to do a long, long,

259
00:00:00,000 --> 00:00:00,000
which is the equivalent to a long in Java.

260
00:00:00,000 --> 00:00:00,000
And again, in C++, we can write this as a long, long int.

261
00:00:00,000 --> 00:00:00,000
Okay? Now, with all of these types that specify the size

262
00:00:00,000 --> 00:00:00,000
of the bytes, we can also specify how they're interpreted.

263
00:00:00,000 --> 00:00:00,000
So you can combine the word unsigned with any of these

264
00:00:00,000 --> 00:00:00,000
above to specify that we want to take the whole bit pattern

265
00:00:00,000 --> 00:00:00,000
and apply it to positive numbers.

266
00:00:00,000 --> 00:00:00,000
So let me just give you a quick example.

267
00:00:00,000 --> 00:00:00,000
If I take a 16-bit number, a short, if I write short,

268
00:00:00,000 --> 00:00:00,000
I can represent numbers from minus 32,768 to plus 32,767.

269
00:00:00,000 --> 00:00:00,000
The zero is right in the middle of the positive

270
00:00:00,000 --> 00:00:00,000
and negative numbers if you put it

271
00:00:00,000 --> 00:00:00,000
on a timeline or a number line.

272
00:00:00,000 --> 00:00:00,000
If I put unsigned short, I cannot store any negative

273
00:00:00,000 --> 00:00:00,000
numbers, but I get twice as many positive numbers.

274
00:00:00,000 --> 00:00:00,000
I can store from zero to 65,535 numbers.

275
00:00:00,000 --> 00:00:00,000
And it's the same for all the types.

276
00:00:00,000 --> 00:00:00,000
Now, Java has a byte type to represent an 8-bit

277
00:00:00,000 --> 00:00:00,000
signed integers.

278
00:00:00,000 --> 00:00:00,000
C++ uses the type char both for characters

279
00:00:00,000 --> 00:00:00,000
and for small integers.

280
00:00:00,000 --> 00:00:00,000
So for characters, you just use a plain char.

281
00:00:00,000 --> 00:00:00,000
For byte integers, you do a signed char

282
00:00:00,000 --> 00:00:00,000
if you want the numbers minus 128 to 127,

283
00:00:00,000 --> 00:00:00,000
or you use an unsigned char if you want

284
00:00:00,000 --> 00:00:00,000
to represent the numbers zero to 255.

285
00:00:00,000 --> 00:00:00,000
We'll actually use these byte integers later

286
00:00:00,000 --> 00:00:00,000
because they're very useful when we process images.

287
00:00:00,000 --> 00:00:00,000
C++ has three floating point types,

288
00:00:00,000 --> 00:00:00,000
unlike Java, which has only two.

289
00:00:00,000 --> 00:00:00,000
Those of you coming from Python are familiar

290
00:00:00,000 --> 00:00:00,000
with the type float, but the float

291
00:00:00,000 --> 00:00:00,000
in type Python is called a double in Java.

292
00:00:00,000 --> 00:00:00,000
Python actually doesn't have the same float type,

293
00:00:00,000 --> 00:00:00,000
which is around four bytes long.

294
00:00:00,000 --> 00:00:00,000
The double type is typically eight bytes long.

295
00:00:00,000 --> 00:00:00,000
And the long double may be the same as the double.

296
00:00:00,000 --> 00:00:00,000
It is on Visual C++, or it may be larger.

297
00:00:00,000 --> 00:00:00,000
Okay? So we will not use long double generally.

298
00:00:00,000 --> 00:00:00,000
It's not actually that useful in C++.

299
00:00:00,000 --> 00:00:00,000
And we will generally not use float unless we happen

300
00:00:00,000 --> 00:00:00,000
to use them in an array for images or something like that.

301
00:00:00,000 --> 00:00:00,000
So for floating point types, we'll almost always use double.

302
00:00:00,000 --> 00:00:00,000
For integer types, we'll almost always use int,

303
00:00:00,000 --> 00:00:00,000
unless we need very small integers,

304
00:00:00,000 --> 00:00:00,000
in which case we'll use signed or unsigned char.

305
00:00:00,000 --> 00:00:00,000
Now, literals mean you literally write out a number.

306
00:00:00,000 --> 00:00:00,000
And when you write out a number, we assume you're working

307
00:00:00,000 --> 00:00:00,000
with decimal numbers, that is base 10.

308
00:00:00,000 --> 00:00:00,000
So with a decimal literal, we can preface it

309
00:00:00,000 --> 00:00:00,000
to change the base.

310
00:00:00,000 --> 00:00:00,000
So if I start a number with the digit zero,

311
00:00:00,000 --> 00:00:00,000
I'm going to assume I'm going to be in base 8 or octal.

312
00:00:00,000 --> 00:00:00,000
So 073 means three ones in seven eights, not seven tens.

313
00:00:00,000 --> 00:00:00,000
If I preface it with 0x, and that x could be capital

314
00:00:00,000 --> 00:00:00,000
or lowercase, it means I'm assuming that the base is 16,

315
00:00:00,000 --> 00:00:00,000
and the number is in hexadecimal.

316
00:00:00,000 --> 00:00:00,000
And so 0x73 is not the decimal number 73,

317
00:00:00,000 --> 00:00:00,000
it's three ones in seven sixteens.

318
00:00:00,000 --> 00:00:00,000
And if I have the -- start with the preface OB, or 0B, not OB,

319
00:00:00,000 --> 00:00:00,000
0B, it's assumed that the numbers are binary.

320
00:00:00,000 --> 00:00:00,000
Now, I can also add a modifier after the literal.

321
00:00:00,000 --> 00:00:00,000
If I do a U, this can be uppercase or lowercase,

322
00:00:00,000 --> 00:00:00,000
it's more common to do capital.

323
00:00:00,000 --> 00:00:00,000
That means that we want to interpret

324
00:00:00,000 --> 00:00:00,000
that number as an unsigned number.

325
00:00:00,000 --> 00:00:00,000
If I do an L, it means we want to use long storage.

326
00:00:00,000 --> 00:00:00,000
If I do two L's, it means we want to use long, long storage.

327
00:00:00,000 --> 00:00:00,000
And of course, I combine the unsigned,

328
00:00:00,000 --> 00:00:00,000
which determines how we view the representation

329
00:00:00,000 --> 00:00:00,000
with the size modifiers.

330
00:00:00,000 --> 00:00:00,000
So I could have 123 ULL.

331
00:00:00,000 --> 00:00:00,000
C++14, we're using C++17 in this class, also allows you

332
00:00:00,000 --> 00:00:00,000
to use the apostrophe to act as a separator for long numbers.

333
00:00:00,000 --> 00:00:00,000
So if you have a very large decimal number,

334
00:00:00,000 --> 00:00:00,000
we commonly separate out the thousands

335
00:00:00,000 --> 00:00:00,000
with a comma, the comma won't work in C++,

336
00:00:00,000 --> 00:00:00,000
but you can use the apostrophe,

337
00:00:00,000 --> 00:00:00,000
so you still get the same visual separation.

338
00:00:00,000 --> 00:00:00,000
For floating point literals, you can type them

339
00:00:00,000 --> 00:00:00,000
as simply 243 dot, notice that'll be type double.

340
00:00:00,000 --> 00:00:00,000
Notice we don't need a trailing zero for that,

341
00:00:00,000 --> 00:00:00,000
but we do need the dot.

342
00:00:00,000 --> 00:00:00,000
The literal 234 is a type int, 234 point is of type double.

343
00:00:00,000 --> 00:00:00,000
If you add an L to the end of your number,

344
00:00:00,000 --> 00:00:00,000
like 7.5432L, it's of type long double, the literal.

345
00:00:00,000 --> 00:00:00,000
And finally, you can do it in scientific notation here,

346
00:00:00,000 --> 00:00:00,000
adding an E with a plus or minus for the exponent.

347
00:00:00,000 --> 00:00:00,000
The E can be capitalized or lowercase.

348
00:00:00,000 --> 00:00:00,000
This'll be type double, using scientific notation.

349
00:00:00,000 --> 00:00:00,000
And if we wanted type float, we would use the letter F. Again,

350
00:00:00,000 --> 00:00:00,000
this can be lower or uppercase, I've used uppercase here.

351
00:00:00,000 --> 00:00:00,000
You should not use lowercase for the L,

352
00:00:00,000 --> 00:00:00,000
because people are going to confuse it with a one,

353
00:00:00,000 --> 00:00:00,000
you're going to confuse it with a one.

354
00:00:00,000 --> 00:00:00,000
Now, we can actually, since we can use literals

355
00:00:00,000 --> 00:00:00,000
to specify a type, and we can use variable names,

356
00:00:00,000 --> 00:00:00,000
or type names like int or double to declare the type,

357
00:00:00,000 --> 00:00:00,000
we can actually use only the literal

358
00:00:00,000 --> 00:00:00,000
to infer or deduce the type.

359
00:00:00,000 --> 00:00:00,000
When you do that, instead of specifying a type name,

360
00:00:00,000 --> 00:00:00,000
you use the keyword auto, and then you don't use braces.

361
00:00:00,000 --> 00:00:00,000
And so, when I say auto A,

362
00:00:00,000 --> 00:00:00,000
notice I haven't specified what kind of thing A is.

363
00:00:00,000 --> 00:00:00,000
The compiler comes along and says, well,

364
00:00:00,000 --> 00:00:00,000
what's going into that?

365
00:00:00,000 --> 00:00:00,000
Well, 23U is an unsigned int,

366
00:00:00,000 --> 00:00:00,000
so the type for A would be an unsigned int.

367
00:00:00,000 --> 00:00:00,000
Similarly, I've done the same thing for the variable B.

368
00:00:00,000 --> 00:00:00,000
I haven't yet specified that it's a float,

369
00:00:00,000 --> 00:00:00,000
but I've written over here that it's type auto,

370
00:00:00,000 --> 00:00:00,000
and so it will induce, deduce, or infer from the 3F

371
00:00:00,000 --> 00:00:00,000
that B is a float.

372
00:00:00,000 --> 00:00:00,000
Now, a lot of modern C++ experts recommend this style called

373
00:00:00,000 --> 00:00:00,000
almost always auto, or AAA,

374
00:00:00,000 --> 00:00:00,000
because first it eliminates uninitialized variables.

375
00:00:00,000 --> 00:00:00,000
If we're going to get the type from the initializer,

376
00:00:00,000 --> 00:00:00,000
we don't have to worry about variables.

377
00:00:00,000 --> 00:00:00,000
It also improves maintenance.

378
00:00:00,000 --> 00:00:00,000
That means if you change the initializer,

379
00:00:00,000 --> 00:00:00,000
suppose you had, you know, int x equals 3, and you came along

380
00:00:00,000 --> 00:00:00,000
and you realized, oh, you know, that really should start

381
00:00:00,000 --> 00:00:00,000
with 3.5, and you forgot to change the int,

382
00:00:00,000 --> 00:00:00,000
then your code would be kind of out of sync.

383
00:00:00,000 --> 00:00:00,000
You wouldn't get an error message,

384
00:00:00,000 --> 00:00:00,000
and so maintenance works easier if you're using always auto,

385
00:00:00,000 --> 00:00:00,000
because the types track as the initializers will change.

386
00:00:00,000 --> 00:00:00,000
And finally, performance.

387
00:00:00,000 --> 00:00:00,000
If you use explicit types like int B equals 3.5F,

388
00:00:00,000 --> 00:00:00,000
we have to do an implicit conversion there

389
00:00:00,000 --> 00:00:00,000
that wouldn't have to happen if we didn't do that.

390
00:00:00,000 --> 00:00:00,000
And so this eliminates these initial conversions.

391
00:00:00,000 --> 00:00:00,000
So if you look on the slides, I have some links

392
00:00:00,000 --> 00:00:00,000
that you can watch and read several things about here.

393
00:00:00,000 --> 00:00:00,000
Watch this video on almost always audio,

394
00:00:00,000 --> 00:00:00,000
or almost always auto if you're interested in that.

395
00:00:00,000 --> 00:00:00,000
Let's go ahead and do an exercise, and let's go ahead

396
00:00:00,000 --> 00:00:00,000
and see if we can do the work of the compiler and infer

397
00:00:00,000 --> 00:00:00,000
from the literals what type would be there.

398
00:00:00,000 --> 00:00:00,000
Now, of course, if we were using auto, we'd put auto there,

399
00:00:00,000 --> 00:00:00,000
but here we're simply going to infer

400
00:00:00,000 --> 00:00:00,000
from the compiler what type would go there.

401
00:00:00,000 --> 00:00:00,000
Okay? So I'm going to make this slightly larger

402
00:00:00,000 --> 00:00:00,000
so it's easier to see on the video.

403
00:00:00,000 --> 00:00:00,000
So we're going to look at this program, and we're going

404
00:00:00,000 --> 00:00:00,000
to provide the correct explicit variable types for each

405
00:00:00,000 --> 00:00:00,000
of the variable declarations.

406
00:00:00,000 --> 00:00:00,000
You can assume that ints are 32 bits, that shorts are 16 bits.

407
00:00:00,000 --> 00:00:00,000
Now, to make this a little trickier, what we want

408
00:00:00,000 --> 00:00:00,000
to do is use the smallest legal type

409
00:00:00,000 --> 00:00:00,000
that will correctly store the subsequent value.

410
00:00:00,000 --> 00:00:00,000
Okay? Okay.

411
00:00:00,000 --> 00:00:00,000
So we're going to take a picture.

412
00:00:00,000 --> 00:00:00,000
We're going to click here.

413
00:00:00,000 --> 00:00:00,000
We're going to go in and look at this program.

414
00:00:00,000 --> 00:00:00,000
I'm going to make this a little larger again so you can see it.

415
00:00:00,000 --> 00:00:00,000
So notice I could say auto A equals this, but I instead,

416
00:00:00,000 --> 00:00:00,000
in which case it would be an int, right, an unsigned int,

417
00:00:00,000 --> 00:00:00,000
.25 is an unsigned int.

418
00:00:00,000 --> 00:00:00,000
Instead, what I want to do is think

419
00:00:00,000 --> 00:00:00,000
about using the smallest correct explicit type for that.

420
00:00:00,000 --> 00:00:00,000
So the question really we're asking is,

421
00:00:00,000 --> 00:00:00,000
what is the smallest type that will store minus 25?

422
00:00:00,000 --> 00:00:00,000
So an int obviously would.

423
00:00:00,000 --> 00:00:00,000
We could put a double inside there,

424
00:00:00,000 --> 00:00:00,000
but all of those would need to convert.

425
00:00:00,000 --> 00:00:00,000
And so the smallest type is an assigned char.

426
00:00:00,000 --> 00:00:00,000
So chars are what we use for values that are 8 bits.

427
00:00:00,000 --> 00:00:00,000
An 8-bit assigned char can hold the numbers

428
00:00:00,000 --> 00:00:00,000
from minus 128 to plus 127.

429
00:00:00,000 --> 00:00:00,000
So B, we could put that as assigned char,

430
00:00:00,000 --> 00:00:00,000
but 249 is outside the range of assigned char.

431
00:00:00,000 --> 00:00:00,000
It's outside the domain.

432
00:00:00,000 --> 00:00:00,000
So it wouldn't fit.

433
00:00:00,000 --> 00:00:00,000
What if instead, though, we made it an unsigned character?

434
00:00:00,000 --> 00:00:00,000
If it was an unsigned char or an unsigned byte, it would fit

435
00:00:00,000 --> 00:00:00,000
because the value for unsigned bytes is 0 to 255.

436
00:00:00,000 --> 00:00:00,000
So this would be an unsigned char.

437
00:00:00,000 --> 00:00:00,000
Okay, C obviously is bigger than we can store in assigned char

438
00:00:00,000 --> 00:00:00,000
or an unsigned char.

439
00:00:00,000 --> 00:00:00,000
How about the next larger number, the short?

440
00:00:00,000 --> 00:00:00,000
That's 16 bits.

441
00:00:00,000 --> 00:00:00,000
Could we store minus 1725 in that?

442
00:00:00,000 --> 00:00:00,000
Well, if it was an unsigned number, we could not,

443
00:00:00,000 --> 00:00:00,000
of course, because we can only have positive ones.

444
00:00:00,000 --> 00:00:00,000
So how about a signed short?

445
00:00:00,000 --> 00:00:00,000
Well, with 16 bits, we can store roughly plus or minus 32,000,

446
00:00:00,000 --> 00:00:00,000
and that will certainly fit.

447
00:00:00,000 --> 00:00:00,000
So this would be unsigned or signed short int.

448
00:00:00,000 --> 00:00:00,000
And with this type, because the default for all

449
00:00:00,000 --> 00:00:00,000
of integers is signed, we can leave off the word signed.

450
00:00:00,000 --> 00:00:00,000
And because with the shorts and longs,

451
00:00:00,000 --> 00:00:00,000
you can actually leave off the word int.

452
00:00:00,000 --> 00:00:00,000
We could write that simply as a short.

453
00:00:00,000 --> 00:00:00,000
Now, D obviously won't fit in plus or minus 32,000,

454
00:00:00,000 --> 00:00:00,000
but how about if we make that short unsigned?

455
00:00:00,000 --> 00:00:00,000
Well, then instead of plus or minus 32,000,

456
00:00:00,000 --> 00:00:00,000
we get 0 to roughly 65,000.

457
00:00:00,000 --> 00:00:00,000
And 49,000 would certainly fit in there.

458
00:00:00,000 --> 00:00:00,000
So this would be an unsigned short int.

459
00:00:00,000 --> 00:00:00,000
And again, we can leave off the word int if we want.

460
00:00:00,000 --> 00:00:00,000
[ Typing ]

461
00:00:00,000 --> 00:00:00,000
Okay, so this number is 2.

462
00:00:00,000 --> 00:00:00,000
There's hundreds.

463
00:00:00,000 --> 00:00:00,000
Here's thousands.

464
00:00:00,000 --> 00:00:00,000
Here's millions.

465
00:00:00,000 --> 00:00:00,000
It's 2,252,000, right?

466
00:00:00,000 --> 00:00:00,000
So obviously, that won't fit in a short.

467
00:00:00,000 --> 00:00:00,000
Will it fit in an int?

468
00:00:00,000 --> 00:00:00,000
Obviously, we have a negative number, so it has to be signed.

469
00:00:00,000 --> 00:00:00,000
It cannot be unsigned.

470
00:00:00,000 --> 00:00:00,000
And remember, the default is signed.

471
00:00:00,000 --> 00:00:00,000
We only have to put the unsigned keyword in there.

472
00:00:00,000 --> 00:00:00,000
We only have to put the signed keyword with chars.

473
00:00:00,000 --> 00:00:00,000
And if you just want to be pedantic,

474
00:00:00,000 --> 00:00:00,000
you can put it inside there.

475
00:00:00,000 --> 00:00:00,000
So an integer is 32 bits.

476
00:00:00,000 --> 00:00:00,000
That means we can store roughly plus or minus 2 billion numbers.

477
00:00:00,000 --> 00:00:00,000
So this is fine for int.

478
00:00:00,000 --> 00:00:00,000
Now, for the last three of these,

479
00:00:00,000 --> 00:00:00,000
I want to do something slightly different.

480
00:00:00,000 --> 00:00:00,000
I want to pretend that I am the compiler.

481
00:00:00,000 --> 00:00:00,000
And I want to put in what auto would put in here with 3u.

482
00:00:00,000 --> 00:00:00,000
And so for 3u, that would be an unsigned int.

483
00:00:00,000 --> 00:00:00,000
For minus 9ll, that would be a signed long long.

484
00:00:00,000 --> 00:00:00,000
Or just long long.

485
00:00:00,000 --> 00:00:00,000
Again, you can put signed long long int.

486
00:00:00,000 --> 00:00:00,000
That would be perfectly fine.

487
00:00:00,000 --> 00:00:00,000
So long long.

488
00:00:00,000 --> 00:00:00,000
And this one is an unsigned long long.

489
00:00:00,000 --> 00:00:00,000
For these exercises, we're using something called code check.

490
00:00:00,000 --> 00:00:00,000
So once you've typed your answer in there, you can go ahead

491
00:00:00,000 --> 00:00:00,000
and just click the code check button.

492
00:00:00,000 --> 00:00:00,000
And it will check it to see if you, in fact, got it correct.

493
00:00:00,000 --> 00:00:00,000
Okay? And so notice it's telling us

494
00:00:00,000 --> 00:00:00,000
that we have the correct values.

495
00:00:00,000 --> 00:00:00,000
And you're going to take a little picture.

496
00:00:00,000 --> 00:00:00,000
And so I'm going to actually make this a little smaller here.

497
00:00:00,000 --> 00:00:00,000
And I'm going to go ahead and take my picture.

498
00:00:00,000 --> 00:00:00,000
I'm going to do Windows shift s because I'm

499
00:00:00,000 --> 00:00:00,000
on a Windows machine.

500
00:00:00,000 --> 00:00:00,000
I'm going to take my picture.

501
00:00:00,000 --> 00:00:00,000
And I'm going to go over to my document here.

502
00:00:00,000 --> 00:00:00,000
And for exercise one, I'm going to go ahead

503
00:00:00,000 --> 00:00:00,000
and paste in those answers.

504
00:00:00,000 --> 00:00:00,000
Okay? If it gets too big, you can make it smaller

505
00:00:00,000 --> 00:00:00,000
so that it fits.

506
00:00:00,000 --> 00:00:00,000
We could have actually shot less,

507
00:00:00,000 --> 00:00:00,000
shot less for that picture.

508
00:00:00,000 --> 00:00:00,000
I shot kind of a lot for that picture.

509
00:00:00,000 --> 00:00:00,000
Okay, so let's go back to talking about.

510
00:00:00,000 --> 00:00:00,000
So that's types and inferred typing.

511
00:00:00,000 --> 00:00:00,000
Let's talk about binary numbers.

512
00:00:00,000 --> 00:00:00,000
I want to talk about how data is stored internally

513
00:00:00,000 --> 00:00:00,000
in these numbers.

514
00:00:00,000 --> 00:00:00,000
So internally, all numbers are stored in binary.

515
00:00:00,000 --> 00:00:00,000
In other words, base two.

516
00:00:00,000 --> 00:00:00,000
So when we talk about the base of a number,

517
00:00:00,000 --> 00:00:00,000
what we're talking about is the number of digits that are used

518
00:00:00,000 --> 00:00:00,000
to represent that number in human readable form.

519
00:00:00,000 --> 00:00:00,000
When we talk about the base of a number, we're talking about,

520
00:00:00,000 --> 00:00:00,000
again, the human readable form.

521
00:00:00,000 --> 00:00:00,000
So base two uses two digits.

522
00:00:00,000 --> 00:00:00,000
Those digits are zero and one.

523
00:00:00,000 --> 00:00:00,000
Base eight, or octal, uses eight digits.

524
00:00:00,000 --> 00:00:00,000
Those digits are zero, one, two, three, four, five, six, and seven.

525
00:00:00,000 --> 00:00:00,000
Base ten, or decimal numbers, uses ten digits.

526
00:00:00,000 --> 00:00:00,000
And the digits are zero through nine.

527
00:00:00,000 --> 00:00:00,000
And base 16, or hexadecimal, uses 16 digits.

528
00:00:00,000 --> 00:00:00,000
So we use the ten digits from decimal, zero through nine.

529
00:00:00,000 --> 00:00:00,000
And then we borrow the first six letters, A, B, C, D, E, and F.

530
00:00:00,000 --> 00:00:00,000
And so that's how we represent human readable

531
00:00:00,000 --> 00:00:00,000
hexadecimal numbers.

532
00:00:00,000 --> 00:00:00,000
So let's talk about how we interpret the bits internally,

533
00:00:00,000 --> 00:00:00,000
how we convert a number that's written

534
00:00:00,000 --> 00:00:00,000
in human readable form, zero, one, two, three, and so forth,

535
00:00:00,000 --> 00:00:00,000
to the actual value that's stored in the number.

536
00:00:00,000 --> 00:00:00,000
What does it mean when we write out the number 123?

537
00:00:00,000 --> 00:00:00,000
Well, in base ten, you learned this in grammar school.

538
00:00:00,000 --> 00:00:00,000
What we mean by 123, or one twenty three,

539
00:00:00,000 --> 00:00:00,000
is simply one times the base.

540
00:00:00,000 --> 00:00:00,000
Let me start at the right here.

541
00:00:00,000 --> 00:00:00,000
So whatever the base is, we take it to the zeroth power.

542
00:00:00,000 --> 00:00:00,000
So any number raised to the zeroth power is one.

543
00:00:00,000 --> 00:00:00,000
So that's three times one.

544
00:00:00,000 --> 00:00:00,000
Then we take the next digit, two times, and this is ten

545
00:00:00,000 --> 00:00:00,000
to the first power, or ten.

546
00:00:00,000 --> 00:00:00,000
So two times ten, plus one, that's the third digit

547
00:00:00,000 --> 00:00:00,000
over here, times ten to the second power,

548
00:00:00,000 --> 00:00:00,000
or ten times ten, or a hundred.

549
00:00:00,000 --> 00:00:00,000
And so in grammar school, you learned

550
00:00:00,000 --> 00:00:00,000
that is this is the ones place, this is the tens place,

551
00:00:00,000 --> 00:00:00,000
this is the hundreds place,

552
00:00:00,000 --> 00:00:00,000
the next one would be the thousands place.

553
00:00:00,000 --> 00:00:00,000
But this is what you're really doing under the hood.

554
00:00:00,000 --> 00:00:00,000
And if you understand that, then binary numbers,

555
00:00:00,000 --> 00:00:00,000
or base eight numbers, or base sixteen numbers, are easy.

556
00:00:00,000 --> 00:00:00,000
So here is a binary number.

557
00:00:00,000 --> 00:00:00,000
Because it's binary, we only have two digits, zero and one.

558
00:00:00,000 --> 00:00:00,000
And the way we interpret that, the way we get the value

559
00:00:00,000 --> 00:00:00,000
out of that, is by taking the base, which is two,

560
00:00:00,000 --> 00:00:00,000
raised to the powers, two to the zero, two to the first,

561
00:00:00,000 --> 00:00:00,000
two to the second, two to the third,

562
00:00:00,000 --> 00:00:00,000
two to the fourth, and so forth.

563
00:00:00,000 --> 00:00:00,000
And simply adding them together.

564
00:00:00,000 --> 00:00:00,000
So our right most digit here is one,

565
00:00:00,000 --> 00:00:00,000
and we take one times two to the power,

566
00:00:00,000 --> 00:00:00,000
two to the zeroth, or one times one.

567
00:00:00,000 --> 00:00:00,000
Then one times two to the first, or one times two.

568
00:00:00,000 --> 00:00:00,000
Then zero times two to the third, which of course is zero.

569
00:00:00,000 --> 00:00:00,000
Then one times two to the third, which is eight.

570
00:00:00,000 --> 00:00:00,000
Then one times two to the fourth, which is sixteen.

571
00:00:00,000 --> 00:00:00,000
Then one times two to the fifth, and so forth.

572
00:00:00,000 --> 00:00:00,000
And so that is simply one plus two, plus eight, plus sixteen,

573
00:00:00,000 --> 00:00:00,000
plus thirty-two, plus sixty-four,

574
00:00:00,000 --> 00:00:00,000
which gives me the same value.

575
00:00:00,000 --> 00:00:00,000
So one twenty-three, and this binary number,

576
00:00:00,000 --> 00:00:00,000
are exactly the same value.

577
00:00:00,000 --> 00:00:00,000
They're just represented in human different terms.

578
00:00:00,000 --> 00:00:00,000
We're representing them in different bases

579
00:00:00,000 --> 00:00:00,000
when we write them out.

580
00:00:00,000 --> 00:00:00,000
Now we will normally use base ten,

581
00:00:00,000 --> 00:00:00,000
but you should know algorithms to convert

582
00:00:00,000 --> 00:00:00,000
to these different bases.

583
00:00:00,000 --> 00:00:00,000
And so this gives you enough information to figure out how

584
00:00:00,000 --> 00:00:00,000
to convert to a different base.

585
00:00:00,000 --> 00:00:00,000
In other words, suppose we had this number,

586
00:00:00,000 --> 00:00:00,000
and we said it was base eight.

587
00:00:00,000 --> 00:00:00,000
Well that would be eight to the zeroth,

588
00:00:00,000 --> 00:00:00,000
plus one times eight to the first,

589
00:00:00,000 --> 00:00:00,000
plus zero times eight to the third, second.

590
00:00:00,000 --> 00:00:00,000
And then eight to the third, and so forth.

591
00:00:00,000 --> 00:00:00,000
We just simply replace these two to the sixth, two to the fifth,

592
00:00:00,000 --> 00:00:00,000
two to the fourth, by eight to the sixth, eight to the fifth,

593
00:00:00,000 --> 00:00:00,000
eight to the fourth.

594
00:00:00,000 --> 00:00:00,000
Or in base three, we do the same thing.

595
00:00:00,000 --> 00:00:00,000
So the conversion is essentially relatively simple.

596
00:00:00,000 --> 00:00:00,000
So we're going to do a second exercise.

597
00:00:00,000 --> 00:00:00,000
For this one, we're going to use our CS50 IDE.

598
00:00:00,000 --> 00:00:00,000
I'm going to go close that little thing I just typed there.

599
00:00:00,000 --> 00:00:00,000
We're going to do this first exercise,

600
00:00:00,000 --> 00:00:00,000
which shows the representation of different values.

601
00:00:00,000 --> 00:00:00,000
This is in part B over here, in IC03.

602
00:00:00,000 --> 00:00:00,000
And you're going to open up represent.cpp.

603
00:00:00,000 --> 00:00:00,000
You don't have to put your name on this, because we're just going

604
00:00:00,000 --> 00:00:00,000
to do some exercises and print

605
00:00:00,000 --> 00:00:00,000
out what the internal representation

606
00:00:00,000 --> 00:00:00,000
of these should be.

607
00:00:00,000 --> 00:00:00,000
Now to do that internal representation,

608
00:00:00,000 --> 00:00:00,000
what we're going to do is we're going

609
00:00:00,000 --> 00:00:00,000
to call a function called two bits.

610
00:00:00,000 --> 00:00:00,000
To do that, we've included this file called represent.h,

611
00:00:00,000 --> 00:00:00,000
that has the definition for the two bits function.

612
00:00:00,000 --> 00:00:00,000
Now most of you won't understand this right now.

613
00:00:00,000 --> 00:00:00,000
By the end of this semester, you will understand this.

614
00:00:00,000 --> 00:00:00,000
So we're going to look at that, and we're going to print

615
00:00:00,000 --> 00:00:00,000
out here what that means for each of those representations.

616
00:00:00,000 --> 00:00:00,000
So if I want the representation of the character A,

617
00:00:00,000 --> 00:00:00,000
what I'm going to print out is two bits, and I'm going to print

618
00:00:00,000 --> 00:00:00,000
out the literal character A. Okay?

619
00:00:00,000 --> 00:00:00,000
Now if I want the literal representation, in other words,

620
00:00:00,000 --> 00:00:00,000
what do the bits look like for the unsigned char B,

621
00:00:00,000 --> 00:00:00,000
I'm going to have to -- or the unsigned char 65,

622
00:00:00,000 --> 00:00:00,000
I'm going to have to make a variable of that type.

623
00:00:00,000 --> 00:00:00,000
So I'm going to say unsigned char B equals 65,

624
00:00:00,000 --> 00:00:00,000
and then I'm just going to print out two bits B. Okay?

625
00:00:00,000 --> 00:00:00,000
So you notice when I did A, I put the quotes around it.

626
00:00:00,000 --> 00:00:00,000
I passed the literal inside here.

627
00:00:00,000 --> 00:00:00,000
Here I'm passing in the variable.

628
00:00:00,000 --> 00:00:00,000
Okay. We've got the short value.

629
00:00:00,000 --> 00:00:00,000
So the signed short value, 32,768.

630
00:00:00,000 --> 00:00:00,000
So I'm going to have short C equals 32,768.

631
00:00:00,000 --> 00:00:00,000
And I'm going to have unsigned -- I'll do it.

632
00:00:00,000 --> 00:00:00,000
I'll do it between them next time.

633
00:00:00,000 --> 00:00:00,000
And so let's do two things here.

634
00:00:00,000 --> 00:00:00,000
Let's do two bits C. And then let's put

635
00:00:00,000 --> 00:00:00,000
out a comma and say C equals -- or I'll use the arrow -- C. Okay?

636
00:00:00,000 --> 00:00:00,000
And let's do a D for the unsigned short.

637
00:00:00,000 --> 00:00:00,000
So unsigned short D equals 32,768.

638
00:00:00,000 --> 00:00:00,000
And I'm going to do exactly the same thing I did here.

639
00:00:00,000 --> 00:00:00,000
I'm just going to copy that.

640
00:00:00,000 --> 00:00:00,000
I'm going to paste it over here.

641
00:00:00,000 --> 00:00:00,000
And I'm going to print out D, D, and D. Okay?

642
00:00:00,000 --> 00:00:00,000
Okay. Here we want the int value, 15.

643
00:00:00,000 --> 00:00:00,000
So two bits, 15.

644
00:00:00,000 --> 00:00:00,000
Now 15, of course, literally is an int.

645
00:00:00,000 --> 00:00:00,000
We want the int value minus 15.

646
00:00:00,000 --> 00:00:00,000
Two bits minus 15.

647
00:00:00,000 --> 00:00:00,000
We want the float, 15F.

648
00:00:00,000 --> 00:00:00,000
And the double 15F -- or double 15.

649
00:00:00,000 --> 00:00:00,000
I'm having a hard time putting my fingers on the right keys.

650
00:00:00,000 --> 00:00:00,000
Two bits, 15.0, or just 15 point.

651
00:00:00,000 --> 00:00:00,000
All right?

652
00:00:00,000 --> 00:00:00,000
If we just did 15, we'd have an integer.

653
00:00:00,000 --> 00:00:00,000
If we did 15.0, we'd have something else.

654
00:00:00,000 --> 00:00:00,000
But the float -- notice I don't need the floating point.

655
00:00:00,000 --> 00:00:00,000
If I put the F on the end of it, it knows it's float.

656
00:00:00,000 --> 00:00:00,000
I'm going to hope that's right.

657
00:00:00,000 --> 00:00:00,000
We'll find out when we compile it.

658
00:00:00,000 --> 00:00:00,000
Now then I'm going to be two bits,

659
00:00:00,000 --> 00:00:00,000
and I'm going to do a minus 15.0.

660
00:00:00,000 --> 00:00:00,000
All right?

661
00:00:00,000 --> 00:00:00,000
Because we did minus 15 with no point zero,

662
00:00:00,000 --> 00:00:00,000
and we got the int minus 15 here.

663
00:00:00,000 --> 00:00:00,000
Here we have the double minus 15.

664
00:00:00,000 --> 00:00:00,000
Now to compile this, we're going to have to right click

665
00:00:00,000 --> 00:00:00,000
on the folder that's in, open it in an integrated terminal,

666
00:00:00,000 --> 00:00:00,000
and notice that it does the change directory

667
00:00:00,000 --> 00:00:00,000
to move us over there.

668
00:00:00,000 --> 00:00:00,000
And then I'm simply going to say make run.

669
00:00:00,000 --> 00:00:00,000
Okay? Now I had an error.

670
00:00:00,000 --> 00:00:00,000
I do need the period on the 15F.

671
00:00:00,000 --> 00:00:00,000
I told you the compiler would tell us if we made

672
00:00:00,000 --> 00:00:00,000
that mistake, and I did make that mistake.

673
00:00:00,000 --> 00:00:00,000
So I'm going to put a period in the 15F.

674
00:00:00,000 --> 00:00:00,000
Okay, let's try it again.

675
00:00:00,000 --> 00:00:00,000
I'll clear the terminal with control L. And make run.

676
00:00:00,000 --> 00:00:00,000
Okay, so this is what we talked about originally with types.

677
00:00:00,000 --> 00:00:00,000
Notice that the character A,

678
00:00:00,000 --> 00:00:00,000
because I said it was a character, represents A.

679
00:00:00,000 --> 00:00:00,000
If I printed out the character A, I would get A.

680
00:00:00,000 --> 00:00:00,000
And actually, let's just do that.

681
00:00:00,000 --> 00:00:00,000
Let's go back here and do the same thing like we did for C

682
00:00:00,000 --> 00:00:00,000
and D. So I'm going to print out A. And here, oh,

683
00:00:00,000 --> 00:00:00,000
I'm going to say -- oh, actually,

684
00:00:00,000 --> 00:00:00,000
let's make a variable of that.

685
00:00:00,000 --> 00:00:00,000
So char A equals A. And put a semicolon there.

686
00:00:00,000 --> 00:00:00,000
And we'll do A. And then we'll print out comma A is --

687
00:00:00,000 --> 00:00:00,000
print out A. And then a new line.

688
00:00:00,000 --> 00:00:00,000
Okay? And we'll do the same thing to here.

689
00:00:00,000 --> 00:00:00,000
We'll add the -- oops.

690
00:00:00,000 --> 00:00:00,000
The comma B equals or B is B. And that will make it a little

691
00:00:00,000 --> 00:00:00,000
clearer when we build this and run it again.

692
00:00:00,000 --> 00:00:00,000
So let me clear the console and do make run again.

693
00:00:00,000 --> 00:00:00,000
[ Background Sounds ]

694
00:00:00,000 --> 00:00:00,000
Well, I didn't like that.

695
00:00:00,000 --> 00:00:00,000
[ Background Sounds ]

696
00:00:00,000 --> 00:00:00,000
I must have made a mistake in my code, which I did.

697
00:00:00,000 --> 00:00:00,000
So I'm going to go -- oh, I said two bits one instead

698
00:00:00,000 --> 00:00:00,000
of two bits A. Okay.

699
00:00:00,000 --> 00:00:00,000
Third time, hopefully this is the charm.

700
00:00:00,000 --> 00:00:00,000
Okay. So notice this bit pattern has a value.

701
00:00:00,000 --> 00:00:00,000
What's its value?

702
00:00:00,000 --> 00:00:00,000
The letter A. Okay?

703
00:00:00,000 --> 00:00:00,000
This bit pattern is the unsigned character 65.

704
00:00:00,000 --> 00:00:00,000
Now, when we print it out, it says it's A, but it's really 65.

705
00:00:00,000 --> 00:00:00,000
So depending on what we determined it was,

706
00:00:00,000 --> 00:00:00,000
notice the value changes.

707
00:00:00,000 --> 00:00:00,000
It was our determination that this was an int or a char.

708
00:00:00,000 --> 00:00:00,000
Right? So unsigned char 65 and int A have the same value

709
00:00:00,000 --> 00:00:00,000
or have the same bit pattern, but they have a different value

710
00:00:00,000 --> 00:00:00,000
because they represent different numbers.

711
00:00:00,000 --> 00:00:00,000
If we look at the short 32768, we get this bit pattern,

712
00:00:00,000 --> 00:00:00,000
16 bits, and we have the value 32768.

713
00:00:00,000 --> 00:00:00,000
If we look at unsigned short 32768,

714
00:00:00,000 --> 00:00:00,000
I'm obviously making some kind of mistake here.

715
00:00:00,000 --> 00:00:00,000
I'm going to pause this while I correct my mistake.

716
00:00:00,000 --> 00:00:00,000
Okay. I'm back.

717
00:00:00,000 --> 00:00:00,000
I'm sure many of you saw my errors.

718
00:00:00,000 --> 00:00:00,000
I said I want the short 32768, and I typed the short 32678.

719
00:00:00,000 --> 00:00:00,000
So 768 and 768.

720
00:00:00,000 --> 00:00:00,000
And I'm going to print this as an int.

721
00:00:00,000 --> 00:00:00,000
Okay. So let me try it.

722
00:00:00,000 --> 00:00:00,000
I said last time three times the charm.

723
00:00:00,000 --> 00:00:00,000
We'll hope that four times is the charm.

724
00:00:00,000 --> 00:00:00,000
So I'm going to do an A print.

725
00:00:00,000 --> 00:00:00,000
Okay. So here we have the character A

726
00:00:00,000 --> 00:00:00,000
and the unsigned character 65.

727
00:00:00,000 --> 00:00:00,000
If we take that value, this value, and we represent it

728
00:00:00,000 --> 00:00:00,000
as a character, it's A. If we represent it

729
00:00:00,000 --> 00:00:00,000
as an integer, it's 1.

730
00:00:00,000 --> 00:00:00,000
If we take this value and we represent it as a short,

731
00:00:00,000 --> 00:00:00,000
notice it won't fit inside a short.

732
00:00:00,000 --> 00:00:00,000
It does what we call an overflow.

733
00:00:00,000 --> 00:00:00,000
And so the value that's stored in there is -32768.

734
00:00:00,000 --> 00:00:00,000
If we store it in an unsigned short, which can store from 0

735
00:00:00,000 --> 00:00:00,000
to 65,000, we can store that value.

736
00:00:00,000 --> 00:00:00,000
So this does what we say overflows the domain.

737
00:00:00,000 --> 00:00:00,000
If we look at the integer 15, we have this bit pattern.

738
00:00:00,000 --> 00:00:00,000
And if we look at the value -15, we get some insight

739
00:00:00,000 --> 00:00:00,000
as how negative and positive numbers are stored differently

740
00:00:00,000 --> 00:00:00,000
as to their bit patterns.

741
00:00:00,000 --> 00:00:00,000
If we look at the float 15,

742
00:00:00,000 --> 00:00:00,000
so here's the integer 15 right here.

743
00:00:00,000 --> 00:00:00,000
And here's the float 15.

744
00:00:00,000 --> 00:00:00,000
Notice they're using the same amount of storage,

745
00:00:00,000 --> 00:00:00,000
but the bits are arranged entirely differently.

746
00:00:00,000 --> 00:00:00,000
In other words, the interpretation

747
00:00:00,000 --> 00:00:00,000
of the bits is different just

748
00:00:00,000 --> 00:00:00,000
because we said it was a different type.

749
00:00:00,000 --> 00:00:00,000
And if you look at the difference between the float

750
00:00:00,000 --> 00:00:00,000
and the double, you'll see

751
00:00:00,000 --> 00:00:00,000
that they arrange somewhat similarly.

752
00:00:00,000 --> 00:00:00,000
You can see the actual data right there for 15

753
00:00:00,000 --> 00:00:00,000
and the data for 15 right there.

754
00:00:00,000 --> 00:00:00,000
And the data for 15 right here.

755
00:00:00,000 --> 00:00:00,000
You can see that they're somewhat the same,

756
00:00:00,000 --> 00:00:00,000
although a little bit differently.

757
00:00:00,000 --> 00:00:00,000
And you notice -15 and positive 15.

758
00:00:00,000 --> 00:00:00,000
So look at the difference between negative and positive here

759
00:00:00,000 --> 00:00:00,000
for integers, the same number.

760
00:00:00,000 --> 00:00:00,000
And look at the difference between negative

761
00:00:00,000 --> 00:00:00,000
and positive for doubles.

762
00:00:00,000 --> 00:00:00,000
Only one bit has changed.

763
00:00:00,000 --> 00:00:00,000
And so what you can take away from this, I don't expect you

764
00:00:00,000 --> 00:00:00,000
to understand this decoding.

765
00:00:00,000 --> 00:00:00,000
What I do expect you to understand is

766
00:00:00,000 --> 00:00:00,000
that the value is a set of bits interpreted according

767
00:00:00,000 --> 00:00:00,000
to its type.

768
00:00:00,000 --> 00:00:00,000
The size of each representation of a type is based

769
00:00:00,000 --> 00:00:00,000
on the individual platform, the individual implementation.

770
00:00:00,000 --> 00:00:00,000
And that we can have two patterns

771
00:00:00,000 --> 00:00:00,000
that are exactly the same.

772
00:00:00,000 --> 00:00:00,000
But if their type is different,

773
00:00:00,000 --> 00:00:00,000
so notice these two patterns are the same.

774
00:00:00,000 --> 00:00:00,000
And these two patterns are the same.

775
00:00:00,000 --> 00:00:00,000
But because their type was different,

776
00:00:00,000 --> 00:00:00,000
their values are different.

777
00:00:00,000 --> 00:00:00,000
All right?

778
00:00:00,000 --> 00:00:00,000
So the value is the set of bits interpreted according

779
00:00:00,000 --> 00:00:00,000
to its type.

780
00:00:00,000 --> 00:00:00,000
Okay. So that's exercise B. You're going to take a picture

781
00:00:00,000 --> 00:00:00,000
of this.

782
00:00:00,000 --> 00:00:00,000
And you're going to take a picture of this part here

783
00:00:00,000 --> 00:00:00,000
for the in-class exercise.

784
00:00:00,000 --> 00:00:00,000
Okay. Let's go on to the next topic,

785
00:00:00,000 --> 00:00:00,000
which is conversions and casts.

786
00:00:00,000 --> 00:00:00,000
Okay? So C++ automatically converts between types

787
00:00:00,000 --> 00:00:00,000
of numbers on initialization or assignment.

788
00:00:00,000 --> 00:00:00,000
Okay? It does this silently.

789
00:00:00,000 --> 00:00:00,000
It doesn't warn you that it's happening.

790
00:00:00,000 --> 00:00:00,000
It just does it.

791
00:00:00,000 --> 00:00:00,000
So in C++11, we can use the curly braces called

792
00:00:00,000 --> 00:00:00,000
"list assignment" to give you a little bit greater control.

793
00:00:00,000 --> 00:00:00,000
So if you had an int variable and you assigned a double to it,

794
00:00:00,000 --> 00:00:00,000
maybe the variable should have been a double,

795
00:00:00,000 --> 00:00:00,000
but you don't notice.

796
00:00:00,000 --> 00:00:00,000
In Java, you get an error.

797
00:00:00,000 --> 00:00:00,000
In C++, you won't unless you use this list assignment.

798
00:00:00,000 --> 00:00:00,000
Now, you may get a compiler warning on an error

799
00:00:00,000 --> 00:00:00,000
or conversion, but there's no guarantee

800
00:00:00,000 --> 00:00:00,000
that that will actually happen because it's not illegal.

801
00:00:00,000 --> 00:00:00,000
So if you mean to explicitly convert between different types,

802
00:00:00,000 --> 00:00:00,000
you should use what's called a static cast.

803
00:00:00,000 --> 00:00:00,000
And see, in Java, you did something similar --

804
00:00:00,000 --> 00:00:00,000
simpler in Python as well, if you wanted to cast.

805
00:00:00,000 --> 00:00:00,000
This shows that the conversion is intentional.

806
00:00:00,000 --> 00:00:00,000
So for instance, if I want to store the whole part

807
00:00:00,000 --> 00:00:00,000
of a number pi, I can assign it to a static underscore cast.

808
00:00:00,000 --> 00:00:00,000
In angle brackets, I put the type I want

809
00:00:00,000 --> 00:00:00,000
to create my temporary of.

810
00:00:00,000 --> 00:00:00,000
So I want to convert pi to an int,

811
00:00:00,000 --> 00:00:00,000
and I put that in parentheses here.

812
00:00:00,000 --> 00:00:00,000
So this is the syntax for a static cast.

813
00:00:00,000 --> 00:00:00,000
Okay, so let's go and look at expressions.

814
00:00:00,000 --> 00:00:00,000
Let's go and look at expressions.

815
00:00:00,000 --> 00:00:00,000
So an expression is a calculation

816
00:00:00,000 --> 00:00:00,000
that produces a value.

817
00:00:00,000 --> 00:00:00,000
And to do that, we use operators and operands.

818
00:00:00,000 --> 00:00:00,000
These are terms from mathematics.

819
00:00:00,000 --> 00:00:00,000
So operands are the data that we operate on.

820
00:00:00,000 --> 00:00:00,000
And operands can be literal.

821
00:00:00,000 --> 00:00:00,000
So 3 plus 5 is an expression.

822
00:00:00,000 --> 00:00:00,000
3 and 5 are literally values.

823
00:00:00,000 --> 00:00:00,000
We can say use variables in expression.

824
00:00:00,000 --> 00:00:00,000
A minus 3.

825
00:00:00,000 --> 00:00:00,000
A is not a value, but it contains a value.

826
00:00:00,000 --> 00:00:00,000
So we can use it in an expression.

827
00:00:00,000 --> 00:00:00,000
We can use a function call.

828
00:00:00,000 --> 00:00:00,000
So func a is not a value, but it produces a value when I call it,

829
00:00:00,000 --> 00:00:00,000
and I can use that in an expression, 2 times func a.

830
00:00:00,000 --> 00:00:00,000
And we can have a sub-expression.

831
00:00:00,000 --> 00:00:00,000
So a plus 3 produces a value.

832
00:00:00,000 --> 00:00:00,000
That's an expression.

833
00:00:00,000 --> 00:00:00,000
And I can use that sub-expression as part

834
00:00:00,000 --> 00:00:00,000
of the expression a plus 3 times 5.

835
00:00:00,000 --> 00:00:00,000
Now the operators are the plus, the minus,

836
00:00:00,000 --> 00:00:00,000
the multiply in this situation.

837
00:00:00,000 --> 00:00:00,000
And all of these operators have three characteristics.

838
00:00:00,000 --> 00:00:00,000
First is the term arity.

839
00:00:00,000 --> 00:00:00,000
Arity simply means how many operands are needed.

840
00:00:00,000 --> 00:00:00,000
So 3 plus 5 is called a binary operator

841
00:00:00,000 --> 00:00:00,000
because two operands are needed.

842
00:00:00,000 --> 00:00:00,000
Minus 5 is a unary operator because only one operand

843
00:00:00,000 --> 00:00:00,000
is needed.

844
00:00:00,000 --> 00:00:00,000
Finally, we have one operator called the tertiary operator

845
00:00:00,000 --> 00:00:00,000
or the conditional operator that requires three operands.

846
00:00:00,000 --> 00:00:00,000
What the condition is, what the true value is,

847
00:00:00,000 --> 00:00:00,000
what the false value is.

848
00:00:00,000 --> 00:00:00,000
Secondly, we have what's called precedence.

849
00:00:00,000 --> 00:00:00,000
Precedence determines which operators bind more tightly

850
00:00:00,000 --> 00:00:00,000
to data than another operator.

851
00:00:00,000 --> 00:00:00,000
Now you probably learned P-E-M-D-A-S,

852
00:00:00,000 --> 00:00:00,000
PEMDAS in algebra.

853
00:00:00,000 --> 00:00:00,000
That's not exactly correct here.

854
00:00:00,000 --> 00:00:00,000
First, we don't have any E.

855
00:00:00,000 --> 00:00:00,000
There's no exponential operator.

856
00:00:00,000 --> 00:00:00,000
The P stands for the parenthesis.

857
00:00:00,000 --> 00:00:00,000
The M stands for the multiplicative operators,

858
00:00:00,000 --> 00:00:00,000
which means multiplication and division.

859
00:00:00,000 --> 00:00:00,000
Neither one of them binds more tightly.

860
00:00:00,000 --> 00:00:00,000
They're just at the same level.

861
00:00:00,000 --> 00:00:00,000
And the last level, the additive operators,

862
00:00:00,000 --> 00:00:00,000
includes addition and subtraction.

863
00:00:00,000 --> 00:00:00,000
Finally, associativity determines whether we go

864
00:00:00,000 --> 00:00:00,000
from right to left or left to right.

865
00:00:00,000 --> 00:00:00,000
And this is called the tie-breaking rule.

866
00:00:00,000 --> 00:00:00,000
We only use associativity when we have two operators

867
00:00:00,000 --> 00:00:00,000
at the same level of precedence.

868
00:00:00,000 --> 00:00:00,000
So let's look at an example.

869
00:00:00,000 --> 00:00:00,000
Here is an expression, 7 times 2 divided by 3.

870
00:00:00,000 --> 00:00:00,000
So each of these is a binary operator.

871
00:00:00,000 --> 00:00:00,000
Notice that multiplication

872
00:00:00,000 --> 00:00:00,000
and division have the same level of precedence.

873
00:00:00,000 --> 00:00:00,000
So the 2 and 3 bind at the same level as the 7 and 2.

874
00:00:00,000 --> 00:00:00,000
So what should we do?

875
00:00:00,000 --> 00:00:00,000
Well, we don't have a way to evaluate this.

876
00:00:00,000 --> 00:00:00,000
We have to fall back on rule 3, associativity.

877
00:00:00,000 --> 00:00:00,000
All binary operators are left associative,

878
00:00:00,000 --> 00:00:00,000
meaning we go from the left to the right.

879
00:00:00,000 --> 00:00:00,000
So this is 7 by 2 times 2, which is 14,

880
00:00:00,000 --> 00:00:00,000
divided by 3, which is 3.

881
00:00:00,000 --> 00:00:00,000
Okay? 3 or 4?

882
00:00:00,000 --> 00:00:00,000
4. 4. Okay.

883
00:00:00,000 --> 00:00:00,000
Okay. So if it was the other way, right,

884
00:00:00,000 --> 00:00:00,000
if we did the 2 divided by 3, we'd get 0 times 7,

885
00:00:00,000 --> 00:00:00,000
which would be 0.

886
00:00:00,000 --> 00:00:00,000
Okay. Now let's look at the arithmetic operators.

887
00:00:00,000 --> 00:00:00,000
We looked at the basic types.

888
00:00:00,000 --> 00:00:00,000
We've looked at the vocabulary for calculations.

889
00:00:00,000 --> 00:00:00,000
Let's look at the operators.

890
00:00:00,000 --> 00:00:00,000
There are five basic arithmetic operators.

891
00:00:00,000 --> 00:00:00,000
There is not an operator for exponentiation, okay,

892
00:00:00,000 --> 00:00:00,000
even though there is a math.

893
00:00:00,000 --> 00:00:00,000
There is not in C++.

894
00:00:00,000 --> 00:00:00,000
Now all five of these don't modify their operands.

895
00:00:00,000 --> 00:00:00,000
So you can use all five of these operators

896
00:00:00,000 --> 00:00:00,000
with an expression or a literal.

897
00:00:00,000 --> 00:00:00,000
So addition and subtraction is the plus and the minus token.

898
00:00:00,000 --> 00:00:00,000
These can also be the unary plus

899
00:00:00,000 --> 00:00:00,000
and the unary minus operators.

900
00:00:00,000 --> 00:00:00,000
So we use the same token depending on the context

901
00:00:00,000 --> 00:00:00,000
as to which operator it means.

902
00:00:00,000 --> 00:00:00,000
We have multiplication, which is the star,

903
00:00:00,000 --> 00:00:00,000
like it is in most programming languages, division,

904
00:00:00,000 --> 00:00:00,000
which is the forward slash, and remainder.

905
00:00:00,000 --> 00:00:00,000
So these last two require a little bit of explanation.

906
00:00:00,000 --> 00:00:00,000
Okay. Integer division in C++ works like integer division

907
00:00:00,000 --> 00:00:00,000
in Java, but unlike integer division in Python.

908
00:00:00,000 --> 00:00:00,000
In Python, when you divide two integers, you get real division.

909
00:00:00,000 --> 00:00:00,000
In other words, 2 divided by 3 is .666.

910
00:00:00,000 --> 00:00:00,000
In Java and C++, 2 divided by 3 is 0, right?

911
00:00:00,000 --> 00:00:00,000
And so look at this little girl standing

912
00:00:00,000 --> 00:00:00,000
at the board dividing 80 by 9.

913
00:00:00,000 --> 00:00:00,000
We have the thing we're dividing by --

914
00:00:00,000 --> 00:00:00,000
the thing we're dividing, the thing we're dividing by,

915
00:00:00,000 --> 00:00:00,000
and on the top of this little house,

916
00:00:00,000 --> 00:00:00,000
what we've done is we've put the quotient.

917
00:00:00,000 --> 00:00:00,000
So 9 -- 80 divided by 9 in C++ is 8.

918
00:00:00,000 --> 00:00:00,000
We discard this 8 down here in the basement.

919
00:00:00,000 --> 00:00:00,000
So it's not 8, 8, and 8/9.

920
00:00:00,000 --> 00:00:00,000
It's just 8.

921
00:00:00,000 --> 00:00:00,000
So the quotient's calculated.

922
00:00:00,000 --> 00:00:00,000
The remainder is discarded.

923
00:00:00,000 --> 00:00:00,000
The result is an integer.

924
00:00:00,000 --> 00:00:00,000
So 8, 8, and 8/9 is, of course, closer to 9, right?

925
00:00:00,000 --> 00:00:00,000
Because 81 would be 9.

926
00:00:00,000 --> 00:00:00,000
If we divided 81 by 9, we'd get 9.

927
00:00:00,000 --> 00:00:00,000
But it's not rounded up to 9.

928
00:00:00,000 --> 00:00:00,000
It's just 8 in that case.

929
00:00:00,000 --> 00:00:00,000
If we want the part down here in the basement,

930
00:00:00,000 --> 00:00:00,000
the part the little girl is drawing right now,

931
00:00:00,000 --> 00:00:00,000
we can use the remainder operator.

932
00:00:00,000 --> 00:00:00,000
This percent sign is not the --

933
00:00:00,000 --> 00:00:00,000
this doesn't have anything to do with percents.

934
00:00:00,000 --> 00:00:00,000
It also is not exactly the modulus operator.

935
00:00:00,000 --> 00:00:00,000
Modulus is a slightly different operation than the remainder.

936
00:00:00,000 --> 00:00:00,000
But it's close to that, okay?

937
00:00:00,000 --> 00:00:00,000
So 12 remainder 5 is 2.

938
00:00:00,000 --> 00:00:00,000
That's because when I divide 12 by 5, I get 2 for the quotient.

939
00:00:00,000 --> 00:00:00,000
There are two 5s in 12, but there's 2 left over, okay?

940
00:00:00,000 --> 00:00:00,000
So that's the remainder operator.

941
00:00:00,000 --> 00:00:00,000
Now, the last operators I want to look

942
00:00:00,000 --> 00:00:00,000
at are called side effect operators.

943
00:00:00,000 --> 00:00:00,000
And side effect operators include assignment,

944
00:00:00,000 --> 00:00:00,000
the shorthand assignment, plus equals,

945
00:00:00,000 --> 00:00:00,000
and increment and decrement.

946
00:00:00,000 --> 00:00:00,000
So increment and decrement, plus plus and minus minus.

947
00:00:00,000 --> 00:00:00,000
Those add 1 or subtract 1 to a variable.

948
00:00:00,000 --> 00:00:00,000
However, like all expressions, they produce a value.

949
00:00:00,000 --> 00:00:00,000
So the secondary side effect is to change the operand.

950
00:00:00,000 --> 00:00:00,000
So plus plus a adds 1 to a.

951
00:00:00,000 --> 00:00:00,000
Minus minus b subtracts 1 from b. It changes a and b.

952
00:00:00,000 --> 00:00:00,000
Thus, because it changes a and b, they only work

953
00:00:00,000 --> 00:00:00,000
with modifiable l values.

954
00:00:00,000 --> 00:00:00,000
That means you cannot write plus plus 7.

955
00:00:00,000 --> 00:00:00,000
Plus plus 7 is not equal to 7 plus 1.

956
00:00:00,000 --> 00:00:00,000
Plus plus 7 is illegal.

957
00:00:00,000 --> 00:00:00,000
You're trying to change the value 7.

958
00:00:00,000 --> 00:00:00,000
So the side effect is always to change 1 or subtract 1

959
00:00:00,000 --> 00:00:00,000
from the variable's values.

960
00:00:00,000 --> 00:00:00,000
So it's just a simpler way of saying x equals x plus 1.

961
00:00:00,000 --> 00:00:00,000
Or x equals x minus 1, right?

962
00:00:00,000 --> 00:00:00,000
You can simply say x plus plus or x minus minus.

963
00:00:00,000 --> 00:00:00,000
Or plus plus x or minus minus x. Now, the value

964
00:00:00,000 --> 00:00:00,000
of the whole expression, however,

965
00:00:00,000 --> 00:00:00,000
depends on where you place the operator.

966
00:00:00,000 --> 00:00:00,000
If you put it in front of the variable plus plus a,

967
00:00:00,000 --> 00:00:00,000
that changes a, and then it returns the variable

968
00:00:00,000 --> 00:00:00,000
that is changed.

969
00:00:00,000 --> 00:00:00,000
So plus plus a means change a and return a

970
00:00:00,000 --> 00:00:00,000
as the value of the expression.

971
00:00:00,000 --> 00:00:00,000
Postfix, writing a plus plus, saves the value

972
00:00:00,000 --> 00:00:00,000
that a had before we changed it, changes a,

973
00:00:00,000 --> 00:00:00,000
and then returns its own old saved value as a temporary.

974
00:00:00,000 --> 00:00:00,000
So let me give you a couple examples, short examples here

975
00:00:00,000 --> 00:00:00,000
so you can see that.

976
00:00:00,000 --> 00:00:00,000
I'm going to close represent, and I'm going to open

977
00:00:00,000 --> 00:00:00,000
up my example here.

978
00:00:00,000 --> 00:00:00,000
And I'm going to just put some simple code in here,

979
00:00:00,000 --> 00:00:00,000
include iostream using namespace standard int main.

980
00:00:00,000 --> 00:00:00,000
So I'm going to say int a equals 6, okay?

981
00:00:00,000 --> 00:00:00,000
I'm going to say int b equals a plus plus.

982
00:00:00,000 --> 00:00:00,000
And then I'm going to print out a and b.

983
00:00:00,000 --> 00:00:00,000
So what would you expect to get out of this?

984
00:00:00,000 --> 00:00:00,000
Now, I'm going to have to open up a terminal here

985
00:00:00,000 --> 00:00:00,000
on my CS150 folder.

986
00:00:00,000 --> 00:00:00,000
And I'm going to have to do make example.

987
00:00:00,000 --> 00:00:00,000
So I don't have a make file for it,

988
00:00:00,000 --> 00:00:00,000
so I have to use its name of the program.

989
00:00:00,000 --> 00:00:00,000
To run it, I have to do dot slash example.

990
00:00:00,000 --> 00:00:00,000
So if you watched in lecture one,

991
00:00:00,000 --> 00:00:00,000
if you watched the CS50 video on using the command line,

992
00:00:00,000 --> 00:00:00,000
you'll realize how to build and make a program.

993
00:00:00,000 --> 00:00:00,000
So when I run example, that prints out 7 and 6.

994
00:00:00,000 --> 00:00:00,000
So notice a plus plus changed a to 7, right?

995
00:00:00,000 --> 00:00:00,000
This changed a to 7.

996
00:00:00,000 --> 00:00:00,000
However, the value of this expression is the temporary

997
00:00:00,000 --> 00:00:00,000
value that a had, and that's what's copied over into b, okay?

998
00:00:00,000 --> 00:00:00,000
So notice b is 6 and a is 7 in this example.

999
00:00:00,000 --> 00:00:00,000
Now, there's some pitfalls with this.

1000
00:00:00,000 --> 00:00:00,000
So here are the things to avoid.

1001
00:00:00,000 --> 00:00:00,000
Notice here, I'm calling a function.

1002
00:00:00,000 --> 00:00:00,000
I'm passing as an argument n,

1003
00:00:00,000 --> 00:00:00,000
and then the expression n times n plus plus.

1004
00:00:00,000 --> 00:00:00,000
Well, the problem here is that n plus plus changes n.

1005
00:00:00,000 --> 00:00:00,000
So I don't know if the n over here on the left or the n

1006
00:00:00,000 --> 00:00:00,000
in the middle have the value before

1007
00:00:00,000 --> 00:00:00,000
or after it's changed.

1008
00:00:00,000 --> 00:00:00,000
You don't know.

1009
00:00:00,000 --> 00:00:00,000
Similarly, this.

1010
00:00:00,000 --> 00:00:00,000
I have an expression with n divided by 2 plus 5 times 1 plus

1011
00:00:00,000 --> 00:00:00,000
n plus plus, I'm not sure if this n has been changed or not.

1012
00:00:00,000 --> 00:00:00,000
Now, it doesn't look like it when you look at it.

1013
00:00:00,000 --> 00:00:00,000
You look at it and you think, well,

1014
00:00:00,000 --> 00:00:00,000
obviously it hasn't been changed.

1015
00:00:00,000 --> 00:00:00,000
It appears after it.

1016
00:00:00,000 --> 00:00:00,000
It's always left to right.

1017
00:00:00,000 --> 00:00:00,000
That's not the case, okay?

1018
00:00:00,000 --> 00:00:00,000
That is not the case, okay?

1019
00:00:00,000 --> 00:00:00,000
Finally, look at that expression.

1020
00:00:00,000 --> 00:00:00,000
Y equals n plus plus plus n plus plus.

1021
00:00:00,000 --> 00:00:00,000
Again, you don't know what that means.

1022
00:00:00,000 --> 00:00:00,000
So some rules to remember.

1023
00:00:00,000 --> 00:00:00,000
Don't use a variable that's part of more than one argument.

1024
00:00:00,000 --> 00:00:00,000
Don't use if a variable appears more than once

1025
00:00:00,000 --> 00:00:00,000
in an expression, n and n plus plus over here.

1026
00:00:00,000 --> 00:00:00,000
The parenthesis won't help you in this case.

1027
00:00:00,000 --> 00:00:00,000
You cannot put parenthesis around it to make it safer.

1028
00:00:00,000 --> 00:00:00,000
It's unsafe, okay?

1029
00:00:00,000 --> 00:00:00,000
So here, this is an expression, n plus plus plus n plus plus.

1030
00:00:00,000 --> 00:00:00,000
Don't use if the variable n appears more

1031
00:00:00,000 --> 00:00:00,000
than once in an expression.

1032
00:00:00,000 --> 00:00:00,000
This also applies to the assignment operator.

1033
00:00:00,000 --> 00:00:00,000
In other words, don't write something like this.

1034
00:00:00,000 --> 00:00:00,000
Y equals y plus plus.

1035
00:00:00,000 --> 00:00:00,000
Well, y plus plus is the value y had before it changed.

1036
00:00:00,000 --> 00:00:00,000
So if y was 3, that would assign to y 3,

1037
00:00:00,000 --> 00:00:00,000
but this changes y to 4.

1038
00:00:00,000 --> 00:00:00,000
So what does that expression even mean?

1039
00:00:00,000 --> 00:00:00,000
It's impossible to parse.

1040
00:00:00,000 --> 00:00:00,000
This is what we call undefined behavior.

1041
00:00:00,000 --> 00:00:00,000
Now, one of my favorite ones is this.

1042
00:00:00,000 --> 00:00:00,000
So here's a is 6.

1043
00:00:00,000 --> 00:00:00,000
I'm going to print out a plus plus, a plus plus, a plus plus.

1044
00:00:00,000 --> 00:00:00,000
Now, again, this is undefined behavior.

1045
00:00:00,000 --> 00:00:00,000
We're using the same variable in part of this whole expression.

1046
00:00:00,000 --> 00:00:00,000
This is all one expression.

1047
00:00:00,000 --> 00:00:00,000
And if we were to run that, I'm going to make example.

1048
00:00:00,000 --> 00:00:00,000
Okay, so I actually -- on our IDE here, we could do this

1049
00:00:00,000 --> 00:00:00,000
in one of the online IDEs here.

1050
00:00:00,000 --> 00:00:00,000
In our IDE, I'm actually treating that as an error.

1051
00:00:00,000 --> 00:00:00,000
I could change this instead of doing make example.

1052
00:00:00,000 --> 00:00:00,000
I could do g plus plus example dot cpp dot o example.

1053
00:00:00,000 --> 00:00:00,000
So I'm skipping all of the error checking that I have turned on.

1054
00:00:00,000 --> 00:00:00,000
And then if I run example, in this case, I get 6, 7, 8.

1055
00:00:00,000 --> 00:00:00,000
Many of you would think that's what it will always print.

1056
00:00:00,000 --> 00:00:00,000
If I do clang plus plus, just another compiler.

1057
00:00:00,000 --> 00:00:00,000
Clang is not going to let me do that

1058
00:00:00,000 --> 00:00:00,000
because it has all the warnings turned on.

1059
00:00:00,000 --> 00:00:00,000
And basically, it's telling me that this is undefined.

1060
00:00:00,000 --> 00:00:00,000
Okay? And so I have an online compiler.

1061
00:00:00,000 --> 00:00:00,000
I've tried it with Visual Studio, C++.

1062
00:00:00,000 --> 00:00:00,000
It gives me 666.

1063
00:00:00,000 --> 00:00:00,000
One of them gives me 678 in SalvaG++.

1064
00:00:00,000 --> 00:00:00,000
Another one will give me 876.

1065
00:00:00,000 --> 00:00:00,000
So the upshot of all of that is you should not ever,

1066
00:00:00,000 --> 00:00:00,000
ever do any of these things.

1067
00:00:00,000 --> 00:00:00,000
These are pitfalls that you're going to need to look out for.

1068
00:00:00,000 --> 00:00:00,000
Okay, we're going to finish this up with the last part

1069
00:00:00,000 --> 00:00:00,000
of our exercise.

1070
00:00:00,000 --> 00:00:00,000
Each time, I'm going to try and do a larger problem that puts

1071
00:00:00,000 --> 00:00:00,000
into, you know, into practice what we've been talking about

1072
00:00:00,000 --> 00:00:00,000
and what we've been learning about.

1073
00:00:00,000 --> 00:00:00,000
We have been working with IPO programs.

1074
00:00:00,000 --> 00:00:00,000
And so down here, we're going to write this basic IPO program.

1075
00:00:00,000 --> 00:00:00,000
And so we're going to do, this time I'm going

1076
00:00:00,000 --> 00:00:00,000
to do something a little bit faster.

1077
00:00:00,000 --> 00:00:00,000
In the last lecture, I went through this step by step.

1078
00:00:00,000 --> 00:00:00,000
This time, we're going to do it really, really quickly.

1079
00:00:00,000 --> 00:00:00,000
So let me bring this over.

1080
00:00:00,000 --> 00:00:00,000
Let me close example.

1081
00:00:00,000 --> 00:00:00,000
Let me go down to C. Let's do nets.cpp.

1082
00:00:00,000 --> 00:00:00,000
Let's put our name on the top of it.

1083
00:00:00,000 --> 00:00:00,000
I'm not going to put the date in because I might want

1084
00:00:00,000 --> 00:00:00,000
to use it another semester.

1085
00:00:00,000 --> 00:00:00,000
So, lecture three.

1086
00:00:00,000 --> 00:00:00,000
I am going to put my full Canvas ID there.

1087
00:00:00,000 --> 00:00:00,000
Okay, so I'm going to go to my problem.

1088
00:00:00,000 --> 00:00:00,000
I'm going to get the instructions out.

1089
00:00:00,000 --> 00:00:00,000
I'm going to put those inside here.

1090
00:00:00,000 --> 00:00:00,000
I'm going to convert the comments.

1091
00:00:00,000 --> 00:00:00,000
[ Typing ]

1092
00:00:00,000 --> 00:00:00,000
I'm going to select that and comment it, slash, and then tab.

1093
00:00:00,000 --> 00:00:00,000
And I'm going to figure out what the inputs,

1094
00:00:00,000 --> 00:00:00,000
outputs, and so forth are.

1095
00:00:00,000 --> 00:00:00,000
So, input, I have weight in pounds.

1096
00:00:00,000 --> 00:00:00,000
This one, I'll use snake case.

1097
00:00:00,000 --> 00:00:00,000
I used camel case in the last one.

1098
00:00:00,000 --> 00:00:00,000
The number of nets for an activity

1099
00:00:00,000 --> 00:00:00,000
and the number of minutes.

1100
00:00:00,000 --> 00:00:00,000
Okay? Okay, so three inputs.

1101
00:00:00,000 --> 00:00:00,000
Output, calories, calories, calories.

1102
00:00:00,000 --> 00:00:00,000
Burn. Okay?

1103
00:00:00,000 --> 00:00:00,000
And what's given on this?

1104
00:00:00,000 --> 00:00:00,000
Well, I'm given one kilogram is 2.2 pounds.

1105
00:00:00,000 --> 00:00:00,000
[ Typing ]

1106
00:00:00,000 --> 00:00:00,000
I'm given anything else in the problem statement.

1107
00:00:00,000 --> 00:00:00,000
Oh, I have a conversion formula.

1108
00:00:00,000 --> 00:00:00,000
Okay. So, that's also given.

1109
00:00:00,000 --> 00:00:00,000
[ Typing ]

1110
00:00:00,000 --> 00:00:00,000
That conversion factor is that.

1111
00:00:00,000 --> 00:00:00,000
And finally, I have my algorithm or processing.

1112
00:00:00,000 --> 00:00:00,000
And again, I was given that in the problem.

1113
00:00:00,000 --> 00:00:00,000
[ Typing ]

1114
00:00:00,000 --> 00:00:00,000
Although not exactly in the form I want to use.

1115
00:00:00,000 --> 00:00:00,000
And so, I'm going to print that in there.

1116
00:00:00,000 --> 00:00:00,000
[ Typing ]

1117
00:00:00,000 --> 00:00:00,000
Okay, so I can get rid of this.

1118
00:00:00,000 --> 00:00:00,000
[ Typing ]

1119
00:00:00,000 --> 00:00:00,000
And we can write our code here.

1120
00:00:00,000 --> 00:00:00,000
Now, what's the first step we're always going to do for the code?

1121
00:00:00,000 --> 00:00:00,000
The first step is always mock up the output.

1122
00:00:00,000 --> 00:00:00,000
So, I'm going to go copy this code here.

1123
00:00:00,000 --> 00:00:00,000
What I want the output to look like.

1124
00:00:00,000 --> 00:00:00,000
I'm going to paste it in there.

1125
00:00:00,000 --> 00:00:00,000
I'm going to separate it.

1126
00:00:00,000 --> 00:00:00,000
I'm going to put quotes around it like we did before.

1127
00:00:00,000 --> 00:00:00,000
[ Typing ]

1128
00:00:00,000 --> 00:00:00,000
Around the parts that are going to stay the same.

1129
00:00:00,000 --> 00:00:00,000
[ Typing ]

1130
00:00:00,000 --> 00:00:00,000
And I'm going to put C outs and output operators.

1131
00:00:00,000 --> 00:00:00,000
So, C out.

1132
00:00:00,000 --> 00:00:00,000
[ Typing ]

1133
00:00:00,000 --> 00:00:00,000
Copy that so I can just put it here multiple times.

1134
00:00:00,000 --> 00:00:00,000
[ Typing ]

1135
00:00:00,000 --> 00:00:00,000
Oops, no, that's not right.

1136
00:00:00,000 --> 00:00:00,000
I have operator there, but not that.

1137
00:00:00,000 --> 00:00:00,000
So, 250 and L. Six and NL.

1138
00:00:00,000 --> 00:00:00,000
90 and NL.

1139
00:00:00,000 --> 00:00:00,000
And output operators here and here.

1140
00:00:00,000 --> 00:00:00,000
Make them go the right way.

1141
00:00:00,000 --> 00:00:00,000
And an NL.

1142
00:00:00,000 --> 00:00:00,000
[ Typing ]

1143
00:00:00,000 --> 00:00:00,000
Okay, now I'm going to open a terminal on that.

1144
00:00:00,000 --> 00:00:00,000
I'm going to right click that and open an integrated terminal.

1145
00:00:00,000 --> 00:00:00,000
So, now notice I'm in folder C.

1146
00:00:00,000 --> 00:00:00,000
I'm going to do make run.

1147
00:00:00,000 --> 00:00:00,000
[ Typing ]

1148
00:00:00,000 --> 00:00:00,000
And I'm going to make sure I haven't made any syntax errors.

1149
00:00:00,000 --> 00:00:00,000
And that the output looks pretty much like my,

1150
00:00:00,000 --> 00:00:00,000
like the code that I copied over there.

1151
00:00:00,000 --> 00:00:00,000
And so, you can see that it, in fact,

1152
00:00:00,000 --> 00:00:00,000
does look pretty similar.

1153
00:00:00,000 --> 00:00:00,000
Okay. Okay, so that was step one.

1154
00:00:00,000 --> 00:00:00,000
Our step two is we're going to now add the input,

1155
00:00:00,000 --> 00:00:00,000
output, and processing sections.

1156
00:00:00,000 --> 00:00:00,000
So, here's my input section.

1157
00:00:00,000 --> 00:00:00,000
[ Typing ]

1158
00:00:00,000 --> 00:00:00,000
Here is my processing section.

1159
00:00:00,000 --> 00:00:00,000
[ Typing ]

1160
00:00:00,000 --> 00:00:00,000
And here is my output section.

1161
00:00:00,000 --> 00:00:00,000
Okay. So, for the input, I need variables, right?

1162
00:00:00,000 --> 00:00:00,000
So, I need my weight in pounds.

1163
00:00:00,000 --> 00:00:00,000
I need the number of mets for that activity.

1164
00:00:00,000 --> 00:00:00,000
And then I need the met conversion factor.

1165
00:00:00,000 --> 00:00:00,000
And then I'm going to send the minutes next exercising.

1166
00:00:00,000 --> 00:00:00,000
So, let's make these first two doubles.

1167
00:00:00,000 --> 00:00:00,000
So, double weight in pounds.

1168
00:00:00,000 --> 00:00:00,000
[ Typing ]

1169
00:00:00,000 --> 00:00:00,000
And let's do CN weight in pounds.

1170
00:00:00,000 --> 00:00:00,000
[ Typing ]

1171
00:00:00,000 --> 00:00:00,000
Let's remove this dummy value and the dummy inline there.

1172
00:00:00,000 --> 00:00:00,000
And I have my first line done.

1173
00:00:00,000 --> 00:00:00,000
And make sure I spell pounds right.

1174
00:00:00,000 --> 00:00:00,000
I like the fact that the editor will color that to make sure

1175
00:00:00,000 --> 00:00:00,000
that I spelled it right and give me a syntax thing.

1176
00:00:00,000 --> 00:00:00,000
Okay. So, this is the number of mets for this activity.

1177
00:00:00,000 --> 00:00:00,000
That might be an int as well, but we're multiplying.

1178
00:00:00,000 --> 00:00:00,000
It was just a factor times 0.75.

1179
00:00:00,000 --> 00:00:00,000
So, let me make it a double.

1180
00:00:00,000 --> 00:00:00,000
Let's write double mets and CN mets.

1181
00:00:00,000 --> 00:00:00,000
And let me remove the dummies here.

1182
00:00:00,000 --> 00:00:00,000
And minutes, I'm going to go ahead

1183
00:00:00,000 --> 00:00:00,000
and make this one an integer.

1184
00:00:00,000 --> 00:00:00,000
So, I'll move the dummy to start with.

1185
00:00:00,000 --> 00:00:00,000
I will have int minutes CN minutes.

1186
00:00:00,000 --> 00:00:00,000
Okay. So, I've got the input part done.

1187
00:00:00,000 --> 00:00:00,000
Now, let's go ahead and do the processing part.

1188
00:00:00,000 --> 00:00:00,000
So, the output is going to be calories.

1189
00:00:00,000 --> 00:00:00,000
So, I'm going to create a double value for that.

1190
00:00:00,000 --> 00:00:00,000
So, double calories.

1191
00:00:00,000 --> 00:00:00,000
Equals. And I'm going to put in this formula.

1192
00:00:00,000 --> 00:00:00,000
And notice the formula isn't exactly in the right format.

1193
00:00:00,000 --> 00:00:00,000
So, this is a formula for calories per minute.

1194
00:00:00,000 --> 00:00:00,000
And so, I want to divide calories by minute.

1195
00:00:00,000 --> 00:00:00,000
I want to, calories by minute, I want to multiply both sides

1196
00:00:00,000 --> 00:00:00,000
by the minute to get this.

1197
00:00:00,000 --> 00:00:00,000
So, that would be this factor times mets times, oops,

1198
00:00:00,000 --> 00:00:00,000
times weighted kilograms times minutes.

1199
00:00:00,000 --> 00:00:00,000
Alright. In other words, if it's calorie divided by minutes,

1200
00:00:00,000 --> 00:00:00,000
I need to multiply both sides by minutes to get the minutes

1201
00:00:00,000 --> 00:00:00,000
on the right-hand side.

1202
00:00:00,000 --> 00:00:00,000
Okay. Now, we actually don't have these two variables.

1203
00:00:00,000 --> 00:00:00,000
And factor was given up to us here.

1204
00:00:00,000 --> 00:00:00,000
It's this value.

1205
00:00:00,000 --> 00:00:00,000
So, I'm going to create a constant for that.

1206
00:00:00,000 --> 00:00:00,000
So, const double K factor equals .0175.

1207
00:00:00,000 --> 00:00:00,000
So, I'm going to replace this factor with K factor.

1208
00:00:00,000 --> 00:00:00,000
And mets, we read inside here, but we don't have weights

1209
00:00:00,000 --> 00:00:00,000
in kilogram, but I do have another given,

1210
00:00:00,000 --> 00:00:00,000
which is the kilogram.

1211
00:00:00,000 --> 00:00:00,000
So, const double K pounds per kilogram.

1212
00:00:00,000 --> 00:00:00,000
Equals 2.2, 2.2 pounds per kilogram.

1213
00:00:00,000 --> 00:00:00,000
And so, given that constant, I can figure

1214
00:00:00,000 --> 00:00:00,000
out what the weight in kilograms is.

1215
00:00:00,000 --> 00:00:00,000
Because here's the weight in pounds.

1216
00:00:00,000 --> 00:00:00,000
So, double weight in kilograms equals weight in pounds.

1217
00:00:00,000 --> 00:00:00,000
Weight in pounds divided by K pounds per kilogram.

1218
00:00:00,000 --> 00:00:00,000
Okay. So, that looks pretty good.

1219
00:00:00,000 --> 00:00:00,000
We're going to have to test it to make sure it's correct.

1220
00:00:00,000 --> 00:00:00,000
For the output here, we want to put our calories.

1221
00:00:00,000 --> 00:00:00,000
That's what we want for the output.

1222
00:00:00,000 --> 00:00:00,000
And we probably want, looks like two decimal places

1223
00:00:00,000 --> 00:00:00,000
in the output.

1224
00:00:00,000 --> 00:00:00,000
So, I'm going to do CL fix set precision 2,

1225
00:00:00,000 --> 00:00:00,000
like I did before.

1226
00:00:00,000 --> 00:00:00,000
I'm going to make sure I have IOMINIP up here, which I do.

1227
00:00:00,000 --> 00:00:00,000
Okay. That looks pretty good.

1228
00:00:00,000 --> 00:00:00,000
So, let's go ahead and try it with make run and put

1229
00:00:00,000 --> 00:00:00,000
in the same input we had before.

1230
00:00:00,000 --> 00:00:00,000
So, make run.

1231
00:00:00,000 --> 00:00:00,000
So, 250 kilograms.

1232
00:00:00,000 --> 00:00:00,000
Mets for the activity, 6.

1233
00:00:00,000 --> 00:00:00,000
Minutes spent exercising, 90.

1234
00:00:00,000 --> 00:00:00,000
You burned an estimated 1073.86.

1235
00:00:00,000 --> 00:00:00,000
It looks okay.

1236
00:00:00,000 --> 00:00:00,000
So, let's try it with some different inputs.

1237
00:00:00,000 --> 00:00:00,000
Let's just do make test.

1238
00:00:00,000 --> 00:00:00,000
And here I've tested with the same 256 and 90.

1239
00:00:00,000 --> 00:00:00,000
Then an input weight of zero.

1240
00:00:00,000 --> 00:00:00,000
Obviously, I'm burning no calories.

1241
00:00:00,000 --> 00:00:00,000
An input weight of 125 pounds.

1242
00:00:00,000 --> 00:00:00,000
An input weight of 175 pounds.

1243
00:00:00,000 --> 00:00:00,000
Okay. It shows the different calories that we've burned.

1244
00:00:00,000 --> 00:00:00,000
So, this will be our picture for the test part.

1245
00:00:00,000 --> 00:00:00,000
And here's the picture for the code part.

1246
00:00:00,000 --> 00:00:00,000
Again, I want you to do more and more of these

1247
00:00:00,000 --> 00:00:00,000
to get practice doing these kinds

1248
00:00:00,000 --> 00:00:00,000
of input/output processing programs.

1249
00:00:00,000 --> 00:00:00,000
And to get some practice with calculations.

1250
00:00:00,000 --> 00:00:00,000
That's it for me today.

1251
00:00:00,000 --> 00:00:00,000
I'll see you in lecture four.

1252
00:00:00,000 --> 00:00:00,000
Thank you.

