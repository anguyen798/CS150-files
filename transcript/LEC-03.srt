
1
00:00:00,000 --> 00:00:11,640
Hello folks, this is Steve Gilbert and welcome to lecture 3 on numbers and calculations.

2
00:00:11,640 --> 00:00:19,520
Before you start, make sure you've gone into the Thursday tab here on calculations in week

3
00:00:19,520 --> 00:00:20,600
1.

4
00:00:20,600 --> 00:00:23,840
You've clicked the link for the lecture exercise.

5
00:00:23,840 --> 00:00:28,960
When lecture 3 exercise comes up, click the link for the starter form.

6
00:00:28,960 --> 00:00:36,120
Make a local copy and make sure you rename it so you can find it later when you get started.

7
00:00:36,120 --> 00:00:45,560
Okay, so let's go ahead and talk a little bit more about type concepts.

8
00:00:45,560 --> 00:00:48,480
So in the last lecture we talked about variables.

9
00:00:48,480 --> 00:00:53,880
A variable is a name storage location that holds a value.

10
00:00:53,880 --> 00:00:59,920
Variables and values both have types and types have three characteristics.

11
00:00:59,920 --> 00:01:07,440
They have the domain, the operations, and the representation of that type.

12
00:01:07,440 --> 00:01:12,720
So the domain simply means all values contained in that type.

13
00:01:12,720 --> 00:01:17,200
The domain for the type bool, for instance, is true and false.

14
00:01:17,200 --> 00:01:20,660
There are no other values maintained in that type.

15
00:01:20,660 --> 00:01:26,640
The domain for the type int is all the whole numbers within the range of the type.

16
00:01:26,640 --> 00:01:33,520
So the type for int is roughly plus or minus 2 billion for a 32-bit int or plus or minus

17
00:01:33,520 --> 00:01:39,000
127 for an 8-bit int, again depending on the size.

18
00:01:39,000 --> 00:01:41,680
So all the values contained in that type.

19
00:01:41,680 --> 00:01:47,160
We could not put for an int, for an 8-bit int, we could not put a number that was larger,

20
00:01:47,160 --> 00:01:51,320
it would be outside of the domain, and we could not put a number that contained a fractional

21
00:01:51,320 --> 00:01:53,800
portion.

22
00:01:53,800 --> 00:02:00,160
Now the second thing with a type, so the values that can be contained in the type is the domain.

23
00:02:00,160 --> 00:02:05,160
The operations are what you can do with that value.

24
00:02:05,160 --> 00:02:11,320
So for the built-in types, these are specified by the C++ language.

25
00:02:11,320 --> 00:02:19,880
So for instance, in Java, we can use the remainder operator on the floating point or real number

26
00:02:19,880 --> 00:02:20,880
types.

27
00:02:20,880 --> 00:02:24,240
In C++ we cannot, the language prohibits that.

28
00:02:24,240 --> 00:02:29,440
So the language specifies what operations are available.

29
00:02:29,440 --> 00:02:37,000
Now for the library types, like the string type, things that are built into the C++ standard

30
00:02:37,000 --> 00:02:42,040
library, those are specified by the language specification.

31
00:02:42,040 --> 00:02:47,480
So the language standard and the language specification specifies the operations for

32
00:02:47,480 --> 00:02:48,720
that type.

33
00:02:48,720 --> 00:02:54,760
Of course, for user-defined types, the operations are defined by the person who wrote the class.

34
00:02:54,760 --> 00:03:04,100
Finally, the representation determines what bits, given a block of memory and a particular

35
00:03:04,100 --> 00:03:08,600
bit pattern, what does that mean?

36
00:03:08,600 --> 00:03:15,760
So if I say "int", how many bytes are required and how are the bits inside that byte interpreted

37
00:03:15,760 --> 00:03:17,080
to be an int?

38
00:03:17,080 --> 00:03:21,400
The same thing if I say "char" or "double" or whatever.

39
00:03:21,400 --> 00:03:30,600
So in C++, unlike Java, the representation, in other words, how the bits are interpreted,

40
00:03:30,600 --> 00:03:37,640
and the size, how many bytes are used for each type, differs by implementation.

41
00:03:37,640 --> 00:03:38,960
And we'll talk about that.

42
00:03:38,960 --> 00:03:41,340
Now why aren't they all the same?

43
00:03:41,340 --> 00:03:48,520
Why don't they do the same thing as Java and make a byte type which is 8-bit, a short byte,

44
00:03:48,520 --> 00:03:52,520
a short type which is 16-bit, and so forth?

45
00:03:52,520 --> 00:03:59,440
That's because different computer hardware is more efficient with different sizes.

46
00:03:59,440 --> 00:04:07,300
So this allows C++ to run to the best effect on the hardware you have.

47
00:04:07,300 --> 00:04:10,760
So these are the three characteristics that make up a type.

48
00:04:10,760 --> 00:04:15,600
We have several categories of types in C++.

49
00:04:15,600 --> 00:04:20,040
We have the built-in, primitive, or fundamental types.

50
00:04:20,040 --> 00:04:22,840
All of those worlds kind of mean the same thing.

51
00:04:22,840 --> 00:04:28,760
The things that are built into the language itself, not the library.

52
00:04:28,760 --> 00:04:33,640
That includes things like the integer types, the whole number types, the floating point

53
00:04:33,640 --> 00:04:39,640
or real number types, the character types, and the bool type.

54
00:04:39,640 --> 00:04:43,520
Now very few of them.

55
00:04:43,520 --> 00:04:48,520
With those types, and actually with other types, we can derive new types.

56
00:04:48,520 --> 00:04:53,100
So these are called derived types or compound types.

57
00:04:53,100 --> 00:04:59,520
So I can take an array, I can take a char, and I can create an array of char.

58
00:04:59,520 --> 00:05:02,880
So an array of char is a different type than just char.

59
00:05:02,880 --> 00:05:06,680
It's derived from char, but it's a derived type.

60
00:05:06,680 --> 00:05:09,840
I can make a pointer to a double.

61
00:05:09,840 --> 00:05:12,920
I can make a reference to an integer.

62
00:05:12,920 --> 00:05:18,560
So arrays, pointers, and references are not their own independent types.

63
00:05:18,560 --> 00:05:23,000
They're based on or derived from other types.

64
00:05:23,000 --> 00:05:27,480
Thirdly, we have user-defined types.

65
00:05:27,480 --> 00:05:30,080
Types that are created in the library.

66
00:05:30,080 --> 00:05:33,320
Types that are created by you, the programmer.

67
00:05:33,320 --> 00:05:39,120
Types that interact with the rest of C++ as if they were built-in types.

68
00:05:39,120 --> 00:05:47,240
And for these, we have enumerated types, that is, single value, numbered, or scalar types.

69
00:05:47,240 --> 00:05:49,480
That's the enum type.

70
00:05:49,480 --> 00:05:56,080
We have struct for structured or record data types.

71
00:05:56,080 --> 00:06:00,720
And then we have classes for object-oriented programming.

72
00:06:00,720 --> 00:06:08,160
Finally, some of these types are used to build the things that are in the standard library.

73
00:06:08,160 --> 00:06:13,320
So we refer to these types as library types, even though they're structures or enumerations

74
00:06:13,320 --> 00:06:15,000
or classes.

75
00:06:15,000 --> 00:06:21,600
So types such as string and vector are not built into the C++ language.

76
00:06:21,600 --> 00:06:30,440
Instead they're built into the standard library that comes with C++.

77
00:06:30,440 --> 00:06:36,320
Now C++ is what we call statically typed.

78
00:06:36,320 --> 00:06:43,720
That means the types of the variables, the types of the functions, are indicated in the

79
00:06:43,720 --> 00:06:45,520
source code.

80
00:06:45,520 --> 00:06:51,920
And so to show you exactly what that means, I have to kind of compare it to other languages.

81
00:06:51,920 --> 00:06:57,720
So Python, for instance, uses what's called dynamic typing.

82
00:06:57,720 --> 00:07:06,200
So this is the definition for a function named add that takes two arguments, a and b.

83
00:07:06,200 --> 00:07:10,380
What kind of value, if any, does add return?

84
00:07:10,380 --> 00:07:13,400
What kind of things are a and b?

85
00:07:13,400 --> 00:07:17,960
Well, you don't know when you're writing your code.

86
00:07:17,960 --> 00:07:21,760
When you run your code, a will be given a value.

87
00:07:21,760 --> 00:07:22,920
It'll be a number.

88
00:07:22,920 --> 00:07:24,280
It'll be a string.

89
00:07:24,280 --> 00:07:27,360
It'll be a real number, an integer number.

90
00:07:27,360 --> 00:07:32,520
Similarly, you don't know until the program runs what the function will return.

91
00:07:32,520 --> 00:07:34,600
So this is called dynamic typing.

92
00:07:34,600 --> 00:07:38,240
a is not a specific kind of variable.

93
00:07:38,240 --> 00:07:41,320
b is not a specific kind of variable.

94
00:07:41,320 --> 00:07:50,960
It's given a value when the program runs, and its type is determined at that time.

95
00:07:50,960 --> 00:07:57,600
Static typing is what Pascal and Java and C++ use.

96
00:07:57,600 --> 00:08:04,860
That is, the types are determined explicitly when we declare or define the variables.

97
00:08:04,860 --> 00:08:07,560
So here is a function in C++.

98
00:08:07,560 --> 00:08:10,480
It would look very similar in Java.

99
00:08:10,480 --> 00:08:14,920
Notice that this specifically says that this function is going to return an integer.

100
00:08:14,920 --> 00:08:19,280
Notice the Python version does not say what kind of function that is.

101
00:08:19,280 --> 00:08:24,660
It also says that the two arguments, a and b, are both going to be integers.

102
00:08:24,660 --> 00:08:32,680
And so the types with static typing are determined when the program is compiled.

103
00:08:32,680 --> 00:08:38,360
Now we have a similar term that's often confused, and this is called strong typing.

104
00:08:38,360 --> 00:08:45,600
So strong typing means that a variable can only hold one kind of value.

105
00:08:45,600 --> 00:08:51,600
And so you might think, well, if I have a double value, and I try and assign, if I have

106
00:08:51,600 --> 00:08:59,880
a double variable, and I try and assign, I'm actually going to open up our editor here,

107
00:08:59,880 --> 00:09:05,480
and I'm going to just create a new file here.

108
00:09:05,480 --> 00:09:17,840
I'll call it example.cpp.

109
00:09:17,840 --> 00:09:33,720
And so if I try and create a variable, and that is actually not very big, I'm going to,

110
00:09:33,720 --> 00:09:38,120
I'm not quite sure why my font is so small when it's bigger over here.

111
00:09:38,120 --> 00:09:39,720
No, I guess it's about the same size.

112
00:09:39,720 --> 00:09:45,640
So double x equals 3.

113
00:09:45,640 --> 00:09:53,920
Now this works in both C++ and Java, but this is not an example of strong typing, because

114
00:09:53,920 --> 00:09:58,640
the value on the right, 3, is a whole number.

115
00:09:58,640 --> 00:10:04,320
The value variable on the left, where I'm putting that, is the wrong kind of thing to

116
00:10:04,320 --> 00:10:05,320
put it in.

117
00:10:05,320 --> 00:10:07,360
This is not an integer.

118
00:10:07,360 --> 00:10:09,120
This is an integer.

119
00:10:09,120 --> 00:10:16,520
And if we had strong typing only, then this would not compile, because we're trying to

120
00:10:16,520 --> 00:10:22,160
put the wrong kind of value in the wrong kind of box, the wrong kind of variable.

121
00:10:22,160 --> 00:10:32,160
And so what both Java and C++ do, is they convert this 3 to, behind the scenes, invisibly,

122
00:10:32,160 --> 00:10:35,160
a 3.0.

123
00:10:35,160 --> 00:10:38,040
And so the 3.0 is what's put inside of that.

124
00:10:38,040 --> 00:10:45,040
It's called a promotion, or a widening conversion.

125
00:10:45,040 --> 00:10:56,960
Now in Java, if we did this, int y equals 3.15, we would get a syntax error.

126
00:10:56,960 --> 00:11:05,480
So that's because this is too big, it's 64 bits, this is a 32 bit bucket, and the bits

127
00:11:05,480 --> 00:11:13,000
are arranged in a different pattern, because remember, the value is the set of bits interpreted

128
00:11:13,000 --> 00:11:14,920
according to its type.

129
00:11:14,920 --> 00:11:22,000
And so the bits that make up 3.15 are not the same as the bits that would go into the

130
00:11:22,000 --> 00:11:23,000
integer x.

131
00:11:23,000 --> 00:11:30,920
And so in Java, this is illegal, but in C++, it is not illegal.

132
00:11:30,920 --> 00:11:39,160
So in C++, we have strong typing, but we have implicit conversions, conversions that are

133
00:11:39,160 --> 00:11:42,280
not allowed in other languages.

134
00:11:42,280 --> 00:11:45,880
So in C++, this is okay.

135
00:11:45,880 --> 00:11:54,400
It's exactly as if we had written, convert this 3.5 to an int, throw away the .5 and

136
00:11:54,400 --> 00:11:56,000
store it into a.

137
00:11:56,000 --> 00:11:58,680
We won't get any errors.

138
00:11:58,680 --> 00:12:04,760
Now because of that, because of the experience people have had with Java and C# in the last

139
00:12:04,760 --> 00:12:10,800
10 or 15 years, people have realized that that leads to some kind of errors.

140
00:12:10,800 --> 00:12:19,600
And so in C++ now, if we want to make sure that we're doing, if we're not inadvertently

141
00:12:19,600 --> 00:12:24,680
losing data, we could do it like this instead of that.

142
00:12:24,680 --> 00:12:31,360
We could just put braces around this and now, just like Java would get an error, which is

143
00:12:31,360 --> 00:12:32,840
what we expect, right?

144
00:12:32,840 --> 00:12:37,280
We would expect this narrowing conversion not to succeed.

145
00:12:37,280 --> 00:12:45,620
But in C++, if you use the traditional assignment, these narrowing conversions succeed.

146
00:12:45,620 --> 00:12:52,800
So sometimes people complain and say, "No, C++ is not strongly typed because I can put

147
00:12:52,800 --> 00:12:56,520
a double inside an int and it didn't tell me I made a mistake."

148
00:12:56,520 --> 00:13:03,520
Well, it is strongly typed, but it has these implicit conversions exactly like Java has

149
00:13:03,520 --> 00:13:08,200
the implicit conversions, but it will do a narrowing conversion.

150
00:13:08,200 --> 00:13:12,480
In other words, losing data, whereas Java will not.

151
00:13:12,480 --> 00:13:17,600
And again, if you want to avoid that, which I strongly recommend, what you should do is

152
00:13:17,600 --> 00:13:24,600
you should make sure that you use the curly braces when you do the assignment.

153
00:13:24,600 --> 00:13:30,480
Okay, so let's go ahead and look at the types now that are built in.

154
00:13:30,480 --> 00:13:38,040
So the first type we have, like Java, is a integer, which is a signed whole number.

155
00:13:38,040 --> 00:13:44,120
When we say a number is signed, we mean that the number or the variable can represent negative

156
00:13:44,120 --> 00:13:47,400
and positive numbers.

157
00:13:47,400 --> 00:13:52,480
Now in Java, ints are signed 32-bit whole numbers.

158
00:13:52,480 --> 00:13:54,960
In C++, that's not the case.

159
00:13:54,960 --> 00:14:02,080
I have worked on C++ compilers where integers were 16 bits, and the largest integer we could

160
00:14:02,080 --> 00:14:03,080
have was 32,767.

161
00:14:03,080 --> 00:14:12,080
Today, 32 is most common, just like Java, but 16-bit is still used in the microprocessor

162
00:14:12,080 --> 00:14:16,000
world, especially for embedded systems.

163
00:14:16,000 --> 00:14:19,880
So it must be at least 16 bits, or it can't be an int.

164
00:14:19,880 --> 00:14:24,120
That's what the language requires, but it could be 32 bits.

165
00:14:24,120 --> 00:14:33,200
In fact, an int could be 64 bits, and I expect to see that soon as processors get larger.

166
00:14:33,200 --> 00:14:39,920
We can modify the type int with a modifier that specifies the size.

167
00:14:39,920 --> 00:14:43,040
So we can write a long int.

168
00:14:43,040 --> 00:14:47,960
We can leave off the word int and use long, just like Java does.

169
00:14:47,960 --> 00:14:51,320
That must be at least 32 bits.

170
00:14:51,320 --> 00:14:55,760
Now in Java, a long must be 64 bits.

171
00:14:55,760 --> 00:14:59,040
Now in C++, that is not the case.

172
00:14:59,040 --> 00:15:06,840
And so many platforms, Visual C++ for instance, longs and ints are exactly the same size.

173
00:15:06,840 --> 00:15:08,840
They're 32 bits.

174
00:15:08,840 --> 00:15:17,600
Shorts, again this is shorthand for short int, but you can just write short if you want,

175
00:15:17,600 --> 00:15:24,360
must be at least 16 bits like they are in Java, but they can be 32 bits as well.

176
00:15:24,360 --> 00:15:30,960
So it would be possible for ints, longs, and shorts all to be the same size on a given

177
00:15:30,960 --> 00:15:32,200
platform.

178
00:15:32,200 --> 00:15:36,880
They usually aren't all the same size, but often several of them are.

179
00:15:36,880 --> 00:15:43,320
The platform we're going to be using, our Unix platform, is going to have 32 bit ints,

180
00:15:43,320 --> 00:15:51,320
64 bit longs, 16 bit shorts, and all platforms now have long, long.

181
00:15:51,320 --> 00:15:57,520
This is an extension before C++11, but now all platforms have the ability to do a long,

182
00:15:57,520 --> 00:16:02,000
long, which is the equivalent to a long in Java.

183
00:16:02,000 --> 00:16:08,440
And again in C++ we can write this as a long, long int.

184
00:16:08,440 --> 00:16:15,560
Now with all of these types that specify the size of the bytes, we can also specify how

185
00:16:15,560 --> 00:16:17,640
they're interpreted.

186
00:16:17,640 --> 00:16:24,760
So you can combine the word unsigned with any of these above to specify that we want

187
00:16:24,760 --> 00:16:30,520
to take the whole bit pattern and apply it to positive numbers.

188
00:16:30,520 --> 00:16:36,680
So let me just give you a quick example.

189
00:16:36,680 --> 00:16:48,920
If I take a 16 bit number, a short, if I write short, I can represent numbers from -32,768

190
00:16:48,920 --> 00:16:53,200
to +32,767.

191
00:16:53,200 --> 00:17:00,120
The zero is right in the middle of the positive and negative numbers if you put it on a timeline

192
00:17:00,120 --> 00:17:02,560
or a number line.

193
00:17:02,560 --> 00:17:09,740
If I put unsigned short, I cannot store any negative numbers, but I get twice as many

194
00:17:09,740 --> 00:17:11,280
positive numbers.

195
00:17:11,280 --> 00:17:17,140
I can store from zero to 65,535 numbers.

196
00:17:17,140 --> 00:17:21,060
And it's the same for all the types.

197
00:17:21,060 --> 00:17:27,520
Now Java has a byte type to represent an 8 bit signed integers.

198
00:17:27,520 --> 00:17:36,880
C++ uses the type char both for characters and for small integers.

199
00:17:36,880 --> 00:17:41,640
So for characters, you just use a plain char.

200
00:17:41,640 --> 00:17:49,920
For byte integers, you do a signed char if you want the numbers -128 to 127 or you use

201
00:17:49,920 --> 00:17:56,400
an unsigned char if you want to represent the numbers 0 to 255.

202
00:17:56,400 --> 00:18:01,120
We'll actually use these byte integers later because they're very useful when we process

203
00:18:01,120 --> 00:18:03,120
images.

204
00:18:03,120 --> 00:18:10,360
C++ has three floating point types, unlike Java, which has only two.

205
00:18:10,360 --> 00:18:16,280
Those of you coming from Python are familiar with the type float, but the float in type

206
00:18:16,280 --> 00:18:20,240
Python is called a double in Java.

207
00:18:20,240 --> 00:18:25,960
Python actually doesn't have the same float type, which is around four bytes long.

208
00:18:25,960 --> 00:18:29,040
The double type is typically eight bytes long.

209
00:18:29,040 --> 00:18:31,480
The long double may be the same as the double.

210
00:18:31,480 --> 00:18:36,720
It is on Visual C++ or it may be larger.

211
00:18:36,720 --> 00:18:40,100
So we will not use long double generally.

212
00:18:40,100 --> 00:18:43,200
It's not actually that useful in C++.

213
00:18:43,200 --> 00:18:48,840
And we will generally not use float unless we happen to use them in an array for images

214
00:18:48,840 --> 00:18:50,600
or something like that.

215
00:18:50,600 --> 00:18:54,240
So for floating point types, we'll almost always use double.

216
00:18:54,240 --> 00:18:59,560
For integer types, we'll almost always use int, unless we need very small integers, in

217
00:18:59,560 --> 00:19:06,720
which case we'll use signed or unsigned char.

218
00:19:06,720 --> 00:19:13,320
Now literals mean you literally write out a number.

219
00:19:13,320 --> 00:19:19,420
When you write out a number, we assume you're working with decimal numbers, that is base

220
00:19:19,420 --> 00:19:21,480
10.

221
00:19:21,480 --> 00:19:29,080
So with a decimal literal, we can preface it to change the base.

222
00:19:29,080 --> 00:19:35,520
So if I start a number with the digit zero, I'm going to assume I'm going to be in base

223
00:19:35,520 --> 00:19:37,880
eight or octal.

224
00:19:37,880 --> 00:19:47,040
So 073 means three ones in seven eights, not seven tens.

225
00:19:47,040 --> 00:19:54,720
If I preface it with 0x, and that x can be capital or lower case, it means I'm assuming

226
00:19:54,720 --> 00:20:00,840
that the base is 16 and the number is in hexadecimal.

227
00:20:00,840 --> 00:20:11,560
And so 0x73 is not the decimal number 73, it's three ones in seven sixteens.

228
00:20:11,560 --> 00:20:20,880
And if I have the, start with the preface 0b, or zero b, not ob, 0b, let's assume that

229
00:20:20,880 --> 00:20:25,080
the numbers are binary.

230
00:20:25,080 --> 00:20:29,240
Now I can also add a modifier after the literal.

231
00:20:29,240 --> 00:20:35,120
If I do a u, this can be upper case or lower case, it's more common to do capital.

232
00:20:35,120 --> 00:20:39,800
That means that we want to interpret that number as an unsigned number.

233
00:20:39,800 --> 00:20:43,640
If I do an l, it means we want to use long storage.

234
00:20:43,640 --> 00:20:47,960
If I do two l's, it means we want to use long, long storage.

235
00:20:47,960 --> 00:20:54,240
And of course I can bind the unsigned, which determines how we view the representation

236
00:20:54,240 --> 00:20:56,320
with the size modifier.

237
00:20:56,320 --> 00:21:01,840
So I could have 123 ULL.

238
00:21:01,840 --> 00:21:10,400
C++14, we're using C++17 in this class, also allows you to use the apostrophe to act as

239
00:21:10,400 --> 00:21:12,960
a separator for long numbers.

240
00:21:12,960 --> 00:21:18,200
So if you have a very large decimal number, we commonly separate out the thousands with

241
00:21:18,200 --> 00:21:19,400
a comma.

242
00:21:19,400 --> 00:21:25,640
The comma won't work in C++, but you can use the apostrophe so you still get the same visual

243
00:21:25,640 --> 00:21:29,160
separation.

244
00:21:29,160 --> 00:21:36,340
For floating point literals, you can type them as simply 243 dot.

245
00:21:36,340 --> 00:21:38,900
Notice that'll be type double.

246
00:21:38,900 --> 00:21:44,200
Notice we don't need a trailing zero for that, but we do need the dot.

247
00:21:44,200 --> 00:21:47,600
The literal 234 is of type int.

248
00:21:47,600 --> 00:21:52,040
234 point is of type double.

249
00:21:52,040 --> 00:22:01,040
If you add an L to the end of your number, like 7.5432L, it's of type long double, the

250
00:22:01,040 --> 00:22:02,640
literal.

251
00:22:02,640 --> 00:22:08,720
And finally, you can do it in scientific notation here, adding an E with a plus or minus for

252
00:22:08,720 --> 00:22:10,120
the exponent.

253
00:22:10,120 --> 00:22:13,100
The E can be capitalized or lowercase.

254
00:22:13,100 --> 00:22:17,640
This'll be type double, using scientific notation.

255
00:22:17,640 --> 00:22:21,200
And if we wanted type float, we would use the letter F.

256
00:22:21,200 --> 00:22:23,320
Again, this can be lower or uppercase.

257
00:22:23,320 --> 00:22:25,600
I've used uppercase here.

258
00:22:25,600 --> 00:22:30,880
You should not use lowercase for the L because people are going to confuse it with a 1.

259
00:22:30,880 --> 00:22:36,360
You're going to confuse it with a 1.

260
00:22:36,360 --> 00:22:46,640
Now we can actually, since we can use literals to specify a type, and we can use variable

261
00:22:46,640 --> 00:22:56,200
names, type names like int or double to declare the type, we can actually use only the literal

262
00:22:56,200 --> 00:22:59,880
to infer or deduce the type.

263
00:22:59,880 --> 00:23:06,360
When you do that, instead of specifying a type name, you use the keyword auto.

264
00:23:06,360 --> 00:23:09,040
And then you don't use braces.

265
00:23:09,040 --> 00:23:15,800
And so when I say auto A, notice I haven't specified what kind of thing A is.

266
00:23:15,800 --> 00:23:20,200
The compiler comes along and says, "Well, what's going into that?"

267
00:23:20,200 --> 00:23:27,440
Well, 23U is an unsigned int, so the type for A would be an unsigned int.

268
00:23:27,440 --> 00:23:33,400
Similarly, I've done the same thing for the variable B. I haven't specified that it's

269
00:23:33,400 --> 00:23:44,080
a float, but I've written over here that it's type auto, and so it will deduce or infer

270
00:23:44,080 --> 00:23:47,120
from the 3F that B is a float.

271
00:23:47,120 --> 00:23:55,520
Now a lot of modern C++ experts recommend this style called "almost always auto" or

272
00:23:55,520 --> 00:24:01,880
AAA, because first, it eliminates uninitialized variables.

273
00:24:01,880 --> 00:24:08,080
If we're going to get the type from the initializer, we don't have to worry about variables.

274
00:24:08,080 --> 00:24:12,360
It also improves maintenance.

275
00:24:12,360 --> 00:24:20,120
That means if you change the initializer, suppose you had int x = 3, and you came along

276
00:24:20,120 --> 00:24:26,320
and you realized, "Oh, you know, that really should start with 3.5," and you forgot to

277
00:24:26,320 --> 00:24:32,000
change the int, then your code would be kind of out of sync.

278
00:24:32,000 --> 00:24:34,360
You wouldn't get an error message.

279
00:24:34,360 --> 00:24:40,520
And so maintenance works easier if you're using always auto, because the types track

280
00:24:40,520 --> 00:24:43,640
as the initializers will change.

281
00:24:43,640 --> 00:24:48,480
And finally, performance.

282
00:24:48,480 --> 00:24:57,480
If you use explicit types, like int B = 3.5F, we have to do an implicit conversion there

283
00:24:57,480 --> 00:25:01,840
that wouldn't have to happen if we didn't do that.

284
00:25:01,840 --> 00:25:05,360
And so this eliminates these initial conversions.

285
00:25:05,360 --> 00:25:10,440
So if you look on the slides, I have some links that you can watch and read several

286
00:25:10,440 --> 00:25:11,800
things about here.

287
00:25:11,800 --> 00:25:20,540
Watch this video on almost always auto, if you're interested in that.

288
00:25:20,540 --> 00:25:27,000
Let's go ahead and do an exercise, and let's go ahead and see if we can do the work of

289
00:25:27,000 --> 00:25:33,000
the compiler and infer from the literals what type would be there.

290
00:25:33,000 --> 00:25:38,320
Now, of course, if we were using auto, we'd put auto there, but here we're simply going

291
00:25:38,320 --> 00:25:45,560
to infer from the compiler what type would go there.

292
00:25:45,560 --> 00:25:50,720
So I'm going to make this slightly larger so it's easier to see on the video.

293
00:25:50,720 --> 00:26:01,720
So we're going to look at this program, and we're going to provide the correct explicit

294
00:26:01,720 --> 00:26:06,280
variable types for each of the variable declarations.

295
00:26:06,280 --> 00:26:12,520
You can assume that ints are 32 bits, and that shorts are 16 bits.

296
00:26:12,520 --> 00:26:17,760
Now to make this a little trickier, what we want to do is use the smallest legal type

297
00:26:17,760 --> 00:26:24,760
that will correctly store the subsequent value.

298
00:26:24,760 --> 00:26:29,800
So we're going to take a picture, we're going to click here, we're going to go in and look

299
00:26:29,800 --> 00:26:35,000
at this program, I'm going to make this a little larger again so you can see it.

300
00:26:35,000 --> 00:26:42,640
So notice I can say auto A equals this, but I instead, in which case it would be an int,

301
00:26:42,640 --> 00:26:46,320
right, an unsigned int, .25 is an unsigned int.

302
00:26:46,320 --> 00:26:53,440
Instead, what I want to do is think about using the smallest correct explicit type for

303
00:26:53,440 --> 00:26:54,800
that.

304
00:26:54,800 --> 00:27:04,160
So the question really we're asking is what is the smallest type that will store -25?

305
00:27:04,160 --> 00:27:08,280
So an int obviously would, we could put a double inside there, but all of those would

306
00:27:08,280 --> 00:27:10,200
need to convert.

307
00:27:10,200 --> 00:27:16,680
And so the smallest type is an assigned char.

308
00:27:16,680 --> 00:27:22,160
So chars are what we use for values that are 8 bits.

309
00:27:22,160 --> 00:27:30,360
An 8 bit assigned char can hold the numbers from -128 to +127.

310
00:27:30,360 --> 00:27:40,440
So B, we could put that as assigned char, but 249 is outside the range of assigned char.

311
00:27:40,440 --> 00:27:44,240
It's outside the domain, so it wouldn't fit.

312
00:27:44,240 --> 00:27:48,160
What if instead though, we made it an unsigned character?

313
00:27:48,160 --> 00:27:54,160
If it was an unsigned char or an unsigned byte, it would fit because the value for unsigned

314
00:27:54,160 --> 00:27:59,680
bytes is 0 to 255.

315
00:27:59,680 --> 00:28:03,000
So this would be an unsigned char.

316
00:28:03,000 --> 00:28:10,640
Okay, C obviously is bigger than we can store in assigned char and unsigned char.

317
00:28:10,640 --> 00:28:14,440
How about the next larger number, the short?

318
00:28:14,440 --> 00:28:17,520
That's 16 bits.

319
00:28:17,520 --> 00:28:23,000
Could we store -1725 in that?

320
00:28:23,000 --> 00:28:27,440
Well if it was an unsigned number, we could not of course because we can only have positive

321
00:28:27,440 --> 00:28:28,440
ones.

322
00:28:28,440 --> 00:28:30,800
So how about a signed short?

323
00:28:30,800 --> 00:28:38,600
Well with 16 bits, we can store roughly +/- 32,000 and that will certainly fit.

324
00:28:38,600 --> 00:28:51,040
So this would be signed short int and with this type, because the default for all of

325
00:28:51,040 --> 00:28:59,400
integers is signed, we can leave off the word signed and because with the shorts and longs,

326
00:28:59,400 --> 00:29:06,200
you can actually leave off the word int, we could write that simply as a short.

327
00:29:06,200 --> 00:29:14,640
Now D obviously won't fit in +/- 32,000 but how about if we make that short unsigned?

328
00:29:14,640 --> 00:29:22,940
Well then instead of +/- 32,000, we get 0 to roughly 65,000 and 49,000 would certainly

329
00:29:22,940 --> 00:29:24,300
fit in there.

330
00:29:24,300 --> 00:29:32,780
So this would be an unsigned short int and again we can leave off the word int if we

331
00:29:32,780 --> 00:29:38,420
want.

332
00:29:38,420 --> 00:29:55,300
Ok so this number is 2,000,000,252.

333
00:29:55,300 --> 00:29:58,260
So obviously that won't fit in a short.

334
00:29:58,260 --> 00:30:02,100
Will it fit in an int?

335
00:30:02,100 --> 00:30:04,860
Obviously we have a negative number so it has to be signed.

336
00:30:04,860 --> 00:30:07,060
It cannot be unsigned.

337
00:30:07,060 --> 00:30:09,180
So the default is signed.

338
00:30:09,180 --> 00:30:12,380
We only have to put the unsigned keyword in there.

339
00:30:12,380 --> 00:30:18,260
We only have to put the signed keyword with chars and if you just want to be pedantic,

340
00:30:18,260 --> 00:30:20,220
you can put it inside there.

341
00:30:20,220 --> 00:30:23,660
So an integer is 32 bits.

342
00:30:23,660 --> 00:30:28,460
That means we can store roughly +/- 2,000,000,000,000 numbers.

343
00:30:28,460 --> 00:30:31,580
So this is fine for int.

344
00:30:31,580 --> 00:30:35,260
Now for the last three of these, I want to do something slightly different.

345
00:30:35,260 --> 00:30:44,820
I want to pretend that I am the compiler and I want to put in what auto would put in here

346
00:30:44,820 --> 00:30:46,940
with 3u.

347
00:30:46,940 --> 00:30:55,100
And so for 3u, that would be an unsigned int.

348
00:30:55,100 --> 00:31:03,420
For -9ll, that would be a signed long long or just long long.

349
00:31:03,420 --> 00:31:05,460
And you can put signed long long int.

350
00:31:05,460 --> 00:31:07,220
That would be perfectly fine.

351
00:31:07,220 --> 00:31:09,300
So long long.

352
00:31:09,300 --> 00:31:16,020
And this one is an unsigned long long.

353
00:31:16,020 --> 00:31:19,140
For these exercises we are using something called code check.

354
00:31:19,140 --> 00:31:24,580
So once you have typed your answer in there, you can go ahead and just click the code check

355
00:31:24,580 --> 00:31:30,140
button and it will check it to see if you in fact got it correct.

356
00:31:30,140 --> 00:31:34,820
And so now this is telling us that we have the correct values and you are going to take

357
00:31:34,820 --> 00:31:38,140
a little picture.

358
00:31:38,140 --> 00:31:42,420
And so I am going to actually make this a little smaller here.

359
00:31:42,420 --> 00:31:44,300
And I am going to go ahead and take my picture.

360
00:31:44,300 --> 00:31:51,140
I am going to do Windows shift S because I am on a Windows machine.

361
00:31:51,140 --> 00:32:03,180
I am going to take my picture and I am going to go over to my document here.

362
00:32:03,180 --> 00:32:10,660
And for exercise one, I am going to go ahead and paste in those answers.

363
00:32:10,660 --> 00:32:14,600
If it gets too big, you can make it smaller so that it fits.

364
00:32:14,600 --> 00:32:18,100
We could have actually shot less, shot less for that picture.

365
00:32:18,100 --> 00:32:23,980
I shot kind of a lot for that picture.

366
00:32:23,980 --> 00:32:30,140
Okay so let's go back to talking about, so that's types and inferred typing.

367
00:32:30,140 --> 00:32:32,180
Let's talk about binary numbers.

368
00:32:32,180 --> 00:32:39,060
I want to talk about how data is stored internally in these numbers.

369
00:32:39,060 --> 00:32:43,100
So internally, all numbers are stored in binary.

370
00:32:43,100 --> 00:32:45,980
In other words, base 2.

371
00:32:45,980 --> 00:32:50,980
So when we talk about the base of a number, what we are talking about is the number of

372
00:32:50,980 --> 00:32:57,300
digits that are used to represent that number in human readable form.

373
00:32:57,300 --> 00:33:05,220
When we talk about the base of a number, we are talking about again the human readable

374
00:33:05,220 --> 00:33:06,620
form.

375
00:33:06,620 --> 00:33:09,360
So base 2 uses two digits.

376
00:33:09,360 --> 00:33:12,660
Those digits are 0 and 1.

377
00:33:12,660 --> 00:33:16,820
Base 8 or octal uses 8 digits.

378
00:33:16,820 --> 00:33:23,300
Those digits are 0, 1, 2, 3, 4, 5, 6, and 7.

379
00:33:23,300 --> 00:33:27,100
Base 10 or decimal numbers use 10 digits.

380
00:33:27,100 --> 00:33:29,820
The digits are 0 through 9.

381
00:33:29,820 --> 00:33:35,420
And base 16 or hexadecimal uses 16 digits.

382
00:33:35,420 --> 00:33:39,460
So we use the 10 digits from decimal, 0 through 9.

383
00:33:39,460 --> 00:33:45,740
And then we borrow the first six letters, A, B, C, D, E, and F.

384
00:33:45,740 --> 00:33:52,820
And so that's how we represent human readable hexadecimal numbers.

385
00:33:52,820 --> 00:34:01,020
So let's talk about how we interpret the bits internally, how we convert a number that's

386
00:34:01,020 --> 00:34:10,220
written in human readable form, 0, 1, 2, 3, and so forth, to the actual value that's stored

387
00:34:10,220 --> 00:34:11,540
in the number.

388
00:34:11,540 --> 00:34:17,700
What does it mean when we write out the number 123?

389
00:34:17,700 --> 00:34:22,020
Well in base 10, you learned this in grammar school.

390
00:34:22,020 --> 00:34:33,380
What we mean by 123 or 123 is simply 1 times the base, let me start at the right here.

391
00:34:33,380 --> 00:34:37,480
So whatever the base is, we take it to the 0th power.

392
00:34:37,480 --> 00:34:41,300
So any number raised to the 0th power is 1.

393
00:34:41,300 --> 00:34:44,700
So that's 3 times 1.

394
00:34:44,700 --> 00:34:52,060
Then we take the next digit, 2 times, and this is 10 to the 1st power, or 10.

395
00:34:52,060 --> 00:35:00,980
So 2 times 10, plus 1, that's the 3rd digit over here, times 10 to the 2nd power, or 10

396
00:35:00,980 --> 00:35:03,620
times 10, or 100.

397
00:35:03,620 --> 00:35:09,180
So in grammar school you learned that as this is the 1's place, this is the 10's place,

398
00:35:09,180 --> 00:35:13,020
this is the 100's place, the next one would be the 1000's place.

399
00:35:13,020 --> 00:35:16,660
But this is what you're really doing under the hood.

400
00:35:16,660 --> 00:35:23,180
And if you understand that, then binary numbers, or base 8 numbers, or base 16 numbers are

401
00:35:23,180 --> 00:35:24,580
easy.

402
00:35:24,580 --> 00:35:26,740
So here is a binary number.

403
00:35:26,740 --> 00:35:31,340
Because it's binary, we only have two digits, 0 and 1.

404
00:35:31,340 --> 00:35:38,220
And the way we interpret that, the way we get the value out of that, is by taking the

405
00:35:38,220 --> 00:35:46,380
base, which is 2, raised to the powers, 2 to the 0, 2 to the 1st, 2 to the 2nd, 2 to

406
00:35:46,380 --> 00:35:52,020
the 3rd, 2 to the 4th, and so forth, and simply adding them together.

407
00:35:52,020 --> 00:36:00,460
So our right most digit here is 1, and we take 1 times 2 to the power, 2 to the 0th,

408
00:36:00,460 --> 00:36:02,620
or 1 times 1.

409
00:36:02,620 --> 00:36:07,060
Then 1 times 2 to the 1st, or 1 times 2.

410
00:36:07,060 --> 00:36:11,340
Then 0 times 2 to the 3rd, which of course is 0.

411
00:36:11,340 --> 00:36:14,420
Then 1 times 2 to the 3rd, which is 8.

412
00:36:14,420 --> 00:36:17,860
Then 1 times 2 to the 4th, which is 16.

413
00:36:17,860 --> 00:36:21,140
Then 1 times 2 to the 5th, and so forth.

414
00:36:21,140 --> 00:36:29,540
And so that is simply 1 plus 2 plus 8 plus 16 plus 32 plus 64, which gives me the same

415
00:36:29,540 --> 00:36:30,540
value.

416
00:36:30,540 --> 00:36:39,060
So 123 and this binary number are exactly the same value, they're just represented in

417
00:36:39,060 --> 00:36:41,740
human different terms.

418
00:36:41,740 --> 00:36:46,900
We're representing them at different bases when we write them out.

419
00:36:46,900 --> 00:36:54,900
Now we will normally use base 10, but you should know algorithms to convert to these

420
00:36:54,900 --> 00:36:56,760
different bases.

421
00:36:56,760 --> 00:37:02,740
And so this gives you enough information to figure out how to convert to a different base.

422
00:37:02,740 --> 00:37:08,100
In other words, suppose we had this number, and we said it was base 8.

423
00:37:08,100 --> 00:37:17,180
Well that would be 8 to the 0th, plus 1 times 8 to the, 8 to the 1st, plus 0 times 8 to

424
00:37:17,180 --> 00:37:22,260
the 3rd, 2nd, and then 8 to the 3rd, and so forth.

425
00:37:22,260 --> 00:37:27,740
We'll just simply replace these 2 to the 6th, 2 to the 5th, 2 to the 4th, by 8 to the

426
00:37:27,740 --> 00:37:33,220
6th, 8 to the 5th, 8 to the 4th, or in base 3, we'll do the same thing.

427
00:37:33,220 --> 00:37:37,800
So the conversion is essentially relatively simple.

428
00:37:37,800 --> 00:37:39,560
So we're going to do a second exercise.

429
00:37:39,560 --> 00:37:45,620
For this one we're going to use our CS50 IDE.

430
00:37:45,620 --> 00:37:49,080
I'm going to go close that little thing I just typed there.

431
00:37:49,080 --> 00:37:57,140
We're going to do this first exercise, which shows the representation of different values.

432
00:37:57,140 --> 00:38:04,420
This is in part B over here, in IC03, and you're going to open up represent.cpp.

433
00:38:04,420 --> 00:38:09,340
You don't have to put your name on this, because we're just going to do some exercises and

434
00:38:09,340 --> 00:38:15,060
print out what the internal representation of these should be.

435
00:38:15,060 --> 00:38:19,660
Now to do that internal representation, what we're going to do is we're going to call a

436
00:38:19,660 --> 00:38:24,300
function called 2 bits.

437
00:38:24,300 --> 00:38:30,460
To do that, we've included this file called represent.h that has the definition for the

438
00:38:30,460 --> 00:38:32,260
2 bits function.

439
00:38:32,260 --> 00:38:35,500
Now most of you won't understand this right now.

440
00:38:35,500 --> 00:38:40,040
By the end of this semester you will understand this.

441
00:38:40,040 --> 00:38:46,040
So we're going to look at that and we're going to print out here what that means for each

442
00:38:46,040 --> 00:38:48,340
of those representations.

443
00:38:48,340 --> 00:38:56,980
So if I want the representation of the character A, what I'm going to print out is 2 bits,

444
00:38:56,980 --> 00:39:02,940
and I'm going to print out the literal character A.

445
00:39:02,940 --> 00:39:13,800
Now if I want the literal representation, in other words, what do the bits look like,

446
00:39:13,800 --> 00:39:20,080
for the unsigned char B, I'm going to have to make, or the unsigned char 65, I'm going

447
00:39:20,080 --> 00:39:23,400
to have to make a variable of that type.

448
00:39:23,400 --> 00:39:34,520
So I'm going to say unsigned char B equals 65, and then I'm just going to print out 2

449
00:39:34,520 --> 00:39:35,520
bits B.

450
00:39:35,520 --> 00:39:43,480
So you notice when I did A, I put the quotes around it, I passed the literal inside here.

451
00:39:43,480 --> 00:39:46,940
Here I'm passing in the variable.

452
00:39:46,940 --> 00:39:55,640
Ok we've got the short value, so the signed short value, 32768.

453
00:39:55,640 --> 00:40:08,880
So I'm going to have short C equals 32768.

454
00:40:08,880 --> 00:40:14,740
And I'm going to have unsigned, oh I'll do it between them next time.

455
00:40:14,740 --> 00:40:17,860
So let's do two things here.

456
00:40:17,860 --> 00:40:31,140
Let's do 2 bits C, and then let's put out a comma and say C equals, or I'll use the

457
00:40:31,140 --> 00:40:39,500
arrow, C. Ok?

458
00:40:39,500 --> 00:40:52,620
And let's do a D for the unsigned short, so unsigned short D equals 32768, and I'm going

459
00:40:52,620 --> 00:40:55,180
to do exactly the same thing I did here.

460
00:40:55,180 --> 00:41:02,580
I'm just going to copy that, I'm going to paste it over here, and I'm going to print

461
00:41:02,580 --> 00:41:19,700
out D, D, and D. Ok, here we want the int value, 15, so 2 bits 15.

462
00:41:19,700 --> 00:41:24,460
Now 15 of course literally is an int.

463
00:41:24,460 --> 00:41:36,860
We want the int value minus 15, 2 bits minus 15.

464
00:41:36,860 --> 00:41:55,900
We want the float 15F, and the double 15F, or double 15, I'm having a hard time putting

465
00:41:55,900 --> 00:42:04,620
my fingers on the right keys, 2 bits 15.0, or just 15 point.

466
00:42:04,620 --> 00:42:10,660
If we just did 15 we'd have an integer, if we do 15.0 we have something else, but the

467
00:42:10,660 --> 00:42:13,220
float, notice I don't need the floating point.

468
00:42:13,220 --> 00:42:17,100
If I put the F on the end of it it knows it's float.

469
00:42:17,100 --> 00:42:20,220
I'm going to hope that's right, we'll find out when we compile it.

470
00:42:20,220 --> 00:42:30,180
Now then I'm going to do 2 bits, and I'm going to do minus 15.0, because we did minus 15

471
00:42:30,180 --> 00:42:39,420
with no point zero, and we got the int minus 15 here, here we have the double minus 15.

472
00:42:39,420 --> 00:42:46,700
Now to compile this, we're going to have to right click on the folder that's in, open

473
00:42:46,700 --> 00:42:52,500
it in an integrated terminal, and notice that it does the change directory to move us over

474
00:42:52,500 --> 00:43:03,300
there, and then I'm simply going to say make run.

475
00:43:03,300 --> 00:43:07,300
I had an error, I do need the period on the 15F.

476
00:43:07,300 --> 00:43:13,940
I told you the compiler would tell us if we made that mistake, and I did make that mistake,

477
00:43:13,940 --> 00:43:20,300
so I'm going to put a period in the 15F.

478
00:43:20,300 --> 00:43:33,620
Let's try it again, clear the terminal with control L, and make run.

479
00:43:33,620 --> 00:43:39,460
Okay so this is what we talked about originally with types.

480
00:43:39,460 --> 00:43:45,500
Notice that the character A, because I said it was a character, represents A. If I printed

481
00:43:45,500 --> 00:43:51,700
out the character A, I would get A, and actually let's just do that.

482
00:43:51,700 --> 00:44:00,500
Let's go back here and do the same thing like we did for C and D. So I'm going to print

483
00:44:00,500 --> 00:44:14,460
out A. And here, I'm going to say, oh actually let's

484
00:44:14,460 --> 00:44:15,940
make a variable of that.

485
00:44:15,940 --> 00:44:37,700
So char A equals A, and put a semicolon there, and we'll do A, and then we'll print out,

486
00:44:37,700 --> 00:44:44,980
comma A is, print out A, and then a new line.

487
00:44:44,980 --> 00:44:46,900
And we'll do the same thing to here.

488
00:44:46,900 --> 00:45:02,660
We'll add the comma B equals, or B is B, and that will make it a little clearer when we

489
00:45:02,660 --> 00:45:05,860
build this and run it again.

490
00:45:05,860 --> 00:45:15,820
So let me clear the console and do make run again.

491
00:45:15,820 --> 00:45:20,820
Well I didn't like that.

492
00:45:20,820 --> 00:45:31,900
I must have made a mistake in my code, which I did.

493
00:45:31,900 --> 00:45:40,300
So I'm going to go, oh I said 2 bits 1 instead of 2 bits A.

494
00:45:40,300 --> 00:45:45,500
Ok third time, hopefully this is the charm.

495
00:45:45,500 --> 00:45:51,020
Ok so notice this bit pattern has a value.

496
00:45:51,020 --> 00:45:52,340
What's its value?

497
00:45:52,340 --> 00:46:00,340
The letter A. This bit pattern is the unsigned character 65.

498
00:46:00,340 --> 00:46:05,260
Now when we print it out it says it's A, but it's really 65.

499
00:46:05,260 --> 00:46:11,700
So depending on what we determined it was, notice the value changes.

500
00:46:11,700 --> 00:46:17,140
It was our determination that this was an int or a char.

501
00:46:17,140 --> 00:46:25,820
So unsigned char 65 and int A have the same value, or have the same bit pattern, but they

502
00:46:25,820 --> 00:46:32,620
have a different value because they represent different numbers.

503
00:46:32,620 --> 00:46:44,700
If we look at the short 32768, we get this bit pattern, 16 bits, and we have the value

504
00:46:44,700 --> 00:46:48,980
32768.

505
00:46:48,980 --> 00:47:00,340
If we look at unsigned short 32768, I'm obviously making some kind of mistake here.

506
00:47:00,340 --> 00:47:03,820
I'm going to pause this while I correct my mistake.

507
00:47:03,820 --> 00:47:08,420
Ok I'm back, I'm sure many of you saw my errors.

508
00:47:08,420 --> 00:47:31,500
I said I want the short 32768 and I typed the short 32678, so 768 and 768 and I'm going

509
00:47:31,500 --> 00:47:43,780
to print this as an int.

510
00:47:43,780 --> 00:47:49,180
Ok so let me try it, I said last time 3 times the charm, we'll hope that 4 times is the

511
00:47:49,180 --> 00:47:50,180
charm.

512
00:47:50,180 --> 00:47:55,500
So I'm going to do my print.

513
00:47:55,500 --> 00:48:01,980
Ok so here we have the character A and the unsigned character 65.

514
00:48:01,980 --> 00:48:07,860
If we take that value, this value, and we represent it as a character, it's A. If we

515
00:48:07,860 --> 00:48:11,820
represent it as an integer, it's 1.

516
00:48:11,820 --> 00:48:20,220
If we take this value and we represent it as a short, notice it won't fit inside a short.

517
00:48:20,220 --> 00:48:22,740
It does what we call an overflow.

518
00:48:22,740 --> 00:48:29,180
And so the value that's stored in there is -32768.

519
00:48:29,180 --> 00:48:37,580
If we store it in an unsigned short, which can store from 0 to 65,000, we can store that

520
00:48:37,580 --> 00:48:38,740
value.

521
00:48:38,740 --> 00:48:43,480
So this does what we say overflows the domain.

522
00:48:43,480 --> 00:48:52,380
If we look at the integer 15, we have this bit pattern, and if we look at the value -15,

523
00:48:52,380 --> 00:48:58,540
we get some insight as to how negative and positive numbers are stored differently as

524
00:48:58,540 --> 00:49:00,860
to their bit patterns.

525
00:49:00,860 --> 00:49:07,180
If we look at the float 15, so here's the integer 15 right here, and here's the float

526
00:49:07,180 --> 00:49:14,900
15, notice they're using the same amount of storage, but the bits are arranged entirely

527
00:49:14,900 --> 00:49:16,420
differently.

528
00:49:16,420 --> 00:49:22,940
In other words, the interpretation of the bits is different just because we said it

529
00:49:22,940 --> 00:49:24,780
was a different type.

530
00:49:24,780 --> 00:49:29,220
And if you look at the difference between the float and the double, you'll see that

531
00:49:29,220 --> 00:49:32,120
they arrange somewhat similarly.

532
00:49:32,120 --> 00:49:40,060
You can see the actual data right there for 15 and the data for 15 right there, and the

533
00:49:40,060 --> 00:49:43,300
data for 15 right here.

534
00:49:43,300 --> 00:49:49,020
You can see that they're somewhat the same, although a little bit differently.

535
00:49:49,020 --> 00:49:55,900
And you notice -15 and positive 15, so look at the difference between negative and positive

536
00:49:55,900 --> 00:50:01,260
here for integers, the same number, look at the difference between negative and positive

537
00:50:01,260 --> 00:50:02,580
for doubles.

538
00:50:02,580 --> 00:50:04,620
Only one bit has changed.

539
00:50:04,620 --> 00:50:09,940
And so what you can take away from this, I don't expect you to understand this decoding.

540
00:50:09,940 --> 00:50:18,100
What I do expect you to understand is that the value is a set of bits interpreted according

541
00:50:18,100 --> 00:50:19,860
to its type.

542
00:50:19,860 --> 00:50:31,780
The size of each representation of a type is based on the individual platform, the individual

543
00:50:31,780 --> 00:50:39,900
implementation, and that we can have two patterns that are exactly the same, but if their type

544
00:50:39,900 --> 00:50:45,580
is different, so notice these two patterns are the same, and these two patterns are the

545
00:50:45,580 --> 00:50:52,540
same, but because their type was different, their values are different.

546
00:50:52,540 --> 00:50:59,020
So the value is the set of bits interpreted according to its type.

547
00:50:59,020 --> 00:51:05,020
OK, so that's exercise B. You're going to take a picture of this, and you're going to

548
00:51:05,020 --> 00:51:16,260
take a picture of this part here for the in-class exercise.

549
00:51:16,260 --> 00:51:25,260
OK, let's go on to the next topic, which is conversions and casts.

550
00:51:25,260 --> 00:51:35,580
So C++ automatically converts between types of numbers on initialization or assignment.

551
00:51:35,580 --> 00:51:37,100
It does this silently.

552
00:51:37,100 --> 00:51:39,340
It doesn't warn you that it's happening.

553
00:51:39,340 --> 00:51:41,260
It just does it.

554
00:51:41,260 --> 00:51:49,340
So in C++11, we can use the curly braces called list assignment to give you a little bit greater

555
00:51:49,340 --> 00:51:50,460
control.

556
00:51:50,460 --> 00:51:55,380
So if you had an int variable and you assigned a double to it, maybe the variable should

557
00:51:55,380 --> 00:51:58,100
have been a double, but you don't notice.

558
00:51:58,100 --> 00:52:00,180
In Java, you'd get an error.

559
00:52:00,180 --> 00:52:04,700
In C++, you won't unless you use this list assignment.

560
00:52:04,700 --> 00:52:10,340
Now you may get a compiler warning on an error or conversion, but there's no guarantee that

561
00:52:10,340 --> 00:52:15,180
that will actually happen because it's not illegal.

562
00:52:15,180 --> 00:52:21,860
So if you mean to explicitly convert between different types, you should use what's called

563
00:52:21,860 --> 00:52:24,540
a static cast.

564
00:52:24,540 --> 00:52:31,180
And see, in Java, you did something similar, simpler, in Python as well, if you wanted

565
00:52:31,180 --> 00:52:32,620
to cast.

566
00:52:32,620 --> 00:52:35,920
This shows that the conversion is intentional.

567
00:52:35,920 --> 00:52:46,060
So for instance, if I want to store the whole part of a number pi, I can assign it to a

568
00:52:46,060 --> 00:52:50,340
static underscore cast in angle brackets.

569
00:52:50,340 --> 00:52:54,220
I put the type I want to create my temporary of.

570
00:52:54,220 --> 00:52:59,660
So I want to convert pi to an int, and I put that in parenthesis here.

571
00:52:59,660 --> 00:53:04,980
So this is the syntax for a static cast.

572
00:53:04,980 --> 00:53:11,580
Okay, so let's go and look at expressions.

573
00:53:11,580 --> 00:53:14,720
Let's go and look at expressions.

574
00:53:14,720 --> 00:53:18,260
So an expression is a calculation that produces a value.

575
00:53:18,260 --> 00:53:21,920
And to do that, we use operators and operands.

576
00:53:21,920 --> 00:53:24,660
These are terms from mathematics.

577
00:53:24,660 --> 00:53:29,460
So operands are the data that we operate on.

578
00:53:29,460 --> 00:53:30,940
Variables can be literal.

579
00:53:30,940 --> 00:53:33,380
So 3 plus 5 is an expression.

580
00:53:33,380 --> 00:53:37,280
3 and 5 are literally values.

581
00:53:37,280 --> 00:53:39,820
We can say, use variables in expression.

582
00:53:39,820 --> 00:53:41,140
A minus 3.

583
00:53:41,140 --> 00:53:44,420
A is not a value, but it contains a value.

584
00:53:44,420 --> 00:53:47,440
So we can use it in an expression.

585
00:53:47,440 --> 00:53:49,020
We can use a function call.

586
00:53:49,020 --> 00:53:53,980
So func a is not a value, but it produces a value when I call it.

587
00:53:53,980 --> 00:53:57,980
And I can use that in an expression, 2 times func a.

588
00:53:57,980 --> 00:53:59,740
And we can have a sub-expression.

589
00:53:59,740 --> 00:54:03,220
So a plus 3 produces a value.

590
00:54:03,220 --> 00:54:04,740
That's an expression.

591
00:54:04,740 --> 00:54:14,300
And I can use that sub-expression as part of the expression a plus 3 times 5.

592
00:54:14,300 --> 00:54:20,140
Now, the operators are the plus, the minus, the multiply in this situation.

593
00:54:20,140 --> 00:54:24,180
And all of these operators have three characteristics.

594
00:54:24,180 --> 00:54:26,940
First is the term arity.

595
00:54:26,940 --> 00:54:30,660
Arity simply means how many operands are needed.

596
00:54:30,660 --> 00:54:38,420
So 3 plus 5 is called a binary operator because two operands are needed.

597
00:54:38,420 --> 00:54:44,820
Minus 5 is a unary operator because only one operand is needed.

598
00:54:44,820 --> 00:54:48,260
Finally, we have one operator called the tertiary operator,

599
00:54:48,260 --> 00:54:52,380
or the conditional operator, that requires three operands--

600
00:54:52,380 --> 00:54:57,740
what the condition is, what the true value is, what the false value is.

601
00:54:57,740 --> 00:55:01,060
Secondly, we have what's called precedence.

602
00:55:01,060 --> 00:55:05,180
Precedence determines which operators bind more tightly

603
00:55:05,180 --> 00:55:08,340
to data than another operator.

604
00:55:08,340 --> 00:55:17,940
Now, you probably learned P-E-M-D-A-S, PEMDAS, in algebra.

605
00:55:17,940 --> 00:55:20,420
That's not exactly correct here.

606
00:55:20,420 --> 00:55:22,340
First, we don't have any E. There's no

607
00:55:22,340 --> 00:55:24,260
exponential operator.

608
00:55:24,260 --> 00:55:27,340
The P stands for the parenthesis.

609
00:55:27,340 --> 00:55:34,380
The M stands for the multiplicative operators, which means multiplication

610
00:55:34,380 --> 00:55:35,540
and division.

611
00:55:35,540 --> 00:55:37,540
Neither one of them binds more tightly.

612
00:55:37,540 --> 00:55:39,500
They're just at the same level.

613
00:55:39,500 --> 00:55:41,940
And the last level, the additive operators,

614
00:55:41,940 --> 00:55:45,740
includes addition and subtraction.

615
00:55:45,740 --> 00:55:51,020
Finally, associativity determines whether we go from right to left or left

616
00:55:51,020 --> 00:55:52,060
to right.

617
00:55:52,060 --> 00:55:54,740
And this is called the tie-breaking rule.

618
00:55:54,740 --> 00:55:58,460
We only use associativity when we have two operators

619
00:55:58,460 --> 00:56:01,380
at the same level of precedence.

620
00:56:01,380 --> 00:56:03,340
So let's look at an example.

621
00:56:03,340 --> 00:56:09,500
Here is an expression-- 7 times 2 divided by 3.

622
00:56:09,500 --> 00:56:13,900
So each of these is a binary operator.

623
00:56:13,900 --> 00:56:19,340
Notice that multiplication and division have the same level of precedence.

624
00:56:19,340 --> 00:56:24,460
So the 2 and 3 bind at the same level as the 7 and 2.

625
00:56:24,460 --> 00:56:26,580
So what should we do?

626
00:56:26,580 --> 00:56:29,380
Well, we don't have a way to evaluate this.

627
00:56:29,380 --> 00:56:32,900
We have to fall back on rule 3, associativity.

628
00:56:32,900 --> 00:56:37,620
All binary operators are left associative, meaning

629
00:56:37,620 --> 00:56:39,660
we go from the left to the right.

630
00:56:39,660 --> 00:56:48,500
So this is 7 by 2 times 2, which is 14, divided by 3, which is 3.

631
00:56:50,340 --> 00:56:51,140
3 or 4?

632
00:56:51,140 --> 00:56:53,180
4.

633
00:56:53,180 --> 00:56:53,680
4.

634
00:56:53,680 --> 00:57:01,900
So if it was the other way, if we did the 2 divided by 3,

635
00:57:01,900 --> 00:57:04,300
we'd get 0 times 7, which would be 0.

636
00:57:04,300 --> 00:57:11,820
Now let's look at the arithmetic operators.

637
00:57:11,820 --> 00:57:13,700
We looked at the basic types.

638
00:57:13,700 --> 00:57:19,620
We've looked at the vocabulary for calculations.

639
00:57:19,620 --> 00:57:21,500
Let's look at the operators.

640
00:57:21,500 --> 00:57:24,420
There are five basic arithmetic operators.

641
00:57:24,420 --> 00:57:29,500
There is not an operator for exponential, even though there is a math.

642
00:57:29,500 --> 00:57:32,460
There is not in C++.

643
00:57:32,460 --> 00:57:36,380
Now all five of these don't modify their operands.

644
00:57:36,380 --> 00:57:42,060
So you can use all five of these operators with an expression or a literal.

645
00:57:42,060 --> 00:57:47,140
So addition and subtraction is the plus and the minus token.

646
00:57:47,140 --> 00:57:54,180
These can also be the unary plus and the unary minus operators.

647
00:57:54,180 --> 00:58:00,700
So we use the same token depending on the context as to which operator it means.

648
00:58:00,700 --> 00:58:04,620
We have multiplication, which is the star, like it is in most programming

649
00:58:04,620 --> 00:58:10,740
languages, division, which is the forward slash, and remainder.

650
00:58:10,740 --> 00:58:15,860
So these last two require a little bit of explanation.

651
00:58:15,860 --> 00:58:21,060
Integer division in C++ works like integer division in Java,

652
00:58:21,060 --> 00:58:25,380
but unlike integer division in Python.

653
00:58:25,380 --> 00:58:29,780
In Python, when you divide two integers, you get real division.

654
00:58:29,780 --> 00:58:36,140
In other words, 2 divided by 3 is 0.666.

655
00:58:36,140 --> 00:58:44,260
In Java and C++, 2 divided by 3 is 0.

656
00:58:44,260 --> 00:58:51,820
And so look at this little girl standing at the board dividing 80 by 9.

657
00:58:51,820 --> 00:58:56,580
We have the thing we're dividing by, the thing we're dividing,

658
00:58:56,580 --> 00:58:58,540
the thing we're dividing by.

659
00:58:58,540 --> 00:59:05,340
And on the top of this little house, what we've done is we've put the quotient.

660
00:59:05,340 --> 00:59:11,580
So 80 divided by 9 in C++ is 8.

661
00:59:11,580 --> 00:59:15,660
We discard this 8 down here in the basement.

662
00:59:15,660 --> 00:59:18,420
So it's not 8 8 and 8/9.

663
00:59:18,420 --> 00:59:20,100
It's just 8.

664
00:59:20,100 --> 00:59:21,860
So the quotient's calculated.

665
00:59:21,860 --> 00:59:24,860
The remainder is discarded.

666
00:59:24,860 --> 00:59:26,820
The result is an integer.

667
00:59:26,820 --> 00:59:31,580
So 8 8 and 8/9 is, of course, closer to 9, right?

668
00:59:31,580 --> 00:59:34,060
Because 81 would be 9.

669
00:59:34,060 --> 00:59:37,620
If we divided 81 by 9, we'd get 9.

670
00:59:37,620 --> 00:59:39,820
But it's not rounded up to 9.

671
00:59:39,820 --> 00:59:43,500
It's just 8 in that case.

672
00:59:43,500 --> 00:59:47,020
If we want the part down here in the basement, the part the little girl is

673
00:59:47,020 --> 00:59:51,460
drawing right now, we can use the remainder operator.

674
00:59:51,460 --> 00:59:57,740
This percent sign is not the-- this doesn't have anything to do with

675
00:59:57,740 --> 00:59:59,460
percents.

676
00:59:59,460 --> 01:00:03,220
It also is not exactly the modulus operator.

677
01:00:03,220 --> 01:00:09,300
Modulus is a slightly different operation than the remainder.

678
01:00:09,300 --> 01:00:11,500
But it's close to that.

679
01:00:11,500 --> 01:00:15,060
So 12 remainder 5 is 2.

680
01:00:15,060 --> 01:00:19,660
That's because when I divide 12 by 5, I get 2 for the quotient.

681
01:00:19,660 --> 01:00:21,580
There are two 5's in 12.

682
01:00:21,580 --> 01:00:24,500
But there's 2 left over.

683
01:00:24,500 --> 01:00:28,580
So that's the remainder operator.

684
01:00:28,580 --> 01:00:33,300
Now, the last operators I want to look at are called side effect operators.

685
01:00:33,300 --> 01:00:38,660
And side effect operators include assignment, the shorthand assignment,

686
01:00:38,660 --> 01:00:42,980
plus equals, and increment and decrement.

687
01:00:42,980 --> 01:00:49,820
So increment and decrement, plus plus and minus minus, those add 1 or

688
01:00:49,820 --> 01:00:53,660
subtract 1 to a variable.

689
01:00:53,660 --> 01:00:59,300
However, like all expressions, they produce a value.

690
01:00:59,300 --> 01:01:03,980
So the secondary side effect is to change the operand.

691
01:01:03,980 --> 01:01:08,700
So plus plus a adds 1 to a.

692
01:01:08,700 --> 01:01:12,620
Minus minus b subtracts 1 from b.

693
01:01:12,620 --> 01:01:16,140
It changes a and b.

694
01:01:16,140 --> 01:01:23,660
Thus, because it changes a and b, they only work with modifiable l values.

695
01:01:23,660 --> 01:01:27,660
That means you cannot write plus plus 7.

696
01:01:27,660 --> 01:01:32,420
Plus plus 7 is not equal to 7 plus 1.

697
01:01:32,420 --> 01:01:34,500
Plus plus 7 is illegal.

698
01:01:34,500 --> 01:01:39,260
You're trying to change the value 7.

699
01:01:39,260 --> 01:01:44,180
So the side effect is always to change 1 or subtract 1

700
01:01:44,180 --> 01:01:46,780
from the variable's values.

701
01:01:46,780 --> 01:01:56,740
So it's just a simpler way of saying x equals x plus 1, or x equals x minus 1.

702
01:01:56,740 --> 01:02:03,060
You can simply say x plus plus, or x minus minus, or plus plus x,

703
01:02:03,060 --> 01:02:06,500
or minus minus x.

704
01:02:06,500 --> 01:02:11,020
Now, the value of the whole expression, however,

705
01:02:11,020 --> 01:02:14,900
depends on where you place the operator.

706
01:02:14,900 --> 01:02:21,540
If you put it in front of the variable plus plus a, that changes a.

707
01:02:21,540 --> 01:02:25,420
And then it returns the variable that is changed.

708
01:02:25,420 --> 01:02:33,540
So plus plus a means change a and return a as the value of the expression.

709
01:02:33,540 --> 01:02:41,900
Postfix, writing a plus plus, saves the value that a had before we changed it,

710
01:02:41,900 --> 01:02:49,340
changes a, and then returns its own old saved value as a temporary.

711
01:02:49,340 --> 01:02:52,660
So let me give you a couple examples, short examples here,

712
01:02:52,660 --> 01:02:54,380
so you can see that.

713
01:02:54,380 --> 01:03:00,220
I'm going to close represent, and I'm going to open up my example here.

714
01:03:00,220 --> 01:03:04,660
And I'm going to just put some simple coding here,

715
01:03:04,660 --> 01:03:15,980
include I/O stream using namespace standard int main.

716
01:03:15,980 --> 01:03:24,300
So I'm going to say int a equals 6.

717
01:03:24,300 --> 01:03:30,140
I'm going to say int b equals a plus plus.

718
01:03:30,140 --> 01:03:32,620
And then I'm going to print out a and b.

719
01:03:32,620 --> 01:03:45,900
So what would you expect to get out of this?

720
01:03:45,900 --> 01:03:52,740
Now, I'm going to have to open up a terminal here on my CS150 folder.

721
01:03:52,740 --> 01:03:54,980
And I'm going to have to do make example.

722
01:03:59,140 --> 01:04:03,380
So I don't have a make file for it, so I have to use its name of the program.

723
01:04:03,380 --> 01:04:06,540
To run it, I have to do ./example.

724
01:04:06,540 --> 01:04:15,460
So if you watched in lecture one, if you watched the CS50 video

725
01:04:15,460 --> 01:04:20,700
on using the command line, you'll realize how to build and make a program.

726
01:04:20,700 --> 01:04:25,820
So when I run example, that prints out 7 and 6.

727
01:04:25,820 --> 01:04:32,100
So notice a plus plus changed a to 7.

728
01:04:32,100 --> 01:04:35,340
This changed a to 7.

729
01:04:35,340 --> 01:04:41,260
However, the value of this expression is the temporary value that a had,

730
01:04:41,260 --> 01:04:45,700
and that's what's copied over into b.

731
01:04:45,700 --> 01:04:51,380
So notice b is 6, and a is 7 in this example.

732
01:04:53,100 --> 01:04:59,540
Now, there are some pitfalls with this.

733
01:04:59,540 --> 01:05:01,940
So here are the things to avoid.

734
01:05:01,940 --> 01:05:04,740
Notice here, I'm calling a function.

735
01:05:04,740 --> 01:05:12,340
I'm passing as an argument n, and then the expression n times n plus plus.

736
01:05:12,340 --> 01:05:18,700
Well, the problem here is that n plus plus changes n.

737
01:05:18,700 --> 01:05:25,540
So I don't know if the n over here on the left or the n in the middle have the value before

738
01:05:25,540 --> 01:05:27,620
or after it's changed.

739
01:05:27,620 --> 01:05:30,100
You don't know.

740
01:05:30,100 --> 01:05:32,100
Similarly, this.

741
01:05:32,100 --> 01:05:40,020
I have an expression with n divided by 2 plus 5 times 1 plus n plus plus.

742
01:05:40,020 --> 01:05:43,900
I'm not sure if this n has been changed or not.

743
01:05:43,900 --> 01:05:47,140
Now, it doesn't look like it when you look at it.

744
01:05:47,140 --> 01:05:50,020
You look at it, and you think, well, obviously it hasn't been changed.

745
01:05:50,020 --> 01:05:51,060
It appears after it.

746
01:05:51,060 --> 01:05:52,660
It's always left to right.

747
01:05:52,660 --> 01:05:54,060
That's not the case.

748
01:05:54,060 --> 01:05:56,260
Okay, that is not the case.

749
01:05:56,260 --> 01:05:57,500
Okay.

750
01:05:57,500 --> 01:05:59,700
Finally, look at that expression.

751
01:05:59,700 --> 01:06:03,780
Y equals n plus plus plus n plus plus.

752
01:06:03,780 --> 01:06:06,420
Again, you don't know what that means.

753
01:06:06,420 --> 01:06:08,820
So some rules to remember.

754
01:06:08,820 --> 01:06:13,220
Don't use a variable that's part of more than one argument.

755
01:06:13,220 --> 01:06:18,580
Don't use if a variable appears more than once in an expression.

756
01:06:18,580 --> 01:06:21,180
N and n plus plus over here.

757
01:06:21,180 --> 01:06:24,080
The parenthesis won't help you in this case.

758
01:06:24,080 --> 01:06:27,580
You cannot put parenthesis around it to make it safer.

759
01:06:27,580 --> 01:06:29,820
It's unsafe.

760
01:06:29,820 --> 01:06:34,560
So here, this is an expression, n plus plus plus n plus plus.

761
01:06:34,560 --> 01:06:39,620
Don't use if the variable n appears more than once in an expression.

762
01:06:39,620 --> 01:06:42,580
This also applies to the assignment operator.

763
01:06:42,580 --> 01:06:44,700
In other words, don't write something like this.

764
01:06:44,700 --> 01:06:47,020
Y equals y plus plus.

765
01:06:47,020 --> 01:06:52,300
Well, y plus plus is the value y had before it changed.

766
01:06:52,300 --> 01:06:59,760
So if y was three, that would assign to y three, but this changes y to four.

767
01:06:59,760 --> 01:07:01,840
So what does that expression even mean?

768
01:07:01,840 --> 01:07:03,500
It's impossible to parse.

769
01:07:03,500 --> 01:07:06,860
This is what we call undefined behavior.

770
01:07:06,860 --> 01:07:13,660
Now one of my favorite ones is this.

771
01:07:13,660 --> 01:07:17,740
So here's a is six.

772
01:07:17,740 --> 01:07:28,940
I'm going to print out a plus plus, a plus plus, a plus plus.

773
01:07:28,940 --> 01:07:31,780
Again, this is undefined behavior.

774
01:07:31,780 --> 01:07:35,740
We're using the same variable and part of this whole expression.

775
01:07:35,740 --> 01:07:38,060
This is all one expression.

776
01:07:38,060 --> 01:07:43,860
And if we were to run that, I'm going to make example.

777
01:07:43,860 --> 01:07:52,980
Okay, so I actually, on our IDE here, we could do this in one of the online IDEs here.

778
01:07:52,980 --> 01:07:58,780
In our IDE, I'm actually treating that as an error.

779
01:07:58,780 --> 01:08:03,300
I could change this instead of doing make example.

780
01:08:03,300 --> 01:08:10,580
I could do g plus plus example dot cpp dot o example.

781
01:08:10,580 --> 01:08:16,620
So I'm skipping all of the error checking that I have turned on.

782
01:08:16,620 --> 01:08:24,100
And then if I run example, in this case I get six, seven, eight.

783
01:08:24,100 --> 01:08:26,900
Many of you would think that's what it will always print.

784
01:08:26,900 --> 01:08:44,220
If I do clang plus plus, just another compiler.

785
01:08:44,220 --> 01:08:48,180
Clang is not going to let me do that because it has all the warnings turned on.

786
01:08:48,180 --> 01:08:52,220
And basically it's telling me that this is undefined.

787
01:08:52,220 --> 01:08:57,900
And so I have an online compiler, I've tried it with Visual Studio, C++.

788
01:08:57,900 --> 01:08:59,900
It gives me six, six, six.

789
01:08:59,900 --> 01:09:02,140
One of them gives me six, seven, eight.

790
01:09:02,140 --> 01:09:04,060
You solve a g plus plus.

791
01:09:04,060 --> 01:09:06,180
Another one will give me eight, seven, six.

792
01:09:06,180 --> 01:09:15,820
So the upshot of all of that is you should not ever, ever do any of these things.

793
01:09:15,820 --> 01:09:19,620
These are pitfalls that you're going to need to look out for.

794
01:09:19,620 --> 01:09:24,820
Okay, we're going to finish this up with the last part of our exercise.

795
01:09:24,820 --> 01:09:35,060
Each time I'm going to try and do a larger problem that puts into practice what we've

796
01:09:35,060 --> 01:09:37,860
been talking about and what we've been learning about.

797
01:09:37,860 --> 01:09:43,580
We have been working with IPL programs.

798
01:09:43,580 --> 01:09:52,220
And so down here we're going to write this basic IPO program.

799
01:09:52,220 --> 01:09:58,060
And so we're going to do, this time I'm going to do something a little bit faster.

800
01:09:58,060 --> 01:10:02,100
In the last lecture I went through this step by step.

801
01:10:02,100 --> 01:10:05,500
This time we're going to do it really, really quickly.

802
01:10:05,500 --> 01:10:10,780
So let me bring this over.

803
01:10:10,780 --> 01:10:12,540
Let me close example.

804
01:10:12,540 --> 01:10:19,260
Let me go down to C. Let's do Mets.cpp.

805
01:10:19,260 --> 01:10:21,380
Let's put our name on the top of it.

806
01:10:21,380 --> 01:10:31,620
I'm not going to put the date in because I might want to use it another semester.

807
01:10:31,620 --> 01:10:36,020
So lecture three.

808
01:10:36,020 --> 01:10:43,020
I am going to put my full Canvas ID there.

809
01:10:43,020 --> 01:10:50,980
Okay, so I'm going to go to my problem.

810
01:10:50,980 --> 01:11:00,980
I'm going to get the instructions out.

811
01:11:00,980 --> 01:11:05,460
I'm going to put those inside here.

812
01:11:05,460 --> 01:11:23,420
I'm going to convert the comments.

813
01:11:23,420 --> 01:11:30,020
I'm going to select that and comment it, slash, and then tab.

814
01:11:30,020 --> 01:11:34,260
And I'm going to figure out what the inputs, outputs, and so forth are.

815
01:11:34,260 --> 01:11:42,140
So input, I have weight in pounds.

816
01:11:42,140 --> 01:11:44,420
This one I'll use snake case.

817
01:11:44,420 --> 01:11:49,620
I used camel case in the last one.

818
01:11:49,620 --> 01:11:58,100
The number of Mets for an activity and the number of minutes.

819
01:11:58,100 --> 01:12:15,340
So three inputs, output, calories, calories, calories, burn.

820
01:12:15,340 --> 01:12:17,580
And what's given on this?

821
01:12:17,580 --> 01:12:35,700
Well, I'm given one kilogram is 2.2 pounds.

822
01:12:35,700 --> 01:12:39,860
I'm given anything else in the problem statement.

823
01:12:39,860 --> 01:12:45,580
Oh, I have a conversion formula.

824
01:12:45,580 --> 01:13:08,660
Okay, so that's also given.

825
01:13:08,660 --> 01:13:11,420
That conversion factor is that.

826
01:13:11,420 --> 01:13:17,940
And finally I have my algorithm or processing.

827
01:13:17,940 --> 01:13:26,100
And again I was given that in the problem.

828
01:13:26,100 --> 01:13:31,620
Although not exactly in the form I want to use.

829
01:13:31,620 --> 01:13:37,380
And so I'm going to print that in there.

830
01:13:37,380 --> 01:13:43,340
Okay, so I can get rid of this.

831
01:13:43,340 --> 01:13:45,860
And we can write our code here.

832
01:13:45,860 --> 01:13:49,820
Now what's the first step we're always going to do for the code?

833
01:13:49,820 --> 01:13:53,780
The first step is always mock up the output.

834
01:13:53,780 --> 01:13:58,180
So I'm going to go copy this code here.

835
01:13:58,180 --> 01:14:02,940
What I want the output to look like.

836
01:14:02,940 --> 01:14:07,140
I'm going to paste it in there.

837
01:14:07,140 --> 01:14:08,340
I'm going to separate it.

838
01:14:08,340 --> 01:14:22,980
I'm going to put quotes around it like we did before.

839
01:14:22,980 --> 01:14:44,140
The parts that are going to stay the same.

840
01:14:44,140 --> 01:14:46,700
And I'm going to put C outs and output operators.

841
01:14:46,700 --> 01:14:47,700
So C out.

842
01:14:47,700 --> 01:15:00,260
I'll copy that so I can just put it here multiple times.

843
01:15:00,260 --> 01:15:07,700
Oops, no that's not right.

844
01:15:07,700 --> 01:15:10,740
I have operator there but not that.

845
01:15:10,740 --> 01:15:30,740
So 250 and 6 and 90 and output operators here and here.

846
01:15:30,740 --> 01:15:53,300
Make them go the right way and an end them.

847
01:15:53,300 --> 01:16:00,980
And I'm going to make sure I haven't made any syntax errors and that the output looks

848
01:16:00,980 --> 01:16:08,020
pretty much like the code that I copied over there.

849
01:16:08,020 --> 01:16:15,540
And so you can see that it in fact does look pretty similar.

850
01:16:15,540 --> 01:16:17,340
Okay so that was step one.

851
01:16:17,340 --> 01:16:23,060
Our step two is we're going to now add the input, output and processing sections.

852
01:16:23,060 --> 01:16:28,220
So here's my input section.

853
01:16:28,220 --> 01:16:32,220
Here is my processing section.

854
01:16:32,220 --> 01:16:37,900
And here is my output section.

855
01:16:37,900 --> 01:16:41,140
So for the input I need variables.

856
01:16:41,140 --> 01:16:43,620
So I need my weight in pounds.

857
01:16:43,620 --> 01:16:48,980
I need the number of mets for that activity.

858
01:16:48,980 --> 01:16:51,980
And then I need the met conversion factor.

859
01:16:51,980 --> 01:16:55,620
And then I'm going to send the minutes next exercising.

860
01:16:55,620 --> 01:16:58,420
So let's make these first two doubles.

861
01:16:58,420 --> 01:17:08,580
So double weight in pounds.

862
01:17:08,580 --> 01:17:16,780
And let's do C in weight in pounds.

863
01:17:16,780 --> 01:17:22,580
Let's remove this dummy value and the dummy end line there.

864
01:17:22,580 --> 01:17:24,380
And I have my first line done.

865
01:17:24,380 --> 01:17:27,140
Make sure I spell pounds right.

866
01:17:27,140 --> 01:17:31,220
I like the fact that the editor will color that to make sure that I spelled it right

867
01:17:31,220 --> 01:17:34,700
and give me a syntax thing.

868
01:17:34,700 --> 01:17:38,220
Okay so this is the number of mets for this activity.

869
01:17:38,220 --> 01:17:45,040
That might be an int as well but we're multiplying it with this factor times 0.75.

870
01:17:45,040 --> 01:17:47,180
So let me make it a double as well.

871
01:17:47,180 --> 01:17:52,260
Number of mets and C in mets.

872
01:17:52,260 --> 01:17:58,460
And let me remove the dummies here.

873
01:17:58,460 --> 01:17:59,460
And minutes.

874
01:17:59,460 --> 01:18:02,260
I'm going to go ahead and make this one an integer.

875
01:18:02,260 --> 01:18:06,860
So I'll move the dummy to start with.

876
01:18:06,860 --> 01:18:10,300
I will have int minutes.

877
01:18:10,300 --> 01:18:14,900
C in minutes.

878
01:18:14,900 --> 01:18:19,500
Okay so I've got the input part done.

879
01:18:19,500 --> 01:18:23,760
Now let's go ahead and do the processing part.

880
01:18:23,760 --> 01:18:27,700
So the output is going to be calories.

881
01:18:27,700 --> 01:18:30,940
So I'm going to create a double value for that.

882
01:18:30,940 --> 01:18:38,000
So double calories equals.

883
01:18:38,000 --> 01:18:46,820
And I'm going to put in this formula.

884
01:18:46,820 --> 01:18:51,300
And notice the formula isn't exactly in the right format.

885
01:18:51,300 --> 01:18:54,900
So this is the formula for calories per minute.

886
01:18:54,900 --> 01:19:00,960
And so I want to divide calories by minute.

887
01:19:00,960 --> 01:19:06,700
I want to, calories by minute, I want to multiply both sides by the minute to get this.

888
01:19:06,700 --> 01:19:32,700
So that would be this factor times mets times, whoops, times weighted kilograms.

889
01:19:32,700 --> 01:19:37,140
Times minutes.

890
01:19:37,140 --> 01:19:39,460
Alright.

891
01:19:39,460 --> 01:19:48,020
In other words if it's calories divided by minutes I need to multiply both sides by minutes

892
01:19:48,020 --> 01:19:52,580
to get the minutes on the right hand side.

893
01:19:52,580 --> 01:19:55,700
Now we actually don't have these two variables.

894
01:19:55,700 --> 01:19:58,300
And factor was given up to us here.

895
01:19:58,300 --> 01:19:59,620
It's this value.

896
01:19:59,620 --> 01:20:02,180
So I'm going to create a constant for that.

897
01:20:02,180 --> 01:20:07,340
So const double k factor equals .0175.

898
01:20:07,340 --> 01:20:17,220
So I'm going to replace this factor with k factor.

899
01:20:17,220 --> 01:20:20,540
And mets we read inside here.

900
01:20:20,540 --> 01:20:22,540
But we don't have weights in kilogram.

901
01:20:22,540 --> 01:20:29,980
But I do have another given which is the kilogram.

902
01:20:29,980 --> 01:20:49,580
So const double k pounds per kilogram equals 2.2.

903
01:20:49,580 --> 01:20:53,700
2.2 pounds per kilogram.

904
01:20:53,700 --> 01:20:58,700
And so given that constant I can figure out what the weight in kilograms is.

905
01:20:58,700 --> 01:21:01,500
Because here is the weight in pounds.

906
01:21:01,500 --> 01:21:24,460
So double weight in kilograms equals weight in pounds.

907
01:21:24,460 --> 01:21:39,980
Weight in pounds divided by k pounds per kilogram.

908
01:21:39,980 --> 01:21:42,940
Okay so that looks pretty good.

909
01:21:42,940 --> 01:21:46,020
We're going to have to test it to make sure it's correct.

910
01:21:46,020 --> 01:21:52,540
For the output here we want to put our calories.

911
01:21:52,540 --> 01:21:55,140
That's what we want for the output.

912
01:21:55,140 --> 01:21:59,460
And we probably want, looks like two decimal places in the output.

913
01:21:59,460 --> 01:22:05,100
So I'm going to do cl fix set precision 2.

914
01:22:05,100 --> 01:22:07,220
Like I did before.

915
01:22:07,220 --> 01:22:10,780
I'm going to make sure I have IOMINIP up here.

916
01:22:10,780 --> 01:22:14,460
Which I do.

917
01:22:14,460 --> 01:22:17,200
Okay that looks pretty good.

918
01:22:17,200 --> 01:22:22,780
So let's go ahead and try it with make run and put in the same input we had before.

919
01:22:22,780 --> 01:22:26,780
So make run.

920
01:22:26,780 --> 01:22:29,580
So 250 kilograms.

921
01:22:29,580 --> 01:22:32,140
Mets for the activity 6.

922
01:22:32,140 --> 01:22:35,580
Minutes spent exercising 90.

923
01:22:35,580 --> 01:22:39,660
You burned an estimated 1073.86.

924
01:22:39,660 --> 01:22:41,340
It looks okay.

925
01:22:41,340 --> 01:22:43,820
So let's try it with some different inputs.

926
01:22:43,820 --> 01:22:48,780
Let's just do make test.

927
01:22:48,780 --> 01:22:53,780
And here I've tested it with the same 256 and 90.

928
01:22:53,780 --> 01:22:57,860
Then an input weight of 0.

929
01:22:57,860 --> 01:23:00,300
Obviously I'm burning no calories.

930
01:23:00,300 --> 01:23:02,420
An input weight of 125 pounds.

931
01:23:02,420 --> 01:23:06,220
An input weight of 175 pounds.

932
01:23:06,220 --> 01:23:10,060
It shows the different calories that we've burned.

933
01:23:10,060 --> 01:23:14,980
So this will be our picture for the test part.

934
01:23:14,980 --> 01:23:18,220
And here's the picture for the code part.

935
01:23:18,220 --> 01:23:23,500
Again I want you to do more and more of these to get practice doing these kinds of input

936
01:23:23,500 --> 01:23:25,980
output processing programs.

937
01:23:25,980 --> 01:23:30,740
And to get some practice with calculations.

938
01:23:30,740 --> 01:23:31,980
That's it for me today.

939
01:23:31,980 --> 01:23:34,940
I'll see you in lecture 4.

940
01:23:34,940 --> 01:23:36,820
Thank you.


