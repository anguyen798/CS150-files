Hello folks, this is Steve Gilbert and welcome to lecture 3 on numbers and calculations.
Before you start, make sure you've gone into the Thursday tab here on calculations in week
1.
You've clicked the link for the lecture exercise.
When lecture 3 exercise comes up, click the link for the starter form.
Make a local copy and make sure you rename it so you can find it later when you get started.
Okay, so let's go ahead and talk a little bit more about type concepts.
So in the last lecture we talked about variables.
A variable is a name storage location that holds a value.
Variables and values both have types and types have three characteristics.
They have the domain, the operations, and the representation of that type.
So the domain simply means all values contained in that type.
The domain for the type bool, for instance, is true and false.
There are no other values maintained in that type.
The domain for the type int is all the whole numbers within the range of the type.
So the type for int is roughly plus or minus 2 billion for a 32-bit int or plus or minus
127 for an 8-bit int, again depending on the size.
So all the values contained in that type.
We could not put for an int, for an 8-bit int, we could not put a number that was larger,
it would be outside of the domain, and we could not put a number that contained a fractional
portion.
Now the second thing with a type, so the values that can be contained in the type is the domain.
The operations are what you can do with that value.
So for the built-in types, these are specified by the C++ language.
So for instance, in Java, we can use the remainder operator on the floating point or real number
types.
In C++ we cannot, the language prohibits that.
So the language specifies what operations are available.
Now for the library types, like the string type, things that are built into the C++ standard
library, those are specified by the language specification.
So the language standard and the language specification specifies the operations for
that type.
Of course, for user-defined types, the operations are defined by the person who wrote the class.
Finally, the representation determines what bits, given a block of memory and a particular
bit pattern, what does that mean?
So if I say "int", how many bytes are required and how are the bits inside that byte interpreted
to be an int?
The same thing if I say "char" or "double" or whatever.
So in C++, unlike Java, the representation, in other words, how the bits are interpreted,
and the size, how many bytes are used for each type, differs by implementation.
And we'll talk about that.
Now why aren't they all the same?
Why don't they do the same thing as Java and make a byte type which is 8-bit, a short byte,
a short type which is 16-bit, and so forth?
That's because different computer hardware is more efficient with different sizes.
So this allows C++ to run to the best effect on the hardware you have.
So these are the three characteristics that make up a type.
We have several categories of types in C++.
We have the built-in, primitive, or fundamental types.
All of those worlds kind of mean the same thing.
The things that are built into the language itself, not the library.
That includes things like the integer types, the whole number types, the floating point
or real number types, the character types, and the bool type.
Now very few of them.
With those types, and actually with other types, we can derive new types.
So these are called derived types or compound types.
So I can take an array, I can take a char, and I can create an array of char.
So an array of char is a different type than just char.
It's derived from char, but it's a derived type.
I can make a pointer to a double.
I can make a reference to an integer.
So arrays, pointers, and references are not their own independent types.
They're based on or derived from other types.
Thirdly, we have user-defined types.
Types that are created in the library.
Types that are created by you, the programmer.
Types that interact with the rest of C++ as if they were built-in types.
And for these, we have enumerated types, that is, single value, numbered, or scalar types.
That's the enum type.
We have struct for structured or record data types.
And then we have classes for object-oriented programming.
Finally, some of these types are used to build the things that are in the standard library.
So we refer to these types as library types, even though they're structures or enumerations
or classes.
So types such as string and vector are not built into the C++ language.
Instead they're built into the standard library that comes with C++.
Now C++ is what we call statically typed.
That means the types of the variables, the types of the functions, are indicated in the
source code.
And so to show you exactly what that means, I have to kind of compare it to other languages.
So Python, for instance, uses what's called dynamic typing.
So this is the definition for a function named add that takes two arguments, a and b.
What kind of value, if any, does add return?
What kind of things are a and b?
Well, you don't know when you're writing your code.
When you run your code, a will be given a value.
It'll be a number.
It'll be a string.
It'll be a real number, an integer number.
Similarly, you don't know until the program runs what the function will return.
So this is called dynamic typing.
a is not a specific kind of variable.
b is not a specific kind of variable.
It's given a value when the program runs, and its type is determined at that time.
Static typing is what Pascal and Java and C++ use.
That is, the types are determined explicitly when we declare or define the variables.
So here is a function in C++.
It would look very similar in Java.
Notice that this specifically says that this function is going to return an integer.
Notice the Python version does not say what kind of function that is.
It also says that the two arguments, a and b, are both going to be integers.
And so the types with static typing are determined when the program is compiled.
Now we have a similar term that's often confused, and this is called strong typing.
So strong typing means that a variable can only hold one kind of value.
And so you might think, well, if I have a double value, and I try and assign, if I have
a double variable, and I try and assign, I'm actually going to open up our editor here,
and I'm going to just create a new file here.
I'll call it example.cpp.
And so if I try and create a variable, and that is actually not very big, I'm going to,
I'm not quite sure why my font is so small when it's bigger over here.
No, I guess it's about the same size.
So double x equals 3.
Now this works in both C++ and Java, but this is not an example of strong typing, because
the value on the right, 3, is a whole number.
The value variable on the left, where I'm putting that, is the wrong kind of thing to
put it in.
This is not an integer.
This is an integer.
And if we had strong typing only, then this would not compile, because we're trying to
put the wrong kind of value in the wrong kind of box, the wrong kind of variable.
And so what both Java and C++ do, is they convert this 3 to, behind the scenes, invisibly,
a 3.0.
And so the 3.0 is what's put inside of that.
It's called a promotion, or a widening conversion.
Now in Java, if we did this, int y equals 3.15, we would get a syntax error.
So that's because this is too big, it's 64 bits, this is a 32 bit bucket, and the bits
are arranged in a different pattern, because remember, the value is the set of bits interpreted
according to its type.
And so the bits that make up 3.15 are not the same as the bits that would go into the
integer x.
And so in Java, this is illegal, but in C++, it is not illegal.
So in C++, we have strong typing, but we have implicit conversions, conversions that are
not allowed in other languages.
So in C++, this is okay.
It's exactly as if we had written, convert this 3.5 to an int, throw away the .5 and
store it into a.
We won't get any errors.
Now because of that, because of the experience people have had with Java and C# in the last
10 or 15 years, people have realized that that leads to some kind of errors.
And so in C++ now, if we want to make sure that we're doing, if we're not inadvertently
losing data, we could do it like this instead of that.
We could just put braces around this and now, just like Java would get an error, which is
what we expect, right?
We would expect this narrowing conversion not to succeed.
But in C++, if you use the traditional assignment, these narrowing conversions succeed.
So sometimes people complain and say, "No, C++ is not strongly typed because I can put
a double inside an int and it didn't tell me I made a mistake."
Well, it is strongly typed, but it has these implicit conversions exactly like Java has
the implicit conversions, but it will do a narrowing conversion.
In other words, losing data, whereas Java will not.
And again, if you want to avoid that, which I strongly recommend, what you should do is
you should make sure that you use the curly braces when you do the assignment.
Okay, so let's go ahead and look at the types now that are built in.
So the first type we have, like Java, is a integer, which is a signed whole number.
When we say a number is signed, we mean that the number or the variable can represent negative
and positive numbers.
Now in Java, ints are signed 32-bit whole numbers.
In C++, that's not the case.
I have worked on C++ compilers where integers were 16 bits, and the largest integer we could
have was 32,767.
Today, 32 is most common, just like Java, but 16-bit is still used in the microprocessor
world, especially for embedded systems.
So it must be at least 16 bits, or it can't be an int.
That's what the language requires, but it could be 32 bits.
In fact, an int could be 64 bits, and I expect to see that soon as processors get larger.
We can modify the type int with a modifier that specifies the size.
So we can write a long int.
We can leave off the word int and use long, just like Java does.
That must be at least 32 bits.
Now in Java, a long must be 64 bits.
Now in C++, that is not the case.
And so many platforms, Visual C++ for instance, longs and ints are exactly the same size.
They're 32 bits.
Shorts, again this is shorthand for short int, but you can just write short if you want,
must be at least 16 bits like they are in Java, but they can be 32 bits as well.
So it would be possible for ints, longs, and shorts all to be the same size on a given
platform.
They usually aren't all the same size, but often several of them are.
The platform we're going to be using, our Unix platform, is going to have 32 bit ints,
64 bit longs, 16 bit shorts, and all platforms now have long, long.
This is an extension before C++11, but now all platforms have the ability to do a long,
long, which is the equivalent to a long in Java.
And again in C++ we can write this as a long, long int.
Now with all of these types that specify the size of the bytes, we can also specify how
they're interpreted.
So you can combine the word unsigned with any of these above to specify that we want
to take the whole bit pattern and apply it to positive numbers.
So let me just give you a quick example.
If I take a 16 bit number, a short, if I write short, I can represent numbers from -32,768
to +32,767.
The zero is right in the middle of the positive and negative numbers if you put it on a timeline
or a number line.
If I put unsigned short, I cannot store any negative numbers, but I get twice as many
positive numbers.
I can store from zero to 65,535 numbers.
And it's the same for all the types.
Now Java has a byte type to represent an 8 bit signed integers.
C++ uses the type char both for characters and for small integers.
So for characters, you just use a plain char.
For byte integers, you do a signed char if you want the numbers -128 to 127 or you use
an unsigned char if you want to represent the numbers 0 to 255.
We'll actually use these byte integers later because they're very useful when we process
images.
C++ has three floating point types, unlike Java, which has only two.
Those of you coming from Python are familiar with the type float, but the float in type
Python is called a double in Java.
Python actually doesn't have the same float type, which is around four bytes long.
The double type is typically eight bytes long.
The long double may be the same as the double.
It is on Visual C++ or it may be larger.
So we will not use long double generally.
It's not actually that useful in C++.
And we will generally not use float unless we happen to use them in an array for images
or something like that.
So for floating point types, we'll almost always use double.
For integer types, we'll almost always use int, unless we need very small integers, in
which case we'll use signed or unsigned char.
Now literals mean you literally write out a number.
When you write out a number, we assume you're working with decimal numbers, that is base
10.
So with a decimal literal, we can preface it to change the base.
So if I start a number with the digit zero, I'm going to assume I'm going to be in base
eight or octal.
So 073 means three ones in seven eights, not seven tens.
If I preface it with 0x, and that x can be capital or lower case, it means I'm assuming
that the base is 16 and the number is in hexadecimal.
And so 0x73 is not the decimal number 73, it's three ones in seven sixteens.
And if I have the, start with the preface 0b, or zero b, not ob, 0b, let's assume that
the numbers are binary.
Now I can also add a modifier after the literal.
If I do a u, this can be upper case or lower case, it's more common to do capital.
That means that we want to interpret that number as an unsigned number.
If I do an l, it means we want to use long storage.
If I do two l's, it means we want to use long, long storage.
And of course I can bind the unsigned, which determines how we view the representation
with the size modifier.
So I could have 123 ULL.
C++14, we're using C++17 in this class, also allows you to use the apostrophe to act as
a separator for long numbers.
So if you have a very large decimal number, we commonly separate out the thousands with
a comma.
The comma won't work in C++, but you can use the apostrophe so you still get the same visual
separation.
For floating point literals, you can type them as simply 243 dot.
Notice that'll be type double.
Notice we don't need a trailing zero for that, but we do need the dot.
The literal 234 is of type int.
234 point is of type double.
If you add an L to the end of your number, like 7.5432L, it's of type long double, the
literal.
And finally, you can do it in scientific notation here, adding an E with a plus or minus for
the exponent.
The E can be capitalized or lowercase.
This'll be type double, using scientific notation.
And if we wanted type float, we would use the letter F.
Again, this can be lower or uppercase.
I've used uppercase here.
You should not use lowercase for the L because people are going to confuse it with a 1.
You're going to confuse it with a 1.
Now we can actually, since we can use literals to specify a type, and we can use variable
names, type names like int or double to declare the type, we can actually use only the literal
to infer or deduce the type.
When you do that, instead of specifying a type name, you use the keyword auto.
And then you don't use braces.
And so when I say auto A, notice I haven't specified what kind of thing A is.
The compiler comes along and says, "Well, what's going into that?"
Well, 23U is an unsigned int, so the type for A would be an unsigned int.
Similarly, I've done the same thing for the variable B. I haven't specified that it's
a float, but I've written over here that it's type auto, and so it will deduce or infer
from the 3F that B is a float.
Now a lot of modern C++ experts recommend this style called "almost always auto" or
AAA, because first, it eliminates uninitialized variables.
If we're going to get the type from the initializer, we don't have to worry about variables.
It also improves maintenance.
That means if you change the initializer, suppose you had int x = 3, and you came along
and you realized, "Oh, you know, that really should start with 3.5," and you forgot to
change the int, then your code would be kind of out of sync.
You wouldn't get an error message.
And so maintenance works easier if you're using always auto, because the types track
as the initializers will change.
And finally, performance.
If you use explicit types, like int B = 3.5F, we have to do an implicit conversion there
that wouldn't have to happen if we didn't do that.
And so this eliminates these initial conversions.
So if you look on the slides, I have some links that you can watch and read several
things about here.
Watch this video on almost always auto, if you're interested in that.
Let's go ahead and do an exercise, and let's go ahead and see if we can do the work of
the compiler and infer from the literals what type would be there.
Now, of course, if we were using auto, we'd put auto there, but here we're simply going
to infer from the compiler what type would go there.
So I'm going to make this slightly larger so it's easier to see on the video.
So we're going to look at this program, and we're going to provide the correct explicit
variable types for each of the variable declarations.
You can assume that ints are 32 bits, and that shorts are 16 bits.
Now to make this a little trickier, what we want to do is use the smallest legal type
that will correctly store the subsequent value.
So we're going to take a picture, we're going to click here, we're going to go in and look
at this program, I'm going to make this a little larger again so you can see it.
So notice I can say auto A equals this, but I instead, in which case it would be an int,
right, an unsigned int, .25 is an unsigned int.
Instead, what I want to do is think about using the smallest correct explicit type for
that.
So the question really we're asking is what is the smallest type that will store -25?
So an int obviously would, we could put a double inside there, but all of those would
need to convert.
And so the smallest type is an assigned char.
So chars are what we use for values that are 8 bits.
An 8 bit assigned char can hold the numbers from -128 to +127.
So B, we could put that as assigned char, but 249 is outside the range of assigned char.
It's outside the domain, so it wouldn't fit.
What if instead though, we made it an unsigned character?
If it was an unsigned char or an unsigned byte, it would fit because the value for unsigned
bytes is 0 to 255.
So this would be an unsigned char.
Okay, C obviously is bigger than we can store in assigned char and unsigned char.
How about the next larger number, the short?
That's 16 bits.
Could we store -1725 in that?
Well if it was an unsigned number, we could not of course because we can only have positive
ones.
So how about a signed short?
Well with 16 bits, we can store roughly +/- 32,000 and that will certainly fit.
So this would be signed short int and with this type, because the default for all of
integers is signed, we can leave off the word signed and because with the shorts and longs,
you can actually leave off the word int, we could write that simply as a short.
Now D obviously won't fit in +/- 32,000 but how about if we make that short unsigned?
Well then instead of +/- 32,000, we get 0 to roughly 65,000 and 49,000 would certainly
fit in there.
So this would be an unsigned short int and again we can leave off the word int if we
want.
Ok so this number is 2,000,000,252.
So obviously that won't fit in a short.
Will it fit in an int?
Obviously we have a negative number so it has to be signed.
It cannot be unsigned.
So the default is signed.
We only have to put the unsigned keyword in there.
We only have to put the signed keyword with chars and if you just want to be pedantic,
you can put it inside there.
So an integer is 32 bits.
That means we can store roughly +/- 2,000,000,000,000 numbers.
So this is fine for int.
Now for the last three of these, I want to do something slightly different.
I want to pretend that I am the compiler and I want to put in what auto would put in here
with 3u.
And so for 3u, that would be an unsigned int.
For -9ll, that would be a signed long long or just long long.
And you can put signed long long int.
That would be perfectly fine.
So long long.
And this one is an unsigned long long.
For these exercises we are using something called code check.
So once you have typed your answer in there, you can go ahead and just click the code check
button and it will check it to see if you in fact got it correct.
And so now this is telling us that we have the correct values and you are going to take
a little picture.
And so I am going to actually make this a little smaller here.
And I am going to go ahead and take my picture.
I am going to do Windows shift S because I am on a Windows machine.
I am going to take my picture and I am going to go over to my document here.
And for exercise one, I am going to go ahead and paste in those answers.
If it gets too big, you can make it smaller so that it fits.
We could have actually shot less, shot less for that picture.
I shot kind of a lot for that picture.
Okay so let's go back to talking about, so that's types and inferred typing.
Let's talk about binary numbers.
I want to talk about how data is stored internally in these numbers.
So internally, all numbers are stored in binary.
In other words, base 2.
So when we talk about the base of a number, what we are talking about is the number of
digits that are used to represent that number in human readable form.
When we talk about the base of a number, we are talking about again the human readable
form.
So base 2 uses two digits.
Those digits are 0 and 1.
Base 8 or octal uses 8 digits.
Those digits are 0, 1, 2, 3, 4, 5, 6, and 7.
Base 10 or decimal numbers use 10 digits.
The digits are 0 through 9.
And base 16 or hexadecimal uses 16 digits.
So we use the 10 digits from decimal, 0 through 9.
And then we borrow the first six letters, A, B, C, D, E, and F.
And so that's how we represent human readable hexadecimal numbers.
So let's talk about how we interpret the bits internally, how we convert a number that's
written in human readable form, 0, 1, 2, 3, and so forth, to the actual value that's stored
in the number.
What does it mean when we write out the number 123?
Well in base 10, you learned this in grammar school.
What we mean by 123 or 123 is simply 1 times the base, let me start at the right here.
So whatever the base is, we take it to the 0th power.
So any number raised to the 0th power is 1.
So that's 3 times 1.
Then we take the next digit, 2 times, and this is 10 to the 1st power, or 10.
So 2 times 10, plus 1, that's the 3rd digit over here, times 10 to the 2nd power, or 10
times 10, or 100.
So in grammar school you learned that as this is the 1's place, this is the 10's place,
this is the 100's place, the next one would be the 1000's place.
But this is what you're really doing under the hood.
And if you understand that, then binary numbers, or base 8 numbers, or base 16 numbers are
easy.
So here is a binary number.
Because it's binary, we only have two digits, 0 and 1.
And the way we interpret that, the way we get the value out of that, is by taking the
base, which is 2, raised to the powers, 2 to the 0, 2 to the 1st, 2 to the 2nd, 2 to
the 3rd, 2 to the 4th, and so forth, and simply adding them together.
So our right most digit here is 1, and we take 1 times 2 to the power, 2 to the 0th,
or 1 times 1.
Then 1 times 2 to the 1st, or 1 times 2.
Then 0 times 2 to the 3rd, which of course is 0.
Then 1 times 2 to the 3rd, which is 8.
Then 1 times 2 to the 4th, which is 16.
Then 1 times 2 to the 5th, and so forth.
And so that is simply 1 plus 2 plus 8 plus 16 plus 32 plus 64, which gives me the same
value.
So 123 and this binary number are exactly the same value, they're just represented in
human different terms.
We're representing them at different bases when we write them out.
Now we will normally use base 10, but you should know algorithms to convert to these
different bases.
And so this gives you enough information to figure out how to convert to a different base.
In other words, suppose we had this number, and we said it was base 8.
Well that would be 8 to the 0th, plus 1 times 8 to the, 8 to the 1st, plus 0 times 8 to
the 3rd, 2nd, and then 8 to the 3rd, and so forth.
We'll just simply replace these 2 to the 6th, 2 to the 5th, 2 to the 4th, by 8 to the
6th, 8 to the 5th, 8 to the 4th, or in base 3, we'll do the same thing.
So the conversion is essentially relatively simple.
So we're going to do a second exercise.
For this one we're going to use our CS50 IDE.
I'm going to go close that little thing I just typed there.
We're going to do this first exercise, which shows the representation of different values.
This is in part B over here, in IC03, and you're going to open up represent.cpp.
You don't have to put your name on this, because we're just going to do some exercises and
print out what the internal representation of these should be.
Now to do that internal representation, what we're going to do is we're going to call a
function called 2 bits.
To do that, we've included this file called represent.h that has the definition for the
2 bits function.
Now most of you won't understand this right now.
By the end of this semester you will understand this.
So we're going to look at that and we're going to print out here what that means for each
of those representations.
So if I want the representation of the character A, what I'm going to print out is 2 bits,
and I'm going to print out the literal character A.
Now if I want the literal representation, in other words, what do the bits look like,
for the unsigned char B, I'm going to have to make, or the unsigned char 65, I'm going
to have to make a variable of that type.
So I'm going to say unsigned char B equals 65, and then I'm just going to print out 2
bits B.
So you notice when I did A, I put the quotes around it, I passed the literal inside here.
Here I'm passing in the variable.
Ok we've got the short value, so the signed short value, 32768.
So I'm going to have short C equals 32768.
And I'm going to have unsigned, oh I'll do it between them next time.
So let's do two things here.
Let's do 2 bits C, and then let's put out a comma and say C equals, or I'll use the
arrow, C. Ok?
And let's do a D for the unsigned short, so unsigned short D equals 32768, and I'm going
to do exactly the same thing I did here.
I'm just going to copy that, I'm going to paste it over here, and I'm going to print
out D, D, and D. Ok, here we want the int value, 15, so 2 bits 15.
Now 15 of course literally is an int.
We want the int value minus 15, 2 bits minus 15.
We want the float 15F, and the double 15F, or double 15, I'm having a hard time putting
my fingers on the right keys, 2 bits 15.0, or just 15 point.
If we just did 15 we'd have an integer, if we do 15.0 we have something else, but the
float, notice I don't need the floating point.
If I put the F on the end of it it knows it's float.
I'm going to hope that's right, we'll find out when we compile it.
Now then I'm going to do 2 bits, and I'm going to do minus 15.0, because we did minus 15
with no point zero, and we got the int minus 15 here, here we have the double minus 15.
Now to compile this, we're going to have to right click on the folder that's in, open
it in an integrated terminal, and notice that it does the change directory to move us over
there, and then I'm simply going to say make run.
I had an error, I do need the period on the 15F.
I told you the compiler would tell us if we made that mistake, and I did make that mistake,
so I'm going to put a period in the 15F.
Let's try it again, clear the terminal with control L, and make run.
Okay so this is what we talked about originally with types.
Notice that the character A, because I said it was a character, represents A. If I printed
out the character A, I would get A, and actually let's just do that.
Let's go back here and do the same thing like we did for C and D. So I'm going to print
out A. And here, I'm going to say, oh actually let's
make a variable of that.
So char A equals A, and put a semicolon there, and we'll do A, and then we'll print out,
comma A is, print out A, and then a new line.
And we'll do the same thing to here.
We'll add the comma B equals, or B is B, and that will make it a little clearer when we
build this and run it again.
So let me clear the console and do make run again.
Well I didn't like that.
I must have made a mistake in my code, which I did.
So I'm going to go, oh I said 2 bits 1 instead of 2 bits A.
Ok third time, hopefully this is the charm.
Ok so notice this bit pattern has a value.
What's its value?
The letter A. This bit pattern is the unsigned character 65.
Now when we print it out it says it's A, but it's really 65.
So depending on what we determined it was, notice the value changes.
It was our determination that this was an int or a char.
So unsigned char 65 and int A have the same value, or have the same bit pattern, but they
have a different value because they represent different numbers.
If we look at the short 32768, we get this bit pattern, 16 bits, and we have the value
32768.
If we look at unsigned short 32768, I'm obviously making some kind of mistake here.
I'm going to pause this while I correct my mistake.
Ok I'm back, I'm sure many of you saw my errors.
I said I want the short 32768 and I typed the short 32678, so 768 and 768 and I'm going
to print this as an int.
Ok so let me try it, I said last time 3 times the charm, we'll hope that 4 times is the
charm.
So I'm going to do my print.
Ok so here we have the character A and the unsigned character 65.
If we take that value, this value, and we represent it as a character, it's A. If we
represent it as an integer, it's 1.
If we take this value and we represent it as a short, notice it won't fit inside a short.
It does what we call an overflow.
And so the value that's stored in there is -32768.
If we store it in an unsigned short, which can store from 0 to 65,000, we can store that
value.
So this does what we say overflows the domain.
If we look at the integer 15, we have this bit pattern, and if we look at the value -15,
we get some insight as to how negative and positive numbers are stored differently as
to their bit patterns.
If we look at the float 15, so here's the integer 15 right here, and here's the float
15, notice they're using the same amount of storage, but the bits are arranged entirely
differently.
In other words, the interpretation of the bits is different just because we said it
was a different type.
And if you look at the difference between the float and the double, you'll see that
they arrange somewhat similarly.
You can see the actual data right there for 15 and the data for 15 right there, and the
data for 15 right here.
You can see that they're somewhat the same, although a little bit differently.
And you notice -15 and positive 15, so look at the difference between negative and positive
here for integers, the same number, look at the difference between negative and positive
for doubles.
Only one bit has changed.
And so what you can take away from this, I don't expect you to understand this decoding.
What I do expect you to understand is that the value is a set of bits interpreted according
to its type.
The size of each representation of a type is based on the individual platform, the individual
implementation, and that we can have two patterns that are exactly the same, but if their type
is different, so notice these two patterns are the same, and these two patterns are the
same, but because their type was different, their values are different.
So the value is the set of bits interpreted according to its type.
OK, so that's exercise B. You're going to take a picture of this, and you're going to
take a picture of this part here for the in-class exercise.
OK, let's go on to the next topic, which is conversions and casts.
So C++ automatically converts between types of numbers on initialization or assignment.
It does this silently.
It doesn't warn you that it's happening.
It just does it.
So in C++11, we can use the curly braces called list assignment to give you a little bit greater
control.
So if you had an int variable and you assigned a double to it, maybe the variable should
have been a double, but you don't notice.
In Java, you'd get an error.
In C++, you won't unless you use this list assignment.
Now you may get a compiler warning on an error or conversion, but there's no guarantee that
that will actually happen because it's not illegal.
So if you mean to explicitly convert between different types, you should use what's called
a static cast.
And see, in Java, you did something similar, simpler, in Python as well, if you wanted
to cast.
This shows that the conversion is intentional.
So for instance, if I want to store the whole part of a number pi, I can assign it to a
static underscore cast in angle brackets.
I put the type I want to create my temporary of.
So I want to convert pi to an int, and I put that in parenthesis here.
So this is the syntax for a static cast.
Okay, so let's go and look at expressions.
Let's go and look at expressions.
So an expression is a calculation that produces a value.
And to do that, we use operators and operands.
These are terms from mathematics.
So operands are the data that we operate on.
Variables can be literal.
So 3 plus 5 is an expression.
3 and 5 are literally values.
We can say, use variables in expression.
A minus 3.
A is not a value, but it contains a value.
So we can use it in an expression.
We can use a function call.
So func a is not a value, but it produces a value when I call it.
And I can use that in an expression, 2 times func a.
And we can have a sub-expression.
So a plus 3 produces a value.
That's an expression.
And I can use that sub-expression as part of the expression a plus 3 times 5.
Now, the operators are the plus, the minus, the multiply in this situation.
And all of these operators have three characteristics.
First is the term arity.
Arity simply means how many operands are needed.
So 3 plus 5 is called a binary operator because two operands are needed.
Minus 5 is a unary operator because only one operand is needed.
Finally, we have one operator called the tertiary operator,
or the conditional operator, that requires three operands--
what the condition is, what the true value is, what the false value is.
Secondly, we have what's called precedence.
Precedence determines which operators bind more tightly
to data than another operator.
Now, you probably learned P-E-M-D-A-S, PEMDAS, in algebra.
That's not exactly correct here.
First, we don't have any E. There's no
exponential operator.
The P stands for the parenthesis.
The M stands for the multiplicative operators, which means multiplication
and division.
Neither one of them binds more tightly.
They're just at the same level.
And the last level, the additive operators,
includes addition and subtraction.
Finally, associativity determines whether we go from right to left or left
to right.
And this is called the tie-breaking rule.
We only use associativity when we have two operators
at the same level of precedence.
So let's look at an example.
Here is an expression-- 7 times 2 divided by 3.
So each of these is a binary operator.
Notice that multiplication and division have the same level of precedence.
So the 2 and 3 bind at the same level as the 7 and 2.
So what should we do?
Well, we don't have a way to evaluate this.
We have to fall back on rule 3, associativity.
All binary operators are left associative, meaning
we go from the left to the right.
So this is 7 by 2 times 2, which is 14, divided by 3, which is 3.
3 or 4?
4.
So if it was the other way, if we did the 2 divided by 3,
we'd get 0 times 7, which would be 0.
Now let's look at the arithmetic operators.
We looked at the basic types.
We've looked at the vocabulary for calculations.
Let's look at the operators.
There are five basic arithmetic operators.
There is not an operator for exponential, even though there is a math.
There is not in C++.
Now all five of these don't modify their operands.
So you can use all five of these operators with an expression or a literal.
So addition and subtraction is the plus and the minus token.
These can also be the unary plus and the unary minus operators.
So we use the same token depending on the context as to which operator it means.
We have multiplication, which is the star, like it is in most programming
languages, division, which is the forward slash, and remainder.
So these last two require a little bit of explanation.
Integer division in C++ works like integer division in Java,
but unlike integer division in Python.
In Python, when you divide two integers, you get real division.
In other words, 2 divided by 3 is 0.666.
In Java and C++, 2 divided by 3 is 0.
And so look at this little girl standing at the board dividing 80 by 9.
We have the thing we're dividing by, the thing we're dividing,
the thing we're dividing by.
And on the top of this little house, what we've done is we've put the quotient.
So 80 divided by 9 in C++ is 8.
We discard this 8 down here in the basement.
So it's not 8 8 and 8/9.
It's just 8.
So the quotient's calculated.
The remainder is discarded.
The result is an integer.
So 8 8 and 8/9 is, of course, closer to 9, right?
Because 81 would be 9.
If we divided 81 by 9, we'd get 9.
But it's not rounded up to 9.
It's just 8 in that case.
If we want the part down here in the basement, the part the little girl is
drawing right now, we can use the remainder operator.
This percent sign is not the-- this doesn't have anything to do with
percents.
It also is not exactly the modulus operator.
Modulus is a slightly different operation than the remainder.
But it's close to that.
So 12 remainder 5 is 2.
That's because when I divide 12 by 5, I get 2 for the quotient.
There are two 5's in 12.
But there's 2 left over.
So that's the remainder operator.
Now, the last operators I want to look at are called side effect operators.
And side effect operators include assignment, the shorthand assignment,
plus equals, and increment and decrement.
So increment and decrement, plus plus and minus minus, those add 1 or
subtract 1 to a variable.
However, like all expressions, they produce a value.
So the secondary side effect is to change the operand.
So plus plus a adds 1 to a.
Minus minus b subtracts 1 from b.
It changes a and b.
Thus, because it changes a and b, they only work with modifiable l values.
That means you cannot write plus plus 7.
Plus plus 7 is not equal to 7 plus 1.
Plus plus 7 is illegal.
You're trying to change the value 7.
So the side effect is always to change 1 or subtract 1
from the variable's values.
So it's just a simpler way of saying x equals x plus 1, or x equals x minus 1.
You can simply say x plus plus, or x minus minus, or plus plus x,
or minus minus x.
Now, the value of the whole expression, however,
depends on where you place the operator.
If you put it in front of the variable plus plus a, that changes a.
And then it returns the variable that is changed.
So plus plus a means change a and return a as the value of the expression.
Postfix, writing a plus plus, saves the value that a had before we changed it,
changes a, and then returns its own old saved value as a temporary.
So let me give you a couple examples, short examples here,
so you can see that.
I'm going to close represent, and I'm going to open up my example here.
And I'm going to just put some simple coding here,
include I/O stream using namespace standard int main.
So I'm going to say int a equals 6.
I'm going to say int b equals a plus plus.
And then I'm going to print out a and b.
So what would you expect to get out of this?
Now, I'm going to have to open up a terminal here on my CS150 folder.
And I'm going to have to do make example.
So I don't have a make file for it, so I have to use its name of the program.
To run it, I have to do ./example.
So if you watched in lecture one, if you watched the CS50 video
on using the command line, you'll realize how to build and make a program.
So when I run example, that prints out 7 and 6.
So notice a plus plus changed a to 7.
This changed a to 7.
However, the value of this expression is the temporary value that a had,
and that's what's copied over into b.
So notice b is 6, and a is 7 in this example.
Now, there are some pitfalls with this.
So here are the things to avoid.
Notice here, I'm calling a function.
I'm passing as an argument n, and then the expression n times n plus plus.
Well, the problem here is that n plus plus changes n.
So I don't know if the n over here on the left or the n in the middle have the value before
or after it's changed.
You don't know.
Similarly, this.
I have an expression with n divided by 2 plus 5 times 1 plus n plus plus.
I'm not sure if this n has been changed or not.
Now, it doesn't look like it when you look at it.
You look at it, and you think, well, obviously it hasn't been changed.
It appears after it.
It's always left to right.
That's not the case.
Okay, that is not the case.
Okay.
Finally, look at that expression.
Y equals n plus plus plus n plus plus.
Again, you don't know what that means.
So some rules to remember.
Don't use a variable that's part of more than one argument.
Don't use if a variable appears more than once in an expression.
N and n plus plus over here.
The parenthesis won't help you in this case.
You cannot put parenthesis around it to make it safer.
It's unsafe.
So here, this is an expression, n plus plus plus n plus plus.
Don't use if the variable n appears more than once in an expression.
This also applies to the assignment operator.
In other words, don't write something like this.
Y equals y plus plus.
Well, y plus plus is the value y had before it changed.
So if y was three, that would assign to y three, but this changes y to four.
So what does that expression even mean?
It's impossible to parse.
This is what we call undefined behavior.
Now one of my favorite ones is this.
So here's a is six.
I'm going to print out a plus plus, a plus plus, a plus plus.
Again, this is undefined behavior.
We're using the same variable and part of this whole expression.
This is all one expression.
And if we were to run that, I'm going to make example.
Okay, so I actually, on our IDE here, we could do this in one of the online IDEs here.
In our IDE, I'm actually treating that as an error.
I could change this instead of doing make example.
I could do g plus plus example dot cpp dot o example.
So I'm skipping all of the error checking that I have turned on.
And then if I run example, in this case I get six, seven, eight.
Many of you would think that's what it will always print.
If I do clang plus plus, just another compiler.
Clang is not going to let me do that because it has all the warnings turned on.
And basically it's telling me that this is undefined.
And so I have an online compiler, I've tried it with Visual Studio, C++.
It gives me six, six, six.
One of them gives me six, seven, eight.
You solve a g plus plus.
Another one will give me eight, seven, six.
So the upshot of all of that is you should not ever, ever do any of these things.
These are pitfalls that you're going to need to look out for.
Okay, we're going to finish this up with the last part of our exercise.
Each time I'm going to try and do a larger problem that puts into practice what we've
been talking about and what we've been learning about.
We have been working with IPL programs.
And so down here we're going to write this basic IPO program.
And so we're going to do, this time I'm going to do something a little bit faster.
In the last lecture I went through this step by step.
This time we're going to do it really, really quickly.
So let me bring this over.
Let me close example.
Let me go down to C. Let's do Mets.cpp.
Let's put our name on the top of it.
I'm not going to put the date in because I might want to use it another semester.
So lecture three.
I am going to put my full Canvas ID there.
Okay, so I'm going to go to my problem.
I'm going to get the instructions out.
I'm going to put those inside here.
I'm going to convert the comments.
I'm going to select that and comment it, slash, and then tab.
And I'm going to figure out what the inputs, outputs, and so forth are.
So input, I have weight in pounds.
This one I'll use snake case.
I used camel case in the last one.
The number of Mets for an activity and the number of minutes.
So three inputs, output, calories, calories, calories, burn.
And what's given on this?
Well, I'm given one kilogram is 2.2 pounds.
I'm given anything else in the problem statement.
Oh, I have a conversion formula.
Okay, so that's also given.
That conversion factor is that.
And finally I have my algorithm or processing.
And again I was given that in the problem.
Although not exactly in the form I want to use.
And so I'm going to print that in there.
Okay, so I can get rid of this.
And we can write our code here.
Now what's the first step we're always going to do for the code?
The first step is always mock up the output.
So I'm going to go copy this code here.
What I want the output to look like.
I'm going to paste it in there.
I'm going to separate it.
I'm going to put quotes around it like we did before.
The parts that are going to stay the same.
And I'm going to put C outs and output operators.
So C out.
I'll copy that so I can just put it here multiple times.
Oops, no that's not right.
I have operator there but not that.
So 250 and 6 and 90 and output operators here and here.
Make them go the right way and an end them.
And I'm going to make sure I haven't made any syntax errors and that the output looks
pretty much like the code that I copied over there.
And so you can see that it in fact does look pretty similar.
Okay so that was step one.
Our step two is we're going to now add the input, output and processing sections.
So here's my input section.
Here is my processing section.
And here is my output section.
So for the input I need variables.
So I need my weight in pounds.
I need the number of mets for that activity.
And then I need the met conversion factor.
And then I'm going to send the minutes next exercising.
So let's make these first two doubles.
So double weight in pounds.
And let's do C in weight in pounds.
Let's remove this dummy value and the dummy end line there.
And I have my first line done.
Make sure I spell pounds right.
I like the fact that the editor will color that to make sure that I spelled it right
and give me a syntax thing.
Okay so this is the number of mets for this activity.
That might be an int as well but we're multiplying it with this factor times 0.75.
So let me make it a double as well.
Number of mets and C in mets.
And let me remove the dummies here.
And minutes.
I'm going to go ahead and make this one an integer.
So I'll move the dummy to start with.
I will have int minutes.
C in minutes.
Okay so I've got the input part done.
Now let's go ahead and do the processing part.
So the output is going to be calories.
So I'm going to create a double value for that.
So double calories equals.
And I'm going to put in this formula.
And notice the formula isn't exactly in the right format.
So this is the formula for calories per minute.
And so I want to divide calories by minute.
I want to, calories by minute, I want to multiply both sides by the minute to get this.
So that would be this factor times mets times, whoops, times weighted kilograms.
Times minutes.
Alright.
In other words if it's calories divided by minutes I need to multiply both sides by minutes
to get the minutes on the right hand side.
Now we actually don't have these two variables.
And factor was given up to us here.
It's this value.
So I'm going to create a constant for that.
So const double k factor equals .0175.
So I'm going to replace this factor with k factor.
And mets we read inside here.
But we don't have weights in kilogram.
But I do have another given which is the kilogram.
So const double k pounds per kilogram equals 2.2.
2.2 pounds per kilogram.
And so given that constant I can figure out what the weight in kilograms is.
Because here is the weight in pounds.
So double weight in kilograms equals weight in pounds.
Weight in pounds divided by k pounds per kilogram.
Okay so that looks pretty good.
We're going to have to test it to make sure it's correct.
For the output here we want to put our calories.
That's what we want for the output.
And we probably want, looks like two decimal places in the output.
So I'm going to do cl fix set precision 2.
Like I did before.
I'm going to make sure I have IOMINIP up here.
Which I do.
Okay that looks pretty good.
So let's go ahead and try it with make run and put in the same input we had before.
So make run.
So 250 kilograms.
Mets for the activity 6.
Minutes spent exercising 90.
You burned an estimated 1073.86.
It looks okay.
So let's try it with some different inputs.
Let's just do make test.
And here I've tested it with the same 256 and 90.
Then an input weight of 0.
Obviously I'm burning no calories.
An input weight of 125 pounds.
An input weight of 175 pounds.
It shows the different calories that we've burned.
So this will be our picture for the test part.
And here's the picture for the code part.
Again I want you to do more and more of these to get practice doing these kinds of input
output processing programs.
And to get some practice with calculations.
That's it for me today.
I'll see you in lecture 4.
Thank you.
